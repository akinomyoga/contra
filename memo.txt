# contra dev note


------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

2016-10-04

* 方向付き文字列 (SRS/SDS string) の取り扱い

  0 文字列の定義によって記憶部上の文字の配列に影響は出ない様にする。

    # これは双方向に対応していないアプリケーションでアラビア語や
    # 双方向制御を含む Unicode 文字列を取り扱っても問題が生じない様にする為に必要である。
    # それに記憶部ではできるだけデータの受信順序を保ちたい。

  1 記憶部で文字列の開始終了の情報を記録・管理し、
    これらの情報から一意的に表示部での配列を再現できる様にする。

  2 行にまたがる文字列構造は管理しない。
    受信したデータの中に改行が含まれている場合や、折り返し処理によって行が分割される場合、
    一旦文字列を全て閉じて改行してから再び文字列を開いたかの様に動作する。

    # 理由は複数ある。
    #
    # + [明示的な改行との取り扱いの一貫性]
    #   明示的な改行が含まれている場合は改行前の文字列は前の行に、
    #   改行後の文字列は次の行に表示する。
    #   行折り返しによる暗黙的な改行も同様に取り扱うべきである。
    #   そうしないと暗黙的な改行が挿入された後に、
    #   再度その内容を別の装置に転送する時に、
    #   文章の順序が保たれなくなってしまうからである。
    #
    #   ※暗黙的な改行を区別して記録すれば良いという意見もあるかもしれない。
    #     しかし、様々な制御機能を経た後にそれが意味論的に
    #     まだ暗黙的改行として扱ってよいかなどを決める規則は難しい問題である。
    #     それに暗黙的な改行を区別する為のデータ表現も色々考えると難しい。
    #
    # + [行毎にSCPした時の取り扱い]
    #   行毎に SCP で character path を切り替える事ができる。
    #   例えば SRS 文字列が複数の異なる character path を持つ行に跨っていた場合に、
    #   どの様にその文字列の "範囲" を表現するのかや、
    #   それをどの様に整合的に表示するのかなどに曖昧な点が生じる。
    #
    #   例えば、文字列の各行に含まれる部分を切り出して一つの文字列としたのと
    #   同様に表示するという取り扱いにするのが自然だろう。しかし、
    #   その様に取り扱うのであれば、初めから各行毎に文字列を分割して管理したほうが良い。
    #
    # + [SCP による複数行表示との一貫性]
    #   例えば単に複数行のアラビア語を表示するとして、
    #   SCP を使用して出力する場合と、出力文字列全体を SRS で囲む場合を考える。
    #   前者では次の行は前の行の下に表示される。
    #   後者でも次の行は前の行の下に表示された方が動作として一貫している
    #   (それに読みやすさの観点から言ってもその方が良い)。
    #
    # + [行内での完結]
    #   表示する際に文字の並び替えは行内で完結していたほうが取り扱いやすい。
    #   ある所に表示する内容が別の行に含まれるというのは始末が悪い。
    #   それに座標の計算をする際に考慮に入れるべき範囲の長さに上限がなくなるので、
    #   そういう意味でも複数行に亘る文字列というのは都合が悪い。

2016-09-27

* ECMA-48/9 には対応しない。

  [2016-09-27 の考察の結果を抜粋する]

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそういう前提の内容がかかれている (15 および D.4.Note3)。
  それ以外の実装は駄目な実装なので気にしなくても良い。

  もともと ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである (ECMA-48/1)。
  意図的に 10/00 - 15/14 を使って制御シーケンスを記述するための物ではない。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、そもそもの前提が崩れるので、
  ECMA-48/9 の内容に対応する必要はない。



------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2016-10-08

* emacs だとかのアプリケーションを動作させるだけであれば、
  terminfo のエントリにある物だけ対応しておけば実は十分という事に気付く。
  一々起動してどの様なシーケンスを送ってくるかを調べる必要はないのだ。

  infocmp xterm を見てみると意外と沢山ある。
  しかしキーシーケンスも多いのでどれが制御機能かぱっと見て分からない。
  後で terminfo の entries についても纏める必要があるだろう。

  序で infocmp ansi を見ると大分すっきりしている。
  というかキーシーケンスが全然ない。考えてみれば当然だ。
  ANSI 規格は制御機能しか定義していなくてキーボードは定義していないからだ。
  また、気になるのは ANSI 規格で処理系定義とされている機能についてだ。
  例えば xenl は infocmp ansi では書かれていないが、
  別に xenl でもそうでなくても ANSI 規格準拠の筈だ。
  後、altcharset (acsc) に普通に非 7 bit 文字が記述されているが、
  これらを utf-8 の環境で使うと何が起こるのか気になる。
  (ncursesw はちゃんと encode してから送信するのだろうか?)

* DECDWL, DECDHL の動作に関して。

  DECDWL, DECDHL, DECSWL は VT510 のページに記述がある。
  これらは行に対する属性として動作する。
  しかしこれらの属性を持つ行に関してカーソルの移動はどの様に働くのだろう。

  xterm, RLogin, mintty が対応していたので動作を観察してみる。

  - VT510 の DECDWL の説明によると元から行に存在していた
    内容の右半分は失われると書かれている。

  - xterm は DECDWL を設定した行であっても表示が二倍の幅になっているだけで、
    一行に収める事のできる文字の数は変化しない様である。
    つまり、画面の右端に行ってもその場では折り返されず、
    行の右半分だけが表示されないという動作になる。
    そして画面の右端に行って隠れた文字列はちゃんと記録されていて、
    \e#5 で行の文字の幅を元に戻すと画面の右端に行って隠れた文字列が戻ってくる。

    また、カーソル移動に関しては \e[C もしくは \e[D で移動すると、
    二倍の距離移動する様になる。つまり、文字数で移動する。
    (因みにカーソルの下に全角文字がある場合に \e[D しても半角分しか移動しない。)

    DECDWL の行で 4 文字目 (つまり7列目) にカーソルがある場合、
    \e[A で上に移動すると他の行の 4 文字目 (4列目) にカーソルが移動する。
    見た目に合わせて 7 列目にカーソルを移動する等という動作はしない様である。
    (ECMA-48 は presentation component での見たままの上下左右の移動に拘っている様なので、
    ECMA-48 を標準化している様な人からすれば \e[A は見た目の通りに 7 列目にするべきと考えるだろう。)

    DECDWL した瞬間にカーソルの位置が変わるかどうかも興味深い。
    xterm の実装では DECDWL した瞬間にカーソル位置は表示上右に2倍の位置に移動する。
    文字データの観点から言うと、DECDWL する前と後で指している文字は変わらない。

    結局のところ xterm の DECDWL, DECDHL の対応はただ単に "表示する時に横幅を二倍にしているだけ" であって、
    実際の端末の処理としては全然幅を認識していないという事になる。

  - mintty は xterm の動作を模倣している。

  - RLogin の場合には画面の見た目で行折り返しが起こる。
    つまり、DECDWL の行では半分しか文字を出力できない。
    然しながら、一旦行内を埋めてから DECDWL してそれから DECSWL をすると、
    また内容が戻ってくる。つまり、SLL を一時的に半分の位置に設定しているだけで、
    実際の内部的な表現としてはやはり一文字一セルで記録している物と思われる。

    面白い振る舞いとしては一旦行内を半分以上埋めて DECDWL をしてカーソルが画面外に出た状態で
    何か文字を出力すると、1文字目は何処にも出力されず、2文字目は行折り返しが起こって
    次の行に表示されるという事である。
    思うに RLogin は現在のカーソル位置が範囲外にあるかどうかをカーソルが移動した時に
    判定して記録しているのだろう。なので、カーソルが移動した後に設定が変わってカーソル位置がはみ出ても
    それを認識せずに文字を置こうとして失敗して、その後でカーソルを移動した時にようやく
    現在位置が範囲外であったという事に気づいて行折り返しを行うというそういう動作になっているのだろうと思う。

    カーソル移動については xterm と全く同じである。\e[C \e[D は2列ずつ移動するし、
    また \e[A \e[B すると前後の行の同じ列ではなく同じ文字番号の場所に移動する。

    所で DECDWL/DECDHL と sixel を組み合わせるとどうなるかを見てみた所、
    sixel の絵も横に二倍に引き伸ばされて表示される様である。
    序に DCH や DL も試してみたがちゃんと画像の一部が削除される様だ。
    これらの動作についてはまた後で様々の実装の間で比較する必要がありそうだ。

  結局、これらの実装が本当に VT の実機と同様なのかは怪しい。
  何れの実装でも行の右半分のデータを保持している。
  一方で、わざわざ VT の説明に行の右半分のデータは discard すると書かれている。
  これは、VT の実装では単に表示を二倍にしているのではなくて、
  丁度表示位置に対応するセルにデータを記録しているという事の気がする。
  だとするとカーソル移動は見た目での列に従って起こるべきだし、
  また行の内容が保持されたり折り返しがなかなか起こらなかったりという事もないのではないか。



2016-10-05

* RIS

* SPH/SPL の効果について

  FF 及び implicit movement それから
  active presentation position does not normally go
  beyond the page limit position というのを実装する。

  しかし、そもそも頁の概念を端末上でどの様に実装するべきかが明確でない。
  その他の頁を制御する制御機能の説明を調べて、
  その上で適切な頁の概念の再現方法を考える事にしたい。

  また SLH/SLL と同様に頁毎に home/limit
  の値を設定する事ができるかどうか考察する。

* 基本的な移動機能その他

  > CUU CUD CUB CUF (現在位置・上下左右)
  HPA HPB HPR VPA VPB VPR (記憶位置・行列)
  CHA CNL CPL (行列)
  CPR
  DCH ICH ECH DL IL EL ED

* RI は一度消えた行ではなくて新しい行を挿入している @ screen
  RI IND

* http://invisible-island.net/vttest/

* TAB 関連の機能

  Mode TSM

  VT VTS
  TAC TALE TATE TBC TCC TSR
  STAB (ISO 8613-6) HTJ HT HTS CHT CBT CTC CVT

  影響のあるもの: DAQ(7) DCH ICH DL IL RIS

  RLogin は HTS, DECHTS, VTS, DECVTS を認識するが、
  何も設定しない状態で HT を呼び出すと何が起こるのだろうか。
  確認する必要がある。
  因みに VT に関しては次の行に単に進むだけの様に見える。
  VTS を設定してる状態で VT を実行するとどうなるだろうか?

2016-10-04

* 本当に行毎に SLL/SLH の値を保持するべきなのか。

  subsequent lines と書かれているが、
  CUU 等で戻ってから上書きする場合には適用されないのか。
  また ED で erased state にされた行に設定されていた home/limit は消去するべきなのか。

  他に "以降の行" に適用される様な状態はあっただろうか。
  それらの機能の自然な動作も考慮に入れて考える。
  例えば SCP が以降の行に対して適用される物である。
  SCP の説明では現在行の内容の更新方法については述べているが、
  以降の行についての更新方法については述べていない。
  - 既に出力された行に再度移動して其処に新しく何かを書き込んだ時に、
    突然表示方法が変化するというのも変である。
    或いは、既に出力された行に移動した瞬間に変化するというのも変である。
    だとすれば、SCP が適用されるのは本当に新しく作った行に対してのみであるべきである。
    或いは LF もしくは NEL によって移動した時にのみ SCP を更新するというのも考えられるかもしれないが、
    しかしそれでも LF を単なる移動に使うという場合も考えられるし、やはり表示方法が突然変化するというのは変である。
  - ED によって空にした行については SCP はどう働くべきだろうか。
    ED によって空にした行についてはそれが新しい行であるかのように動作して欲しい。
    以前其処にあった方向性が残っているというのはおかしいからである。
    例えば中身が全て erased になっている行に限っては SCP の方向性が新しく適用されるというのはどうだろうか。
    しかし、それも不自然な気がする。周りの行が新しい SCP に影響されていないのに、間にある行だけ影響を受けるというのも変である。
    という事は、行自体に "この行は新しい行である" かどうかを保持するデータをつけておくべきだろうか。
    そして新しい行であった時に限って、現在の SCP をその行に適用し、"新しい行ではない" という様に書き換える。
  - では書き換えるタイミングは何であろう。例えば、一番初めに文字を書き込んだときであるべきか。
    それともカーソルを移動させた瞬間であるべきか。
    カーソルを一気に動かした場合にはどうするべきか。
    カーソルを一気に動かした場合にはスキップされた間の行にまで値が適用されるのは変な気がする。
    という事はカーソルを一気に動かした場合にはあいだの行には SCP は適用しないとする。
    そして、カーソルを一気に動かした場合と一歩ずつ動かした場合で同じ動作になって欲しいという事を考えると、
    結局カーソルの移動だけでは新しい行に属性を適用するには至らないという風にした方が良い気がする。
    つまり、行に対して具体的に何らかの変更が適用される時に初めて行の属性を適用するという風にする。

  さて SCP がこの様な動作をしている時に SLL/SLH はどの様に動作するべきか。
  カーソルを移動して前の場所に戻った時に、現在の SLL/SLH を用いて動作する方が良いか、
  それとも行が生成された時の SLL/SLH を用いて動作する方が良いか。

  % 普通に考えると現在の SLL/SLH を用いて動作したい所だが、
  % 一方で SCP での "以降の行" というのは新しく生成した行に対してのみ適用する事に決めた。
  % この時 SLL/SLH での "以降の行" を別の意味に解釈するのも変である。
  % もう少し考えてみる。SLL/SLH は行を生成した時の値を用いるという動作の方が自然に思われる様な例があるかもしれない。
  %
  % % 例えば、SCP で character path が反転している様な場合はどうだろう。
  % % DCSM(PRESENTATION) の場合には見た目によって位置が決まる。
  % % →しかし、よく考えてみたら SCP は表示部での character path つまり文字位置の番号自体を反転させるのであって、
  % %   記憶部と表示部の列番号の対応関係に影響を与える物ではない。
  % %   そして SCP の異なる行を跨った場合には、例え DCSM(PRESENTATION) であっても、
  % %   見た目に左右が反転している事を考慮に入れて表示部での列番号を移動するのではなく、
  % %   飽くまで表示部での列番号は保持したままで実際の位置は左右反転するという事になる気がする。
  %
  % うーん。でもやはり SCP での "以降の行 (subsequent lines)" との整合性から考えて、
  % SLL/SLH で設定される境界についても各行で保持して、
  % 新しい行に対してのみ現在の設定を適用するという様にするべきな気がする。

  →改めて規格を見てみると SCP の "以降の行 (subsequent lines)" は SCP の説明にしか出てこない。
    一方で、SLL/SLH の "以降の行 (lines of subsequnet line)" は TAB の設定などで複数回出てくる。
    さて、もし SLL/SLH を SCP と同様に各行で定義するとすると、
    整合性から考えて tab stop 等も全て行毎に管理しなければならなくなる。
    それは面倒であるし効率が悪そうな気がする。
    だとすれば、やはり SLL/SLH については共通の設定を一つ何処かに持っておいて、
    行毎には記録しないように変更するべきか。

  [結論]

  - 行には新しい行かそうではないかを識別するための属性をつける。
  - 新しい行に初めて文字などの書き込みを実行する時に、属性を適用する。
    また LF や NEL を実行した際にも属性を適用する。
    後 CR の直前にも実行しなければならない。というか LF の代わりに CR で実行するべき?
  - ED 等の消去関数を用いた場合には空になった行は新しい行としてマークする。

  これらについてはタブ関連の機能について調べてからで良いだろう。
  タブ関連の機能を見て、行毎に tab stop を管理しなければならなそうであれば、
  SLL/SLH も含めて行毎に管理をする様にする。
  もしタブは全ての行について共有なのだとすれば SLL/SLH もその様にする。
  →どうもタブ関連の機能は TSM で動作を切り替えられる様である。
    しかし TSM に影響されずに動作する DAQ(7) 等の機能も存在する。
    つまり基本的に character tab stop は行毎に管理して、
    但し、TSM = MULTIPLE の場合には特定の制御機能は
    全ての既存の行に対して作用するという事らしい。
    全体で共通の tab stop を管理するという様な事ではない様だ。

2016-09-25

* 各機能のテストコードを書く必要がある。

* BEL/HT/VT の正しい実装

* cell で毎回セルのアドレスを計算して取得するのではなくて、
  window.cur に現在のセル、もしくは現在の行へのポインタを保持した方が
  効率が良いのではないか。

2016-09-24

* planned programs

  - terminal multiplexer
  - terminal with graphical user interface
  - screen の様に複雑なことをする物が最終目的の一つだが、
    一方で、cygterm の様に他のプログラムとの仲介を行う物もあった方が良い。
    何かの折にそのようなシンプルな物が欲しくなることがあるだろうからである。

* ポーリングを O_NONBLOCK でやって sleep するのはやはり良くない?

  とはいいつつ入力と出力の両方を監視しなければならないので結局
  timeout を設定して交互に確認することになるので結局同じかもしれない。
  いや、然し同時に複数のオブジェクトを待つという種類の同期の方法が
  提供されていても良いはずだ。

  これについては今の所は致命的な問題になっていないので対処しない。
  後で余裕が出てきた時に正しい方法を模索する事にすれば良い。

2016-09-23

* PLD/PLU/SGR 10-19 の出力を実装する

* SGR 60-69 の実装方法について決める

  同時に複数の属性を on にできるのかそうでないのか。
  或いは出力先のターミナルに応じて処理を変えるべきか否か。

2016-09-22

* ルビ?

  ANSI や Unicode にルビの機能があるようである。面倒である。

  - ANSI に PTX という物がある。これはルビのための制御機能に見える。
    「CSI 1 \ 漢字 CSI 3 \ かんじ CSI 5 \」などの様にして使うものと思われる。
    行内に無理やり押し込めるのではなくて、隣の行に表示することを意図している様だ。

  - 更に Unicode にもそれ専用の文字がある。
    U+FFF9 .. U+FFFB  Interlinear annotation characters
    「<U+FFF9>漢字<U+FFFA>かんじ<U+FFFB>」などの様にして使う。

    <a href="http://unicode.org/reports/tr20/tr20-1.html">UTR #20: The Use of Unicode with Markup Languages</a>
    <a href="http://www.slideshare.net/xkawabata/2014-1109-texruby">TeXユーザの集い2014　発表資料（W3C Ruby）</a>
    <a href="https://en.wikipedia.org/wiki/Ruby_character">Ruby character - Wikipedia</a>

* ANSI の記述によるとエスケープシーケンスは全て "文字" ではなくて "数" で指定されている。
  つまり、変な文字コードを使っていたとしても、エスケープシーケンスに含まれる
  '[' や ';' や '0' は ASCII における値を使わなければならない。
  従って、ソースコード中ではこれらは数字で表現するべきである。


2016-09-20

* original contra のコードの取り込み

  更にもっと古い ConsoleEscapeSequenceHandler についても統合を行いたい。

* gh-pages

2016-09-18

* 端末を作って遊ぶ。

* 端末の要素

  制御シーケンス・文字コードの解釈

    文字コードの枠組み iso2022 は制御シーケンスと渾然一体になっているので、
    どの様に取り扱うかは微妙である。既存のライブラリを部分的に使うかそれとも全部自前で処理するか。
    取り敢えず UTF-8 だけに対応してみるというのであれば大分楽である。というか自明である。

    制御シーケンスの最大の長さというものは決めておかなくても良いだろうか。
    幾らでも巨大なシーケンスを許容すると、超巨大なシーケンスを送りつけてメモリ不足にさせる、
    という攻撃が可能になってしまう。例えば、巨大なシーケンスはファイルに書き出すなどとしても、
    ディスク容量に依存してしまう。そういう訳で制御シーケンスの長さに制限を与えるのが現実的である。
    しかし現代に於いては巨大なデータを送りつける用途もある。
    シーケンスの種類に応じて適応的に処理するべきな気がする。

  バッファの管理

    内部的なデータの表現方法が鍵になる。この定義によって性能が規定される。

    そもそも何が必要か。行、文字、文字幅、属性の管理が必要だ。
    更に unicode grapheme clusters を考えると、結局文字はどう頑張っても可変長になる。
    属性については種類を限定せずに幾らでも拡張可能な様に設計するのが無難だ。
    また、画像だとかのインライン要素も管理しなければならない。

    同時にメモリ効率や変な脆弱性が入らない様にしたい。

  bidi

    既存の各 terminal が bidi をどの様に処理しているのかは確認しておく必要がある。
    特に行折り返しの時にはどうしたら良いのだろう。
    http://unix.stackexchange.com/questions/100811/are-there-terminal-emulators-that-support-bi-directional-text

    うーん。ある場所に hoge (表示 egoh) と出力して、その後にカーソルを色々移動した後に
    hoge の末端に移動して fuga (表示 aguf) と出力したとする。この時にこの二つの文字列が結合して、
    agufegoh という表示になるとそれは変だ。という事は bidi に対応する場合には、
    どの部分が連続して出力されたものなのかという情報を保持する必要がある。

    例えば属性を用いてこれを表現するなどはどうだろう。或る属性がついている文字は、
    次の文字と結合して bidi になる。最後の文字には bidi 属性は設定しない。次の文字とくっつかない為に。
    但し、最後の文字を削除する場合には前の文字から bidi を削除しないと勝手に次の文字とくっついてしまうので注意する。

    →ECMA-48 を読んでいたらわざわざ bidi の為に presentation component
    と data component という物が用意されている様だ。[ECMA-4.8/6.1]

  描画部

    この部分はただ愚直に実装すれば良い。何も問題はない。
    但し、更に別の端末に対して出力を行う場合には terminfo 等を参照せねばなるまい。

  キーシーケンスその他

    逆にユーザ側からアプリケーションに向かって送信されるデータ。
    これについても愚直に実装すれば良いだけである様に思う。
    但し、別の端末から受け取ったデータは翻訳する必要がある。
    これはやはり terminfo 等を参照する事にする。



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2016-10-05

* SPH/SPL

  page_home_position -> page_home, page_limit
  取り敢えず値を設定できる様にする。

* sequence_decoder, sequence: support ESC sequence
* escape sequences の解釈

2016-10-04

* SCP SPD に対応する。
* CR ... SCP SPD の向きが逆の場合に対応する。

* data position と presentation position の変換方法について。

  SCP による character path の方向は基本的な計算部分に影響を与えない。
  何故ならば character path は presentation position の番号と、
  実際に表示される位置の対応関係を規定する物であって、
  data position と presentation position の間の関係には影響ないからだ。
  但し、directed string の ltor と rtol は、
  character path によって意味が入れ替わるので注意する。

  従って、計算の上で気にしなければならないのは directed_string だけである。
  directed_string によって向きが反転している範囲の中にあれば反転するという事をしなければならない。


  presentation position -> data position の実装は比較的簡単である。
  1 先ず presentation position を x とする。
  2 directed_string のリストから x を含む
    一番大きい directed_string を拾って str とする。
    もし x を含む directed_string がもうなければ処理は終了する。
    ここで x は記憶部で最終的に必ず str の範囲に含まれる事に注意する。
  3 もし str の向きが外側の向きと一致していなければ x の位置を反転させる:
    x = str.end - 1 - (x - str.begin);
  4 以降は str 及び、その中に含まれる directed_string のみを考えれば良い。
    従って、str に含まれる directed_string のリストについて 2 に戻って繰り返す。

  data position -> presentation position については少々厄介である。
  presentation position -> data position の逆の処理をすれば良いかと考えたが、
  外側と較べて反転しているかどうかを知るためには外側から順に辿って
  一旦何処で反転が起こるのかを記録しなければならない。
  もっと賢い方法はないだろうか。
  反転は線形の関数である事を思えば、shift の量だけを記録すれば行ける気がする。
  反転が起こる度に、

    x = -x + (str.end + str.begin - 1)

  という事になる。i 回目での shift 量を

    shift[i] = str[i].end - 1 + str[i].begin

  とすれば、最終的な結果は、

    x[i] = -x[i-1] + shift[i],
    (-1)^i x[i] = (-1)^{i-1} x[i-1] + (-1)^i shift[i],
    (-1)^n x[n] = (-1)^0 x[0] + ∑[i = 1 .. n] (-1)^i shift[i],
    x[n] = (-1)^n x[0] + ∑[i = 1 .. n] (-1)^{n-i} shift[i]

  で求められるという事になる。但し、i の小さな shift の方が、
  より小さな範囲の directed_string に対応している。
  今、番号付けを変更して k = n - i とすれば、
  一番大きな単位の directed_string が k = 0 に対応する様になる。

    x[n] = (-1)^n x[0] + ∑[k = 0 .. n - 1] (-1)^k shift[n-k].

  これで行く。自身がないので様々な例に対してテストを実行して確認する。

    x[n] = (-1)^n (x[0] + ∑[i = 1 .. n] (-1)^i shift[i])

* tty_player (SGR): ANSI font

* bidi サポート [2016-10-02]

  具体的にどの様に実装するべきかについて。
  これは ECMA TR/53 の Appendix にある動作例が参考になる。

  思っていたのと似たような動作を考えている様だが、実際にはもっと複雑である。
  具体的には nested strings という仕組みが問題である。
  行の中に配置を反転して表示するべき領域を埋め込むという構造は想定していた。
  しかしその様な文字列を幾らでも入れ子にする事ができる様なのである。

  問題点が二つある。

  1 先ずその様な入れ子構造を表現するのに適したデータ構造は一体なんであろうか。

    勿論、愚直にそのまま実装すれば実装できない事はないが、
    パフォーマンスなどへの影響が気になる。
    特にこの様な、実際に使う人が本当に存在するのかどうか不明な謎機能のために、
    フラットな配列の構造を諦めて何らかのリストの様な構造にするのは受け入れがたい。
    つまり、基本的には配列の構造にデータを記録しておいて、
    この様な埋め込み文字列の様な物を表現したい場合に特別な取り扱いをするというのが良い。
    その時にできるだけシンプルに最小限のデータサイズで記録する方法があれば良い。
    特に、入れ子構造を表現する為の固定長のデータ表現が存在しうるかという事である。

    例えば各セルにネストレベルを記録したらどうだろうか。
    そうしておけば同じ位置でネストレベルが複数段階変化する場合に対応できる。
    (ab[[cde]fgh]ijk の様な感じの入れ子構造が存在しうる。)
    しかしそれだと各ネストレベルでどの方向性を持っていたかという情報を保持できない。
    或いは完全に別のデータ構造として構造を保持するという手の方が現実的なのかもしれない。

  2 もう一つは後から編集が起こって別の文字を上書きした時に、
    どの様に更新範囲を検出するのかという事である。
    更に関連して編集の順序を記録しないでもちゃんと一意的に座標の対応を取る事ができるのかというのも気になる。
    また SHP や SLL を変更した時に既に出力した内容について
    どのような表示を行うべきかについても考える必要がある。

  うーん。その前にもっと詳しく動作について考えておく必要がある。

  文字列をどの様に記録するかについては 2016-10-04 に議論を残した。
  具体的に文字列の挿入を行う時にどの様に動作するべきかについては後で考える事にして、
  取り敢えずはデータ構造を確定する事にする。

  →データ構造は Memo 2016-10-04 にある通りに、
    方向付き文字列のリストとして表現する事にした。
    後で問題が起こればその時にまた変更すれば良い。


* SLL/SLH と DCSM の関係

  | DCSM(PRESENTATION) の時 DCSM(DATA) の時で動作が異なる。
  | ここで問題になるのが実際に効くのは、
  | SLL/SLH を設定した時の DCSM なのか、
  | それとも実際に CR などを実行する瞬間の DCSM なのかという事である。
  |
  | もう一つ気になるのは、SLL/SLH を設定した時の DCSM が効くという場合に、
  | それを data component における座標に対応させる事は可能なのかという事である。
  | (つまり単に data component における座標を記憶しておくだけで良いのか、
  | 或いは、SLL/SLH を設定した瞬間の DCSM の状態も
  | 一緒に記録して置かなければならないのかという事である。)
  |
  | これを決定する為には、CR の動作を詳しく調べて、
  | それに整合する様に決めなければならない。
  | 例えば DCSM(PRESENTATION) で CR/LF を実行した時に、
  | LF によってカーソルが丁度下に移動する様にしたい。
  | もしくは DCSM(DATA) の時に CR/LF して、
  | LF によってカーソルが data component 内部で丁度下に移動する様にしたい。
  |
  | CR について調べた。CR 自体の動作が DCSM, SIMD によって、
  | SLL の値を使ったり SLH の値を使ったりという風になっている様だ。
  | そして SLL/SLH が設定された時の DCSM がどうたらという様な記述は全くない。
  |
  | a つまり、SLL/SLH の側では特に DCSM の値によって記録方法を変えたり
  |   という事はしなくて良い様に思う。
  |   それに、その方が自然である。つまり、DCSM や SIMD によらない
  |   一定の範囲が存在して、CR の方がモードによって変化するという事である。
  |   範囲自体が DCSM や SIMD を切り替える度に変化するというのは変である。
  |   一方で DCSM(PRESENTATION) DCSM(DATA) の切り替えによって、
  |   見た目の範囲が変わってしまう。
  |
  | b (他の例) DCSM(PRESENTATION) か DCSM(DATA) かに拘らず表示部での表示位置で
  |   記録するという様な実装も考えられたが、DCSM(DATA) の状態で
  |   SLL/SLH した行で表示部・記憶部で複雑な座標の対応になっている場合、
  |   記憶部での値で指定した列を表示部での座標に変換して記録する事になる。
  |   どの様に動作するかを予期するのが難しく、しかも使い所が分からない。
  |   うーん、訳が分からない。
  |
  | やはり自然なのは a である。
  | ECMA-48 の説明には SLL/SLH の項目で矢鱈説明がされていて、
  | SLL/SLH した瞬間に複雑な処理をしなければならない様に錯覚するが、
  | これらの説明は単に CR や他の制御機能にどう影響を与えるかを説明しているだけと思われる。
  | というか、CR や他の制御機能の説明の所に書かれている動作をそのまま再度説明しているだけで、
  | ECMA-48 SLL/SLH の部分に書かれている説明は冗長である。
  | 丁寧という事なのかもしれないが規格書らしくないし、却って混乱を招いている。
  | ここは単に "CR/IL/DL/NEL で参照される、行内の使用範囲の先頭列を設定する" とか書いておけば良いのだ。

  [結論]

  - SLL/SLH によって記録される情報は単に一つの列番号であり、
    DCSM の状態に応じて変化する様な物ではない。
  - 機能 CR/IL/DL/NEL を実行する際に、
    それぞれの機能が DCSM の値に応じて SLH または SLL の値を参照する。

* 双方向テキストに対応する際の動作について [2016-10-02]

  | ★例えば nested strings の中で行末に達して、折り返し処理をしなければならない場合にはどうすれば良いのか。
  |
  |   例えば [one [two [three] four] five] の各箇所で改行が起こった場合にどの様になるべきだろうか。
  |   但し一番外側の括弧で括られた部分は左から右で、その内側の括弧で右から左になり、更に内側で左から右になっているとする。
  |   折り返しがない場合には、[one [ruof [three] owt] five] という具合に表示される。
  |
  |   1 もう少し単純化する。[one [two] five] の場合はどうだろう。[one [owt] five] と表示される。
  |     これで tw の直後で改行が起こったとする。こうか?
  |
  |       [one [wt
  |       o] five]
  |
  |     或いは、
  |
  |       [one [ow
  |       t] five]
  |
  |     元の言語の文章に於いて改行を考えるとすれば前者の様な気がする。
  |     しかし改行の後に一番左に配置されるというのは元の言語の文章ではないことだし、
  |     また、これはその言語の文章というよりも外側の言語に埋め込まれた物だと思うと、
  |     埋め込まれた部分の内部で内側の言語の改行ルールによる改行が行われるというのも変である。
  |     つまり、改行というのは一番外側のレベルで行われる物なので、
  |     一番外側の言語の規則で行われるべきものなのではないかという気がするのである。
  |     だとすると後者のほうが正しいという事になる。
  |
  |   2 具体的な例で考えてみないと感覚がよくわからない。
  |
  |     日本語は古くは右から左であったが、しかし、
  |     これは、基本的に縦書きで高さが狭い場合には右から左になるという事であって、
  |     本当に右から左なのかというと微妙だし、更にそこで改行を入れることがあるのかというともっと微妙である。
  |     それに普段使っている訳ではないので実際にこれで例を作ってみた所で感覚はよく分からない。
  |
  |     どちらの方が自然だろうか。これは縦書きの日本語の文章に含まれた英文でも同様の事が言えるだろう。
  |     英単語を右に 90 度傾けて印刷する場合には問題は起こらない。英語も日本語も上から下に流れるからだ。
  |     しかし、もし仮に英単語を左に 90 度傾けて印刷する事になった場合にはどうだろう。
  |     英語は下から上に読まなければならない。そしてその途中に改行が入った場合に、
  |     英単語をどの様に並べるべきだろうか。考えて見るにどちらでもありの様な気がする。
  |
  |     取り敢えず、埋め込まれている部分が短い場合には外側の言語のルールで改行し、
  |     内側の言語については一旦行内に全て配置してから見た目で改行を実行するのが自然そうだ。
  |     つまり、1 の例で言えば後者である。
  |     しかし、ある程度の長さの文章(複数行に跨る)が埋め込まれている場合には、
  |     1 の例で言えば前者の様にした方が自然な気がする。
  |     でもやはり総じて後者の方が良いような気がする。
  |
  |   3 ここで TR/53 の例で参考になる物はないか改めて調べてみる事にする。
  |
  |     うーん。途中で改行したりという事はしていない様だ。
  |
  |     % というかそもそもの SRS の動作がよくわからない。
  |     % →と思ったら勘違いだった。data component を見ていた。
  |
  |
  | ★一番初めに各 SRS や SDS の動作について確認しておくべきだ。
  |
  |   SRS 元々確立されている方向性とは逆方向の文字列の開始・終了を定義する。
  |
  |     [ECMA-48] における記述は以下の通りである。
  |
  |     但し、character progression (data component 内の文字の記録順序) は影響を受けない。
  |     つまり、data component の中で見ている限りには SRS はあってもなくても変わらない。
  |     ただ、presentation component における位置との対応を考える為には、
  |     SRS が何処で始まって何処で終わっているのかといった情報を記録する必要があるだろう。
  |
  |     また、"文字列" 中で CVT HT SCP SPD VT によって引き起こされる効果については定義されない。
  |     また are に関係する機能 DAQ, EPA, ESA, SPA, SSA は文字列の中では用いてはならない。
  |
  |   SCP
  |     これは表示の際の方向を指定する。
  |
  |     途中で改行したりした時に一体どういう扱いにするつもりなのかと考えて改めて ECMA-48 を参照してみると、
  |     この制御機能は "現在の行" 及び "それ以降の行 (subsequent lines)" に対して適用される物のようである。
  |
  |     では、既に確立した行に対してはどうなのだろう。例えばカーソルを移動してそこに何か書き込んだ時はどうなるか、
  |     これは TR/53 の動作を見るに、後で SCP してからその行に戻って其処に文字を書き込んだとしてもその行の
  |     characater path は変わらないという様に見える。それでは一旦カーソルを上に戻して、その場所で SCP したら
  |     一体どうなるのだろうか。もし subsequent lines というのが行番号が現在いる行よりも大きい全ての行、
  |     という意味であるのだとすれば既に表示している内容に影響を与えるという事になる。
  |     一方で、もし subsequent lines というのが新しく作成される行なのだとしたら、
  |     既に出力されている行については影響を受けないという事になる。
  |
  |     うーん。説明を読むと、現在の位置に既に書かれている内容をどの様に処理するかについては書かれているが、
  |     subsequent lines の内容をどの様に処理するかについては何も書かれていないので、
  |     新しく生成される行に対してのみこの character path が適用されると考える方が自然だろう。
  |
  |     然し、一方で subsequent lines in presentation component という表現もされれているので、
  |     見た目で現在行よりも下に表示されている全ての行に対して適用するという意味なのかもしれないが、
  |     もしそうだったとすると規格の文章にはミスがあるという事になる。
  |     既に表示されている内容についてどの様に処理するかは active line については記述があるが、
  |     subsequent lines については記述がない。しかし、"subsequent lines にも同様に適用する"
  |     だとかいう感じに簡単に一文付け加えるだけで済むはずなので、この記述がないという事は、
  |     そもそも subsequent lines は空の新しい行であるか、
  |     或いは規格を記述・確認した人たちがうっかりしていて思い至らなくて書き忘れたかのどちらかである。
  |     しかし、規格を記述するにあたって実現不可能な変な記述がないように参照実装ぐらいは行って、
  |     規格に問題がないかというのを確認するのが普通だと思われるし、
  |     特に記述がないという事は subsequent lines というのは新しく生成される行という事で問題ないだろう。
  |     →この解釈については escseq.html に記述する事にした。
  |
  |   TR/53 の二つ目の例を見る限り、文字列の中で新しく文字の挿入を行った場合は、
  |     入れ子のレベルはその部分におけるレベルに埋め込まれる形で文字が挿入される様だ。
  |     つまり、その場所に移動した時点でそこにある入れ子レベルに従う事になる。
  |
  |   結局、一通り ECMA-48, ECMA-TR/53 の内容を gh-pages/escseq.html にまとめた。
  |   結局不明な事は不明なままであるが、何が不明で何が分かっているかが多少すっきりした様に思う。
  |
  |   * 自動的な折り返しに際してどの様に振る舞うかについては記述はない。
  |   * 文字列の中で制御機能を用いて移動を行った場合にどの様に振る舞うかについても記述はない。
  |   * 文字列中での active data position は定義されていない。
  |     しかし TR/53 Annex A で何かしらの方法が与えられている様にも見える。
  |   % * "文字列" の中に後から文字を挿入して追加することができる。
  |   %   これはとても厄介である。
  |
  | ★文字列の入れ子構造は記録部に記録されるのか? そして後で挿入を実行できるのか?
  |
  |   % "文字列" の中に後で内容を追加する事はできるのかできないのか。
  |
  |   TR/53 の Example 2 を見ると、一度出力して確定した "文字列" の入れ子構造の内部に
  |   後から文字を挿入する事によって、入れ子構造を変化させる事ができるという様にも見えた。
  |   しかし、落ち着いて考えてみると実はそうではないのかもしれない。というのも、
  |
  |   1 先ず、規格を参照して見るに strings だとか nested strings の概念があるのは、
  |     data stream だけであって、data component や presentation component に関しては、
  |     string がどうのこうのという記述はない様に思われる。
  |     従って後になって入れ子構造がどうのこうのというのは変なのではないか。
  |
  |   2 また、別に入れ子構造を保持していなかったとしても、
  |     data component と presentation component でそれぞれ独立に文字の挿入を行って、
  |     同時に data position と presentation position の対応関係をセル毎に記録したとする。
  |     その様な動作をしている限りにおいては Example に出ているのと同様の効果が得られるであろう。
  |
  |     しかし何れにしても対応関係をセルごとに記録するとしても、
  |     文字が新しく来る度にその対応関係を大幅に更新しなければならない。
  |     少なくとも文字列が閉じるまでは入れ子構造を保持しておく必要がある。
  |     但し、文字列が閉じた後は内部の並び替えは起こらない物と思って、
  |     入れ構造を記録したデータについては削除しても良い。
  |
  |     然しながら、data/presentation positions の対応表を保持するぐらいであれば、
  |     実のところ元になった入れ子構造を記録しておいても良い気がする。
  |
  |
  |   さて、これを区別するためには TR/53 の Example 2 で挿入する文字列について、
  |   "方向を明示せずに挿入する"、もしくは "SRS 文字列を挿入する" という例があれば良い。
  |   文字列の入れ構造に挿入されるのだとしたら、"方向を明示せずに挿入" した結果、
  |   挿入点の方向に影響されて文字列が表示されることになる。
  |   一方で、単に指定した位置に data/presentation component 上で文字列を挿入するというだけであれば、
  |   "方向を明示せずに挿入" した結果として普通の文字列の向きで文字が表示されることになる。
  |   しかし、残念ながら "方向を明示せずに挿入する" 例も "SRS 文字列を挿入する" 例も載っていない。
  |   説明文には "Character insertion is always performed according to the presentation directions
  |   and the nesting level which are established by the data stream." としか書かれていない。
  |   data stream によって確立した nesting level が何処で記録されるかによって解釈が異なる。
  |   もし data/presentation component の各行・文字の位置で記録されるのだとしたら、
  |   入れ子構造を後から変更できるという事になるし、もし nesting level というのは
  |   実際にデータを受け取って書き込む時に保持するものなのだとしたら、
  |   後から文字列を挿入するのは単に data/presentation component 上の配列を見て挿入するだけという事になる。
  |
  |   と思ったが改めて SRS の説明を見ると "SRS is used to establish in the data component
  |   the beginning and the end of a string of characters as well as the direction of the string."
  |   と書かれている。つまり、SRS は data component 内部に入れ子構造を構築するという事になる。
  |
  |   それに data/presentation component の間の座標の対応を一つずつ覚えておく方法だと、
  |   結局どのように表示されているのかということが人にとって良く分からない物になる気がする。
  |
  |   [結論]
  |
  |   文字列の入れ子構造は記録部に記録する。
  |   そして文字の挿入は入れ子構造の内部で行われる。
  |
  |   但し、方向が異なる場合には新しく入れ子文字列を作って挿入するのが良いだろう。
  |   挿入点の方向について意識しなくても安全に挿入ができる様にするためである。
  |   というのはアラビア語など言語自体が方向性を持っている場合、
  |   明示的に SRS/SDS を指定しなくても反転文字列が設定されうる。
  |   その時に或る任意の場所に新しく文字列を書き込もうとした時に、
  |   挿入位置の方向に従って勝手に文字列が反転されてしまっては困るからである。
  |
  |
  | ★途中で折り返しや改行があった場合の処理方法としてどの様な物が考えられるか。
  |   先ず初めに、明示的な改行があった場合にはそのまま其処で改行してしまって良い。
  |   改行前の文字列の内容は前の行に表示し、改行後の文字列の内容は次の行に表示する。
  |   折り返しによって反転部分に改行が挿入された時の動作は微妙である。
  |
  |   a data [he][llo] presentation [eh/oll] (/ が折り返し改行挿入位置)
  |     (行毎に文字列の構造を管理し、表示内容は行分割してから方向を適用したものにする。)
  |
  |     行に入る部分までを一つの文字列の単位として切り、改行を挿入する。
  |     続きの部分はまた新しい文字列として開始する。
  |     この方法が一番単純であり実装に曖昧さが残らない。
  |     これだと外側の文字列に埋め込まれた部分文字列だという風に思うと不自然な結果になる。
  |
  |   b data [hello] presentation [ol/leh]
  |     (複数の行に跨って構造を管理し、表示内容は方向を適用してから行分割したものにする。)
  |
  |     外側の文字列に埋め込まれた形で行を構築して、その後で行を分断したという感じになる。
  |     しかし right-to-left の人にとって見れば読みにくい文章になるかもしれない。
  |     この方法だと改行に跨った領域に "文字列" が存在するという事を管理しなければならない。
  |     特に、後になって行を挿入したり行を削除したりした時に一体どの様に管理するのか謎である。
  |
  |     例えば文字列を構成するセルを一つずつ全て記録してリストにして保持するとする。
  |     - その時、最終的な結果を別の端末に転送する場合にはどうしたら良いのか。
  |       正しく転送する為には文字列を構成するセルの順序に従って端末内を
  |       色々に飛び回る様なシーケンスを生成する必要が出る。
  |     - ※例え文字列の内部で制御機能を呼び出す事が禁止されていたとしても、
  |       後になって行を追加削除したり文字を追加削除したり出来る様になっている以上は、
  |       "文字列" が連続になっている事は保証できないのではないかという気がする。
  |       或いは、挿入される行や文字は全て "文字列" の内部に追加されるという風に考えるのだろうか。
  |     - 然し、何れにしてもその様な実装は極めて不自然である。
  |       その様な動作を期待してそれに整合する様なプログラムを書くのは難しい。
  |       結局、多少動作が人間にとって不自然に思われても、
  |       曖昧さを含まない単純な規則で動作する様に実装しないと、
  |       アプリケーションプログラムを書くのが難しくなる。
  |       人間的に自然かどうかだとかそういった事に対して柔軟に対処するためには、
  |       そういったものは装置の側で対応するのではなくてアプリケーションプログラムの側で対応するべきである。
  |
  |     従って、この方法にするとしても開始点と終了点だけを保持して、
  |     それ以降に内部に行が挿入されたり削除されたりという事は気にしない様にするという手もある。
  |     つまり、開始点と終了点だけを素直に記録して、
  |     間に文字や行が挿入される場合には開始点と終了点も同じだけずらすという様な具合にしたらどうだろう。
  |     - しかし、色々と問題がある。例えば開始点と終了店の間で SCP をした時に行内容の位置がずらされるが、
  |       その時に、元々の文字列の内容があった領域は分断される事になる。
  |       間に新しく入った空白も反転の対象だと解釈すると表示が滅茶苦茶になり、
  |       SCP がどうのといった機能が効かなくなってしまうのでそれはない。
  |
  |   c data [hello] presentation [eh/oll]
  |     (複数の行に跨って構造を管理し、表示内容は行分割してから方向を適用した物にする。)

  色々に考えた結果、一定の結論を得た。
  この結論は 2016-10-04 の memo にまとめる。

  以上の事から "文字列" を管理するデータを行毎に管理する事にする。
  特に文字列を使用する事はそんなに多くない事から、実装の見通しが立ちやすい様なデータ構造を採用する。
  (開始点, 終了点, 方向) の三組を配列に格納し、未だ閉じていない文字列に関しては終了点に -1 でも代入しておく。
  implicit movement をしている限りは終了点の更新は行わない。


2016-09-27

* ECMA-48/9 の記述についてどうするか。

  Control sequences や Control strings の中にある文字 (0xA0-0xFE) は、
  0x20-0x7E と同じに解釈しろと書かれている。しかし、これに愚直に従うと、
  Control strings で日本語などの文字列を送ることができなくなる。

  | というか、何故この様な仕様になっているかというと、
  | ECMA-35 (ISO 2022) に従って 7bit から 8bit に変換した時に、
  | GL に何を呼び出しているかに応じて変換後に 0x20-0x7E が 0xA0-0xFE に
  | map されてしまうという問題があるからなのだと思われる。
  | つまり escape sequences の内、CSI sequences や control strings は処理せずに、
  | ISO 2022 の sequences だけを実行してしまうことに問題がある。
  |
  | 例えばUTF-8 前提でやっている場合にはこの問題は起こらない。
  | あるいは ISO 2022 の sequences と CSI sequences
  | を同時に処理する場合にも問題は起こらない。
  | 然し、何処かに変な filter が入っていたりすると問題になる。
  |
  | 普通は端末とプログラムの間に文字コード変換が入ったりする事はない。
  | 問題になるとすればエスケープシーケンスを出力するプログラムの内部の問題である。
  |
  | | % 通常はエスケープシーケンスを出力する部分と、
  | | % 文字コードを変換する部分は分離されて設計されている。
  | | % 特にエスケープシーケンスを含む文字列を生成して、
  | | % それからそれをエンコードすると思われる。
  | | % UTF-8 にエンコードするという場合はどうなるだろう。
  | | % 多分受信側で先に UTF-8 をデコードするという仕組みにしている限りは何も起こらない。
  | | % では、ISO 2022 にする場合はどうなるだろう。
  | | % 先ず、制御文字の表現は決まっているので変な混乱は起こらない。
  | | % 一方で、0x20-0x7E が ISO 2022 を通した結果としてどの様に変換されるかは謎である。
  | | % もしかすると GR に割り当てられた上で 0xA0-0xFE というバイトで送られてくるかもしれない。
  | | % しかし、この場合は先に ISO 2022 から UTF-32 に戻してしまえば、
  | | % 結局元々の数値に戻るのでやはり問題は起こらない。
  | |
  | | つまり「送信側(アプリケーション)はエスケープシーケンスを生成してからそれをエンコードする。
  | | 受信側はUTF-32にデコードしてからエスケープシーケンスを解釈する」
  | | という取り決めにしている限りは途中の文字コードが ISO 2022 であろうと UTF-8 であろうと平気である。
  | |
  | | しかし送信側(アプリケーション)が通常文字列はエンコードしてから出力するが、
  | | エスケープシーケンスは直接書き込んでしまう、などという設計になっていると面倒だ。
  | | 受信側ではエスケープシーケンスと ISO 2022 のシーケンスを同時に処理する必要がある。
  | | その様にしておけば一応問題は起こらないのだろうと思われる。
  | | また UTF-8 だと 8bit C1 と UTF-8 を構成するバイトの区別ができないので死ぬ。
  | | ただ出力するエスケープシーケンスを 7bit C1 文字に徹していれば問題は起こらない。
  | |
  | | - gettext を使って国際化している場合などにはこれに該当すると思われる。
  | |   ただ、gettext で ISO 2022 を出力する際に毎回 GL を元の状態に戻すと思われるので、
  | |   先にデコードを実行してからでも問題は起こらない?
  | |   (そうでないと gettext を通さない英語のメッセージなどが文字化けしてしまう。)
  | |   UTF-8 の場合には 7bit エスケープシーケンスだけ出力する様に設計されていれば、
  | |   先にデコードして問題ない。8bit C1 を使っている場合にはそもそも論理的に
  | |   一意な切り出しが不可能なのでアプリケーションが壊れていることになる。
  | |   なのでそんなアプリケーションの事は気にしなくても良い。
  | |
  | | - gettext などは使わずに自前で文字列をエンコードしながら、
  | |   それでいてエンコード結果にエスケープシーケンスを挿入している場合は、
  | |   やはり問題が起こる。この場合は確かにエスケープシーケンスとデコードを同時にしなければならない。
  | |   しかし、そもそも stateful なエンコード形式を採用していながら、
  | |   そのエンコード結果を切り貼りする様なプログラムは壊れているとしか言いようがない。
  |
  | 以上の考察からまともな実装になっているアプリケーションの出力は、
  | 普通にデコードしてからその後で制御シーケンスの処理を行っても問題は起こらない筈である。
  |
  | もう一つの可能性は伝送路の途中に文字コード変換が挟まっている場合である。
  | この場合でもまともな設計のアプリケーションの出力する制御シーケンスならば、
  | 制御シーケンスは壊されずにちゃんと文字コード変換される筈である。
  | なのでこれも問題ないのではないかという気がする。
  |
  | さて、一方で気になる事もある。この ANSI (ECMA-48) が制定されたきっかけは、
  | 文字コードによってアルファベットなどの実際の数値が異なるので、
  | bit combinatinos (column/row) を用いて規格を記述する、という事である。
  | つまり、文字コードの変換をする前の生のバイト列に対して処理することを考えている。
  |
  | - うーん。プログラムを書く上では 'a' などと書くとそれがどの様にエンコードされるか (execution charset)
  |   が保証できないので危険で、だからこそ 0x61 などの様にして表現するわけだが、
  |   でもよく考えたら U'a' とか書いておけば済む話の様な気もする。
  |
  | これらの整合性については ISO/IEC 10646 に記述があるという事だった様に思うが
  | 一体どのようにしているのか実際に確かめてみる必要がある様に思う。
  |
  | http://kikakurui.com/x0/X0221-2007-01.html
  | [JIS X 0221/D.2.Note3] によると C1 の文字は U+0080 - U+009F を UTF-8 に変換した表現を持つとしている。
  | つまり、エスケープシーケンスを含んだ文字列を char32_t の列で作っておいて、
  | それをまるごとエンコードするという方式になっている。
  | [JIS X 0221/15] UTF-32, UTF-16 の時も同様のようである。

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそうしろと書かれている。
  それ以外の実装は駄目な実装なので気にしなくても良い様に思う。

  | しかし、ECMA-48/9 にある事を考えて、駄目なアプリケーションの為に
  | 途中で GL と GR が入れ替わったりする可能性を考慮に入れて、
  | CSI sequences だけは 0xA0-0xFE を受け入れても良い?
  | と思ったが例えばその後 UTF-8 に変換されたりすると、
  | 最早 iso 2022 でどの様な構成バイトを持っていたかの情報も失われてしまうので、
  | 下手に対応しないのが良い様に思う。
  |
  | うーん。改めて ECMA-48/9 を読んで見る。
  | 結局のところ iso 2022 の state に依らず同じ representation を
  | 制御機能に持たせたいが、その様にすると 7/8 bit 変換でぶれができるという事に見える。
  | そして実は iso 2022 の範囲内で扱っている限りに於いては 7/8 bit 変換のぶれは
  | 必ず GL/GR の入れ替わりしかないということが保証されているのだろう。
  | しかしそこに Unicode が入ってくると混乱が生じる。
  | Unicode から iso 2022 への変換は一意でない。
  | 同じ文字が複数の言語に含まれているかもしれないからだ。
  | だとすると GL/GR の文字化けは一旦 unicode にすると復元不可能という事になる。
  | というか文字化けとかそういうのに限らず、
  | "iso 2022 の state に依らず同じ representation になっている制御シーケンス" を
  | そのまま unicode に変換した時点で単射性が失われるので復元不可能である。

  ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、ECMA-48/9 の内容に対応する必要はない。

2016-09-24

* 取り敢えず 00/08-00/13 は実装しようと思ったが、ECMA-48 にある FF の説明が分からない。

  screen では FF は単に無視される様だ。一方で ECMA-48/8.3.51 には FF は、
  列はそのままで、presentation component の中の次の form/page の
  page home position がある行に移動するという事になっている。

  然し、form だとか page とか page home position だとかは一体何なのか。
  仕方がないので ECMA-48 の初めの方の説明も見てみる事にする。
  presentation component だとか device (装置) について書かれているのは 6.1 である。

  | [ECMA-48/6.1.1, 6.1.3] presentation/data component とはそれぞれ行の集まりであり、
  | 行は文字を表示する位置の集まりである。
  | [ECMA-48/6.1.5] presentation が実際に表示される座標に関連する物であって、
  | data は内部的な座標に関連する物と考えれば良い。双方向 (bidi) の文字列表示に対応する為にある。
  | [ECMA-48/6.1.2, 6.2.4] presentation/data component はそれぞれカーソル (active position) を持つ。
  | active line/field/area/page はそれぞれカーソルが存在しているそれを指す。
  | [ECMA-48/6.1.5, 6.1.8] 両者のカーソルの位置は連動 (indirect movement) する。
  | [ECMA-48/6.1.6] 文字の挿入によるカーソルの移動は data component に作用する (implicit movement)。
  | [ECMA-48/6.1.7] 制御機能によるカーソルの移動は data copomponent もしくは
  | presentation component に作用する (explicit movement)。
  | 何れのカーソル移動の場合にも存在しない場所に移動しようとしたときの動作は処理系依存である。

  この説明の中で既に field/area/page などと言った定義の不明な語句が出てくる。
  もっと遡って調べる必要があるのか。最初の語句定義に色々載っていることに気付く。
  [4.2.7] Area: 範囲。連続する文字描画位置の集まり (必ずしも1つの行に含まれているとは限らない)
  [4.2.40] Field: ある tabstop から次の tabstop までの area (範囲)。
    但し、次の tabstop はその field には含まない。
  [4.2.56] Page: 連続する行の集合。
  [4.2.57] Page home position: presentation/data component の中でカーソルがそれ以上前へ動かせない位置。

  結局良くわからない。特に page が一体何なのかというのが分からない。
  というか出力のデバイスとして display または printer を想定するという事が書かれていたので、
  printer の場合には page というのはそのまま物理的な紙の事だと思って良いだろうか。
  だとすると、display を考える時には page という物を想定しなくても良いという事だろうか。

  改めて SPH/FF の説明を読んで見る。物理的な page だと思うとこの説明も納得が行く。
  page home position は紙を1枚送った後に何処にヘッドを置くのかという事に対応するのだろう。
  だとすれば display での自然な実装は、clear screen してから
  SPH の設定した位置を含む行に移動するという事だろうか。

  - ところで screen で試してみたが SPH にも対応はしていない様だ。
  - 次に xterm で試してみた所 FF は VT と同じ役割を持つ様に設計されている様だ。
  - mintty は xterm と同じ動作だ。
    沢山の機能を実装している RLogin はどうだろう→RLogin も xterm と同じく VT で実装している。
    SPH 等には対応しているのだろうか→対応していない様だ。
  - 更に RLogin の説明を読むと LF/VT/FF は全て同じ動作をする様だ。
    また LF で CR LF の動作になっている様に見えたのは仮想端末が LF を CR LF に翻訳しているからの様だ。
    基本的には全て VT の動作を行う。そして Mode 20 LNM でその動作を変更する事ができて、CR LF と同じ効果にできる。
  - これについて xterm でも確認を行ってみたが、やはり同様に LNM で VT/FF/LF の全てが影響を受ける様だ。
    また、何れも SPH 及び FF のそれっぽい実装には対応していない様だ。
    様々な端末における動作がよく分からなかったので包括的に調べる事にした。

  | 調査方法
  |
  | $ stty nl; printf '\e[20hhello\nworld\n\e[20lhello\nworld'
  | $ stty nl; printf '\e[20hhello\vworld\n\e[20lhello\vworld'
  | $ stty nl; printf '\e[20hhello\fworld\n\e[20lhello\fworld'
  |
  | - 仮想端末が勝手に \n を \n\r に変換しない様に設定する必要がある。
  | - Mode 20 LNM が設定されているかどうかで振る舞いが変わる。
  | - 更に現在位置が最終行かどうかで振る舞いが変わりうる。
  |   次の行を追加するかどうかで実装にぶれがある様だ。

  結果は gh-pages branch の escseq.html にまとめた。

* これから本格的に端末の機能を実装していこうと考えている。
  しかし、多少プログラムが長くなってきたので再度構造を考えてからにする。

  window 自体はできるだけ plain な構造体にしたい。
  端末自体は window とは独立に "window を書き換える者" として実装したい。
  また window の描画先は "window の中身を写す者" として実装したい。
  つまり受動的なオブジェクトとして描画先を定義するのではなくて、
  能動的に window の中身を見て描画を行うのである。

  window を書き換える者の名前は何にしようか。案としては
  controller, painter, writer, layouter, application,...
  writer や application は一般的すぎる気がする。
  layouter は何か違う気がする。painter にすると、
  window を実際に描画する者の方は一体何になるのかという問題がある。
  controller も少々一般的というか余りしっくりと来ない。
  window を碁盤か何かと考えれば player と observer がいい。
  或いは window も board か何かに改名するか。
  (しかし、"player" はまた別の意味にも取れるかもしれない。)
  →取り敢えず各クラスの名前を変更する。

  出力に関しては現在は全体を出力する様になっているが、
  これは勿論効率が悪い。dirty section を管理する様にしなければならない。
  しかし一つの window に複数の observer がくっついている場合には、
  全ての observer で同じタイミングに同じ範囲を反映する様にするか、
  もしくは各 observer 側で dirty section を管理しなければならない。
  一つの window の履歴から各 observer の中で dirty section を再現するのは困難である。
  各セルについて version 番号を保持するという手もあるが効率的ではない。
  また、行の移動なども追跡したい。
  という訳で、やはり実際に window を変更するのと同時に dirty section を更新するしか無い。
  従って、実際の実装では (dirty section 情報を書き出すオブジェクト) を用意して、
  observer が自分の中に保持しているそれを、window の内部にあるリストに登録し、
  window は自分の状態が変更される度にそのリストにある dirty section オブジェクトの更新を行う、
  という仕組みにするのが良いのではないかと思う。

  何れにしても、出力部分を後で処理する事にする。
  それよりは先に実装するべきは player の方である。
  受け取ったバイトに応じて制御機能を呼び出すのである。
  また同時に UTF-8 のデコードも行いたい。
  一番初めに実装するべきは何か。UTF-8 のデコーダか。
  何でも良いから早く動くようにしたいという意味では、
  普通にバイトを受け取ってそれを書き出すという風にすれば良い。
  現在の put_char 関数を拡張する形で良いのではないだろうか。
  取り敢えず出力部分に関しては別のファイルに分離するか。

* is_ideogram_exclusive が使われていない -> fixed
* 49 が無駄に出力されている? -> fixed

2016-09-23

* 仮想端末の作り方については確か POSIX にサンプルコードが載っていたはず。

  [[posix_openpt>http://pubs.opengroup.org/onlinepubs/9699919799//functions/posix_openpt.html#]] これ。

  ポーリングは O_NONBLOCK にするのが楽?
  [[ファイル入出力の基本 (IO モデル) を勉強する - フリーフォーム フリークアウト>http://d.hatena.ne.jp/cou929_la/20121103/1351950688]]

  あと exit とか _exit とか _Exit とか色々あるけれど何だったか。
  [[_Exit>http://pubs.opengroup.org/onlinepubs/9699919799/functions/_exit.html]]
  [[fork - Wikipedia>https://ja.wikipedia.org/wiki/Fork]] たぶん _exit でよい。

  一応何か起動した。
  bash: cannot set terminal process group (2692): Inappropriate ioctl for device
  と出るので子プロセスで setsid() しなければならない。

  さて、次に仮想端末の設定が変だ。どうも親プロセス側の仮想端末の設定がいけない様だ。
  (というか bash 側は bash 側でなんとかしているはずだ。)
  と、色々試行錯誤した後で以下の親切なページを見つけた。

  [[PTY を使ってシェルの入出力を好きなようにする - Hika Hibariya>http://note.hibariya.org/articles/20150628/pty.html]]

  簡単にできた。色々調べたりしながら分かった setsid や dup2 のことも全て書かれていた。
  初めから此処を見ていれば余り悩むこともなかった (然し理解が浅いままだったかもしれない)。
  あと、終了時に念のため子プロセスを kill しておくようだ。
  と思ったらこれらの事は詳細UNIXプログラミングという本に書かれている様だ。

2016-09-20

* バッファのデータ構造 [2016-09-19]

  行の管理

    行の管理はB木が良い様に思われたが、世の中にはスキップリストというデータ構造もある様だ。
    平衡を保つ仕組みは複雑になりがちだがそれから開放されるというのが売りの様である。然し実際の所どうなのだろう。
    Wikipedia によるとやはりリスト構造であるが故に遅いという様なことが書かれている。
    もっと調べると、M分木にすればB木だと logN/logM になるが、
    スキップリストだと M logN/ logM になるとある。考えてみれば確かにそうだ。
    連続添字の配列として使う場合は、赤黒木よりは良いけれど B 木には及ばないという所ではないか。
    しかしながらスキップリストには、アルゴリズムが簡単なお陰で並列処理・非同期処理などで分がある様だ。
    しかし、もし一旦画面の外に出た部分で内容の更新が起こらないのだとすれば、
    わざわざB木にしなくても単なる配列(or linked array)で良い。
    表示領域の高さは精々数百行なので挿入などは大したことない。

  文字の管理

    % 文字の管理はどうするのか悩ましい。
    % 一つの方法は列数と同じ要素数の配列を用意して、
    % その文字が表示される位置に文字を書き込むというものである。
    % しかしそれだと grapheme clusters に対応するのが苦しい。
    % 外字的な取り扱いにして新しい種類の clusters が来る度に登録を行うという手がある。
    % メモリリークを防ぐためには参照カウンタ方式にでもするか。
    % 遅そうではあるが、普通の文字を扱っている分には overhead がないというのは良い。
    % 一方で、proportional な font を許すような terminal を考えるとこの方法は苦しい。
    % (そもそもそんな物があるのか分からないし、あったとしても各文字の幅や
    % kerning などをどの様に取り決めておくのかという大きな問題がある。
    % 取り決めをしておかないと表示が乱れることになる。)
    %
    % 或いは、初めから可変長な文字の存在を受け入れて、
    % 要素が可変長な配列みたいな構造にしてしまうという手もある。
    % メモリ的にはこれが最もコンパクトである。UTF-8 を使うことにすれば
    % 通常のアルファベットを扱っている限りは各文字 1B しか消費しない。
    % 但し文字幅などの補助情報を持たせるとすると結局 2B になるか。
    % この時の問題はその様なデータ構造は前代未聞なので効率良い実装が可能なのかという事である。
    % 特に index を指定した時に対応する cluster を特定するのに必要な補助情報と計算時間である。
    % 補助情報が一切ないと先頭から順に文字を区切って行かなければならず不毛である。
    % 一応 B 木の各節で、下にぶらさがっている cluster の数を保持しておけば大分ましになる。
    % 問題は B 木の葉である。一つの方法は 1 cluster 1 byte の配列 (A) と、
    % 実際の文字の羅列を記録した配列 (B) の両方を保持して、
    % (A) に (B) 内での index を記録する方法である。
    % 然し、この方法だと単一の grapheme cluster の合計サイズに制限がかかってしまう。
    % また、その葉に含まれる全データサイズにも制限がかかる。
    % しかし、B木の容量を要素数ベースではなくデータ量ベースにするという手もある。
    % 更に一つの cluster が複数の葉に跨る事も許すことにすれば良い。
    % しかし効率の面から言ってこの方法は本当に得策なのか。
    % そもそも端末画面の横幅というのは上限がある。
    % 1行の文字数に制限のないエディタを作るのでないかぎりはB木にする必要もない。
    % また、端末での操作は基本的に挿入ではなくて上書きである。
    % なので各配列要素が各列に対応する様な設計の方が自然である。
    % やはりその様な側面から考えてもB木にするのは大げさである。
    %
    % やはり struct { char32_t ch; int32_t flags; } の配列のような構造にするのが無難だろうか。
    % しかし大抵の場合アルファベットの plain な配列だという事を考えるとこの表現はやはり無駄が大きいように感じられる。
    % この構造をベースに考えて、より効率化するという方向で考えられないだろうか。。
    % 例えば普段は char 配列で考える事にして、unicode 文字等の場合には何らかの特別な文字を使う。
    % そして unicode 文字本体の情報は別の所に格納する。
    % しかし何処に格納するのか? 格納位置を直接表現しようと思えば sizeof(void*) のデータが必要であり、
    % これだとそもそも char32_t と同じ大きさになってしまう。
    % だからと言って char の 128-255 の値を index に使おうと考えれば 128 文字しか unicode 文字を扱えない。
    % 或いは、128文字ごとに buffer を切り替えるというのも手なのかもしれない。うーん。
    % 然しそれだと初めから char32_t*128 の領域を確保しておくのと較べて得しているのかどうか怪しい。
    % 何より大量の文字が流れている場合、結局最終的に char32_t*画面の広さ 分だけの領域を確保する事にもなりそうである。
    % その場合には、初めから char32_t で全部領域を確保しておけば良かったという結論になりそうである。
    % 計算してみると、例えば sizeof(char32_t)*210*80 = 67.2 KB である。
    % 全部 char で済んだとしても 1/4 になるだけである。何かどうでも良い気がしてきた。
    % 実際に動いているプロセスを見ると普通に MB 食っている。
    % 16bit マシンならば 64KB もしくは 32KB に収めないといけないのかもしれないが、
    % 実のところその様なマシンで動かそうと思ったらプログラム自体をコンパクトにせねばならずそちらの方が問題だ。

    結局、char32_t ch の単純な配列で管理するのが良さそうだ。
    余計にメモリの確保解放を繰り返さない為には、初めから領域と同じ大きさの配列にしてしまう。

    Grapheme cluster は上限の大きさを決めておかないと攻撃が可能になってしまう。

  属性の管理

    さて次に考えるべきは属性をどの様に管理するのかという事である。
    実際の使用される状況を考えると、以下のことが言える。
    - 多くの場合は属性は設定されない。特に大量のデータを出力する場合。
    - 属性が設定されているとしても各文字ごとに設定されることは少なくて、
      連続する文字は完全に同じ属性を持っている可能性が高い。
    - colorful な実装にするにしても xterm 256color までが普通で、
      24bit color 等を出力する様なプログラムは稀である。
    勿論、これに反する様ないじわるなプログラムも作ることはできるが、
    上記の様な状況に対して効率の良いような実装にしてしまっても問題ないと思う。

    どのようにするのが良いか様々な実装について考えてみる。
    一番単純な方法は文字のデータと一緒に管理するという物である。
    しかし、実際に描画する時には一文字ずつ属性に応じて描画するというのは効率が悪い。
    普通は同じ属性の物をまとめて描画するという様にする筈である。
    実際に描画を行う場合には属性が連続しているかどうかを確認して出力を行うことになるだろう。

    もう一つの方法は Poderosa で使われている方法である。属性オブジェクトへのポインタを各セルに保持しておいて、
    描画する際の同じ属性の連続かどうかの判断はポインタが一致するかどうかで判定するという方法である。
    しかし、これが本当に効率的なのかどうかは怪しい。先ず、単に文字を描画すると言っても、
    複数の段階がある。まず初めに背景画像を描画し背景色があればそれを描画する。その後で文字を描く。
    各ステップで使用される属性が異なるので同じ属性が連続しているかどうかの判定も、
    属性オブジェクトをひとまとめにして行うのではなくて、
    関連のある属性のみに絞って連続しているかどうか判定した方が良さそうな物である。
    また、属性オブジェクトの確保・解放などの操作にもコストがかかる様な気がする。
    基本的な属性に関して言えば十分 32bit におさまるので
    32bit/64bit のポインタで属性オブジェクトを参照する方が余程メモリを食う。
    Poderosa の方法だと拡張性が高いのは良いが効率面で余り良くないだろう。

    あるいは Poderosa の様に属性オブジェクトを作るまでではないが、
    属性に変更があるという意味のフラグを char32_t の内部に置いて
    (unicode はどうせ 10FFFF までなのでフラグを幾つか設置する自由はある)、
    別の箇所に属性データを記録するという風にすることも可能だろう。
    しかし、その場合属性データはどの様に保持するべきだろう。
    属性に変更があったかどうかのフラグだけでは属性データに対する参照にならない。
    一つの方法は配列にして適用対象の文字と同じ位置に属性データを格納する事である。
    しかしこの方法だと初めから文字と一緒に属性データを記録するのとメモリ効率的に変わらない。
    逆にメモリの管理や参照が複雑になるだけで意味がない。
    もう一つの方法はハッシュテーブルや平衡木などを用いて sparse な map にするという物である。
    これならばメモリを節約できる。しかし、そこまでする程の事なのかという疑問が残る。
    特に高が属性を参照するのに一々毎回複雑なデータ構造を辿るというのは非効率的に思われる。

    結局、基本的な属性の範囲であれば文字のデータと一緒に固定長で管理をし、
    特別な種類の属性を含む場合にはそれを示すフラグと拡張属性データの index を埋め込む。
    拡張属性データは別の一つの配列に入れておいて管理すれば良い。
    同じ属性が連続して続く場合を考えれば拡張属性データは複数の文字から参照できる様にして、
    また参照カウントを用いて管理するのが良いだろう。

    基本的には各セル struct { char32_t ch; uint32_t flags; }; を保持する。
    基本的な属性に関しては flags に格納する事にして、
    特殊な属性を含む場合には或るフラグを立てておく事にする。
    そのフラグが立っている場合には、別に持っている拡張属性データ用配列にデータの格納を行う事にする。
    拡張属性データの配列要素は、参照カウントと基本属性と更に拡張属性データへのポインタを持つ。
    char32_t ch に収まらない様な unicode grapheme clusters についても同様に処理を行う。


  他に必要なデータはあるか

    他の実装も確認してみる。

    yaft.h を見ると、先ず気づくのは文字データは一つのオブジェクトとして生成し、
    セルはそこへのポインタを保持する。更にセルは uint8_t fg, bg と、
    enum char_attr attribute と、それから width まで保持する。
    加えて sixel support としてセル内部に bitmap データまで持つ
    (これはセルのサイズが固定だからできる事であろう)。
    yaft の目的上、メモリ使用量の上限が分からない動的なメモリ確保ではなくて、
    使用メモリ量の計算がしやすい固定的な割当になっているという事だろうか。
    また、glyph に関してはビットマップに結びついているので、
    予め用意された文字しか扱えない。当然、grapheme clusters に対応しているとは思われない。

    struct cell_t {
        const struct glyph_t *glyphp;
        struct color_pair_t color_pair;
        enum char_attr attribute;
        enum glyph_width_t width;
        bool has_bitmap;
        uint8_t bitmap[BYTES_PER_PIXEL * CELL_WIDTH * CELL_HEIGHT];
    };

    sixel もしくは端末の特定の領域に設置される挿入オブジェクトを管理できる様にしたい。
    当初は属性データに持たせる事を考えたが、属性データは複数の文字で共有されるという性質があり、
    しかし一方で挿入されるオブジェクトは或る位置セルに紐付けて管理した方が良い気がする。
    あるいは領域に属する全てのセルで共有しても良いが、何れにしても属性と同列の物ではない気がする。
    だとすれば flags とは別に更に拡張可能なオブジェクトを設定するべきか。
    もしくは grapheme clusters の別種として管理するべきか。それが良い気がする。
    例えば sixel オブジェクトと文字を両方保持しなければならないという事はなさそうに思われるし。

    tmux.h を見るとどうやら文字データは UTF-8 で保持している様だ。
    5 bytes で属性・フラグ・色・幅・UTF-8の長さを持つ様だ。
    不思議なのはこの実装も "幅" を保持している事である。
    幅なんていう物は右のセルに続いているかどうかだけ見れば良い気がするのだが。
    文字のデータには 9 bytes 使っている。そんなに使う文字は存在していただろうか。謎である。
    特定の grapheme clusters だけは扱える様にしているのかもしれない。

    #define UTF8_SIZE 9

    struct grid_cell {
            u_char  attr;
            u_char  flags;
            u_char  fg;
            u_char  bg;

            u_char  xstate; /* top 4 bits width, bottom 4 bits size */
            u_char  xdata[UTF8_SIZE];
    } __packed;

    screen については何処に定義があるのだろう?? image.h の struct mchar, mline?
    どうも screen がどういう処理方法になっているのか色々見ても見えてこないが、
    取り敢えずそれっぽいものはこれしかない。
    文字に関しては恐らく image と mbcs に分割して格納されている。
    ASCII の範囲内であれば image で、そうでなければ mbcs に続きが格納されるという事だろうか。
    他に色と属性とフォント(?)がある。./configure --help を見たがフォントが何か分からなかった。
    面倒なのでこれ以上は深追いしない。しかし前から思っていたがやはり screen のソースコードは汚い。

    struct mchar {
             unsigned char image;
             unsigned char attr;
    IFFONT(  unsigned char font; )
    IFCOLOR( unsigned char color; )
    IFCOLORX(unsigned char colorx; )
    IFDWCHAR(unsigned char mbcs; )
    };

    struct mline {
             unsigned char *image;
             unsigned char *attr;
    IFFONT(  unsigned char *font; )
    IFCOLOR( unsigned char *color; )
    IFCOLORX(unsigned char *colorx; )
    };

    mintty は term.h に一連の定義がある。
    mintty の構造は他のプログラムに較べてよく考えられた構造になっている。
    綺麗だ。他のプログラムが俄然ごみの様に思われてくる。詳しく見てみる事にする。
    - 気付く事は、色は初めから true color 前提で書かれている。
      256色前提の場合パレットを変更した時に既に表示した文字の色も変わってしまうので、
      理想的にはパレットの変更に追随させておけば背景黒と背景白の切り替えなどをしても見にくくならない、
      等の利点があると考えられるが実際にはそううまくは行かない。
      複雑な出力や様々な色を表示するプログラムの場合、パレット変更は普通は想定しない。
      パレットが変更されたときのことまで考えて設計するのは困難な為である。
      それを考えると true color 前提で書いた方が本当は良いのかもしれない。
    - もう一つ気になるのは grapheme clusters の取扱である。
      複数の文字が一つのセルに含まれる場合には、
      各文字毎に 文字&属性&cc_next(=リスト用) を保持する様になっていて、
      更に、同じセル内の次の文字 cc_next は相対位置で表現している。
      配列中で未だ使用されていない文字は termline::cc_free を先頭として、リストで管理している。
      よく考えられた設計である。気になるのは combining characters が沢山来て、
      行内の文字数が SHRT_MAX を超えた場合に何が起こるのかという事である。
      ちょっと見た所、何も対策がなされていない気がするがいいのか?
      後、相対位置にする意味があるのかというのも可也謎である。
      というか相対位置にしていると行内の文字を削除して
      切り詰める時に余分な操作が必要になってしまう気がする。
      もう一つは文字を格納する領域を行単位で管理している事である。
      これだと部分スクロールなどをする場合に文字の移動と一緒にリストを再構築しなければならない。
      一方で利点もある。行の生成・削除が簡単だという事である。
    - また sixel に関しては特殊な文字コード 0xFFFC で表現している。
      恐らく文字がこれになっている場合には其処には文字ではなくて画像が入るという事なのだろう。
      これの意味する所は端末の文字サイズ拡大縮小に際して
      埋め込み画像のサイズは一緒に大きくなったり小さくなったりするという事である。
      しかし下手に埋め込み画像をピクセル単位にしてレイアウトが変わったりするよりは、
      出力したときの領域をそのままに画像も一緒に大きくなったり小さくなったりするのが自然である。
      また U+FFFC は OBJECT REPLACEMENT CHARACTER で place holder の役割のある Unicode 文字の様だ。
      画像本体はどの様に管理しているのかと思ったら struct term の中に保持している様だ。
      恐らくこの中に画像の表示位置などの情報も含まれているのだろう。
    - 属性も様々な属性がある。
      bold dim underline italic reverse invisible blink
      doubleunderline overline protected wide/narrow/expand
    - temp_strage_t は temp_storage_t のつづり間違いではないだろうか。

    typedef struct {
      unsigned long long attr;
      uint truefg;
      uint truebg;
    } cattr;

    typedef struct {
      short cc_next;
      wchar chr;
      cattr attr;
    } termchar;


  結論

    エディタとデータ構造を共有する (エディタにも転用可能にする) のであれば、
    巨大なファイルに対して行の挿入などがスムーズにできる様に B 木にする。
    また、proportional なフォントに対応するために列と配列要素を対応させる構造は使えない。
    ファイルへの書き出しが楽になる様にするためには、
    ファイルに書き出すデータをそのまま保持するようなデータ構造の方が良いかもしれない。

    しかし terminal 専用に設計するのであればより簡単な実装になる。
    流れたデータは単に末尾に追加可能な配列に溜めれば良いし、
    行のデータも長さ決め打ちで良い。
    端末の領域と同じサイズの単一のメモリ領域でも allocate すれば良い。
    効率を考えれば terminal 専用に設計して、特殊な機能に関しては例外的な方法で処理するのが断然良い。

* 名称 [2016-09-18]

  [議論]

  名称を決めよう、と思うが良い名前は何だろう。
  変に凝った様な名前は嫌なので短いのが良い。でも他とは被りたくない。
  混同しやすいようなものや検索しにくいものも万一のため避けたい。

  暫定的に tty1 (単に tty の初めての実装ぐらいの意味) としたが、
  これは既に /dev/tty1 と被っていてよくない。それに version 番号をつけにくい。

  端末の名前といえば、*term *tty などが多い。
  この系統にするとしたら一文字入れるのが良い。
  然し未だ使われていないものが良い。
  - xterm は言うまでもない。
  - iTerm は Mac 用の物。
  - aterm はルータの製品名に使われている。
  - atty は isatty を思い出す。isatty は何の略だろう。"is a tty" ということか?
  - stty は仮想端末の設定を行うコマンドである。
  - RTTY とはアマチュア無線×TTYのこと??
  - VTTY というのも既にあるようだ。

  関連して pseudo-terminal を pty としたりする様だが、
  それだと pseudo-typewriter にならないか?
  それに、近くにあるコンソール tty に tele という語句が入って、
  遠くにあるリモートに繋がっている pty で tele が抜けていることになり妙だ。話がそれた。
  何れにしても ty だけを取るというのも手なのである。
  - mty とか vty とか…? 三文字だと流石に既存のコマンドなどと被るだろうか。

  screen 系列で行くと
  - 例えば tmux がある。これは terminal multiplexer の略である。
  - また、byobu というのもある (単なる設定集の様な物だが)。
    これは screen の言い換えだ。

  contra

    ふと昔書きかけたプログラムの事を思い出した。contra という名前だった。
    エスケープシーケンスを翻訳して TERM に応じた出力に変換する為の物である。
    もしくは Windows のコンソールに対して出力を行ったりもできる様にするという目的だった。
    これと合流するのが良い考えである様に思う。
    名称も contra に変更する。

    というのも今回のプログラムの構想としては、

    1 端末の内部状態と描画部分を分離する
    2 描画部分は "他の端末に対する制御シーケンス" だったり、
      あるいは "GUI ウィンドウに対する描画" だったり、
      容易に切り替えられる様にする。
    3 端末の内部状態に対する操作は、
      "プログラムから直接操作" したり、
      "制御シーケンスを解釈して操作" したり
      色々切り替えられる様にする。

    ということであったが、一方で contra は制御シーケンスの解析
    と制御シーケンスの解釈部分を分離して、
    制御シーケンスの適用先をまた別の端末にしたり、
    或いは Windows のコンソールやその他の GUI Window にしたりという事だった。

    これらは容易に統合してより機能を綺麗に整理する事ができる。

    - icontrol_function_processor

      制御シーケンスからデコードされた制御機能の呼び出しを処理する。

      実装として二通り考えられる。内部端末に対する操作を行うもの。
      それから他の端末に対する制御シーケンスを生成するもの。

      - tty_writer: icontrol_function_processor を実装

      - window_writer: icontrol_function_processor を実装

    - tty_reader

      制御シーケンスを解釈して icontrol_function_processor を操作する。

    - iwindow_target

      window の内容を表示・出力するための物。様々な実装が考えられる。

      - tty_target

        m_proc = icontrol_function_processor に対する操作として実装する。
        特に m_proc が tty_writer の場合には端末に対する出力になるし、
        或いは window_writer の場合には window の簡易複製になる。

      - x_target
      - gdi_target
      - console_target

        様々な GUI interface やコンソールに対する描画として実装しうる。

    以上を組み合わせれば様々なプログラムを容易に実装できる。

    - 例えば、tty_reader -> tty_writer を組み合わせれば、
      制御シーケンスの翻訳として動作する。

    - 或いは、tty_reader -> window_writer -> tty_target を組み合わせれば、
      screen の様なことができる筈である。

    - もしくは tty_reader -> window_writer -> x_target とすれば、
      新しい terminal emulator を実装できる。
      特に、様々の target を実装するだけで様々な環境に移植できる。

    さて、ここまで考えたのはプログラム→端末のデータの流れについてであるが、
    逆に端末→プログラムのデータの流れ (主にユーザの入力操作) についても
    同様に綺麗に扱うことができる。

    - キーシーケンスの解釈部: キーシーケンスを操作のイベントの列にする。
    - イベントの列を処理する部分:

      例えば、直接ここにプログラムを実装してしまっても良いだろう。
      或いは、また TERM に応じたキーシーケンスに翻訳しても良い。

  [結論]

  contra にする。更に、元々 contra という名前で書いていたコードと順次統合する。
