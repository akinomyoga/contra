# contra dev note


------------------------------------------------------------------------------
  仕様に関して特に註記の必要な事項
------------------------------------------------------------------------------

2020-02-10

* 範囲を指定する制御機能に関する注意 [#M0006]

  ECMA-48 では対になる制御機能で範囲を指定する物が複数ある。しかし、
  範囲が何処で定義されるかは制御機能によって様々なので注意する。

  data stream は端末アプリケーションが出力して端末が受信する一次元の
  データ列である。データ部(記憶部)は受信した data stream を書き込む
  先の、行・列から成る二次元の記憶装置である。表示部はデータ部に含ま
  れる情報を元に二次元的に配置(特に双方向テキストの処理)された文字の
  集まりを保持する。

  a data stream の中で定義される範囲。データ部の中には単一のオブジェ
    クトとして埋め込まれて取り扱われると考えるのが自然だろう。一旦範
    囲が定まったら後になってこの範囲の内容を後で編集したりする事はで
    きない。

    PTX (ルビや平行文字列) はこれに属する。PTX で囲まれる文字列自体
    が複数行に跨る事もある事に注意する。PTX の中で様々の制御機能を使っ
    た時に何が起こるかについては規定されていない気がする。

    Unicode の類似の制御機能も同様に取り扱うのが自然である。

    PLD..PLU はこれに属する。効果は表示部で定義されているが範囲は data
    stream 内で定義されている。

  b データ部の中で定義される範囲。これは[開始]と[終了]をそれぞれ独立
    したオブジェクトとしてデータ部の中に埋め込むことを表す。

    SDS や SRS はこれに属する。

    Unicode の文字にも類似の物がある。Unicode の双方向アルゴリズムが丁
    度埋め込まれた[開始]と[終了]を元に全体的に構築する形になっているの
    で、この取り扱いは自然に思われる。

  c 表示部の中で定義される範囲。これも b と同じく[開始]と[終了]をそ
    れぞれ独立したオブジェクトとしてデータ部に埋め込む物である。但し、
    範囲の解釈がデータ部で行われるか表示部で行われるかが異なる。

    DAQ や SSA/ESA, SPA/EPA はこれに当たる。論理的な事を考えると、こ
    れはデータ部で範囲を定義するべきな気がする。振る舞いとして不自然
    だし或いは protected / guarded が意図した範囲に適用されずに、不
    本意な結果になる可能性もある。[実装: 実際の端末の実装ではデータ
    部で範囲を定義するべき気がする。contra では protected / guarded
    / selected 等の属性は data stream の中で付加する事にし、EA 等の
    操作では DCSM に応じて表示部・データ部で解釈する事にする ]

  o どういう範囲なのか明記されていない制御機能もある。

    GCC(1)..GCC(2) は data stream 内で定義して論理的な複合文字を作る
    とも考えられるし、或いは表示する時にだけ合字として表示するとも考
    えられる。[実装: 唯、GCC(1)..GCC(2)によって非自明な文字幅になる
    のだとすれば先に文字幅を確定する必要から data stream 内で論理的
    な複合文字に確定した方が良い。contra で実装するとしたら取り敢え
    ず data stream 内で一つの文字として組む事にする。途中で図形文字
    以外が来たら中止する。孤立した GCC(2) が来たら無視する ]

2019-08-10

* contra の ISO-2022 の実装について [#M0005]

  * 端末アプリケーションから受信したバイト列を処理する時、
    先ず初めに Unicode 等で復号して char32_t の文字の列とする。
    その後で其処に含まれる ESC 等を処理する。
    特に ISO-2022 のエスケープシーケンスも処理する。
    この時 U+0000..U+00FF を octet に同一視して文字集合の処理を行う。
    それ以外の Unicode 値は ISO-2022 の状態に関係なくそのまま通常の文字として扱う。

    追記: Terminal WG #19 の書き込みで Unicode もその様に実装する事を想定している事が分かった。
    https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/19#note_532641

    > Taken from version 4 of the Unicode book, section 15.1:
    >
    > # Escape Sequences
    >
    > [...]
    >
    > From version 3.2, section 2.8, a bit more explicit that Unicode
    > encoding occurs below the VT100 layer:
    >
    > # Control Characters
    >
    > [...]

  * 初めの段階の decode (UTF-8) では普通に文字列の符号化方式として処理する。
    NUL/DEL 等は勝手に削除したりはしない。然し、制御機能の実行時に
    生じる ISO-2022 復号の時には NUL/DEL は ECMA-48 の仕様通りに削除する。

    追記: 実は ECMA-35 でも実は CC-data-element の中に DEL を
    勝手に挿入・削除しても意味が変わらないとしている (6.2.1)。
    CC-data element は文字の表現も含まれる。NUL については規定はない。
    従って、寧ろ文字の途中に含まれる DEL/NUL は無視するのが
    ISO-2022 的にも正当である。

  * ISO-2022 の文字集合として受け取った文字は、
    Unicode とは独立な文字コード値として端末画面に挿入する。
    但し例外として
    ASCII (94文字集合 4/2) は U+0000..U+007F に同一視する。
    ISO-6429 (96文字集合 4/1) は U+0080..U+00FF に同一視する。

    文字集合には設定ファイル等を用いて予め定義される通常の文字集合と、
    DECDLD 等の制御機能によって動的に定義される文字集合がある。
    更に、94/96/94^n/96^n などの種類がある。
    contra では 94/96 及び 94^2/96^2 に対応する。
    3バイト以上の文字集合には対応しない。

    取扱い上、文字集合を4つに分類する。

      - 分類1 1B文字集合        94/96文字集合
      - 分類2 2B文字集合        94^2/96^2文字集合
      - 分類3 DRCS 1B文字集合   DRCS によって定義される 94/96 文字集合
      - 分類4 DRCS 2B文字集合   DRCS によって定義される 94^2/96^2文字集合

    各文字集合には属する分類の中で一意となる charset_index が与えられる。
    他の分類に属する異なる文字集合に同じ charset_index が与えられる事がある
    事に注意する。

    DRCS に関しては、基本的には DECDLD 等を通して定義された時に
    動的に charset_index が割り当てられていく。但し、
    0F型のエスケープシーケンスに対応する 94 及び 96 文字集合については
    予め 0-79 (94文字集合) 及び 80-159 (96文字集合) の charset_index が割り当てられる。

    文字コード値は属する文字集合の分類ごとに異なる範囲に対応付けられる

      0x010XXXXX .... 分類1 1B文字集合
      0x011YYYYY .... 分類2 2B文字集合
      0x012XXXXX .... 分類3 DRCS 1B文字集合
      0x013YYYYY .... 分類4 DRCS 2B文字集合

    但し、具体的な値は以下の様にして計算される。

      XXXXX = charset_index * 96 + 点
      YYYYY = charset_index * 96 * 96 + 区 * 96 + 点

      ※範囲に収まる為には 1B 文字集合は分類内で 10922 個までしか定義できない。
      2B文字集合は分類内で 113 個までしか定義できない。

  * ISO-2022 文字の文字幅は取り敢えずの実装として、
    1B文字集合に属する文字は全て半角で
    2B文字集合に属する文字は全て全角として取り扱う。

    但し実際には 1B 文字集合の中に combining 文字なども存在する事から
    将来的にはちゃんと各文字に対して割り当てられる様にする必要がある気がする。
    本当に需要があるのかどうかは分からないが。
    或いは combining (non-spacing) な文字は無視して、
    勝手に spacing な文字として取り扱うという様にしても良いのかもしれない。

2018-02-19

* データの表現方法 [#M0004]

  行内の文字ではなくて行内の各文字位置(半角)に対して board_cell を保持する。
  board_cell は二つのメンバを持つ。

  - character_t character (32bit)
  - attribute_t attribute (32bit)

  character は character_flags と文字コードのビット和になる。
  character_flags として何も指定されていない時、値は Unicode である。
  character_flags として is_wide_extension が指定されている時、
  その領域は半角よりも大きな幅を持つ文字の余白である。

  is_wide_extension は一定の大きさの文字を格納する時に
  各セルに対応して board_cell がある。

2016-10-11

* 全角文字の取り扱い [#M0003]

  - ECMA-48/6.1.6/2 暗黙的移動 (文字挿入に伴って起こる) によって現在記憶位置は一つ次の文字位置に移動する
  - ECMA-48/6.3/3 行は予め決められた数の文字位置からなる
  - ECMA-48/6.3/5 文字位置の大きさは其処にある文字に依存しても良い

  これらの記述を総合するに、ECMA-48 では全角文字は複数の文字位置を専有するとして実装されるのではなく、
  文字位置自体の幅が大きくなって実装されるという想定の様である。しかし、この仕様は現実の実装と異なる。
  更に、行に含まれる全角文字の数に応じて各行の大きさが異なるという事になるし、
  また、CUU CUD CUB CUF などの制御機能でどの様にカーソルが移動するかを計算するのが困難になる。
  contra では ECMA-48 に従った実装は行わず、現実の端末と同様の方法で全角文字を取り扱う。

2016-10-04

* 方向付き文字列 (SRS/SDS string) の取り扱い [#M0002]

  0 文字列の定義によって記憶部上の文字の配列に影響は出ない様にする。

    # これは双方向に対応していないアプリケーションでアラビア語や
    # 双方向制御を含む Unicode 文字列を取り扱っても問題が生じない様にする為に必要である。
    # それに記憶部ではできるだけデータの受信順序を保ちたい。

  1 記憶部で文字列の開始終了の情報を記録・管理し、
    これらの情報から一意的に表示部での配列を再現できる様にする。

  2 行にまたがる文字列構造は管理しない。
    受信したデータの中に改行が含まれている場合や、折り返し処理によって行が分割される場合、
    一旦文字列を全て閉じて改行してから再び文字列を開いたかの様に動作する。

    # 理由は複数ある。
    #
    # + [明示的な改行との取り扱いの一貫性]
    #   明示的な改行が含まれている場合は改行前の文字列は前の行に、
    #   改行後の文字列は次の行に表示する。
    #   行折り返しによる暗黙的な改行も同様に取り扱うべきである。
    #   そうしないと暗黙的な改行が挿入された後に、
    #   再度その内容を別の装置に転送する時に、
    #   文章の順序が保たれなくなってしまうからである。
    #
    #   ※暗黙的な改行を区別して記録すれば良いという意見もあるかもしれない。
    #     しかし、様々な制御機能を経た後にそれが意味論的に
    #     まだ暗黙的改行として扱ってよいかなどを決める規則は難しい問題である。
    #     それに暗黙的な改行を区別する為のデータ表現も色々考えると難しい。
    #
    # + [行毎にSCPした時の取り扱い]
    #   行毎に SCP で character path を切り替える事ができる。
    #   例えば SRS 文字列が複数の異なる character path を持つ行に跨っていた場合に、
    #   どの様にその文字列の "範囲" を表現するのかや、
    #   それをどの様に整合的に表示するのかなどに曖昧な点が生じる。
    #
    #   例えば、文字列の各行に含まれる部分を切り出して一つの文字列としたのと
    #   同様に表示するという取り扱いにするのが自然だろう。しかし、
    #   その様に取り扱うのであれば、初めから各行毎に文字列を分割して管理したほうが良い。
    #
    # + [SCP による複数行表示との一貫性]
    #   例えば単に複数行のアラビア語を表示するとして、
    #   SCP を使用して出力する場合と、出力文字列全体を SRS で囲む場合を考える。
    #   前者では次の行は前の行の下に表示される。
    #   後者でも次の行は前の行の下に表示された方が動作として一貫している
    #   (それに読みやすさの観点から言ってもその方が良い)。
    #
    # + [行内での完結]
    #   表示する際に文字の並び替えは行内で完結していたほうが取り扱いやすい。
    #   ある所に表示する内容が別の行に含まれるというのは始末が悪い。
    #   それに座標の計算をする際に考慮に入れるべき範囲の長さに上限がなくなるので、
    #   そういう意味でも複数行に亘る文字列というのは都合が悪い。

2016-09-27

* ECMA-48/9 には対応しない [#M0001]

  [2016-09-27 #D0008 の考察の結果を抜粋する]

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそういう前提の内容がかかれている (15 および D.4.Note3)。
  それ以外の実装は駄目な実装なので気にしなくても良い。

  もともと ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである (ECMA-48/1)。
  意図的に 10/00 - 15/14 を使って制御シーケンスを記述するための物ではない。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、そもそもの前提が崩れるので、
  ECMA-48/9 の内容に対応する必要はない。


  [2019-08-06 追記 #D0189]

  * UTF/sjis 等のステートレスな文字符号化方式については先に処理する。
  * iso-2022 や acs 等の処理は端末の処理の一部として実施する。
    取り敢えずは Unicode にできるだけマッピングする。

  ※RLogin も上記の様な方針を取っている様子である。
  ※mlterm は Unicode に変換せずに、
    iso-2022 の文字集合毎に文字を区別している様子である。


------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

2019-08-04

* Linux で fontconfig の設定をするには
  ref #D0172

  何故かうまく行かなかったが、一般的には
  $XDG_CONFIG_HOME/fontconfig/fonts.conf ファイルに記述する。
  内容は以下の様な感じにする。
  詳しくは https://www.freedesktop.org/software/fontconfig/fontconfig-user.html に書かれている。

  | <?xml version="1.0"?>
  | <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
  | <!-- $XDG_CONFIG_HOME/fontconfig/fonts.conf for per-user font configuration -->
  | <fontconfig>
  | <!--
  |   Private font directory
  | -->
  | <dir prefix="xdg">fonts</dir>
  |
  | <!--
  |   use rgb sub-pixel ordering to improve glyph appearance on
  |   LCD screens.  Changes affecting rendering, but not matching
  |   should always use target="font".
  | -->
  | <match target="font">
  |   <edit name="rgba" mode="assign"><const>rgb</const></edit>
  | </match>
  | <!--
  |   use VL Gothic font when sans-serif is requested for Japanese
  | -->
  | <match>
  |   <test name="lang" compare="contains">
  |     <string>ja</string>
  |   </test>
  |   <test name="family">
  |     <string>sans-serif</string>
  |   </test>
  |   <edit name="family" mode="prepend">
  |     <string>VL Gothic</string>
  |   </edit>
  | </match>
  | </fontconfig>

  ファイルを適当に $HOME/.local/share/fonts に配置して、
  $ fc-cache
  を実行すれば良い事になっている。

  然し failed to write cache のエラーが発生して失敗する。
  sudo fc-cache -v しても、
  sudo dnf reinstall fontconfig しても、
  touch $HOME/.local/share/fonts しても、
  sudo setenforce 0 しても、
  chmod 777 $HOME/.local/share/fonts しても、駄目だった。

  /usr/local/share/fonts/murase からのシンボリックリンクにしても駄目。
  /usr/share/fonts/murase にコピーして sudo fc-cache したら成功した。
  然し、これはユーザ毎の設定ではなくてシステムにフォントを登録している。
  よく分からないが面倒なのでシステムに登録するので良いという事になった。
  fc-list | grep MeiryoKe でちゃんと登録されているのを確認した。

2019-08-03

* Cygwin で Windows のフォントを使える様にするには以下の様にする

  $ ln -s /cygdrive/c/Windows/Fonts /usr/share/fonts/win-fonts
  $ fc-cache

  Ref: https://superuser.com/questions/801545/how-to-make-the-cygwin-fontconfig-package-inherit-windows-fonts

2019-05-02

* twin/draw: Win API (GDI) で描画する時のメモ。

  * grapheme cluster / surrogate pair に関して (ref #D0106)
    - TextOut ではなく ExtTextOut を使うべき。
    - ExtTextOut で cluster に与える進み幅は総和だけが意味を持つ。
    - ExtTextOut の表示は微妙。乗り換えるなら freetype である。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2021-09-04

* Zutty という端末の記事が気になる
  https://tomscii.sig7.se/2020/12/A-totally-biased-comparison-of-Zutty

2021-06-19

* PP/NP: ページに対応したら do_decdsr(6) でページ数を返す様にする
* UDK (user-defined keys): update do_decdsr(25)
* Macro: update do_decdsr(62) do_edcdsr(63)
* DSR-DIR: do_decdsr(70) に於いて最初だけは 73 を返す様にする。
  RIS も実装してから考え直す必要がある気がする。

* DECDSR(53,55)
  https://ja.osdn.net/projects/ttssh2/lists/archive/commit/2010-August/000816.html
  DEC Locator Mode はこれを利用するらしい。

* mintty は Mode ?7700 で文字幅報告 CSI 1 W, CSI 2 W を返すらしい。
  togetter MinEd のやばさのまとめに載っていた

2020-10-13

* スクリーン毎に dpi が異なる場合の調整は WM_DPICHANGED を捕まえる
  https://www.slideshare.net/hiyohiyo/sapporocpp6win8win32

* DirectWrite と従来の GDI 描画を混ぜて使うには IDWriteGdiInterop?
  https://www.slideshare.net/hiyohiyo/win32directwrite?next_slideshow=1

  ? 然し DirectWrite にすると文字単位の位置指定ができるか分からない。
    もっと言うと combining characters や絵文字や bidi 等も考えると、
    文字単位の位置指定が果たしてうまく行くのかも良く分からない。

    一方で様々な環境で動かしたいという事を考えると DirectWrite の様な高級な機能に
    依存して配置を決めるという事はできない。何れにしても内部で combining
    characters や bidi 等の処理をしなければならないのではないか。そしてその場合に
    は自前で全て処理しなければならない。

    然しだからといって freetype 等を使用して自前でラスター化まですると、今度は
    x11 環境での描画が遅くなってしまう。それは避けたい。結局一つ一つの文字の描画
    に関しては OS 等の API に任せて、bidi 等の配置に関しては自前で処理するという
    形に落ち着くのだろう。そしてそれは、現在の実装の形態に近い。

  でも使い方がよく分からない。メンバを見ると少ししか無い。

  Font と LOGFONT の変換関数が存在するが、説明を読む限りは "compatible
  property" を使って対応する設定で新しくフォントを作るのであって、DirectWrite
  のフォントレンダリングが GDI で直接使える様になったり或いは逆をしたりという事
  ができる訳ではない様に見える。

  唯一気になるメンバ関数が IDWriteGdiInterop::CreateBitmapRenderTarget である。
  検索してみると https://twitter.com/egtra/status/804974586693435393 にある様に、
  GDI の HDC に直接文字を書き込む事が出来るようになるという事?
  https://stackoverrun.com/ja/q/11485152

  この関数は IDWriteBitmapRenderTarget を返す。そしてこのインターフェイスは、
  DrawGlyphRun というメンバ関数を持つ。その他のメンバ関数は何れも座標指定に見え
  る。(SetCurrentTransform でアフィン変換を指定できる。つまりフォントサイズや回
  転はこれで良いのでは?)

  * COM なので実は CoInitialize/CoUniniitialize を呼び出す必要がある?
    https://github.com/vim-jp/issues/issues/262
    一方で DWrite は COM の様なインターフェイスだが実際は COM ではないという話もある。
    https://social.msdn.microsoft.com/Forums/vstudio/en-US/edad7bd5-4577-4782-b850-40b141e43198/

  * subrange に対する着色も指定できる?
    https://stackoverrun.com/ja/q/324606
    然し render target に依存していそうな気もする。

2020-06-28

* input_decoder: SS3 ... の形式のキーシーケンスにも対応する。
* input_decoder: paste に囲まれたデータの上限を設定する。
* input_decoder: 例外的なキーシーケンスを個別に登録できる様にする。
  * input_decoder: terminfo から読み取る?
* input_decoder: DCS や OSC を処理する様にする。
* input_decoder: PM, SOS, APC はオプションで選べる様にする。
* input_decoder: ESC を Meta として処理しないモードも用意する?
  もしくはタイムアウトを設定する?
* input_decoder: 現在は1文字ずつ処理する様になっているが、
  これは遅いので配列を渡して処理できる所まで処理して、
  好きな場所で中断できる様にする。
  要するに duff's device の様に実装すれば良い。
* sequence_decoder: これも同様にまとめて処理する様にした方が速い。
  現状の実装だと毎回トップレベルにまで制御を戻すので遅い。
  一応通常文字はまとめて処理する様にはしているが限界がある。
  また、速度が却って遅くなっていないかについて、
  新しい実装と古い実装で実測して比較する必要がある。

2020-06-27

* bel に対応しようと思ったが何から対応したら良いだろうか。
  そもそも manager で表に出ていない時に伝達するべきかどうかも微妙。
  visible bell と audible bell の切り替えもどの様に実装するのか。

2020-02-29

* tstate が独立して存在している理由は何だろうか。これは本当に必要?
  多くは term に移動するべきではないだろうか。
  mode に関する処理、色に関する処理は別々のクラスに分けて term のメンバとする。

* 絵文字対応

  今どきのターミナルは絵文字に対応している事が重要のようである。
  少なくとも西洋の端末ではこれが必須であると考えられている。
  少なくとも GDI は絵文字に対応していない。DirectWrite というのを使わなければならないらしい。
  然し、これを GDIと組み合わせて使おうとすると遅いという話がある。
  従って全て Direct2D で書き直さなければならないという事なのだろうか。

  mintty の実装を確認してみた所、実は mintty は GDI で (Ext)TextOut を用いて実装していて、
  絵文字に関しては GDI+ で画像ファイルを読み取ってそれを切り出して自前で描画している様だ。
  つまり一文字ずつ自前で表示している。まあ、そういう対応の仕方もある。
  色々な環境で同時に対応させるという事を考えたら自前で実装する方が確かに良い。
  画像の保存形式に関してはどうするか。png か gif などを使って保存しておく事にするか。
  そうするとライブラリを要求する事になる。或いは自前で sixel かまたは pnm 形式で保存しておくという手もある。
  思うに sixel 形式で保存して、セルに記録する情報も文字から sixel データへの参照という取り扱いにする、
  というのが現実的な気がしないでもない。然し、PTX等を考えるとやはりその他の種類のデータも記録できるべき。

2020-02-19

* manager: 階層に名前を付ける
  session / layout / frame / term という事にする。

2020-02-15

* 最適化: セルサイズを 4B+4B の 8B にまで減らす計画
  Ref #D0251, #D0252, #D0253, #D0254

  文字拡張と描画拡張は独立に取り扱う。

  文字

    bit31    is_extended
    bit29-30 width
    bit28    is_marker
    bit27    is_cluster_extension [廃止予定]
    bit26    is_wide_extension [廃止予定]
    bit0-25  文字コード

    is_extended が立っている時、この文字は [ (1) 非標準の文字幅
    (0,1,2,4以外)を持つ文字 (2) 二文字以上から成る grapheme cluster
    (3) 重ね書き文字 (4) PTX や Sixel 等のオブジェクト ] など特殊な文
    字である事を表す。この時文字コードの代わりに、exchar_table の中の
    インデックスを記録する。

    exchar_table は index -> (type, param, data) の辞書である。
    type にはオブジェクトの種類 (cluster, char, sixel, ptx, obj, etc.)
    を指定して、param には補助的なデータ(整数値)を指定し、data には
    可変長のデータを格納する。こんな感じ:

      struct entry {
        entry* listp;
        std::uint32_t type;
        std::uint32_t param;
        std::vector<std::uint32_t> data;
      };
      std::vector<entry>;

    data は std::vector ではなくて
    もっと特化して最小限にした物で良い気がする。
    或いは std::uintptr_t で何とか処理する。
    何れにしてもこれらは自由に使って良いという事にしたい。
    それに別にバッファを使い回す事に拘らなくても良い。

  描画属性

    描画属性も同様に一番上の bit に is_extended を付加する。
    exattr_table に番号から実際のデータへの辞書を保管する。

* 最適化: スクロールバッファの圧縮・データ構造の見直しに関して

  [まとめ] #D0249 で考察した内容のまとめ

  セルデータの拡張によるメモリ使用量の増大について

  * mintty の様に表現を圧縮すれば良い。
    よくあるケースで小さくなる様にバイナリ表現を設計する。
  * 然しそれでもデータの拡大は注意深く行いたい。

  * 文字専用の属性 (前景色・字体) と
    共通属性 (背景・プロテクト) は分けた方が良いかもしれない。
    オブジェクトにも適用できるデータとそれ以外のデータ。
    これは共通処理で必要になってからでも良いかもしれない。

    共通属性は 16bit もあれば十分では。
    幅は 16bit で十分なのか分からない。
    proportional の時の object 幅が大きな物になる可能性?

  * 属性をインデックスで共有・参照する案については
    参照カウント or Mark/Sweep の計算コストが増える。
    コピーコストと比べてこれらが低いとは思えないので工夫が必要。

    こう言った管理は、実はオブジェクトを共有したりする時、
    複雑な書記素や重なり文字を管理する時にも必要になる。
    その時に改めてまとめて考えると良いかもしれない。

  * mintty の様に固定長に戻すという手も考えられるかもしれない。
    * 現状の利点: 本当の proportional に対応するなら
      現在の方法を避けることはできない。
    * 固定長の利点: メモリ効率が良い。cluster extension
      についても属性や幅を管理する事に意味はあるか。
    或いはセル構造も可変長にしてしまうという手もあるかも。

    何れにしても大幅な書き換えが必要になるし、
    書き換えの挙げ句に前よりも遅くなったという事になるかもしれない。
    (mono/prop の内 prop の書き換えなのだからmonoで遅くなる事は
    工夫すれば防ぐことができる気がしないでもない。)

  * また別の観点による案だが、受信したデータを取り敢えず
    data stream の形式で保持してカーソル位置だけ計算し、
    実際に画面内に配置するのは遅延するという案。
    流れて出ていったデータは配置する前に捨てる。

    これは難しい。捨てると言ってもスクロールバッファには残して
    おかなければならない。またカーソル位置だけ計算するという
    事が実際に可能なのか分からないし、"普通" の状況だけで最適化
    して特別な状況の時に物凄く複雑&遅くなる様では駄目。

  取り敢えずの所、セルデータは拡張する。
  また、属性の取り扱いについても変更する?

  scrollback する時の圧縮について。
  これを実装するとかなり遅くなると思われる。
  実装するかどうか。実際に実装してみて
  どれくらい影響があるのか確認しても良い。
  mintty と同程度に収まればまあ我慢できる。

  [まとめ2] #D0250 の考察の結果

  * sequence_decoder はまとまった入力に対する処理を書き直すべき。
    毎回現在の解析状態に従って分岐するのは遅い。
    解析状態に変化がない限りは直接に読み進める事ができる筈。
    途中で終端に達した時にだけ状態を保存して戻るのが良い。

  * 属性値を4Bにするのは確かに効果がある気がする。
    4Bにする為には拡張属性を外部に記録して適宜 mark&sweep できる
    様にする必要がある。特に大きな scrollback があると効率が低くなる。
    従って scrollback を圧縮して記録する様にした後で実装する。

2020-02-10

* stderr: 現在エラーメッセージは stderr に書き込んでいるが
  これは 2 に繋がっていて偶 pty が 2 で開かれると其処に書き込まれてしまう。
  これは脆弱性の原因になるので明示的に /dev/tty 等で開いた場所に
  書き込むように変更しなければならない。
  或いは、起動時に stderr 2 が開いていなければ適当にファイルを開く。

  或いは、グローバルなメッセージ書き込み先を用意しておく事にする。

* tx11: 日本語入力

  一番簡単な対応方法
  https://qiita.com/ai56go/items/63abe54f2504ecc940cd
  編集中の文字列を取得する方法 (on-the-spot でも動かす方法?)
  https://garasubo.github.io/hexo/2020/01/25/xim.html
  丁度二ヶ月前に XIM が GTK4 から削除されている。XIM は時代遅れなのか?
  https://gitlab.gnome.org/GNOME/gtk/merge_requests/1195

* mintty の DECSLRM 時のスクロールは高速だ。
  或いは contra が遅い。urxvt はそもそも対応していない。
  xterm は相変わらず遅いが contra と比べて物凄く遅い訳ではない。

  st がシンプルなので urxvt よりも速いのではないかという話があったので
  hp2019 上で yes で調べてみたが、contra よりも遅かった。
  urxvt 2.7, contra 4.0, st 4.7 と言った所である。

2020-02-07

* RLogin のマニュアルを見ていると色々間違いを見つける
  纏めておいて後で報告する事にする。

  * RLogin は TSM (TABULATION STOP MODE) が ISM という略称になっている。
  * TSM (ISM) のマルチとシングルの名称が逆になっている。説明と実装は正しい。
  * CTC(4) と CTC(5) の記述が違っている。
  * Mode ?8441 クロース → クローズ
  * Mode ?8449 Unicde → Unicode
  * DECNKM の説明は完全に逆。実装は正しい。
    また全体に DECPNM -> DECKPNM, DECPAM -> DECKPAM の筈である。
  * 94x94 E が Blissymbol と書かれているが CCITT Chinese Set の誤りである。
    ISO-IR-165 は正しい。(Blissymbols は 169 である。)
  * DECPQPLFM は DECRQPKFM の誤りではないだろうか。
    ソースコードの中も間違っている。

  その他 RLogin の振る舞いで気になる事。

  * RLogin で C-left, C-right, C-1, etc が端末に奪われている。
    これらを全面的に無効化する、もしくは部分的に無効化する方法はあるのだろうか。
    或いは tmux や screen の様に prefix key の様な物を設定できれば良い。
    →と思ったら[オプション]-[キーコード]の一番下にあるチェックボックスで指定できた。

  * C-S-1 は何にも割り当てられていない気がするのに modifyStringKeys で送られてこない。

  * RLogin で文字の大きさの拡大縮小をその場で実行する方法はあるだろうか。
    例えば mintty では C-scroll で拡大縮小を行うことができる。
    現在の RLogin だと一々[メニュー]から[オプション]を開いて[スクリーン]タブで
    文字の大きさをドロップダウンリストから選ばなければならない。
    * しかも[適用]を押してもその場では表示が更新されない。
    * 再びオプションを開くと別のタブに行っている。
      前回閉じた時のタブを覚えておくことはできないか。
    手軽に状況に応じて拡大縮小をするという事ができない様になっている。
    実はそういう機能が何処か別の場所にあったりするだろうか。。

  * 高DPIに対応してツールバーのボタンや文字の既定の大きさなど大きくならないだろうか。

  mintty の termout.c の以下の行のコメントが間違っている。

    when CPAIR(' ', '@'):     /* SR: ECMA-48 shift columns left */


2020-02-06

* TABULATION

  昔した考察を最近見かけないと思ったら #D0023 にあった。
  何か結論でも出たのかと思って調べてみるが途中である。
  誤って終了済みの議論という事にされていたという事。

  改めてどの様な考察があったのかまとめる事にする。

  * TATE だとか TCC など色々と解釈に困る機能が定義されている。
  * ECMA-48 には表示部で移動するとは書かれているが
    データ部で移動するとは書かれていない。
    つまり、データ部では単にマーカを置くというだけの実装も可能である。
  * タブを確立するという事とタブが設置されているという事は別。
  * 現実の端末の実装では表示部における配置だけで実装されていると
    考えても良い様な気がする。

  もし仮に TAB が表示部だけで移動を起こし、データ部に於いては何も移動
  を行わないのだとしたら。表示位置とデータ位置の対応関係が複雑になる。
  特に複数のフィールドが overlap する事が可能になる。その場合の取り扱
  いが謎である。更に ECH や ICH 等も絡んでくると話は更に複雑になってし
  まう。

  % もし一から設計し直す事ができるのだとしたら。そもそもデータ部におけ
  % る位置というのは意味がない物と考える。或いはどの文字やマーカも同じ
  % 大きさを持った一升を占めるオブジェクトと見る。実際に表示される時に
  % どのようにレイアウトされるのかというのは計算して求める。表示位置か
  % らデータ位置への対応は何らかの方法で列挙して探索する。

  半角・全角の処理を考えるとデータ部を文字幅を考えない文字の配列と見るのは難しい。
  一方で、文字だけ文字幅を考えてタブ等については幅を考えないという実装も可能ではある。

  そもそも TATE の解釈は本当に正しいのだろうか。
  これは T.416 を読んだら何かヒントがあるだろうか。
  T.416 は様々の機能を HPR HPB 等に置き換える方法を説明している。
  つまり ECMA-48 と組み合わせて愚直に読むとデータ部での移動と書き込みになる。

  ? 所で HPR, HPB は文字単位の移動ではないのか。T.416 の HPR, HPB は
    SMU 単位と書かれている。調べると他に BMU という単位も現れる。Web
    で検索するがその様な単位は全く見つからない。ECMA-48 にも登場しない。

    検索すると実は似たような別の規格の日本語版が見つかった。JT-T503v6
    である。中で T.412 等を参照している。画素伝送密度という所に 1 BMU
    = 1200 dpi とある。5 BMU = 240 dpi とある。つまり 1 BMU = 1/1200
    in という事になる。また BMU は基本測定単位の略だそうだ。

    と思ったら T.412 7.3.4.1 Basic measurement unit で BMU は定義され
    ていた。1/1200 in と明記されている。SMU は 7.3.4.2 Scaled
    measurement unit であり、既定では BMU と同じだが、文書が指定する整
    数 m, n (T.414)で m/n 倍にする事ができるそうだ。

    pc = 12 pt = 1/6 in = 200 BMU = (m/n) 200 SMU


* twin: 以下の頁が詳しい。特に WM_DEADCHAR の振る舞いについて説明がある。
  http://moeprog.web.fc2.com/moe/Win32API/System/Keyboard.htm

  また WM_KEYDOWN の repeat count の振る舞いについてもちゃんと書かれている。

* tx11: 拡大縮小
  tx11 ではフォントサイズの変更に対応していない?
  manager が操作しているのではなかったか。
  何故だろうか。と思ったら、

  contra::term::terminal_events の request_change_size

  というのを実装していないと動かない様だ。これはまた後で考える。

2020-02-05

* cluster: do_insert_graph, do_insert_graphs: 零幅文字の挿入に対応?

  | cluster exntesion etc に実は対応していない。
  | cluster extension がある場合には SIMD (逆暗黙移動) の時の
  | 零幅文字の挿入位置について注意が必要である。
  | 或いは cluster extension は別の関数で一文字ずつ処理するのか?
  | そうだとしても SIMD に気をつけて実装をする必要がある。
  |
  | 零幅extensionは do_insert_graphs には入らない事にする。
  | 一文字ずつ処理する。SIMD の時には現在位置の右にある
  | 文字に extension を追加するという規則にしておけば良い。
  |
  | 何れにしてもこれらに対応する為には grapheme cluster を
  | ちゃんと理解してからでないといけない気がする。
  | 現在の実装ではその辺りがちゃんとなっていない。
  |
  | cluster に関する議論にどの様な物があったかを遡って調べたが
  | 何も議論されていない。何を議論するにしても最初に Unicode の
  | 分類を実装しなければならないので議論していないという事なのだろう。

  零幅文字もしくは grapheme cluster で特殊な振る舞いをする文字は現状の
  insert_graph で対応するのではなくて、それ専用の関数で実装することに
  するのが良い。

  grapheme cluster は以下に日本で平易に解説している。しかし最新版では
  変更があるかもれしれない。
  https://hydrocul.github.io/wiki/blog/2015/1025-unicode-grapheme-clusters.html
  以下が最新版の規則部分である。何と Prepend というクラスが追加されて
  いる。Prepend は ISO-2022 にある non-spacing mark と同じ振る舞いをするのだ
  ろうという気がするが、然し、これに対応するという事は現状の実装を大き
  く変更するという事になるのではないだろうか。
  http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules

  * データ構造に対する再考

    元々どの様に実装することを想定していたのだったか。最初期の考察を改
    めて参照しなければならない?  細かい議論は #D0002 にある。議論を纏
    めると

    | 様々なレベルの実装が考えられる。エディタの様に振る舞う物
    | (proportional fonts から様々なオブジェクトの埋め込みまで) から単
    | 純な端末で文字と位置が対応する様な物まで。機能を考えると複雑なデー
    | タ構造にする必要がある。速度を考えれば単純な端末の様に実装する必
    | 要がある。二つのモードを使い分けるのが良さそう。つまり、単純な内
    | 容しか無い場合は普通の端末の様な内部実装にして、複雑な内容がある
    | 場合にはエディタの様な内部実装にする。

    ここで問題になるのは、grapheme cluster は単純実装に属するべきか、
    複雑実装に属するべきかという事。grapheme cluster は一升に幾らでも
    詰め込めるので単純実装には余り合わない。例えば mintty は色々工夫を
    して行データに grapheme cluster データを詰め込む努力をしている。他
    の実装でどうしているかは確認していないが恐らくメモリを確保するのが
    自然な実装だろう → やはり grapheme cluster は現在の実装の様に複雑
    実装に属するのが自然である。

    grapheme cluster の表現はどうするのが自然か。現在は零幅の文字とし
    て実装されている。然し、実は本体の文字の従属データとして保持した方
    が自然なのではないかとも思う。そもそも現在の実装だと grapheme
    extension に対して描画属性などが割り当てられているが、完全に意味を
    為していない。

  * 様々な文字幅・オブジェクトを考慮したデータ表現に対する考察

    | * 独立した零幅文字も在る。
    |
    | * ANSI 的には文字幅は可也自由である
    |
    | * ANSI 的にはデータ部と表示部の対応は一文字ずつ追跡しないと分から
    |   ない仕組みになっている気がする。特に monospace で内容を並べる場
    |   合。うーん。或いは余り深く考えていなかったが実は現在の実装で既に
    |   それに違いことができている可能性はある? 現在の実装はデータ部での
    |   位置と表示部での位置は全く関係ない事になっている。ちゃんと数えて
    |   計算しなければならない。ANSI的な完全な proportional と違うのは、
    |   データ部での文字幅と表示部での文字幅が同じであり、違いは文字の表
    |   示順序だけという事。
    |
    | 改めて可能性について考える。
    |
    |   a データ部には唯単にオブジェクトを並べる。文字の幅は考慮しない。
    |     データ部での移動は単に何番目のオブジェクトかという情報で計算す
    |     る。表示部ではオブジェクトの幅を考慮に入れる。
    |
    |   b データ部ではオブジェクトをデータの順序に並べる。データ部での文
    |     字の移動などに関しては文字の幅も考慮する。表示部とデータ部の対
    |     応は双方向文字列による文字の並び替えのみ。これが現在の実装。
    |
    |   もしかすると a が ECMA-48 が想定した事なのかもしれないと思う。
    |   零幅のマーカーだとかが埋め込まれている時に、任意の位置にカーソ
    |   ルを移動する為には零幅オブジェクトの間も移動できる様になってい
    |   なければならない。b の解釈だと零幅の制御機能 (formatter) に対
    |   する自由な操作ができないのである。
    |
    |   然し一方で ECMA-48 は双方向処理がなければデータ部と表示部は一致
    |   するとも述べている気がする。うーん。ECMA-48 にある零幅マーカー的
    |   な物は双方向処理の文字列とタブの二種類がある。双方向処理がないと
    |   してもタブの処理をどうするのかというのは不思議である。
    |
    |   ANSI は寧ろ WYSIWIG なエディタ的な仕様である。なので ANSI をフル
    |   にサポートするならば複雑実装を考える必要がある。それも今ある実装
    |   よりも格段に複雑な物が必要になるのではないか。第三段の実装を考え
    |   る必要すらあるかもしれない。
    |
    | 考えがまとまらない。結局 ECMA-48 の要求を実現しながらどういう実装
    | にするのが一番自然なのかというのが問題なのである。そして何が確定事
    | 項で何が考察の余地があるのか。
    |
    | * ECMA-48 の指定は文字の幅という概念が欠落している気がする。
    |
    | * Unicode には様々な文字の幅がある。零幅文字もある。cluster もある。
    |   但し cluster はくっつけて一つの文字として取り扱うのが自然ではあ
    |   る。
    |
    | * 端末は全角文字は二つの文字位置として取り扱うのが自然である。
    |   別の言い方をすれば全角文字の途中に移動する事ができる。
    |
    | * ECMA-48 の記述的にはデータ部と表示部の違いは双方向処理だけの様に
    |   見える。一方で TATE, JFY, ルビだとか複雑な仕様もある筈。


    実際のデータ構造を考える前に、具体的な論理的構造を確定させる必要が
    ある。実の所、目的に応じて一番良さそうな振る舞いが異なる気がする。
    特にレイアウト計算に関しては四種類の座標レベルを考える事ができる。

    a 行番号・文字数
    b 文字幅(双方向処理前)
    c 文字幅(双方向処理後)
    d タブやルビや上付き・下付き等の処理後の描画座標

    表示部での移動を考える時は c か d である (ECMA-48 規格的には少なく
    とも双方向は考えなければならない)。印刷機的には d のレベルで移動し
    たい。端末アプリケーション的には d だと制御が困難である。そもそも
    端末は文字単位の移動が基本なので細かい制御はできない。

    データ部での移動を考える時は a か b である。零幅文字やマーカー (双
    方向文字列やタブ) の存在を考えると a の方が良い気がする。然し、現
    実の端末の文字挿入は全角文字幅を認識して行われるので b である。

    * STAB は "表示部での以降の文字列" の配置を指定している様に読める。
      そうだとすると表示部での位置が決まってから更に配置が決まると解釈
      しなければならない。然し、"以降の文字列の配置を表示部で指定する"
      と読めなくもない。この記述は微妙である。

    ? c の段階ではルビや諸々は零幅オブジェクトとして取り扱い、外側の並
      びには影響を与えない様に実装するのが現実的だろうか。

    ? ECMA-48 の細かい移動とデータ部の二次元構造との関係は?  ECMA-48
      によると行間は任意に調整できるし、文字の大きさや間隔も任意に調整
      できる。データ部の格子的な二次元構造とどう折り合いを付けるのか謎
      である。

  * data stream: 改めて ECMA-48 をよく見てみると data stream というの
    はデータ部の中に蓄積されているデータの事ではなくて、受信する
    stream に過ぎない。つまり「data stream の中で次に〇〇が現れる迄」
    という記述は、データ部の中で先に[終了]が現れてから後で[開始]が現れ
    た時に改めて再構成する必要があるとかそういう事は考えなくても良い?

    そうすると現在の SDS/SRS の実装は間違っている? と思って ECMA-48 を
    確認すると SDS/SRS に関してはデータ部の中に保存されて位置を示す様
    である。つまり現在の実装で正しい。まとめると ECMA-48 で現れる範囲
    を表す制御機能には二種類がある。データ部の中にマーカとして保存され
    る物と、data stream の中での範囲を表す物。data stream の中で範囲を
    表す制御機能は実際にデータ部の中に文字位置として挿入される訳ではな
    い。確認する。DAQ は表示部の中での位置を示すマーカ。SLH も表示部の
    中での記述である。うーん。つまり特に今まで勘違いはなかった? 然しこ
    こで整理しておくと良いのだという気がする。

    一方で、PLD, PLU は表示部での位置の移動について記述していて、然し
    data stream の中で次に打ち消す物が現れるまで効果があると書かれてい
    る。つまり、これはデータ部・表示部にマーカが埋め込まれる種類の物で
    はない。

    PTX は data stream の中で定義される範囲である。

2019-09-18

* 実は cp932 はある程度判定できるのではないか。
  というのも Cygwin console はちゃんと判定できている。
  mintty は判定できていない。

  sjis の構造について確認しておく。第1バイトは
  0x80--0x9F または 0xE0-0xEF の範囲に入る。
  0x80--0x9F に関しては UTF-8 では第1バイトに絶対現れない。
  0xE0--0xEF は微妙である。3バイト文字の第1バイトに使われる文字と被っている。
  第1バイトが 0x80-0x9F の時は sjis と思って良い。
  第1バイトが 0xE0-0xFC で第2バイトが 0x80-0xBF 以外の時は sjis である。
  [0xE0,0xFC][0x80,0xBF]と来て更に[0x80,0xBF]が来た時にはやはり区別が付かない。
  そのまた次の文字を見てUTF-8の第一バイトとして許されるバイトでなければsjisとする。

  結局、UTF-8の復号をメインとしてエラーが発生した時にsjisに切り替えるという実装が良い。
  この時エラーが発生した時に遡って修正する必要がある可能性がある事にも注意する。
  実際は面倒なので其処まで頑張らなくても良いのかもしれない。

  * 2019-09-29 やはり UTF-8 で解釈できない文字列を受け取った時に
    Shift_JIS で解釈するなり何なりという事をしたい。
    Cygwin 日本語環境では Windows のコマンドを実行すると
    一々文字化けして面倒なのである。

    これを実装する為には何処を修正すれば良いだろうか。
    結局 utf8 の枠組みの中でエラーが発生した時に文字を 0xFFFD に
    変換してしまっていて此処で情報が失われるので、
    それより前の段階で処理するべきである。

    もしくはエラーが発生した時にそれを外側に伝達して、
    代わりの方法による decode を試みるという事も考えられる。
    然し、それだと局所的な文字コードの変更に対しては弱い。
    やはりエラーが発生した各文字に対して sjis による
    recovery を考えたい様な気もする。どの様にするのが良いだろうか。

    そもそも UTF-8 でエラーになったとして、
    どの様に処理するべきだろうか。
    utf8_decode に fallback の関数を渡せる様にするのが良い気がする。

    error_char を指定する代わりに関数を渡せる様にするのである。
    fallback の関数はどの様なインターフェイスにするのが良いだろうか。

    * 懸念: fallback の中で書き込みバッファが足りない事が判明したらどうするのか。
      error_char の場合には高々1文字であったので残り1文字は書き込めるのだという事を
      確かめてから入力を読み取る様にしておけば問題は生じなかったのだった。
      うーん。fallback を呼び出してもし buffer が足りなかったら何もせずに戻る、
      という具合にするのが適切である様に思われる。

    * 懸念: もう一つの問題は fallback で現在未処理のバイトが全て処理される
      とは限らないという事である。この時に未処理のバイトを改めて utf8_decode
      に処理させたいが、どの様に処理させるべきかという問題がある。

      a 未処理のバイトが現在の utf8_decode 呼び出しに含まれている物であれば、
        現在の utf8_decode 呼び出しの入力バッファのポインタを未処理のバイト数だけ
        戻して続きの処理を実行する様にすれば良い。
        然し、未処理のバイトが前回の utf8_decode 呼び出しの入力バッファにあって、
        state 経由で carry されて来た物である場合はその方法は通用しない。

      b うーん。utf8_decode の呼び出しが跨っている場合には
        もう復元は諦めるというのでも良いのかもしれない。
        と思ったが utf8_decode の呼び出しが跨る要因として、
        受信のタイミングだけであればそれで良い気もするが、
        実際にはユーザが用意したバッファが中途半端の大きさをしていた
        等の理由で起こる可能性もある。
        これは振る舞いが予測できなくなるのでデバグも困難になる。
        従ってこの方針は避ける様にしたい。

      c というより state を更新して上手に実行する事はできないだろうか。
        と思ったが、例えば即時書き込むことができる文字が並んでいる場合等には、
        state でその途中状態を表現する事ができない。
        その場で出力バッファに書き込まなければならないが、
        出力バッファに文字を書き出せるだけの幅があるかも分からない。

      或いは最低のバッファサイズを決めておく必要がある。
      最初の状態から一文字の書き出す事ができない場合には例外を発生する様にしても良い。

  * もしくは utf-8 及び sjis の両方に対応する関数を作成する?

2019-09-07

* ttty: 実は起動時に 0,1,2 が /dev/tty ではないという場合もあるのではないか
  その様な場合には SIGWINCH を trap しても仕方がないので、
  代わりに別の戦略で (例えば定期的に問い合わせる) winsize を取得する必要がある。

  或いは /dev/tty で明示的に端末を開いて処理をする。

2019-09-05

* render: 部分転送?
  最後に全体を BitBlt しているが、更新のあった部分だけで良いのでは。
  唯、この最後の転送が全体に占める時間というのはそもそもそんなにないのかもしれない。
  と言いつつ転送範囲の決定の計算時間と実際の転送の速度を考えると、
  やはり転送範囲を決定して実行した方が良い気がする。

2019-08-13

* tx11: X11 で通信が詰まっている時に画面描画を抑制するという
  事を考えても良いのではないかという気がする。
  それを確認せずに実行していると大変な事になる。

  と思って調べたが通信が詰まっているかどうかを確認する
  方法が出てこない。描画を無限に書き込めるのだろうか…。
  或いは応答が必要な処理を適宜挟む事にすれば良いのかもしれない。
  と思ったが RTT 自体が遅い場合にはそういう事をすると大変な事になる。

  或いは応答をメッセージとして受け取る事ができるのではないか。
  いかにもそういうのがありそうである。
  いざとなれば XCopyArea でダミーの Pixmap で GraphicsExpose か NoExpose
  を無理やり発生させれば良い気がする。ローカルですぐに反射してくるという
  可能性もあるが。その場合にはその手法は使えない。

  改めて調べてみた所 XSynchronize という関数がある様だ。
  然し、この関数は sync か async かの設定を切り替える物で、
  その場で sync したり、或いは通信が詰まっているかどうかを確認する物ではない様だ。

  X Synchronization Extension Library という物もある様だが資料が少ない。

  と思ったら標準で XSync という関数が存在する様だ。
  然し、現在バッファが一杯かどうかの判定には使えない。

  event を調べてみると ClientMessage という物が存在する。
  20 bytes のデータと一緒に SendEvent で送った物を受信できるそうだ。

2019-08-11

* bidi: 括弧などは Unicode の property を参照して反転させる等したい。

  実はこれは get_cells の段階で処理するべき事なのかもしれない。
  get_cells だけが局所的な方向性を知っているのだから。

  然しその前に unicode のデータを整理して置く必要があるのである。

  後 iso-2022 文字の反転はどうしたら良いのだろうか。
  get_cells の段階で反転させる為には iso-2022
  文字について辞書を引かなければならない。
  描画時には実際に具体的な Unicode 文字に変換するのだから、
  その時に Unicode 文字の情報を用いて反転させる事ができる。
  描画時に反転させるのだとすれば方向性についての情報を
  get_cells の時に抽出しておかなければならない。

  sixel やオブジェクトの反転についてはどうしたら良いのだろうか。
  sixel をセルごとに画像位置の参照として取り扱うのだとすれば、
  SPD で方向性を変換している場合には変な事になってしまう。

  所で検索していたら縦書きに関しては UAX #50 がある。
  http://www.unicode.org/reports/tr50/

* 仕様書を見ていて気づいたのは実は CCITT T.61 に PLD/PLU で
  文字に対する装飾も一緒に上下するべきなのだという記述があるという事。
  PLD/PLU の項にも書かれているし SGR の項にも書かれているし Annex F には例まで載っている。

  % しかし、PLD/PLU に書かれている説明によると PLD/PLU より前に現れた SGR(4) による
  % 下線の位置は PLD/PLU で影響を受けないと書かれている。これは Annex F と矛盾していないか。
  % →と思ったが、これは PLD/PLU より左にある下線が改めて位置変化したりしないという事だろう。

  現在の contra の実装では文字の上下に関係なくセル内で固定の位置に下線を引いている。
  下線以外の上線や打ち消し線・箱・囲み丸もそうである。全部一緒に動かなければならない
  のだろうか。それはなかなか面倒であるし、そもそも実装として自然なのかも分からない。

* CCITT T.61 に含まれる diacritical mark は台字の前に置かれる

  [T.61/4.1.3.1] (b) アクセント付きの文字は二バイトで表現することができる。
  初めのバイトがアクセントの記号であり、次のバイトが適用対象のアルファベットである。
  (d) 二バイト目に SP を指定する事によってアクセント単体を表現できる。
  (e) CCITT T.61 の non-spacing underline は次に現れる図形文字に適用される。
  その間に別の制御機能が幾つか挟まれていても良い。

  [T.61/Table-2] 縦書きの場合には半角文字は90度回転する。但し、double width の
  時にはそのままの形で表示するという事の様だ。と思ったがこの double width は、
  単に全角文字ということのように思われる。後、中国語と日本語では規則が少々違う様だ。

  [T.61/E.3.2.1] RLF という制御機能が存在する様だ。8/13 となっているがこれは RI と等価だろうか。
  →調べてみたところ RI も 8/13 なので等価である。RI の別名と思っておくのが良いだろう。

  [T.61/E.3.1.2] DRCS は漢字を増やす為に使われると書かれている…。
  複数バイト文字集合を G0 にシフトするのに ESC $ F が使えるとか…。
  ISO-2022 にはそんな記述はない。図による説明でも G0 にはシフトできない事になっていた筈。
  と思ったらすぐ下の Note に例外的であると書かれている。DRCS の時だけ使えるという事なのか。

  [T.61/E.3.2.1] ここに SGR(26) Proportional の意味が書かれている。
  Note1. proportional を解さない端末の為に一行にSHSで決まるより多くの行を出力し
  てはならないそうだ。うーん。結局現在の contra の様な実装が端末上では自然なのだと思う。
  - SGR では default param と一緒に別の param を使えない事になっている。
  - termcap の為の応答 (T.62) では proportional に対応している事は SGR(26) で知らせる。
    他の引数と一緒には送らない。→T.62を確認してみたがこれは文書を送る為のバイナリの規格で、
    文書がスタートする時に端末に要求する機能の一覧を指示する部分がある様に見える。
    其処でその機能を実際に使う時に使う制御シーケンスを埋め込む様だ。抑 SGR(26) に限らず、
    何れの cap 指示に於いても引数は一個しか指定できないとされている。
  - 所で T.62 を見ると DRCS の定義も文書の初めに格納する様である。但し、具体的な形式は
    明らかでない様な気がする。"dot pattern" はどの様に配置されるのだろうか?
    何れにしても T.61 は文字端末とは関係のない話である。そもそもバイナリ形式である。

  [T.61/E.3.1.2] SCO の回転中心は文字のセルの中心だと明記されている。
  (特に中国語の場合について書かれているが、これは半角文字は自明だから書いていないという事?)
  →T.62/5.7.4.4 の書きぶりを見るとそもそも SCO は漢字の為の制御機能とも読める。

2019-08-10

* オブジェクトの描画について

  そもそも未だオブジェクトを格納できる機能は実装していないのだが。
  しかし実装するとしても色々と問題がある様に思われる。

  * 各 term の中に格納しているオブジェクトを
    描画する側でどう取得・管理するのかという問題について

    | つまり、オブジェクトの情報をどの様にして共有するのかという事である。
    | 現在の実装ではオブジェクトの情報を term 側で格納する予定である。
    | 描画ルーチンでそれを呼び出す時にセルの情報だけ取得すると、
    | term の中に格納されているオブジェクトのデータを取得することが出来ない。
    |
    | a オブジェクトはグローバルに一意のIDを与える事によって管理すれば良いのだろうか。
    |   とも思ったが、将来的に detach/attach に対応する事を考えると困難である。
    |   そもそもグローバルにIDを管理する事ができるのかという問題がある。
    |   更にグローバルになる様にしたところで今度はオブジェクトのデータが必要になった
    |   時に毎回データを他のプロセスに問い合わせる必要がある。
    |
    | b 或いは、オブジェクトを管理するのは飽くまで term の内部にしておいて、
    |   外に出す時にはオブジェクトのデータではなくて描画用のデータしか
    |   渡さないという仕組みにするのか? それは一つの手である。
    |   然し、やはり容量が増えて重くなってしまう原因となる。
    |
    | c やはり term から manager/renderer にセル情報を渡す時に、
    |   一緒にオブジェクトの配列も渡すという仕組みにすれば良いだろうか。
    |   然し、そうするとやはり描画の度にオブジェクトのデータをコピーする
    |   必要が生じてしまい、これが通信路の上で行われていると重い。
    |
    |   まあ、これについては保持しているオブジェクトの version と id を
    |   request の際に添付して、それを見て転送を省略するか更新するか、
    |   或いはオブジェクトに応じて差分だけ送る様にするか、という事を
    |   伝達する事ができるようにするのが良いのである。
    |   まあ、差分機能に関してはそんなに必要になるとは思われないので、
    |   実際に問題になって必要が生じるまでは実装しない事にするというので良い。
    |
    |   オブジェクトを取得できる様にしてしまうと、
    |   今度はオブジェクトの変更をどう同期するのか、
    |   という問題が生じしてしまう様に思うが、
    |   これに関してはオブジェクトの変更は飽くまで term 側で実行する物とし、
    |   取得した側では一切の変更は行わないという規則にすれば問題ない。
    |
    | まあ、ttty の実装は今はいい加減になっているので
    | ttty の実装を行う時に改めて考えれば良いのではないか、
    | という気もする。或いは ttty の実装も今から真面目に初めた方が良いだろうか。
    | うーん。あまり実装が進みすぎると ttty が追いつけなくなるというか、
    | ttty が構造的に対応できない、という領域に達してしまう気がする。
    | なので余り遠くない内に ttty の方の対応もした方が良い気がする。
    | まあ、何れにしても ttty の事を気にして実装をどうのこうのというのは
    | 程々にして適当に実装すれば良いのだという気がする。

    結論としてはセル情報を取得するのと同じタイミングで
    オブジェクトのデータも取得する様にすれば良いという事。
    取得したデータは描画用に参照するだけであって、
    オブジェクトに対する操作などはできない様にする。

  * オブジェクト自体が変化するという事を考える場合

    | ttty の様な枠組みを使っていると、
    | オブジェクト自体の変化を伝達する仕組みが必要になる。
    | と思ったが、よく考えてみればそもそもオブジェクト自体が変化したとしたら、
    | それは恐らく端末アプリケーションによる指令によってオブジェクトが変化した
    | という事になるので全く同じ指令を用いてオブジェクトを更新すれば良いのである。
    |
    | 或いは端末アプリケーションと関係なくオブジェクトの状態が
    | term 上の操作によって変化してしまうという事があるだろうか。
    | うーん。term の入口はユーザ入力と端末アプリケーションの出力しかない。
    | 端末アプリケーションはそれを想定しているので、それ以外の操作に関しては保証外である。
    | という事を考えれば基本的にオブジェクトの状態が勝手に変化する事はない。
    |
    | 唯一の例外がユーザからの入力に対してオブジェクトが勝手に反応して、
    | それで状態が変化してしまうという事である。うーん。
    | そう言った物を考える事も可能なのかもしれないが、
    | それはそれでその変化を端末アプリケーションに伝達する仕組みなども必要になるので、
    | 必要が生じたらその時に改めて考察するという風にふれば良い。

    結論としてはオブジェクトの変化は基本的に
    端末アプリケーションからの制御によって起こる筈だから、
    同じ様にして ttty の外側にあるオブジェクトも同期できる筈である。
    それ以外の変化が生じるとしたら、端末アプリケーションも含めて
    それを同期する完全に新しい枠組みが必要になるのでここで考えなくて良い。

* sixel: コピペする時にモザイク文字を使って近似するという
  手法が考えられるかも知れない。というより、普通に sixel に対応していない
  端末に対して出力する時にもモザイク集合を使う事ができるかもしれない。

* DECDLD で DRCS に対応する時には

  * 新しい DRCS の文字集合に charset_index を割り当てる処理が必要
  * 文字集合を開放する処理も書く必要もある
  * DRCS の文字の定義が変更されたら完全再描画が必要
    従って定義変更を検出する為に version 番号を管理する必要がある。
  * DECDLD による定義は term_t 毎に行う必要がある気がする。
    charset_index も場合によっては term_t 毎に割り当てる必要があるのでは。
    という考察は改めて後で行えば良い。

* ExtTextOut とアラビア文字

  現在の実装では高速化の為に隣接していない文字であっても、
  ExtTextOut を使用して offset を指定して無理やり繋げて表示していた。
  然し、アラビア文字が含まれていると実は offset が無視されて、
  複雑な事が起こってその結果として表示が変な事になっている気がする。

  しかしよく考えてみれば現在の contra では結合文字の事を全く考えていない。
  少なくとも結合文字を extension として取り扱った時に問題が未だ再現するかを
  確かめて、それでも発生するという時に限って再考すれば良いのではないかと思う。

* 曖昧文字幅

  曖昧文字幅の問題は結構面倒である。
  先ず、端末アプリケーションと端末エミュレータで合わせなければならない。
  それで万事OKなのかというと微妙でフォントの方も合わせないと、
  画面が見にくい事になってしまう。

  * 字毎に拡大縮小を実施する?

    実は RLogin はフォントの metric を見て勝手に拡大縮小して描画する様だ。
    しかしこれはこれで処理が重くなる。毎回フォントを確保・開放していると
    重くなるし、かといってあらゆる拡大縮小に対してフォントを生成して
    キャッシュしていると今度はメモリ的に大変な事になってしまう気がする。
    拡大縮小に関するラスタライザは縮小だけで対応してくれるとかそういう
    機能はフォントにはないのだろうか等とも思うが、ClearType 的な事を考えると
    そうも言っていられないのだろうという気もする。RLogin はどうしているのだろう。
    拡大縮小が起こった場合に描画が汚くなってしまうという事を考えると、
    自前で拡大縮小を実装しているのだろうか。とも思ったが背景との合成などが
    大変である。という事を考えればやはりフォントを生成しているという事なのだろうか。

    拡大縮小の比率についても気になる。例えば全角を半角に縮小して表示する場合を考える。
    字形のデータ上の進み具合が全角であったとしても、字形としては全角目一杯に
    大きく表示するのではなくて、中央に少し小さめに配置していたりする。
    この状態で普通に半分に縮小してしまうとどういう事になるかと言うと、
    物凄く圧縮された感じになってしまうのである。なのでそれが難しい。
    然しだからと言って実際に字形の右端と左端を見るという事にすると、
    今度は・等の記号が変に拡大されてしまうという事態になる。
    まあ、拡大率の上限を設定すればこれは自然に解決する気がする。

    因みに文字毎に拡大縮小を変更するという事を考えるのであれば、
    実は自分でラスタライザを書いてしまうとか、
    そういう事までした方が柔軟に対応できたりするのかも知れない。
    但し、X11 の場合にはそういった画像をどうやってリモートに送るのかというのが問題になる。
    毎回画像を送っていると遅くなってしまう。リモートの Pixmap に保存しておくとしても、
    背景画像との合成などをどのようにするのかという問題が残ってしまう。

    X11 での対応が汚い事になってしまいそうな気がするのでこれについては断念するか?
    或いは別に twin と tx11 で同時に対応する必要もない。
    その為に文字列の配置コードと文字列の描画コードを分離しているのである。
    と思ったが、もし全角・半角の情報を使うのだとすれば文字列の配置コードの方も弄る必要がある?
    と思ったが、少なくとも期待される文字幅を配列に入れて渡すという事をすれば十分なので、
    実はそんなに気にしなくても良いという気がする。


2019-08-09

* CNS 11643 について

  現在の実装では以下を元にしている。
  また本来実際には 1992 の版であるべきである。
  それ以降に追加・削除された文字について考慮していない。
  http://kanji-database.sourceforge.net/charcode/cns.html

  他のテーブルとして以下の物がある。比較してみたい。
  http://kanji.zinbun.kyoto-u.ac.jp/~yasuoka/CJK.html

* iso2022: NRCS MCS 等に関して

  | 調べているとどうやら文字集合の宇宙は iso-2022 を超えて広がっている様だ。。
  | RLogin が private (1 及び 2) で対応している文字コードについて調べると。
  | 先ず初めに DEC_TCS というのを調べてみると Wikipedia にページがある。
  | https://en.wikipedia.org/wiki/DEC_Technical_Character_Set
  |
  | 更に其処から https://en.wikipedia.org/wiki/Multinational_Character_Set
  | MCS (IBM 1100) という物があるという事が分かる (これにシーケンスが割り当てられている
  | のかどうかについては分からない)。更に IBM DEC emulations 等と言って、
  | IBM 1020, 1021, 1023, 1090, 1101..1107, 1287, 1288 というのがあるそうだ。
  |
  | http://test.daemon-secours-776655.com/index.php/National_Replacement_Character_Set
  | そして DEC terminal では NRCS という仕組みを使ってソフトウェア的に文字コードを
  | 構築して切り替える事ができるようにしているという事。
  | どうも上記の IBM 云々というのは大体 NRCS で DEC VT についてきた文字コードの様である。
  |
  | エスケープシーケンスに関しても実は NRCS を通して定義する事ができるという事なのだろうか。。
  | うーん。https://qiita.com/arakiken/items/626b02cd857d20c12fbc を思い出す。
  | DRCS で定義できる文字集合に実は制限はないのだろうか??
  | 調べると DECDLD という制御機能で DRCS を定義できるという事である。
  | そして DECDLD を見る。Dscs には SCS で使える名前を指定できるとある。
  | そして SCS を見ると…うわー。沢山定義されている。あるある。一杯ある。
  | https://vt100.net/docs/vt510-rm/DECDLD.html
  | https://vt100.net/docs/vt510-rm/SCS.html
  |
  | https://vt100.net/charsets/technical.html に実は DEC TCS の説明が一部書かれている。

  まとめると。DEC VT では私用 NRCS を色々と定義していて、
  どういう物が定義されているかは https://vt100.net/docs/vt510-rm/SCS.html で確認できる。
  但し、具体的に中身がどうなっているのかについては VT のマニュアルには書かれていない。
  代わりに IBM が DEC emulations として数々の物を定義している。
  それらは Wikipedia にちゃんと載っている。特に
  https://en.wikipedia.org/wiki/Multinational_Character_Set を目次として使える。

  * https://vt100.net/docs/vt510-rm/SCS.html に文字集合と designator が載っている。
    一応一覧を転写する。ISO-IR に登録されている物は省略する。

      SB94 %5  DEC Supplemental
      SB94 "?  DEC Greek
      SB94 "4  DEC Hebrew
      SB94 %0  DEC Turkish
      SB94 &4  DEC Cyrillic
      SB94 9 or Q  French Canadian NRCS
      SB94 `, E, or 6  Norwegian/Danish NRCS
      SB94 5 or C  Finnish NRCS
      SB94 =   Swiss NRCS
      SB94 7   or H  Swedish NRCS
      SB94 %6  Portuguese NRCS
      SB94 ">  Greek NRCS
      SB94 %=  Hebrew NRCS
      SB94 %2  Turkish NRCS
      SB94 %3  SCS NRCS
      SB94 &5  Russian NRCS
      SB94 0   DEC Special Graphic
      SB94 >   DEC Technical Character Set
      SB94 <   User-preferred Supplemental
      SB96 <   User-preferred Supplemental

    https://vt100.net/docs/vt510-rm/chapter13.html には WYSE の ESC c @ XX YY という指定が
    書かれている。然し、これは体系として微妙に異なる様な気がしている。

    https://vt100.net/docs/vt510-rm/chapter7.html#S7.2.1 には文字集合のリストが書かれているが、
    結局上記の SCS を point している様である。

  * 結局具体的な文字表に関しては Wikipedia の以下を参照するのが良さそう。
    https://en.wikipedia.org/wiki/Code_page#DEC_emulation_code_pages

  * https://vt100.net/docs/vt3xx-gp/chapter7.html#S7.3 にも書かれている。
    と思ったがこれは ReGIS 専用のものだった。
    基本的には上記の物の subset だが以下は上には記述されていなかった。

      SB94 4 Dutch

  * https://vt100.net/docs/vt220-rm/chapter4.html#S4.4 にも書かれている。
    ここによると DSCS (DECDLD の前身) の例で載っている &%c は &%c の解釈だそうだ。
    つまり DECDLD の &%c が %c になるという説明は何処かで & が脱落しただけの事だろう。
    更に https://vt100.net/docs/vt220-rm/contents.html の Tables の 2-1 から 2-16
    にちゃんと文字テーブルが載っている…が何だか怪しい。PDF版で確認した方が良いかもしれない。

  * DRCS に関しては DECDLD で定義する事ができて、
    実は任意の文字コードを書き換えてしまう事が可能な様にも思われる。

    うーん。やはり恐ろしい事に任意の文字コードを書き換えてしまう事が可能の様に見える。
    つまり標準の文字コード (US) ですら書き換えてしまう事が可能な様に思われるのである。

  * RLogin は private 94 charsets の "1" として DEC_TCS を実装しているが、
    然し一方で https://vt100.net/docs/vt510-rm/SCS.html によると、DEC_TCS は "<" である。
    RLogin が実装している IBM437 は以下に表がある。
    https://en.wikipedia.org/wiki/Code_page_437

2019-08-06

* iso2022: 複数バイト文字集合には未対応である
* iso2022: その他の様々な文字集合にも対応していない
* iso2022: 現在は必要最低限の対応なので他にも色々制御機能がある筈
* iso2022: input decoder をどのように実装するかは非自明。
  特に Meta 修飾としての ESC と、エスケープシーケンスの ESC の区別。

  そもそも数々の文字集合のデータを何処かで取ってこれるのだろうか?
  https://www.itscj.ipsj.or.jp/itscj_english/iso-ir/ISO-IR.pdf に置いてある。

* iso2022: mosaic 集合を自分で描画できるか?

2019-08-05

* test: 文字の種類とフォントの切り替えに関して。
  取り敢えず暫くは contra の上で作業をしてみようと思う。
  気づいたのだが実はフォントが微妙に違うのである。
  Poderosa では教科書体を用いていた。
  contra/twin で部分的にフォントを変更する事は可能なのだろうか。
  考えてみると色々と修正する必要がある様な気がする。
  というか教科書体を用いるのだとしたらそもそも MeiryoKe に拘る必要すらない気もする。
  一方で Poderosa では日本語のフォントと英語のフォントを切り替えられたのだった。
  うーん。フォントの切り替え機能も実装する事にしようか…。

  Note: これは描画に関する事だから処理が多少重くても問題ないのである。
  但し、文字毎にフォントを切り替える事になる訳だから…色々考えなければならない。
  font_t は 24bit 現在使われている。未だ 8bit 在るしいざとなれば 64bit に拡張しても良い。

* manager: タブのメニュー表示が欲しい
  端末のタイトルは此処で使われるのである。
  端末のタイトルは既定で pty で開いた時に設定するのが良いのではないか。

2019-08-04

* ベルを鳴らすという事について

  Windows ではどの様にベルを鳴らせば良いのか。
  Beep を呼び出すと本当にデバイスからのビープ音が鳴ってしまう。

  X11 では正に XBeep という名前の関数が用意されている様である。
  https://kakurasan.hatenadiary.jp/entry/20071126/p1

* twin, tx11: 前回のウィンドウの位置・サイズ・状態を記録する?
  その為には何処かに状態を保存しなければならない。
  適当に ~/.local/share/contra 辺りにファイルを作ってしまえば良いだろうか。

* tx11: Window のアイコンを変更する方法に関して
  Window のアイコンは window manager の管轄である。
  アイコンのプロパティ名から Atom を生成して、
  XChangeProperty を使って設定するという風にするらしい。
  https://stackoverflow.com/questions/43237104/picture-format-for-net-wm-icon
  http://hackage.haskell.org/package/GLFW-0.2/src/glfw/lib/x11/x11_window.c

* tx11: というか alpha blending が X11 だと絶望的な事になるのでは?
  リモートで合成できないのでローカルで合成してから転送しなければならない。
  と思って調べたら XRender という拡張を使うのだそうだ。
  https://en.wikipedia.org/wiki/X_Rendering_Extension
  https://ja.wikipedia.org/wiki/XRender

  % 所が XRender は絶望的にドキュメントがないそうだ。
  % https://xorg.freedesktop.narkive.com/smVkQQtA/looking-for-xrender-examples
  % Xft/Qt/cairo 等を通して使えとの事らしい。
  % 然し、これらの議論は全てテキスト描画を念頭に置いている?

  と思ったら以下にちゃんと関数の一覧などが載っている。
  https://www.x.org/releases/X11R7.5/doc/libXrender/libXrender.txt
  と思ったが色々の情報に比べると機能が少ない気がする。古いという事か?

  Alpha blend に対応していない時は
  背景画像を設定している場合は NUL かつ背景色が設定されていない
  升目だけ背景画像が見える様にするという手がある。
  その様にすれば別に透過に対応しなくてもちゃんと背景画像に対応できる。
  文字が浮かんでいるという雰囲気にする事は難しいのかも知れないけれども。

2019-08-03

* tx11: 設定ファイルからフォント名を読み取る
  自分だけで使うから問題ないと思っていたが、
  よく考えたら自分でも Win や Linux 等色々な環境で使う。

  これは何処かからか既存の実装を持ってきて実装するのが良い気がする。
  というより hprism 辺りに実装があった様な気がする。
  然し、hprism は面倒な事に libmwg に依存している。
  取り敢えず hprism をコンパイルして確認してみた所。
  これはこれで ttx を使った複雑な実装になっている。
  今必要なのはこのような複雑なものではなくて単純な物である。
  結局自前で実装してしまう方が楽だろうか。

2019-07-28

* tx11: フォント描画について
  http://www.02.246.ne.jp/~torutk/cxx/x11/string.html

2019-07-27

* twin: 画面外で選択のドラッグを止めるとコピーされない
  マウスキャプチャしなければならない気がする。

* view: 実は横方向のスクロールも考えるべきなのではないか。
  然し、これは実際にそういう機能を実装してから対応するべき。

  →やはり screen の様な物を観察すると横方向のスクロールを考えている。

* 処理時間を計測してみたが不思議な事に
  端末処理や描画をしない様にした方が2倍位遅くなる。
  何か返答がないと処理を待つ等の事があっただろうか。不思議な事である。

  或いは idle の待ち時間の問題だろうか…。
  →これだった idle 時の待ち時間を 10ms から 1ms に変えたら改善した。
    然しそれでもやはり端末処理を省略したとしても余り早くならない。
  端末の処理自体は実は 1/5 位しか時間を使っていない様に見える。
  残りは入出力なんだという気がする。

  やはり現在の入出力の方法は変なんだ。
  また簡単なプログラムでも書いて動作を確認するのか。
  うーん。何れにしても…複数の端末を開いている時には
  現在表示している端末を優先させたいのである。

  マルチスレッドにするとかそういうのは後で考えれば良い。
  寧ろシングルスレッドで動作する枠組みを整えた方が
  後々色々な事を実行しやすいのではないだろうか。
  poll 及び Windows の WaitForMultipleObjects をどう統合するのか。
  結局一方での結果を他方に何らかの手段で伝達するという方法しかないのか。
  つまりそれぞれに待つ為のスレッドを作って、
  サブのスレッドがメインのスレッドに通知を行うという形にする。
  twin.exe ならば Windows のループの方をメインにしなければならない。
  然し、そうすると優先順位などを付けるのが難しくなってしまうのではないか。
  とも思ったが現在 sleep している所をそれに置き換えるだけと考えれば、
  そんなに難しくもない様に思われる。

2019-07-26

* ttty: 入力 decoder について

  * 現在は ttty/screen 内に直接実装しているが入力の decoder は
    一般に様々のアプリケーションで使う物の筈であるから将来的には分離して
    他からも使える様にするべきである。

  * terminfo を参照する様に修正する
    ncurses のライセンスは MIT ライクなライセンスである。
    terminfo のバイナリ互換性は怪しい。ncurses を使うのが無難。
    ncurses が使えない時には自前のデコーダを使って誤魔化す。

* 何だか色々と考えがぐちゃぐちゃになって整理が付かない。
  ble.sh はかなり整理されているというか、
  やりたい事があらかた終わってしまったので安定した状態になっているという事。
  対して contra は実装しなければならない事、
  気になる事が多すぎて駄目になっているのである。

  やりたい事が多すぎるから最終的にどの様な構造になるのか決定できず、
  結果としてコードを整理しようにもどう整理したら良いのかが分からないから、
  コードの整理が進まないという事なのだろう。

  どの様に進めるべきかというとやりたい事を少しに絞って、
  その上で最終的にどの様にやりたい事を絞るのかという事を決める事である。

2019-07-25

* scroll buffer に関して。

  * transfer mode (GATM) 等に対応する。
    つまり guarded な文字は空白等に置き換える処理を行う。
    空白に置き換える時には当然 line の version は増やす必要がある。
  * altscreen の時には transfer しない。
  * transfer として別の出力先 (ファイルなど) も対応できる様にする。

2019-05-26

* 複数の画面を切り替える場合はどの様に実装すれば良いか。

  manager の側では特に何もしなくても良い様な気がする。
  単に現在の app を切り替えるだけ。

  問題は描画の方である。切り替えたら表示内容を全てクリアして
  再描画しなければならない。dirty だけ設定しておけば自動的に
  クリアされるだろうか。

  本来は画面分割も一緒に考えて対応するべきなのかもしれないが、
  先に画面切り替えだけ実装してしまっても良い様な気がする。
  というのも、画面分割の変更の場合にも結局再描画は必要になるからである。

  画面分割の変更の場合にはどの様に更新をするのが良いのだろうか。
  m_dirty は分割毎に保持しておくべきなのではないだろうか。

  というか現状のGUI端末としての用途を完成する上では
  これは後回しでも良い気がする。中で screen を起動すれば良い。
  →Poderosaの代替として使用する為にはやはり欲しい。

2019-05-16

* settings: 設定ファイルを読み取る様にする
* settings: 装飾キーの設定をできるようにする

2019-05-10

* memo.txt の番号付について

  番号のついている行の数
  $ awk 'done && /^\* .*\[#D[0-9]+\]/ {print;} /^  Done/ {done=1}' ../memo.txt | wc -l

  番号のついていない行
  $ awk 'done && /^\* .*/ && !/\[#D[0-9]+\]/ {print;} /^  Done/ {done=1}' ../memo.txt

  重複する番号
  $ grep -o '\[#D[0-9]\{1,\}\]' ../memo.txt | sort | uniq -d

  参照一覧
  $ awk '/#D[0-9]+/ && !/\[#D[0-9]+\]$/ {print;}' ../memo.txt
  $ grc '#D[0-9]+'

2019-05-08

* manager: S-select で行選択。M-S-select で行末まで矩形選択

* term: 巨大なデータを貼り付けると input_buffer が大きくなってそのまま

* エラーメッセージだとかログファイルへの出力だとか整理したい。
  取り敢えず stderr に出力している所はログファイルへの出力に後で変更する。

* twin/draw: 縦書き表示に対応する為には
  装飾の類を全て再実装する必要がある。
  また、SCO の回転方向と座標補正に関しても確認する必要がある。
  font_store_t の displacement は x,y を交換して解釈すればいけるだろうか。

* manager: extract_selection 時に行を追跡するべきでは。
  というか実は選択されていたとしても追跡しなければならないのではないか…。
  これについては実装された後で考えれば良い。

* twin: サイズを変更している間は何もかも止まっている気がする。
  なので通知しても意味がないのでは。
  と思ったが、やはりサイズ変更通知は変更が確定してから起こっている?
  或いは家のマシンと学校のマシンで設定が異なる?

2019-05-07

* test: 1x1 でテストするとバグなど洗い出せるかもしれない。
  他に DECSTBM で幅を2にした時に安全に動くかや、
  DECSLRM で高さを2にした時に安全に動くかなど。

2019-05-06

* c2w 高速化に関して
  cat /dev/urandom における現在のボトルネックは c2w の気がする。
  実際にそうなのかも含めてテストする必要がある。

  - 少なくとも c2w を u < 0xA0 ? 1 : 2 の様な物に変えたら速度は改善した。
  - 或いは error_char を 0xFFFD ではなく '?' にした場合はどうだろうか。

* twin: write でブロックされると GUI も一緒に固まってしまうのでは…。
  未だ実際になったことはないが接続が切れるとそういう事になるはず。。

  更に複数のセッションを開いた時にどのように管理するのが良いだろうか。
  各 fd について全部 non-blocking で試して回るのは非効率の気がする。
  一方で、今 terminal_application に抽象化してしまったので、
  複数の fd に対して poll するというのは面倒である。というか、
  ttty で実装するとしても fd に対してだけ poll していれば十分なのか、
  というのも気になるところではある。一応、ユーザからの入力も
  アプリケーションからの入力も全ては fd を介して行われるのは確か。

  write しきれなかった分に関しては何処かにバッファリングしておく
  必要があるかもしれない。という事。

* ライセンスの追加
  考えるのは嫌なので BSD-3 にする。MIT にしていると Copyright の名前を
  すべて書き換えて公開するという輩が出てくる。そういうのを幾らも見てきた。
  しかし GPL の様に厳しいのは嫌である。という訳なので、BSD-3 にするのである。

* twin: mouse capture しないと際のところにある物を選択するのが面倒だ。

* twin: mouse が範囲外に出た時の down up のつじつま合わせ?

2019-05-05

* ansi: SLL, SLH の "それ以降の行" の解釈は変えるべきではないか
  現在は "それ以降に新しく現れた行" という事になっているので、
  既に存在している行には適用されない。

  例えば LF,NEL や FF や VT 等を実行した時に適用されるなど。
  然し、もしそうなのだとしたら結局 SLL SLH は暗黙移動でしか使われないので、
  余り意味がない事になってしまうかもしれない。つまり SLL,SLH を参照する時に
  毎回行の SLL,SLH を上書きするのだとしたら記録してある行の SLL,SLH が使われる機会がない。

2019-05-04

* twin: modifyOtherKeys に対応して出力を変更する。

* twin: modifyOtherKeys で修飾キーや、keyup の操作も送信するのか?
  調べてみたがそういう事はないようだ。
  RLogin に書かれている説明と xterm が送ってくる sequence は
  齟齬がある様な気がする。どの様にシーケンスが切り替わるのかは
  もっとちゃんと調べる必要がある。

  然し、調べていて思ったが実はこれには対応しなくても良いのでは。
  という気がしてきた。結局 ble.sh の様にどの様なシーケンスが送られてきても
  ちゃんと対応できる様にしなければならないのは確かだし、
  どんなシーケンスを送っても許されるのでは。
  modifyOtherKeys は C0 で表現できる物も全て encode してしまう。

  うーん。取り敢えずは modifyOtherKeys の機能は
  要らない気がするのでそのままにしておく。

* twin: surrogate pair の IME 入力はどの様に受信されるのだろうか。。

* 端末からの通知をどの様にして受け取る様にするのが良いか。

  沢山 on_term_resize だとか on_term_bell だとか
  そういう仮想関数を用意するのだろうか。
  或いは、単一の関数でメッセージ方式で処理する様にするのだろうか。
  どちらの方が効率が良いだろうか。
  結局単一の関数で受け取るとしても各関数に配分する事になるのだから、
  やはり on_term_* という関数を沢山持った抽象クラスを準備するのが良いだろうか。

2019-05-03

* twin: 使い物になる為に必要な機能は…。

  - ok: 単独で起動できる様にしなければならない。
    これはまあ制限はある物の許せる振る舞いではある。
    真面目な対応は後で考えれば良い。
  - done: 先ずスクロールバックできる様にならないと駄目。
    因みにリサイズした時にはみ出る行についてもスクロールバッファに送りたい。
  - done: コピー・ペーストの機能は必要。
    ペーストは欲しい。

  - フルスクリーン機能は欲しい
  - mintty はバッファ内の検索等ができる様になっている。
    これは ttty でも欲しい機能なので GUI では対応しない。

* twin: 端末からのサイズ変更の要求があった時にウィンドウサイズを更新する。
  対応できない大きさへの変更が要求された場合には変更し返す。

* [疑問] twin: 英語のフォント名を指定しなければならない理由?
  ref #D0116
  不便である。本来日本語のフォント名で指定できてしかるべきである。

* ansi: エスケープシーケンスを適当に出力する fuzzer が欲しい。
  少なくとも変な操作でクラッシュして死ぬ様な端末は信用できない。
  (Poderosa は実際にすぐクラッシュしてしまうのであるが…。)

* [保留] twin/draw: 圏点を描画するのに Unicode の圏点を使う可能性
  問題点: グリフが用意されていない可能性・位置大きさの調整が難しいこと。

* twin/draw: フォーカスがない時はカーソルは表示しない?
  - 例えば Poderosa はその様にしている。
  - xterm は表示している。しかも点滅している。
    フォーカスを失って暫くすると点滅をやめる。
  - RLogin はフォーカスを失うとカーソルを消す。
    所でフォーカスを持っていても暫くすると点滅をやめる。
    一方で文字の blinking は無限に続ける。

* twin/draw: 背景画像
  背景だけの background buffer を作って良い気がする。
  というか背景画像は何れにしてもリソースとして持たなければならないので。

* twin/draw: FillRect と PatBlt と Rectangle と BitBlt のどれが速いのか。
  更に直線の場合は線を直接引くのと比べてどれが速いのか。

2019-05-02

* ansi: grapheme cluster については以下のリンクがよく整理されている。
  https://hydrocul.github.io/wiki/blog/2015/1025-unicode-grapheme-clusters.html

* twin/draw: 背景画像との合成を行う為には HBITMAP がアルファに対応していないといけない気がする。

  ? もし CreateCompatibleDC で異なる物が生成された場合には、変換しなければならない?
    或いは単に BitBlt が遅くなるだけなのだろうか?

  ? そもそも現在の PixelFormat を取得するにはどうしたら良いのだろうか。
    調べると GetBitmapBits という関数があるそうだ。
    https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/nf-wingdi-getbitmapbits
    然しこれは Win16 API なので、代わりに GetDIBits を使えとの事。

    うーん。これは丁度 C# でビットマップをバイナリで処理する時に使っている関数だ。
    その裏で実行されているのがこの関数なのだろうという気がする。
    まあ最終的にはこの関数を使って無理やり転送すれば良いという事である。
    然し、巨大な画像を転送するのには時間がかかりそうではある。
    うーん。やっぱり時間はかかるのだろうという気がする。

  実は合成するよりも再描画してしまった方が速いという可能性もある?
  と思ったが普通に考えたらそんな事はないはず。やはり手動でも合成した方が速い筈…。
  まあ、実測する価値はある様には思う。

2019-05-01

* twin: カーソルの形状の指定、色の指定、点滅など
  background buffer に描くのではなくて別に描画するべき。

  WM_PAINT による部分更新に際しては反転色で変な事が起こらない様に注意する。
  →Invalidate 領域を全て再描画するのだとすれば実は気にしなくても良さそう。

* twin/draw: 反転色部分の空白
  →これは背景色と前景を別々に描画する事にしたので問題ない。

* twin: cat /dev/urandom でフリーズした
  描画の振る舞いに関しても改善した気がする。
  暫く走らせてみる…と思ったらフリーズした…。こりゃ駄目だ。
  実は Visual Studio の C-A-p でアタッチできてしまう様だ…。
  調べてみると twin.exe!00418766 にいる様だ。これは…

  contra::multicast_device::dev_write(char const*, unsigned int)
  うーん。呼び出している関数は free で更に dlfree を呼び出している様に見える。
  しかも完全に停止している。何かのデッドロック状態になっているという事だろうか。

  うーん。例外が発生してそれでメモリの解放中に止まったという事?
  もう全然わからないので終了する事にした。

  分かっている事は直前に端末の幅が 1 文字しか無い様な、そんな動作をしていた事である。
  殆ど縦一列に表示されていて、しかし、時々長い行がある、というそんな感じ。
  これはどの様な場合に発生するだろうか。例えば勝手に端末幅が制限された時に起こる?
  端末の幅や高さを勝手に書き換える様なシーケンスには対応していない気もする。
  うーん。或いは、DECLRMM, DECSLRM が同時に設定されたのだろうか。
  しかし DECSLRM の場合には最低でも2列はある筈である…。
  と思ったが DECSTBM で 1 行になったりもしている…。
  或いは、何か別の理由でスクロール範囲が変わっているのだろうか。
  もしくは decawm が off になっていた等?

  * fixed: うーん。やはり Poderosa の上で twin を実行すると何だか滅茶苦茶な事になる。
    サウンドデバイスを呼び出しまくって固まってしまう。CPU もたくさん使う。
    mintty も何だか応答が悪くなってしまうのであった。
    これからは mintty の上の twin の上で twin を動かすという方式に変更してみる事にする。
    と思ったらそれでも何だか変なビープ音が出力される。これはどういう事だろうか。
    少なくとも screen の中で起動している内は変な音は出力されない。
    mintty 中の twin でもやはり同様に変な音が出る。
    うーん。screen/twin だと大丈夫である。screen/twin/twin でも平気である。
    これが意味する所は何かというと、BEL が伝達しているという事である。
    と思ったら screen の window list で確認すると、BEL がある事を示すマークが出ていた。
    つまり、BEL を伝達しているという事である…。

    然し、変である。BEL を何故…あー。
    do_bel() の暫定実装で取り敢えず標準出力に \a を書き込む様になっていた…。
    これは実のところ term に設定できる様にするべきである。
    何かイベントリスナーでも登録できる様にするべきなのである。

2019-04-30

* kill(sess.pid) しているが誤爆の心配はないのか。
  もっとちゃんと検知する方法が存在するのではないか。

* twin: bash を exit した時に自動で閉じたいが正しい閉じ方は?
  現在の実装だと単にアプリケーションを終了してしまっている。
  本当は WM_CLOSE 等を呼び出して閉じるべきなのではないだろうか。

2019-04-29

* [保留] twin: dead-char 対応

  dead-char (フランス語やスペイン語のキーボードで現れる) の仕組みがよく分からない。
  そして dead-char を入力する時にどのような順序でメッセージが送られてくるのかもよく分からない。

  ? 例えば WM_CHAR を見ていれば WM_DEADCHAR と同じ内容が見えるのだろうか。
    それとも WM_CHAR または WM_DEADCHAR のどちらか一方だけが送られてくるのだろうか。

  ? dead-char を入力しかけている状態でも WM_KEYDOWN が送られてくるのだろうか。

  ? ::ToUnicode/::ToAscii に指定する keyboard state はダミーの変な物であっても、
    ちゃんと (何処かに記録してあるキーボード状態を参照する等して) 正しく変換してくれるのだろうか。

    どうも、同じ引数で2回呼び出しても結果が変わる様なので、何処かに状態が記録されている気がする。
    (或いは勝手に keyboard state を書き換えてしまう等の事はあるのだろうか)
    しかし、何を元に状態を更新しているのかについてはよく分からない。
    渡した keyboard state によって内部状態を更新しているのだとしたら、
    ダミーの keyboard state を渡している限りは dead keys は受信できない。

  ? ::ToUnicode の戻り値が 3 以上の場合も存在しうるらしいが、
    最大で幾つなのだろうか。そしてもしバッファが足りなかった場合には残りは取得できないのか。
    https://stackoverflow.com/questions/42667205/maximum-number-of-characters-output-from-win32-tounicode-toascii

  ? 更に、実際に dead-char を受信するとしても修飾キーがついていた時に、
    1つ目の文字に修飾キーをつけるのか、
    或いは全ての文字に修飾キーをつけるのか、というのはよく分からない。

  mintty のホームページを見ていたら dead-char 対応も謳っている。

2019-04-28

* trace_line_scroll は DECSLRM,DECSTBM に対応している端末では
  表示幅が全体でなくてもこれらを使って対応できる筈。

  また、is_terminal_bottom での処理に関しても、
  DECSTBM が設定できるのであれば敢えて挿入する必要はない筈である。

* vttest: ESC ( B, ESC ) B, ESC ( 0 等を出してくる。
  文字コード関連も整備した方が良いのだろうか。

* 画面サイズが変更された時に端末に通知していない気がする…。
  tty_observer でちゃんとサイズ変更を検知して、
  更に出力しなければならない。

  というか変更された瞬間に実行するべきなのか、
  或いは表示する瞬間に実行するべきなのか。
  これは恐らく変更された瞬間に実行するべきである…。
  もし変更を指示したのがそのアプリケーション自体であった場合、
  アプリケーションは画面サイズの変更通知を待たずに、
  そのサイズを前提とした処理を実行してくるはずだからである。

2019-04-27

* [保留] なめらかなスクロール (mode_decsclm)

* tty_observer: Mode ?8 の変更を外側に伝達

* 他にも外に伝達するべき mode 変更について考える必要がある

  実は Mode ?5 の変更に際しても term から tty_observer に伝達があると良い。
  或いは tty_observer 側で前回の状態を記録しておいて丁寧に差分を取るか。
  しかし、volatile に変更を外に伝達したい場合もあるのではないかという気がする。
  (具体的には今は思い浮かばないので volatile な伝達は必要になってから考えれば良い。)

* 入出力の順序等に関して

  * 現在の実装で yes を実行したらどうなるのか確認した
    ちゃんとすぐに C-c が通じて yes を終了する事ができる。
    そう。本来そうでなければいけないはずなのである。

    一方で、他の端末はどうなのだろう。実は Poderosa が駄目なだけなのでは。

    - と思って試してみると xterm も RLogin も C-c
      を押してからだいぶ経ってから yes が終了する。

    - mintty に関してはそもそも yes を終了することもできず、mintty 自体がフリーズしてしまう。
      CPU 100% になっている訳でもなくデッドロック状態になっている様に見える。

    - 後、今気づいたのだが文字を入力していると Poderosa は結構 CPU を食っている。
      これはどうやら Google IME が CPU を食っているという事の様である。
      日本語の入力をしている時には 10% ぐらいになるが、
      英語の入力をしている時には上に上がってこない。

2019-04-23

* 縦スクロールの外側端末に対する描画に関して

  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)
  terminal multiplexer で縦スクロールをどの様に外部に伝達するのかについては
  確かに面倒であるという事が議論されている。

  a 例えば縦スクロールの直前に画面を全て更新して
    縦スクロールのシーケンスを送信するという手がある。
    しかし、そうすると縦スクロールを全て送信しなければならなくなる。
    大量の出力の末にスクロールしきった一番最後の状態を表示するというのができない。

  b 特に、画面が隠れていた時に行われた縦スクロールはどの様に処理するのか…。
    と思ったが、実はそれは気にしなくて良い気がする。画面が現れた時に、
    何れにしてもその時の状態は全描画しなければならないので、
    それまでに実行された縦スクロールなどは気にしなくて良い。

  c うーん。縦スクロールは DECSLRM に従って実行されると仮定すれば、
    実は DECSLRM で切って差分などを取る事によって移動を検出すれば良いのではないだろうか。
    DECSLRM が解除した後であっても最後にスクロールを実行した時の lrmargin を記録しておくという手もある。
    現在スクロールは do_vertical_scroll で実行しているので大域的な変更は必要ない。

    実際にスクロールと言うか内容の移動が検出できたとしてどの様に移動を実施するのか。
    例えば DECSTBM DECSLRM が対応できていたとして SU, SD で移動すれば良いのだろうか。
    IL, DL を使った実装は xterm で期待通りに動かない。xterm では DECSLRM を無視して
    本当に行を挿入したり削除したりするからである。一方で、SU SD で本当に期待通りに動くのか
    については確認していないのでわからない。

  というか実際にそれを実装するとしても DECSTBM, DECSLRM を外側の端末が対応している
  という事を確定できなければ使うことができないのである。
  これの実装に関しては後で余裕があれば考える事にする。

  或いは DECCRA に関しても最後に実行した時の座標を記録しておくというので十分の気がする。
  複数回実行した時に関しては考えない事にする。

2019-04-21

* 資料

  DECCRA もしくは DECSLRM について
  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)

  SCOSC と DECSLRM のシーケンスの区別について
  [LeoNerd's programming thoughts: ANSI vs DEC, arbitrary scrolling in terminals](http://leonerds-code.blogspot.com/2012/03/ansi-vs-dec-arbitrary-scrolling-in.html)

  端末判定について
  [端末エミュレータマニアから見たMinEdの実装のヤバさ - Togetter](https://togetter.com/li/380509)

* sixel の振る舞いについて少し調べてみた。

  - RLogin では文字として表示されている気がする。
    ICH などでずれるし、上書きすればそのマス目だけが潰される。
    色々と画像の継ぎ接ぎができる。

  - 一方で、過去の twitter の議論を観察すると、
    実機では ICH などでずれない様だ? 直接 VRAM 上に置かれているという説だそうだ。

  - mintty の実装は何か変である。

    | mintty の場合には ICH ではずれない。
    | 描画範囲はずれない。というか色々微妙な動作をする。
    |
    | - ICH(3) すると何も変化は見えない。DCH(3) すると画像の末尾が欠ける。
    | - DCH(3)ICH(3) も ICH(3)DCH(3) も変化は齎さない。
    | - DL(2) すると画像範囲が小さくなるだけで画像の一部が削られたりとかはない。
    | - IL(2) してもやはり画像の表示領域が消えるだけで画像が二つに分かれるとかではない。
    |
    | ここから推測するに、mintty は sixel のマス目かどうかの情報を文字と同じ様に保持しているが、
    | 一方で、そのマス目に表示する内容は相対座標か何かで決定している。
    | ICH 等によってマス目が画像の範囲外に移動した時には何も表示しない。
    | 元画像への参照と元画像の原点 (?) の位置を保持している。
    | 然し、原点を保持するにしてもスクロールして画面の外に出てしまった場合に
    | どの様に処理しているのか不思議である。
    |
    | - DECSTBM して sixel を表示してみて分かったが、
    |   mintty では単にスクロールした回数を記録しているだけの気がする。
    |   スクロール範囲外の sixel 画像も一緒にスクロールしてしまうのが観察された。
    | 然し、mintty は画面上から流れて出ていった画像を見る為にスクロールすると
    | 何か描画が変である。画像が残ったり残らなかったりしている。

    まとめると、mintty では文字と同様にそれが sixel の升目かどうかを保持している。
    元の sixel 画像がどれかだけを参照していて、元の画像のどの部分かの情報は保持していない。
    一方で sixel 画像の側に現在の表示位置を保持している。
    sixel 画像の位置はスクロールを実行する度に更新される。
    SU は sixel 画像の位置を更新するが、RI や SD は更新しない。
    何故この様な中途半端な実装になっているのか分からない。

    実機を真似ているという事なのだろうか。。

  - xterm は RLogin と同様の実装になっている気がする。
    DL(3) や IL(3) も試してみたがやはり行と一緒に画像が切り貼りされる感じだ。

  どれが良いのかは分からないがデザインとして納得できるのは RLogin/xterm の方式である。
  従って、もし対応するのであれば RLogin/xterm の方式で考える事にする。
  但し、現在の実装では文字以外の物体を置く仕組みを整備していないので後で考える。

  文字以外の物体を置くとしてどの様に置くのが良いだろうか。つまり参照方法。

  a 例えば object id を以て参照するというのは以前のアイディアである。
    うーん。結局 object id を以て参照するというので良い気がしてきた。
    但し、各升目に対して object を配するのはコストが高い気もする。
  b 或いは、ポインタを保持するという手もある。
    ポインタをデータメンバとして追加すると更にメモリを食うようになる。
    フラグが立っている場合にはポインタを保持して、
    フラグが立っていない時には属性を保持するという様にする、
    という事も考えられるが実装が複雑になる。

  更に、メモリ管理はどの様にするのかが問題になる。

  a 以前は手動で inc/dec して管理していたがとても面倒だし、
    直ぐにミスしてメモリリークしそうである。
  b かと言って ctor/dtor/copy 等でカウントするのは
    それはそれでコストが高い様に思われる。
  c 或いは参照カウントは諦めて毎回メモリをコピーする事にするか。
    これはメモリ確保解放が増えるので重くなる。
    更に、それが必要かどうかを判定する必要があるので、
    結局参照カウント方式と比べて何か楽になる訳でもない。
  d もう一つの可能性は行ごとにリソースを管理して、
    行が消滅する時に一気に開放するという物である。
    これは単一行でずっと処理を繰り返した場合に
    どんどんメモリ使用量が増えてしまうという問題がある。
  e 或いは GC の様に時々 mark/sweep を実施するというのでも良いかもしれない。
    mark/sweep のタイミングは n 回メモリ確保をした時点で実施する、などにする。
    この時に root オブジェクトは何処にあるだろうか。
    各ページ・スクロールバッファ・代替画面などにある。
    他にスタックの上などに置いてあったりはしないだろうか…。
    まあ、そんなには難しくないような気がする。
    この方法は一つの手であると思われる。

2019-04-20

* ansi (get_cells_in_presentation): prop の場合の動作
  prop の場合にちゃんと動作するかどうにかについてテストしていない。

* ansi (get_cells_in_presentation): 振り仮名・sixelなどの埋め込まれたオブジェクト
  振り仮名だとかの marker は適切に開始・終了等の並び替えを実行する必要があるのではないか。

* observer: 描画中は一時的にカーソルを隠す
  これについては現在の端末のカーソルの状態と term_t のカーソルの状態を
  管理できる様にしてから実装する事にする。

* DA2 に対する応答_
  https://qiita.com/kefir_/items/0bda5e55f43392420d66

  現在の impl2 ではただ単に画面の内容を追跡しているだけで、
  画面を自前で描画している訳ではないので、
  DA2 に応答しても仕方がない。
  然し、今後の実装としてはちゃんと自前で描画できる様にしたい。
  その時にはちゃんと DA2 に対する応答を書き込まなければならない。
  書き込み先を設定できる様にする必要がある。

* 描画に関して

  後、描画に関してはどの様にするのが良いだろうか。
  以前の構想だと端末の内部状態の管理とは別に、
  observer を用意してそこから端末の内部状態の変化を調べて表示するという話だった。
  然し、本当にそれで大丈夫だろうか。内部状態の変化をどの様に検出するのかとか、
  或いは、効率的な内部状態変化の適用方法などがあったとしてそれを如何に実行するのか。

  出力先が端末かそれとも GUI かによっても色々取り扱いが異なってくるだろう。
  例えばスクロールだとかに関しては出力先がどちらであっても、
  できるだけスクロールとして実装したい様に思う。
  例えば、その為には行IDの様な物を保持しておいて、それを元に行を追跡する。

  在る範囲の属性の変更等に関しては GUI が出力先の場合には何れにしても全て再描画である。
  一方で、出力先が端末の場合には実は

  a "属性の変更" という操作を送信した方が早いのではないか。
    x 大量の出力があった時に描画を省略したい場合には、
      却って属性の変更という操作を送信する様にするのは、
      全てを出力することを要求する事になるので避けた方が良いのではないか。

  b 実際に画面が有限の大きさである事を考えると、全部再描画しても問題ない様な気もする。

  c "属性を変更した" というイベントを何処かに記録しておいてそれを使って何とか操作を送信するか。

  d term で属性を変更する直前に画面状態を更新しておいて、その上で属性を変更しつつ
    属性を変更する操作を observer にも送るという手もある。

  うーん。画面の大きさが有限である事などを考えると、まあ行内容の更新は、
  変化のあった部分について全て再描画というので問題ない気がする。
  念の為、文字の部分一致についても調べてできるだけ短いシーケンスになる様には努める。
  (然し、それでも速度の遅い端末では問題になる気がする。)

  しかしできるだけ短いシーケンスというのはどの様に決定したら良いのだろうか。
  つまり、文字をシフトした方が短いのか或いは普通に出力した方が早いのか。
  a これはシフト対象について連続する文字の数にもよるだろう。
    更に、潰される文字に関しては連続していると解釈しても良さそうだし、うーん。
  b 或いは、もう単純な場合にだけ短くなる様に工夫して、
    ある程度以上複雑な更新が必要になったら、フルに描画してしまう事にするか。
  c もっと細かく考えたら何か動的計画か何かで最短になるシーケンスを算出できるのだろうか。
    確かに競技プログラミングの問題に出てきそうではある。

* DECSTBM の影響範囲
  MC, DECMC は DECSTBM, DECPEX の影響を受けるそうだ。
  DECOM についてもちゃんと DECSTBM に対応する様にする必要がある。

2019-04-14

* ansi: うーん。ECMA-48 を見て思う事は、実は ECMA-48 及び ANSI は端末の規格というよりも、
  ワープロの様な物の規格の様に思われてくるという事である。
  フルに様々なオブジェクトを埋め込める様なそういうデータ形式が想定されている様な気がする。
  JFY (text-justification) だとか PTX (ふりがな) だとかを考えると、
  端末の機能として実装するのはかなり難しい様な気がしてくる。
  実際の所はどうなのだろうか…。

  思うに完全に実装しようとすると遅くなってしまうので現在の mono/prop の様に、
  更に上の段階として full 的な物を用意して、
  そのデータ形式に於いて様々な入れ子の構造などにも対応するという形が良いのかもしれない。

  | うーん。というか PTX 等で振り仮名を振っている時にも中でフルに
  | 文字列を作成したりフィールドを作成したり領域を作成したりする事は可能なのだろうか。
  | 或いはそういった機能は未定義という事なのだろうか。
  | 改めて規格を確認してみたが何も書かれていない。細かい Note は書かれているが、
  | どの様に表示されると考えられるかという例について説明されているに過ぎない。
  |
  | 改めてデータ部と表示部の説明を確認してみる。
  | 何処にもどの文字位置も同じ大きさを持つとは書かれていない。
  | 更に一行に含まれる文字の数についても触れられていない。
  | 行の高さが同じであるとも書かれていない。
  | そういう事を総合して考えると、これは端末の規格というよりは、
  | やはりワープロソフトもどきの装置の規格の様である。
  | 或いは、もう実際にその様に実装してしまうというのも手かもしれない。
  |
  | prop から full に昇格した時の整合性はあるのだろうか。
  | 例えば prop で処理している時には先に文字列の終端を挿入して
  | 後で文字列の開始を挿入したとしてもその瞬間のデータ部における
  | マーカの関係を考慮に入れて入れ子の状態を認識する様になっている。
  | つまり、prop では HTML のソースを弄る様な形で処理が行われる。
  |
  | 一方で、full に昇格して現在どの入れ子の中にいるのかという
  | 入れ子構造の木の中で挿入を行う仕組みにしてしまうと、
  | 先に文字列の終端を挿入してから後で文字列の開始を挿入する
  | と言った操作が困難になる。というか、文字列の開始を挿入した時点で
  | 木の構造を再構築しなければならなくなってしまう。
  |
  | 現在求められているのはどちらであろうか。
  | "データストリームの編集" と考えれば HTML のソースを弄る様に、
  | 一次元的なデータを編集する様にして、
  | その瞬間瞬間での解釈を用いて表示を行う事になる。
  | やはりそちらの方が自然である様に思われてきた。

  [結論] データ部では HTML を編集する様にしてデータストリームを編集すると解釈する。
  また、その時に文字の幅などは特別に解釈して右での折返しを実装できれば望ましい。

  さて、問題は、PTX の様な物の幅をどのように取り扱うかである。
  うーん。PTX が含まれる場合には計算する時の x 位置の幅を
  リセットするとかそういう事になるのだろうか。

  - その場合には実は _prop_glb, _prop_lub の定義を弄るだけで
    対応できてしまったりはしないだろうか。

  - 双方向文字列はどの様に処理すればよいだろうか。
    双方向文字列に関しては振り仮名の中はスキップする様にするのが良さそう。
    これは双方向文字列を処理するルーチンの修正が必要になる。
    しかし、それさえ修正してしまえば実は終わりなのでは?

    と安易に考えてはいるが実際に対応しようと考えると、様々な考察やテストが必要になる。
    或いは、もっと安全なデータ構造を考えた方が良いかもしれない。

* ansi (_bdsm_shift_cells): ECH/ERM
  現在の実装では ERM で protected な部分に関しては、
  方向文字列などの状態は復元せずに、そのままデータ部で
  保持する様に実装しているがこの実装は適切だろうか。

  ユーザからすると変な振る舞いに見えるのではないだろうか。
  然し一方で、境界上に protected/unprotected な物が混ざっていると、
  方向文字列などの復元をどの様にしたら良いのかが非自明となる。
  或いは、方向文字列に関連する marker だけは unprotected であっても残す様にするのか。
  そしてそれ以外の unprotected 零幅文字は削除するという仕様にするか。

2019-04-13

* DAQ に対応する。
  protected/guarded の属性に関しては描画属性で対応する事にする。
  然し、input だとか HT の設定だとかに関しては描画属性で対応する物かどうかは微妙である。
  実際の所、始まりと終わりの marker を保持しておいてその間を領域と解釈するべきなのではないか。

  然し、SPA EPA 等と混ざっていた時に EA などが認識する "領域" はどの様に解釈すれば良いだろうか。
  また、SPA, EPA 等は全ての行に亘って検索するべき気もする。うーん。

  結局、DAQ は SPA, EPA 等で終了するという様に決めておかないと駄目な気がする。
  その様に考えると属性も DAQ と SPA で共通にして良いのでは。とも思うが、
  まあ、両者が混在した場合などを考えるとやはり区別したほうが良いか。。

  思うに EA が認識する "領域" と、DAQ 及び SPA-EPA がそれぞれ自分で把握している "領域" は
  独立であっても良いのではないかという事。

* line (_bdsm_shift_cells): erase unprotected cells におけるテスト項目
  境界上の大きな文字に対する補正として、
  その大きな文字が特に3文字以上ある時に
  境界から左端・右端への距離が分からない。
  現在の実装では両方試す実装になっているが、
  実のところ3文字以上の大きな文字に未だ対応していないのでテストしていない。
  3文字以上の文字が現れた時にテストを追加するべきである。

2019-04-10

* どの段階で term.initialize_line(line) が適用されるべきか不明瞭である。
  一番最初に何らかの編集が行われる時?
  それとも一番最初にカーソルが移動した時?
  或いは一番最初に画面に現れた時?
  或いは初めてタブなどが実行されて情報が必要になった時かもしれない? うーん。

  cur.y に値を代入している箇所はそんなにないので
  そのタイミングで実行するので良い気がする。
  その行に移動しなくても何か編集作業が起こる事があるだろうか。
  そしてその様な時には initialize_line を実行するべきだろうか。

  また移動せずに編集作業が起こったとしてもその瞬間に適用する必要はないのかもしれない。
  そもそも SLL SLH は暗黙移動に関する物で HT もカーソルの移動に関する物である。
  従って、カーソルがその行に始めて移動した時に処理するというので良い気がしてきた。

* TSM for DL IL

* ERM for EA, ED, EF, EL
  - done: ECH については完了した。
  - done: 取り敢えず ED と EL についても対応した。動作確認はしていない。
  - EA, EF についてはそもそも現時点で実装されていない。

* SEE for DCH DL ICH IL

* DECSTBM は現在のページだけに影響を与えるのだろうか。
  それとも全てのページに対して影響を与えるのだろうか。
  これはページに対応する時に改めて調べる事にする。

* sequence: 制御列などは最大長さを設定しておくべきでは
* sequence: 中に規格外の文字列が入っても許容する設定があっても良いのでは

2019-04-08

* ansi: 思ったのだが marker と通常の文字を区別する意味はあるのだろうか。
  表示する時に出力されるかどうか?
  文字幅が0かどうかの違いしか無い様な気がする…。
  例えば bidi の制御文字に関して考えると、
  正しくレンダリングされる為にはやはり制御文字も一緒に表示する必要がある。
  という事などを考えるとやはり通常の文字として埋め込んでしまう方が良いのでは…。

* ansi: 結合文字について
  やはり screen と Poderosa で振る舞いが異なる。
  というか UTF-8 ではない文字列が送られてくる様になる。

* attribute だとか character の拡張機能はどの様に処理するべきか。

  * 拡張オブジェクトの寿命管理はどの様にするのが良いか

    | attribute や character のコピーコンストラクタ等に処理を追加してしまう事にするか。
    | そうすると書き込みや読み込みなどの際に毎回チェックが入る事になり重い気がする。
    | 勿論、殆どの場合には拡張はないので if でフラグを検査するだけではある。
    |
    | 或いは、cell の側にオブジェクトなどを保持する為のポインタを設置するべきか。
    | 特に文字に関してはそちらの方が良い様な気もする。
    | "文字" というスカラー値でオブジェクトを運搬できる様にする必要性など実はないのである。
    | 然し、そういったオブジェクトの寿命は誰が管理するのだろうか。
    | 特に複数のセルで使い回されている時にどうするのか。
    |
    | 様々の事を考えると実は character に持たせるのではなくて
    | セル側に持たせるほうが自然に思われてくる。
    | 然し、一方で巨大な attribute をコピーする理由は何だろう。
    | attribute はそう頻繁に変更する物でもないし、
    | コピーして持ち回るほうが普通なのではないか。
    | Poderosa の場合には GC があるので自由にコピーして良かった。
    | C++ で実装する時にはどうするのが良いか。
    | よく考えたら C# で GC に頼っているのであれば、
    | C++ でも同様に実装しても良いのではないか。
    | つまり、"時々" 全体をスキャンして使われていなない属性を破棄するという事。
    | しかし、時々というのはどのタイミングだろうか。
    | 更に sixel 等の巨大なオブジェクトの場合には時々ではなくて、
    | やはり消滅する時にちゃんと始末しておきたい所である。
    | うーん。何とか全体をスキャンするコストを抑えつつ、
    | 参照カウントの更新の様な煩わしさを避けつつ、
    | という様にする事はできないだろうか。
    |
    | 例えば、画面の見える領域に関しては全体をスキャンする事にして、
    | そしてそれ以外の領域に関しては参照カウントで対処する等。
    | うーん。それが良いような気がする。
    | 画面の見える領域に関しては root オブジェクトとして取り扱う。
    | 画面から出ていった領域に関しては行を登録する時と、
    |
    | 行を削除する時に参照カウントを更新する事にする。
    | 以前の取り扱いよりも更に複雑になった気がしないでもないが、
    | まあ、この様にする位が高速で良いのだろうという気がする。

    画面の見える領域については参照カウントはしない。
    GC をする時に全体をスキャンして使われているかどうかを判定する。
    画面から出ていった部分については参照カウントを実行する。
    つまり、画面外 buffer に行を移動する時に inc して、
    画面外 buffer から行を削除する時に dec する。
    基本的に画面外 buffer に含まれる行は二度と編集が起きないという事は仮定する。

    ページ等に関しては退避する時に参照カウントを inc して、
    また復帰する時に dec する事にすれば良い。
    GC は一定の回数 attribute を生成する毎に実行する。
    大きなオブジェクトに関してはその都度チェックを実施すれば良い。

  * attribute に拡張属性を使用するか

    | 今 attribute は 4 bytes である。
    | extended attributes は 16 bytes ある。
    | 実はそんなにけちる程の物でもないかもしれないが、
    | 将来的に拡張する事なども考えるとやはり拡張性を持たせる?
    | 16 bytes あっても普通は使わないのである。と思ったが、
    | 最近では full color 対応なども出てきた。
    | そう考えると full color の為の 8 bytes はやはりあった方が良いのだろうか。
    | xattr に関してはそんなに使う頻度が高いとは思われないが、
    | しかし contra が広まるなどして拡張属性が広まれば
    | やはり使われる様になるかもしれない。
    | 文字を書き込む度に 16 bytes のコピーを何度も実施するのは微妙な気もするが、
    | しかし、うーん。現状で既に文字を書き込む度に物凄く色々な処理をしている。
    | 文字幅のテーブルを引いて、それから踏み潰される全角文字がないか確認して、
    | その上で書き込みを実施するのである。16 bytes のコピーをけちる所ではない。
    | 或いは、ASCII のみしか存在していない状況で最適化した実装をする事ができるだろうか。
    | 何れにしても 16 bytes (4 fields) のコピー程度は何の事はないだろう。

    16 bytes は文字の書き込み時に行っている処理の複雑さを考えれば
    大した手間とはならない (それを言い出すと拡張フラグのチェックも大した手間ではないが)。
    データサイズ的にはそんなに大きな物ではない。
    例えば 200字x10000行x16bytes = 32MB である。うーん。結構ある…。
    char 4B width 4B attr 16B だと 48MB であり、
    char 4B width 4B attr 4B だと 24MB である。2倍位の差になる。

    c 或いは画面から流れた内容を何らかの方法で圧縮して
      保持する方法などあるだろうか…。ANSI seq に変換して記録する等。
      然し、それはそれで複雑な行内容だった場合に困難が生じるし、
      複雑なオブジェクトがある場合には何れにしても困る。

    d 画面から流れた内容はファイルに書き出してしまっても良いのかもしれない。
      と思ったが、その時には拡張属性等はどう管理したら良いだろうか…。
      ファイルの中に領域を作るのも変だし、拡張属性・拡張オブジェクトだけ
      メモリ上に保持するというのも片手落ちな気がする。
      更にファイルに記録するとすると、そのファイルのインデックス等も
      管理しなければならない。ファイル内のどの位置が何行目に対応しているかという。

      然し、ECMA 48 の書き方を考えると画面から出て行った内容に対して、
      この様にファイルに書き出す機能という物があっても良い様には思う。
      それを画像として出力するのか、テキストファイルとして出力するのか、
      或いは、ASCII seq を含んだファイルとして出力するのかは色々。
      HTML にして出力してしまうという手もあるのではないか。
      sixel 部分に関しては適当に画像に変換してセルごとに保存してしまう。
      うーん。オブジェクトは確かに画面の外に出た瞬間に
      画像として残すだけで良い気がしてきた。

      一方で、昨今の Web インターフェイスの様な物を考えると、
      実は端末上でも領域に id でもつけて対話的な事ができるようにしても良いのでは、
      そしてスクロールして色々な情報を見られる様にして良いのではないか、
      等と考えないでもないが、まあその様な機能を実装したとして広まらないし、
      やはりやっても余り意味が無いような気がするので考えても仕方がない。

      本気でなにか広めるのだとしたら新しい OS でも作って、
      標準のターミナルでそういう面白い機能をふんだんに使った
      アプリケーションを提供する等しなければならない。
      しかし、余り複雑だとそれに追随するソフトウェアが現れないし難しい所である。
      精々ボタンを設置して、そのボタンが押された時に受信されるシーケンスを設定する位である。
      或いは terminfo に代わる様なライブラリを提供するか。

* [暫定実装] ansi: c2w の実装は中途半端な物である。
  結合文字などの文字幅 0 の文字の事を考慮に入れていない。
* [暫定実装] ansi: utf8_decode の実装も中途半端である。
  これは別の encoding の場合も考慮に入れて
  インターフェイスを考えておく必要がある。
  使う側もそれに合わせて実装する必要がある。

2019-04-05

* bidi: 情報を収集していたら余計によく分からなくなった。

  Unicode には bidi 関連の機能を制御する文字がある。
  それだけでなく文字の種類によって自然な文字の方向というのが存在して、
  アラビア文字等の場合には特に制御をしなくても勝手に文字の方向が決まる。

  contra の内部実装ではデータ部での論理配置を軸にして、
  表示上の移動などにも対応する事になる。
  表示部での操作を実装する為には、対応するデータ部での配置に変換できなければならない。
  その変換を実行するために必要なデータ構造は何だろうか。
  また、データ部・表示部における様々な操作に対してそのデータ構造を更新する必要がある。

  アラビア文字を挿入する度に周囲のアラビア文字との結合を考えるのは面倒である。
  従って、データ部・表示部の変換を実行する度に、
  行内にどの様な種類の文字が存在してどの様な配置になるのかという事を計算するのか。
  或いは、文字配置に関連するデータをキャッシュしても良い。
  或いは、やはり文字を挿入する度にそう言ったデータを管理する様にするのか。

  そしてマーカはやはり文字列としてデータ部の中に埋め込む形にするのが良いだろうか。
  その場合にはデータ部における明示的移動でマーカをどの様に設置することにするのか。
  文字を新しく挿入するとその右にあるマーカは削除する事になる。
  現在の実装のアイディアはこれに基づいている気がする。

  - 属性化領域(DAQ)・選択領域(SSA, ESA)・保護領域(SPA, EPA)
    これらはデータ部・表示部の変換に影響しない。
    従って独立に管理するのが良いのではないだろうか。
    また ECMA-48 に従うと表示部に対する範囲指定だが、
    用途を考えるとデータ部に対する範囲指定と考える方が良いのではないか。

    ECMAによると SDS, SRS の内部でこれらを設定する事はできない。
    然し、実際の端末ではそういった入力を受け取る可能性を排除できない。
    これらはその位置における SDS, SRS を解除すると見做す事にする。
    然し、その様に解釈すると DAQ, SSA, ESA 等のマーカーも全て
    記録しなければならないのではないだろうか…。

  - 方向付き文字列(SDS)・反転文字列(SRS)
    これらはマーカとして埋め込む。対応はその場その場で構築する。
    変なマーカの配置の仕方をしていてもちゃんとそれっぽく解釈する。
    折返しが起こる場合には一旦方向付き文字列を閉じて、
    改行してから再び同じ入れ子状態に復元する。

  - タブ(HT)
    これは事前に設定されているタブストップの位置と、
    実際にタブによって移動した時に起こるタブの確立を区別するべき。
    そして実際にタブで動いた時に起こるタブはまた内部に記録される。
    実際に発生したタブについて実は TCC を考えると
    文字も記録しなければならないのではないだろうか。
    うーん。従って現在の形式はやはり何か限界があるという気がする。

  うーん。簡単なプロトタイプ実装でも作って考えてみる事にする。
  UAX #9 を確認してみる。思いの外複雑である。
  というか先に UAX#9 を実装してから考えるのが良さそう。
  UAX#9 の為に一から作り直しになるのは面倒である。

  UAX#9 の要点をまとめつつ読んでいく。X1 の規則が滅茶苦茶長い。
  うーん。然し…これに従って並び替えた後に
  表示部での消去を実装するとどう振る舞うべきなのだろうか…。
  この様な複雑な処理を経ると最終的にどの様に切断したら
  見た目を変化させずに消去する事ができるのかという事を判定できない…。
  或いは表示部で範囲を決定するだけで、実際の消去はデータ部で実行して良いのだろうか。

  % UAX#9 の UBA の overflow_isolate_count と
  % overflow_embedding_count の取扱はこれで良いのか。
  % 例えば max_depth = 124 の時 LRI に失敗してその後に RLE に成功する事がある。
  % この時 oic = 1, oec = 0 になる。PDF が来るとそのまま処理される。
  % PDI が来ると oic-- して oec はそのままである。
  % 或いは max_depth = 124 の時 LRE に失敗してその後に LRI に成功したとする。
  % この時 vic = 1, oic = 0, oec = 1 になる。
  % PDI が来ると、vic=0,oic=0,oec=0 になってしまう。
  % そして PDF が来ると駄目になる気がする。
  →と思ったが、よく文章を読んでみると oic || oec の時必ず失敗する事になっている。
    従って失敗した後それが pop されるまでは成功する事はあり得ない。

  取り敢えず UAX#9 の実装を試みる事にする。

2016-10-19

* 方向付き文字列の対応
  - HT によるマーカの挿入
  - 各種テストの実装
  - マーカ個数の最大数を設定

2016-10-10

* ページについて。

  ページ関連の機能については一体どの様に実装するのが良いのかと悩んでいたが、
  RLogin のエスケープシーケンスを眺めていた所 RLogin はページに対応している事に気づいた。
  (もしかして xterm なんかも実装しているのだろうかと思って試してみたが実装していない様だ。
  mintty, screen, Poderosa も実装していない。)

  # 特に気になっていたのは画面の上端から流れて出ていった内容をある一定の長さで区切ってページとするべきなのか、
  # 或いはそれどころか画面内である一定の行数毎に区切ってページとするべきなのかという事であった。
  # それよりは画面内はやはりずっと同じページだし、
  # 上端から流れて出ていった内容もやはり同じページにあると考えた方が自然な気もした。
  # しかしそれだと他のページの内容を確認しにくいし、
  # SPH で設定した行は画面内の行ではなくて流れていった内容に含まれる行なのかなど色々わからない。

  RLogin の実装を見てみた所、ページは恐らく見えている範囲が 1 ページになっていて、
  各ページは altscreen と同様に差し替えられるという仕組みになっている様だ。
  上端から流れていった内容は別にページの一部とは考えれていない。
  ページの視点からは上端から流れて出ていった内容は飽くまで失われた内容という事である。

  結局、既存の実装があるのだからこれに従うのが良さそうだし、
  何よりなんとなくこの実装がそれ自体設計として良さそうに思われる。
  が、保険のためもう少しこの実装の声質について考えてみる。

  | なるほど確かに考えてみれば display で見えている範囲というのが丁度カーソルによって移動できる範囲であり、
  | それがプリンタに於ける一枚の紙とみなすのは自然である。そして上端から流れていった内容は、
  | 単に端末の追加機能として記録している物に過ぎず、端末の制御下にあるものではないと考える。
  |
  | と思ったがロール紙 (?) の様なのに印刷している場合はどうなんだろう。その場合には上端から流れていった内容も
  | やはり移動の対象としても良いような気がする。何よりページの移動というのは実際の印刷機では
  | 一体どのような動作に対応するのだろうというのが気になる。特にページを戻るというのは何だろう。
  | 普通のプリンタでは一度出力した紙はトレーに落ちて機械的に自動的に戻したりする事はできない。
  | そういう事を考えると一連の長いロール紙にページという単位の区切りを用意して前にスクロールしたり、
  | 後ろにスクロールしたりする事でページを移動するという風にデザインする事も可能である。
  |
  | そして規格の意図していることとは独立に、アプリケーションから見た時の、
  | 端末機能としての利便性という観点からも考えたほうが良いかもしれない。
  | そういう観点だとページの機能というのは、複数ある画面を切り替えるものとして実装するととても便利そうである。
  | 一つの画面の中に勝手にページ区切りができたりという風な設計だと使いにくいし、
  | また、手動でページ区切りを挿入するのだとしても別に便利だとは思われない。
  | そんなのはアプリケーション内で独自に別の管理の仕方をした方が楽に決まっている。
  | そういう意味で実装して意味のある機能か、という観点から言っても RLogin の実装は合理的である。
  |
  | また上端から出ていった内容に関しては、データの管理の観点から言って
  | 其処にカーソルを戻す事ができる様な設計になっているのは面倒である。
  | というか現在の実装を大きく書き換えなければならなくなり面倒である。
  | もしそれに対応するのだとしたら上端から流れていった内容に関しても、
  | ディスプレイの続きとして同じ配列の中で管理しなければならなくなるし、
  | そうするとメモリ効率などの点から行っても余り嬉しくない。
  | そもそも上端から流れて出ていった内容を確認する頻度というのは、
  | 画面内に文字を出力する頻度と比べれば小さい物だし、
  | どこかに掃き溜めの様に集めておくだけで良いのである。
  |
  | 一つの懸念は FF である。FF は規格どおりに実装するのだとしたら
  | 次のページに移動して SPH に移動するという物である。
  | (page or form と書かれているから頁ではなくフォームでも良いのかもしれない。
  | しかし form とは何だろう。実質 page と同じに扱って良い気がする。)
  | この実装だと、誤って FF を出力した場合に混乱を来す事になる。
  | 次のページに進むことによって今まで表示されていた内容が見えなくなるからである。
  | しかし混乱を来すとは言っても再描画すれば済むことだしそんなに致命的でない気もする。
  | 誤ってではなく意図的に FF を出力する様なプログラムも、LF や VT がある事を考えれば、ないだろう。
  | そう考えれば FF は本当に次の頁に移ってしまうという実装で良い気がする。
  | 一応 FF で LF と同じ動作になる様にできるオプションも付けておくのが良いだろう。
  | # 所で、複数のページがある時に現在のページ番号を表示する様にしても良い。
  |
  | もう一つの懸念は幾らでもページを追加できる様にするのかという事である。
  | 例えば FF だとか PPR を延々と吐き出すプログラムを作った時に
  | 端末はどの様に応答するべきかという事である。
  | 上端から流れていった内容に関しては通常は最大の行数を指定する事ができて、
  | それより沢山の行を出力する場合には順次ローテーとして古い行から消えていく。
  | しかしページの場合には PPA を用いてページ番号を明示的に指定して移動する事ができるので、
  | 古い物から順に消していくという作戦も使えない。或いは、その様に実装して
  | 消えたページに戻った時には空の内容を表示するという風にしたとしても、
  | 実際にいざ移動した時に新しく確保したメモリは配列にどの様に格納するのかという問題が生じる。
  | 勿論スパースな配列を実装して其処に記録するというのでも良いのかもしれないが、
  | それもまた変な実装である。何より使う側からすると謎の挙動に見えて分かりづらいだろう。
  | だとすると予めページ数に上限を加えるというのが現実的な解になるだろう。
  | とここまで考えて RLogin の実装はどうなっているのかというのを確認してみる事にする。
  | もし上限があれば何処かで止まるか、あるいはエラーになるかするし、
  | 上限がないのだとしたらメモリがどんどん増えていくというのを観察できるはずだ。
  |
  | $ for f in {0..10000}; do printf $'\e[ Qhello'$f'\n'; done
  |
  | 結果 RLogin の最大ページ数は 100 という事が分かった。最大ページ番号まで行くと、
  | それより次に行こうとしても何も起こらなくなる (※カーソル位置も動かない)。
  | もしかして設定項目に最大ページ数があるのかもしれないと思って確認してみたが、
  | [スクロールバックできるヒストリー行数] は設定できてもページ数は設定できない様だ。
  | しかし、[通信ログ] の項目に PAGE が云々と書かれているのでやはりページを意識した設計になっている。
  |
  | 更に RLogin のページを見ていると DECRQDE DECCRA DECRQCRA でページについて言及がある。
  | つまり、VT系列の端末ではページに対応していたと考えられ、
  | だとすると RLogin のページに関する動作は VT互換な物であると期待できる。
  | 従って、やはり RLogin の真似をして実装するしか無いだろう。
  |
  | 他に NP PP という機能がある。ECMA に従うと n-th following/preceding page to be displlayed
  | と書かれている。表示されるだけというのはどういう事だろう。
  | また active presentation position の変化は定義されないと書かれている。
  | 一方で RLogin の実装では上端から流れた内容を一時的に表示する
  | (というかスクロールバーの位置を変更する) 様になっている。
  | 現在位置は変化せず、次に最新の内容に変化があった時にはまたもとの画面に戻る。
  | つまり、PPA PPR PPB で操作される "page" と、NP PP で操作される "page" は異なるという事になる。
  |
  | ECMA-48 にも色々書かれている事が分かった。
  | - ED が ECMA では ERASE IN PAGE になっている事から、
  |   やはり page は ED の対象の範囲と同一であるべきで、
  |   だとすれば現在の page というのは現在表示されている範囲の事だと思うべきである。
  |   (ただ、これだけだと現在のページ以外のページがどういう形態を持つのか、つまり、
  |   上端から流れたデータをも含むのか、それとも別のバッファとして記録するのかは不明である)。
  | - 更に QUAD JFY に関する補足が ECMA-48 の付録にあって其処では、
  |   a display device with a multiple-page buffer では云々と書かれている。
  |   つまり page を扱える為にはそれ専用の特別のバッファを持っていると想定できる。
  |   ただ単に上端から流れていく情報を溜めておく装置は multiple-page buffer とは言い難いし、
  |   上端から流れていく情報を一定の行数毎に区切って移動できる様にしただけの物に
  |   新しく multiple-page buffer と名前をつけてそれを display device の特徴の一つとして挙げるのも変である。
  |   そういう事を考えれば、やはり規格的にも page というのは RLogin が実装している様に、
  |   それ専用の buffer に割り当てられる領域とするのが自然であろう。
  | - もっと ECMA-48 を見てみるとちゃんと [ECMA-48/6.3/3] に page について書かれている。
  |   また、[ECMA-48/6/2] にも書かれている。所で気になるのは、行は predetermined number of character positions
  |   からなると書かれている一方で、ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている事である。
  |   これについてはまた別に項目を立てて考察を行う事にする。

  [まとめ]

  - アプリケーションから見た時の利便性の観点からも RLogin と同様の実装が支持される。
  - DECRQDE DECCRA DECRQCRA などの存在から VT 端末も RLogin と同じ動作だろうと期待できる。
  - ECMA-48 的にも ED や Annex C の記述から、page 専用の buffer を持つディスプレイ装置が想定される。
  - NP PP は ECMA-48 的には一時的に他のページを表示するもの (?) の様だが、RLogin は上端から流れた内容を表示する。

  - PPA PPR PPB NP PP に関しては全面的に RLogin と同様に実装する。
  - FF はオプションで LF と同じか次のページに行くかを選べる様にする。
  - 頁数の上限を設定できる様にする。


  関連する制御機能を整理しておく。

  SPH SPL FF PFS
  PPA PPR PPB NP PP
  他にも未だあったような気がする…→ SEF だ。

  | * [2016-10-05] SPH/SPL の効果について
  |
  |   FF 及び implicit movement それから
  |   active presentation position does not normally go
  |   beyond the page limit position というのを実装する。
  |
  |   しかし、そもそも頁の概念を端末上でどの様に実装するべきかが明確でない。
  |   その他の頁を制御する制御機能の説明を調べて、
  |   その上で適切な頁の概念の再現方法を考える事にしたい。
  |
  |   また SLH/SLL と同様に頁毎に home/limit
  |   の値を設定する事ができるかどうか考察する。

  これに関しては行の属性と同様に、
  各ページに SPH, SPL を保持する様にする。
  同時に "現在の既定の SPH, SPL" も保持する。

2016-10-08

* emacs だとかのアプリケーションを動作させるだけであれば、
  terminfo のエントリにある物だけ対応しておけば実は十分という事に気付く。
  一々起動してどの様なシーケンスを送ってくるかを調べる必要はないのだ。

  infocmp xterm を見てみると意外と沢山ある。
  しかしキーシーケンスも多いのでどれが制御機能かぱっと見て分からない。
  後で terminfo の entries についても纏める必要があるだろう。

  序で infocmp ansi を見ると大分すっきりしている。
  というかキーシーケンスが全然ない。考えてみれば当然だ。
  ANSI 規格は制御機能しか定義していなくてキーボードは定義していないからだ。
  また、気になるのは ANSI 規格で処理系定義とされている機能についてだ。
  例えば xenl は infocmp ansi では書かれていないが、
  別に xenl でもそうでなくても ANSI 規格準拠の筈だ。
  後、altcharset (acsc) に普通に非 7 bit 文字が記述されているが、
  これらを utf-8 の環境で使うと何が起こるのか気になる。
  (ncursesw はちゃんと encode してから送信するのだろうか?)

* DECDWL, DECDHL の動作に関して。

  DECDWL, DECDHL, DECSWL は VT510 のページに記述がある。
  これらは行に対する属性として動作する。
  しかしこれらの属性を持つ行に関してカーソルの移動はどの様に働くのだろう。

  xterm, RLogin, mintty が対応していたので動作を観察してみる。

  - VT510 の DECDWL の説明によると元から行に存在していた
    内容の右半分は失われると書かれている。

  - xterm は DECDWL を設定した行であっても表示が二倍の幅になっているだけで、
    一行に収める事のできる文字の数は変化しない様である。
    つまり、画面の右端に行ってもその場では折り返されず、
    行の右半分だけが表示されないという動作になる。
    そして画面の右端に行って隠れた文字列はちゃんと記録されていて、
    \e#5 で行の文字の幅を元に戻すと画面の右端に行って隠れた文字列が戻ってくる。

    また、カーソル移動に関しては \e[C もしくは \e[D で移動すると、
    二倍の距離移動する様になる。つまり、文字数で移動する。
    (因みにカーソルの下に全角文字がある場合に \e[D しても半角分しか移動しない。)

    DECDWL の行で 4 文字目 (つまり7列目) にカーソルがある場合、
    \e[A で上に移動すると他の行の 4 文字目 (4列目) にカーソルが移動する。
    見た目に合わせて 7 列目にカーソルを移動する等という動作はしない様である。
    (ECMA-48 は presentation component での見たままの上下左右の移動に拘っている様なので、
    ECMA-48 を標準化している様な人からすれば \e[A は見た目の通りに 7 列目にするべきと考えるだろう。)

    DECDWL した瞬間にカーソルの位置が変わるかどうかも興味深い。
    xterm の実装では DECDWL した瞬間にカーソル位置は表示上右に2倍の位置に移動する。
    文字データの観点から言うと、DECDWL する前と後で指している文字は変わらない。

    結局のところ xterm の DECDWL, DECDHL の対応はただ単に "表示する時に横幅を二倍にしているだけ" であって、
    実際の端末の処理としては全然幅を認識していないという事になる。

  - mintty は xterm の動作を模倣している。

  - RLogin の場合には画面の見た目で行折り返しが起こる。
    つまり、DECDWL の行では半分しか文字を出力できない。
    然しながら、一旦行内を埋めてから DECDWL してそれから DECSWL をすると、
    また内容が戻ってくる。つまり、SLL を一時的に半分の位置に設定しているだけで、
    実際の内部的な表現としてはやはり一文字一セルで記録している物と思われる。

    面白い振る舞いとしては一旦行内を半分以上埋めて DECDWL をしてカーソルが画面外に出た状態で
    何か文字を出力すると、1文字目は何処にも出力されず、2文字目は行折り返しが起こって
    次の行に表示されるという事である。
    思うに RLogin は現在のカーソル位置が範囲外にあるかどうかをカーソルが移動した時に
    判定して記録しているのだろう。なので、カーソルが移動した後に設定が変わってカーソル位置がはみ出ても
    それを認識せずに文字を置こうとして失敗して、その後でカーソルを移動した時にようやく
    現在位置が範囲外であったという事に気づいて行折り返しを行うというそういう動作になっているのだろうと思う。

    カーソル移動については xterm と全く同じである。\e[C \e[D は2列ずつ移動するし、
    また \e[A \e[B すると前後の行の同じ列ではなく同じ文字番号の場所に移動する。

    所で DECDWL/DECDHL と sixel を組み合わせるとどうなるかを見てみた所、
    sixel の絵も横に二倍に引き伸ばされて表示される様である。
    序に DCH や DL も試してみたがちゃんと画像の一部が削除される様だ。
    これらの動作についてはまた後で様々の実装の間で比較する必要がありそうだ。

  結局、これらの実装が本当に VT の実機と同様なのかは怪しい。
  何れの実装でも行の右半分のデータを保持している。
  一方で、わざわざ VT の説明に行の右半分のデータは discard すると書かれている。
  これは、VT の実装では単に表示を二倍にしているのではなくて、
  丁度表示位置に対応するセルにデータを記録しているという事の気がする。
  だとするとカーソル移動は見た目での列に従って起こるべきだし、
  また行の内容が保持されたり折り返しがなかなか起こらなかったりという事もないのではないか。

2016-10-05

* RIS

  xterm ,screen, mintty はちゃんと表示内容も消去する。
  RLogin は RIS をしても表示内容を消去しない。
  Poderosa はそもそも RIS に対応していない。

* 基本的な移動機能その他

  > CUU CUD CUB CUF (現在位置・上下左右)
  > HPA HPB HPR VPA VPB VPR (記憶位置・行列)
  > CHA CNL CPL (行列)
  CPR
  DCH ICH ECH DL IL EL ED

* RI は一度消えた行ではなくて新しい行を挿入している @ screen
  RI IND

* Poderosa IL bug
  →バグ特定については 2016-10-12 を参照。

* http://invisible-island.net/vttest/

2016-10-04

* 本当に行毎に SLL/SLH の値を保持するべきなのか。

  subsequent lines と書かれているが、
  CUU 等で戻ってから上書きする場合には適用されないのか。
  また ED で erased state にされた行に設定されていた home/limit は消去するべきなのか。

  他に "以降の行" に適用される様な状態はあっただろうか。
  それらの機能の自然な動作も考慮に入れて考える。
  例えば SCP が以降の行に対して適用される物である。
  SCP の説明では現在行の内容の更新方法については述べているが、
  以降の行についての更新方法については述べていない。
  - 既に出力された行に再度移動して其処に新しく何かを書き込んだ時に、
    突然表示方法が変化するというのも変である。
    或いは、既に出力された行に移動した瞬間に変化するというのも変である。
    だとすれば、SCP が適用されるのは本当に新しく作った行に対してのみであるべきである。
    或いは LF もしくは NEL によって移動した時にのみ SCP を更新するというのも考えられるかもしれないが、
    しかしそれでも LF を単なる移動に使うという場合も考えられるし、やはり表示方法が突然変化するというのは変である。
  - ED によって空にした行については SCP はどう働くべきだろうか。
    ED によって空にした行についてはそれが新しい行であるかのように動作して欲しい。
    以前其処にあった方向性が残っているというのはおかしいからである。
    例えば中身が全て erased になっている行に限っては SCP の方向性が新しく適用されるというのはどうだろうか。
    しかし、それも不自然な気がする。周りの行が新しい SCP に影響されていないのに、間にある行だけ影響を受けるというのも変である。
    という事は、行自体に "この行は新しい行である" かどうかを保持するデータをつけておくべきだろうか。
    そして新しい行であった時に限って、現在の SCP をその行に適用し、"新しい行ではない" という様に書き換える。
  - では書き換えるタイミングは何であろう。例えば、一番初めに文字を書き込んだときであるべきか。
    それともカーソルを移動させた瞬間であるべきか。
    カーソルを一気に動かした場合にはどうするべきか。
    カーソルを一気に動かした場合にはスキップされた間の行にまで値が適用されるのは変な気がする。
    という事はカーソルを一気に動かした場合にはあいだの行には SCP は適用しないとする。
    そして、カーソルを一気に動かした場合と一歩ずつ動かした場合で同じ動作になって欲しいという事を考えると、
    結局カーソルの移動だけでは新しい行に属性を適用するには至らないという風にした方が良い気がする。
    つまり、行に対して具体的に何らかの変更が適用される時に初めて行の属性を適用するという風にする。

  さて SCP がこの様な動作をしている時に SLL/SLH はどの様に動作するべきか。
  カーソルを移動して前の場所に戻った時に、現在の SLL/SLH を用いて動作する方が良いか、
  それとも行が生成された時の SLL/SLH を用いて動作する方が良いか。

  % 普通に考えると現在の SLL/SLH を用いて動作したい所だが、
  % 一方で SCP での "以降の行" というのは新しく生成した行に対してのみ適用する事に決めた。
  % この時 SLL/SLH での "以降の行" を別の意味に解釈するのも変である。
  % もう少し考えてみる。SLL/SLH は行を生成した時の値を用いるという動作の方が自然に思われる様な例があるかもしれない。
  %
  % % 例えば、SCP で character path が反転している様な場合はどうだろう。
  % % DCSM(PRESENTATION) の場合には見た目によって位置が決まる。
  % % →しかし、よく考えてみたら SCP は表示部での character path つまり文字位置の番号自体を反転させるのであって、
  % %   記憶部と表示部の列番号の対応関係に影響を与える物ではない。
  % %   そして SCP の異なる行を跨った場合には、例え DCSM(PRESENTATION) であっても、
  % %   見た目に左右が反転している事を考慮に入れて表示部での列番号を移動するのではなく、
  % %   飽くまで表示部での列番号は保持したままで実際の位置は左右反転するという事になる気がする。
  %
  % うーん。でもやはり SCP での "以降の行 (subsequent lines)" との整合性から考えて、
  % SLL/SLH で設定される境界についても各行で保持して、
  % 新しい行に対してのみ現在の設定を適用するという様にするべきな気がする。

  →改めて規格を見てみると SCP の "以降の行 (subsequent lines)" は SCP の説明にしか出てこない。
    一方で、SLL/SLH の "以降の行 (lines of subsequnet line)" は TAB の設定などで複数回出てくる。
    さて、もし SLL/SLH を SCP と同様に各行で定義するとすると、
    整合性から考えて tab stop 等も全て行毎に管理しなければならなくなる。
    それは面倒であるし効率が悪そうな気がする。
    だとすれば、やはり SLL/SLH については共通の設定を一つ何処かに持っておいて、
    行毎には記録しないように変更するべきか。

  [結論]

  - 行には新しい行かそうではないかを識別するための属性をつける。
  - 新しい行に初めて文字などの書き込みを実行する時に、属性を適用する。
    また LF や NEL を実行した際にも属性を適用する。
    後 CR の直前にも実行しなければならない。というか LF の代わりに CR で実行するべき?
  - ED 等の消去関数を用いた場合には空になった行は新しい行としてマークする。

  これらについてはタブ関連の機能について調べてからで良いだろう。
  タブ関連の機能を見て、行毎に tab stop を管理しなければならなそうであれば、
  SLL/SLH も含めて行毎に管理をする様にする。
  もしタブは全ての行について共有なのだとすれば SLL/SLH もその様にする。
  →どうもタブ関連の機能は TSM で動作を切り替えられる様である。
    しかし TSM に影響されずに動作する DAQ(7) 等の機能も存在する。
    つまり基本的に character tab stop は行毎に管理して、
    但し、TSM = MULTIPLE の場合には特定の制御機能は
    全ての既存の行に対して作用するという事らしい。
    全体で共通の tab stop を管理するという様な事ではない様だ。

2016-09-25

* 各機能のテストコードを書く必要がある。

* BEL/HT/VT の正しい実装

* cell で毎回セルのアドレスを計算して取得するのではなくて、
  window.cur に現在のセル、もしくは現在の行へのポインタを保持した方が
  効率が良いのではないか。

2016-09-24

* planned programs

  - terminal multiplexer
  - terminal with graphical user interface
  - screen の様に複雑なことをする物が最終目的の一つだが、
    一方で、cygterm の様に他のプログラムとの仲介を行う物もあった方が良い。
    何かの折にそのようなシンプルな物が欲しくなることがあるだろうからである。

* ポーリングを O_NONBLOCK でやって sleep するのはやはり良くない?

  とはいいつつ入力と出力の両方を監視しなければならないので結局
  timeout を設定して交互に確認することになるので結局同じかもしれない。
  いや、然し同時に複数のオブジェクトを待つという種類の同期の方法が
  提供されていても良いはずだ。

  これについては今の所は致命的な問題になっていないので対処しない。
  後で余裕が出てきた時に正しい方法を模索する事にすれば良い。

2016-09-23

* PLD/PLU/SGR 10-19 の出力を実装する

* SGR 60-69 の実装方法について決める

  同時に複数の属性を on にできるのかそうでないのか。
  或いは出力先のターミナルに応じて処理を変えるべきか否か。

2016-09-22

* ルビ?

  ANSI や Unicode にルビの機能があるようである。面倒である。

  - ANSI に PTX という物がある。これはルビのための制御機能に見える。
    「CSI 1 \ 漢字 CSI 3 \ かんじ CSI 5 \」などの様にして使うものと思われる。
    行内に無理やり押し込めるのではなくて、隣の行に表示することを意図している様だ。

  - 更に Unicode にもそれ専用の文字がある。
    U+FFF9 .. U+FFFB  Interlinear annotation characters
    「<U+FFF9>漢字<U+FFFA>かんじ<U+FFFB>」などの様にして使う。

    <a href="http://unicode.org/reports/tr20/tr20-1.html">UTR #20: The Use of Unicode with Markup Languages</a>
    <a href="http://www.slideshare.net/xkawabata/2014-1109-texruby">TeXユーザの集い2014　発表資料（W3C Ruby）</a>
    <a href="https://en.wikipedia.org/wiki/Ruby_character">Ruby character - Wikipedia</a>
    <a href="http://www.wdic.org/w/CUL/%E3%83%AB%E3%83%93">ルビ ‐ 通信用語の基礎知識</a>

    U+FFF9 - U+FFFB にはそれぞれ IAA IAS IAT という略称が与えられている様だ。

    しかし Unicode も一体何を目指しているのか謎だ。変な制御機能を追加してドキュメントの構造を定義するのであれば、
    SGR だとかに対応する様な機能をつけて加えても良いような気がしてくる。勿論、論理的な意味構造に対応する物しか
    追加したくないという主張なのだろうが、誰が使うのか分からない妙な制御機能を付け加えるならばより明確な機能である
    描画属性ぐらい対応しても良い気がする。毒も喰らわば皿までという事である。

  * PTX と SRS, SDS の interaction についての問題

    | PTX は ECMA-48 を読む限り "普通は隣の行に表示する" などと書かれているが、
    | SRS や SDS など双方向テキストが混ざっている場合にどうするのかというのが謎である。
    | 逆方向の文字列に文字を追加するとその度に既に出力した文字列の位置はずれる。
    | そこに PTX が含まれていると "隣の行" の内容をふりがなで塗りつぶす事になるのではないか?
    | 更に、隣の行の上での双方向の構造がどのようになるのかも謎である。
    |
    | 改めて PTX の説明を読んでみると、PTX is used to delimit strings of graphic characters that are communicated
    | one after another in **the data stream** but that are intended **to be presented** in parallel with one another,
    | usually in adjacent lines. と書かれている。6.3/4 によると data stream はデータ部の中にあるデータの事と思われ、
    | だとすればデータ部の中ではルビは単に付加情報として取り扱われ隣の行には影響を与えない。
    | 実際に表示部に表示されるときにだけ隣の行に上書きして表示するものと考えるという事になりそうだ。
    | しかし、そうすると隣のセルに既に内容がある場合にどちらを優先して表示するのかといった問題が生じる。
    | 例えば、
    | a 常にルビを優先するか、
    | b 或いは常に本来のセル内容を優先するか
    | c もしくは後に描画したものの方を優先して表示するとか
    | a' 次の行の内容を優先するか
    | b' 前の行の内容を優先するという可能性がある。
    | d 或いは重ねて表示してしまうか。
    |   考えて見るに Unicode を完全に処理するとしたら行からはみでて表示される文字も表示したいし、
    |   そう考えてみると重ねて表示してしまうというのが現実的な解になるのだろう。
    |   また実際に其処にあるのに表示されない文字というのも変なので、両方表示したい。

    [結論]

    - データ部ではルビは付加情報として埋め込み、隣の行には影響を与えない。
    - 表示の際に具体的にどうするかは実装に任せる。
      一般的な実装としては表示の際に隣の行に表示する。
      隣の行に既に内容がある場合は重ねて表示してしまうのが良い。

    ※はみ出る文字があると再描画領域の計算などが難しくなるが、
      HTML レンダリングエンジンではそれをやっているのだし、
      何れにしてもふりがなだとかよりも先に実装することになるだろう。

* ANSI の記述によるとエスケープシーケンスは全て "文字" ではなくて "数" で指定されている。
  つまり、変な文字コードを使っていたとしても、エスケープシーケンスに含まれる
  '[' や ';' や '0' は ASCII における値を使わなければならない。
  従って、ソースコード中ではこれらは数字で表現するべきである。

2016-09-20

* original contra のコードの取り込み

  更にもっと古い ConsoleEscapeSequenceHandler についても統合を行いたい。

* gh-pages

2016-09-18

* 端末を作って遊ぶ。

* 端末の要素

  制御シーケンス・文字コードの解釈

    文字コードの枠組み iso2022 は制御シーケンスと渾然一体になっているので、
    どの様に取り扱うかは微妙である。既存のライブラリを部分的に使うかそれとも全部自前で処理するか。
    取り敢えず UTF-8 だけに対応してみるというのであれば大分楽である。というか自明である。

    制御シーケンスの最大の長さというものは決めておかなくても良いだろうか。
    幾らでも巨大なシーケンスを許容すると、超巨大なシーケンスを送りつけてメモリ不足にさせる、
    という攻撃が可能になってしまう。例えば、巨大なシーケンスはファイルに書き出すなどとしても、
    ディスク容量に依存してしまう。そういう訳で制御シーケンスの長さに制限を与えるのが現実的である。
    しかし現代に於いては巨大なデータを送りつける用途もある。
    シーケンスの種類に応じて適応的に処理するべきな気がする。

  バッファの管理

    内部的なデータの表現方法が鍵になる。この定義によって性能が規定される。

    そもそも何が必要か。行、文字、文字幅、属性の管理が必要だ。
    更に unicode grapheme clusters を考えると、結局文字はどう頑張っても可変長になる。
    属性については種類を限定せずに幾らでも拡張可能な様に設計するのが無難だ。
    また、画像だとかのインライン要素も管理しなければならない。

    同時にメモリ効率や変な脆弱性が入らない様にしたい。

  bidi

    既存の各 terminal が bidi をどの様に処理しているのかは確認しておく必要がある。
    特に行折り返しの時にはどうしたら良いのだろう。
    http://unix.stackexchange.com/questions/100811/are-there-terminal-emulators-that-support-bi-directional-text

    うーん。ある場所に hoge (表示 egoh) と出力して、その後にカーソルを色々移動した後に
    hoge の末端に移動して fuga (表示 aguf) と出力したとする。この時にこの二つの文字列が結合して、
    agufegoh という表示になるとそれは変だ。という事は bidi に対応する場合には、
    どの部分が連続して出力されたものなのかという情報を保持する必要がある。

    例えば属性を用いてこれを表現するなどはどうだろう。或る属性がついている文字は、
    次の文字と結合して bidi になる。最後の文字には bidi 属性は設定しない。次の文字とくっつかない為に。
    但し、最後の文字を削除する場合には前の文字から bidi を削除しないと勝手に次の文字とくっついてしまうので注意する。

    →ECMA-48 を読んでいたらわざわざ bidi の為に presentation component
    と data component という物が用意されている様だ。[ECMA-4.8/6.1]

  描画部

    この部分はただ愚直に実装すれば良い。何も問題はない。
    但し、更に別の端末に対して出力を行う場合には terminfo 等を参照せねばなるまい。

  キーシーケンスその他

    逆にユーザ側からアプリケーションに向かって送信されるデータ。
    これについても愚直に実装すれば良いだけである様に思う。
    但し、別の端末から受け取ったデータは翻訳する必要がある。
    これはやはり terminfo 等を参照する事にする。


------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2021-09-20

* contra で emacs や vim が focus/blur に対して変な振る舞いをする

  そもそも何故 focus/blur が有効になっているのかと思ったら少なくとも emacs に関
  しては CSI ?1004h を呼び出している。xterm でも試してみたが xterm では問題は起
  こっていない。TERM を完全に一致させても同様である。

  実際に xterm が blur に対して送っているシーケンスと contra が送っているシーケ
  ンスを比べた所、どうも違っている。xterm は CSI O を送っているのに対して
  contra は SS3 O を送っている。

  % 一方で、right, left, etc に関してはちゃんと両方とも SS3 C や SS3 D を送信し
  % ている。つまり xterm は kp かどうかに関わらず focus/blur に関しては CSI で
  % シーケンスを送信するという事である。
  %
  % 本当は xterm の様々なモードに対する振る舞いを調べるべきなのだろうが、これにつ
  % いてはまた後で調べる事にして、取り敢えず contra では default の xterm に合わ
  % せる事にする。本当は emacs の側にちゃんと対応する様にしてもらいたいし、xterm
  % にも中途半端な振る舞いをしないよう要求したいところだがそれらの要求が通ること
  % はないだろうと思われる。なので、結局 contra 側が折れるしかないのである。
  %
  % と思って実装を見てみたが、focus/blur はそもそも常に SS3 で送る様になっていた。
  % decckm で切り替わるなら未だしもこれは変である。一方で、そもそも常に CSI なシー
  % ケンスも沢山ある。切り替わるのは cursor keys だけである。contra.gh の
  % escseq.html には CSI O, CSI I としか書かれていない。という事を考えると、現在
  % の実装で ss3 を使っているのは単に実装ミスという事の気がする。

  結局 SS3 を常に送る様になっていて、これは単なるミスト思われる。常に csi で送
  る様に修正する事にする。

2021-06-19

* CPR には流石に対応したい [#D0269]
  DSR (CPR), DECDSR, MW に対応した。細かい振る舞いで今後修正するべき物は色々あ
  るがそれらは ToDo に残す事にした。

* 2020-09-27 標準エラーが端末の fd と被ってしまう問題 [#D0268]
  取り敢えず idevice に対して出力する事にして、
  stderr が使えない時には empty_device で初期化する事にした (#D0265)

  後々に需要があれば stderr が使えない場合に
  代わりに別の場所にも記録を残す仕組みを作る。

2020-10-12

* 2020-03-05 連続入力の時の modifyOtherKeys の振る舞いが変だ [#D0267]

  mintty は A... で A の連続が入力されるが、
  contra の内部だと連続入力の時には小文字の a が入力される。
  また emacs の内部で試すと A~~~~~~~~~~~~~ の様になってしまう。

  どうも autorepeat の時にだけ何か予期しない動作になっている気がする。実際に送
  信されているのは ^[[27;2;97~ である。どうもこれは modifyOtherKeys に関係なく
  autorepeat が入っている時に ~ 形式で入力する様になってしまっている?

  autorepeat の処理を間違えているのかと考えたが間違いようもない気がする。
  と此処で気づいたのは autorepeat が入っている時には、
  A ではなく S-a という形でキーが送信されるという事。
  これは本来は A にして送信しなければならなかった筈。

  →取り敢えず修正した。然し、これが元々の問題だったのかはよく分からない。
  でもこれだった気がする。

* vttest の 1 か 2 を実行すると文字化けする様になってしまう [#D0266]
  twin, tx11 の両方で再現するのでデコーダの言語の状態が変になるという事だろうか。

  実際に試してみると 2 で問題が発生する。stderr に iso2022.def が見つからないと
  いうメッセージが出るので、やはり何か別の文字集合に切り替わってしまって問題が
  発生する様になっている。

  * iso2022.def が見つからない事が原因になっているのかもしれないと思って、
    ~/.local/share/contra を正しく配置し直してちゃんと iso2022.def が読み込まれ
    る様にしたが、それでも問題はそのままである。

  * 画面を見る限りでは変な文字集合に変わる余地はない様に思われたが…。よく考え
    たら altcharset を使っているのだろうという事。然し自前の demo.sh による
    altcharset では特に変な事は起こっていない。

  * 不思議なのは同じアルファベットでも表示されたりされなかったりするという事。
    SGR 周辺で変な事が起こっている様な気もする。

  sequence_printer を有効にしてみる? →有効にしてみたが変な物は何も出力されてい
  ない。よく考えたら escape sequence は sequence_decoder で処理してしまうので
  sequence_printer には制御が移らないのだった。

  うーん。sequence_decoder の入り口で出力を dump する様にして見た所、"ESC ( B"
  と "ESC ) B" を使っている。実際にこれを自分で出力してみて問題が再現するか確か
  める→ OK. 問題は再現する。そして実は iso2022.def の読み込みは無関係だった様
  だ。さて、この二つのシーケンスは一体どういう効果を意図した物であるか確認する
  必要がある。

  "ESC ( B" は "G0D4(B)" であり、"ESC ) B" は "G1D4(B)" である。うーん。G1D4 の
  方が怪しい気がする。うーん。試しに "G1D6(A)" を実行してみた所状態が直る事は確
  かめた。問題は、明らかに G1 に関係ない文字にも影響が出ている様に見えるという
  事。もしかすると iso2022 の状態になっている時には全般的に振る舞いがおかしくなっ
  てしまうという事なのかもしれない。うーん。どうにも分からない。

  改めて sequence_printer で確認してみたが別に変な文字が出力されている訳ではな
  い様である。謎である。やはり変な事は置きていない。唯、何故か文字が消滅したり
  色々変な事が起こっている。変な事が起こっているのは SGR の周辺である。SGR の処
  理自体に変な事が起こっている可能性? 或いは SGR に限らず CSI seq が変なのか。
  どうも SGR に限らず CSI seq が来た時に何か変な事が起こっている? SGR 自体は正
  しく受信できている。

  どうやら process_char で変な文字が受信されている様子。もしかして制御文字が
  process_char に混入している? sequence_printer で見ると何も変な物はない。どう
  も sequence_printer と実際の term で受信している物の内容が異なる様だ。そして、
  term では 0x1B を受信している。

  分かった。修正した。最近書き直した新しい decoder のバグであった。

2020-10-06

* 2020-09-27 標準エラーが端末の fd と被ってしまう問題 [#D0265]

  プログラム全体でエラーメッセージの出力先を制御できる様にしたい。
  特に標準エラー出力は最初に 2 が使えるかどうか確認し、
  もし 2 に何も紐付いていない時には自前で何か fd を生成する。
  然し、fd を介さずに自前の stream に記録する等の事もしたい。
  という事を考えると fd の代わりになる仕組みを作りたい気もする。

  printf 系統の出力を行いたいと思うと自然と制限がかかって来る。

  a 一つの方法は自前で printf 系統のプログラムを作るという事。

    x standalone 版の xprintf を作っても良いのかもしれない。

  b もう一つの方法は pipe を自分で生成してそれに紐付ける file を生成して、それに
    対して fprintf を実行するという事。別プロセスかスレッドを使って pipe のもう
    一方を読み取る必要がある。

  c 或いは sprintf を呼び出して実装する。fmt から予想される最大の文字数を計算し、
    それを元にしてバッファを確保して sprintf を呼び出す。問題は %*x 等の様にして
    引数から幅を読み取る様な指定があった場合に最大の文字数を計算するのが困難とい
    う事。%*x の内部まで解析してそれに応じてバッファを確保するのだとすれば、それ
    は殆ど printf の書式の処理をしている事になり、それぐらいであれば全て自分で実
    装しても良いのではないかという気がする。

  d 或いは % 指定の部分だけ抜き出して % 指定の部分毎に sprintf を呼び出す? この
    方法の問題点は何かというと、%1$d 等の位置指定の書式に対応するのが困難である
    という事。というよりそうでなくても大変である。自分で改めて引数を並び替える必
    要がある。引数を全く並び替えずにそのまま渡して、代わりに書式の方に全て明示的
    に番号を指定するという手もあるが何れにしても書式指定を自分で解析する必要が出
    てくる。

  e 或いは printf を使わずに全て実装し直す? 然し、それはそれで結構面倒な気がする。
    また文字列に変換する仕組みなどについて色々考える必要が出てきてしまう。

  今考えるに現実的な方法は libmwg の xprintf を移植する事である。然し、実際的な
  問題が生じるかもしれない。先ずは xprintf を観察してみるという事。うーん。
  #pragma%include して mwg_pp マクロを呼び出している。かなり面倒な気がする。或い
  は mwg_pp で処理した後のファイルを使う?

  うーん。試しに少し書き換えてみたがかなり面倒である。defs や functor にも依存し
  ているし、更に mwg/bits/autoload.inl 等まで呼び出している。機能制限をするにし
  ても結構複雑である。色々考えて見るに、libmwg の側で C++11 の default の
  mwg_config.h を提供するのが良い気がする。或いは、MWG_STANDALONE 的なマクロが定
  義されていた場合には別の mwg_config.h を読み取る様にする。然し、それはそれで色々
  と面倒なのだろう。

  何れにしても contra を libmwg に本格的に依存させる気はない。本格的に依存させる
  ぐらいであれば、自前で作った方が良いという様な気がする。或いはもし本当に
  libmwg に依存するのだとしたら少なくとも libmwg をもっとまともな形で使える様に
  整理しなければならない。

  * エラーメッセージを内部的に処理するとしても、どの様に処理するのが良いだろうか。
    単にメモリにどんどん書き足していく? 或いは、ファイルに書き出す? 無制限にメモ
    リに書き出していくとメモリ不足になる。

    a という事を考えたらやはり内部端末を作成して其処に書き込んでいく事にする? うー
      ん。内部端末を作成して其処に書き込ませるのが良い気がしてきた。そうすると、
      やはり FILE* または fd 経由で書き込む事になる。

    b 然し内部端末を割り当てるとなると pty に依存する様になってしまう。pty のな
      いシステムでも別の手段で端末を実現したいという事で contra のベース部分は
      pty に依存しない様になっている。なので、エラーメッセージのために pty を要
      求するというのは避けたい。実のところ、pty を経由しなくても直接端末に書き込
      むことはできる。この実装では、直接端末に書き込みを行う事にしたい。

    一般的な入出力の枠組みを作ってそれ経由で全てのエラーメッセージを書き込む様に
    したい。と思ったが、実は既にその様な枠組みがある。contra::idevice である。単
    にこれに書き込む様にすれば良いのではないか。そして取り敢えずグローバルに
    contra::idevice を置いておく事にする? 行く行くは割り当てた端末ごとにエラーメッ
    セージの出力先を切り替えたり出来るようにしたいが、最初は一つのグローバルオブ
    ジェクトに対して出力するという具合で良い事にする。

  * mwg/expcet.h が stderr に出力しているのはどうするのか? と思って contra を探
    したが mwg_check と mwg_assert しか使っていないので、何れにしてもこれが発生
    するのはバグを踏んだときであって、しかも即終了するのでそれ程問題にはならない
    筈。これは気にしなくても良い。

2020-09-27

* tx11: マウスに対応してみたがドラッグが遅い。 [#D0264]
  描画をイベントの処理を終わらせてからに変更しても遅い。
  もしかすると mousemove の発生を厳密に 1px 毎に発生させているのかもしれない。
  →そうではなかった。これは get_modifiers が遅いのだった。
  get_modifiers をする度に XServer に対して問い合わせの通信をしている。
  これが原因で遅くなってしまっている。では問い合わせずに済ませる事は可能か。

  a 調べてみると 左右shift,ctrl,alt 等を区別しているので、
    event.xbutton.state からは状態を調べる事はできない。

  b 或いは左右shift,ctrl,alt等のキーボードの状態を追跡する事は可能だろうか。
    FocusIn, FocusOut に対しては Query して更新する必要がある。

  x fixed: うーん。調べていてもうひとつ分かった事がある。
    contra x11 で Ctrl の押し損ねが発生すると思っていたら、
    これは Ctrl+key を押した時に Ctrl を離すのが早すぎると、
    key を押した時点では Ctrl が押された状態になっていたとしても、
    通信をしている段階で Ctrl が外れしまっている為に、
    Ctrl なしで key が押されたと勘違いされてしまうという現象の様だ。
    →自前で追跡する様に修正した時に一緒に修正した。OK

  [実装]

  一応、左右C-A-S- は区別可能という事が分かった。

  XkbGetIndicatorState で取得している caps/num/scroll lock の状態は微妙。
  一応それぞれのボタンを押したり離したりは検出できるが、
  現在の状態に関しては問い合わせ無いと分からない。
  それぞれのボタンが押された時・離された時に問い合わせを行って更新すれば良い気がする。

  色々実験した所 XkbGetIndicatorState と XQueryKeymap はやはり時間がかかる。
  XKeysymToKeycode に関しては通信コストは存在しない様である。

  実装し直した。取り敢えず速度の問題は解決した。

  x ok: 右Altが正しく動作していない気がする。何故か左Altと同じ振る舞いになっている。
    調べると KeySym も KeyCode もちゃんと左右で区別できていて相互変換もできている。
    →これは単に設定ファイルを読み込めていなかっただけだった。

  x 保留: やはり ScrollLock の状態を正しく取得できていない。
    調べると XkbGetIndicatorState はプロトコルで返される値をそのまま返すとの事。
    これは Cygwin の XServer に実装されていないという事だろうか。

    XQueryKeymap がどの様な値を返すかについて確認する。
    →うーん。これだと本当に現在押されているか離されているかしか分からない。
    lock 状態がどうなっているのかについて取得する事ができない。

    Cygwin の XServer は Cygwin/X というらしい。中でも XWin が恐らく処理を担っている。
    https://x.cygwin.com/devel/server/ にソースコードがある。
    https://cgit.freedesktop.org/xorg/xserver/tree/
    https://gitlab.freedesktop.org/xorg/xserver
    ソースコードを確認してみたがよく分からない。
    KEY_ScrollLock は元より KEY_CapsLock ですら読み取っていない様な気がする。
    何故だろう。或いは wParam, lParam から読み取っているかもしれないと思ったが、
    ちょっと見た限りでは該当する部分は見つけられていない。

    うーん。多分難しい。取り敢えず保留にする。

  x ok: UnmapNotify というイベントが発生している。これは何だろう。
    適宜無視するか対処するかする。これは StructureNotifyMask で送られる様になる。
    MapNotify というのは既に無視する様にしている。これと同じ対処で良いだろう。

  x fixed: クリックが全く発火していない。何故だろうか。twin と同じく manager が
    管理している筈なので、twin で動作していれば tx11 でも動作する筈である。

    →どうも on_click までは発火しているが on_multiple_click が発火していない様だ。
    或いはこれはもしかすると scrolllock と関係している可能性?
    でも scrolllock がどちらの状態でも twin は動いているので関係ない。

    x fixed: これは key_mouseN_{down,up} の合成に失敗していたのが原因だっ
      た。_key_base | _key_mouse_event_down | button << _key_mouse_button_shft等
      としなければならない所で _key_base を忘れていた。然し、よく考えたらボタン
      も三種類しかないし条件分岐も面倒なので、そのまま合成済みの
      key_mouseN_{down,up} をそれぞれ返す事にした。

    と思ってこれを修正したがそれでも on_multiple_click は発火しない。
    どうも X11 だとマウスが動かなくても MotionNotify がクリックする度に発生する様だ。
    前の位置を記録しておいて同じ位置だったら無視するようにする必要がある。
    その様に修正したら期待通りに動くようになった。

2020-09-26

* bce を直したと思ったらまた別の問題が生じている [#D0263]

  clear_sgr で m_fill_dirty を立てるのを忘れていたから修正した。
  と思ったらまた行末まで着色されてしまう問題が再発する様になった。
  と…。mintty でも同様に問題が生じているので、これは ble.sh の問題である。
  ble.sh を改めて直したらちゃんと直った。

* 2020-09-02 [自然解消] ble.sh 24 bit color を使うと背景色の属性が変わってしまう [#D0262]
  具体的に何が起こっているのかはちゃんとは分かっていない。

  実はこの問題も #D0261 なのではないか?
  直っているかどうか確認する為には一旦新しい修正を捨てた状態で再現させて、
  その後で新しい法で再現しないという事を確認しなければならない。

  どの様なコマンドで再現させたら良いか。
  ble.sh の記録を見ると以下のコマンドで再現できるそうだ。

  $ ble-color-setface command_builtin 'fg=#4bd'

  →再現できた (ble.sh の version も元の物に戻して試した。
  今の ble.sh には erase する時に sgr0 しないというバグが混入している為)。
  次に、修正した fill_attr で問題が直っている事を確かめる。
  →OK。修正できている。

* mode_bce が反映されていない気がする [#D0261]
  調べると abuild.fill_attr() が常に 0 を返している。
  fill_attr の内部で取得している背景色を確認すると常に 0 である。
  と思ったら extended かどうかに関わらず m_attribute を参照していた。
  これは extended でない時には m_attr の方を参照するべきである。
  修正した。

2020-09-06

* mode ?1004 が mode_XtermAnyEventMouse になっている [#D0260]
  term.mode.def を全体に名前が入れ替わってしまっている。
  何処かの段階で置換に失敗したのだろう。

2020-06-28

* ttty を使える様に改修する (1) [#D0259]

  * ok: キーボード入力は別の枠組みで送受信しても良いが、やはり最終的には
    decode を実装する事になるのだから先に実装しておいても問題ない。
    機能の直行性を考えたら一番最初に実装するべきはこれである。

    或いは ttty を始めから作り直した方が楽なのかもしれない。
    現在の ttty は元々はデバグの為に簡単に書いたものに端を発している。

    →実際に実装を確認したら既にキーボード入力を処理する枠組みはあった。
    しかもちゃんと tty に接続されている気がする。と思って試そうとしたが、
    prefix key を定めていないのでちゃんと動いているのか判断が付かない。
    少なくとも文字入力はできているからちゃんと動いている様な気がする。
    然し、もしかすると input_decoder を経由していない可能性もある。

    →どうもちゃんと使っている。但し、super を application として
    使う様になっている。prefix key も定義して良いのではないかという気がする。
    prefix key は manager の側に実装するのが良い気がする。

  取り敢えず ttty を multiplexer として使える事までは確認した。
  prefix key C-a を処理する様にした。
  また、新しく terminal session を作っても正しく描画されない問題を修正した。

  取り敢えずの所は動く様になったが、色々操作性に問題がある。
  また、C-a C-a でウィンドウ切り替えをできる様にしたい。

* キー入力読み取りの実装確認 [#D0258]

  % 取り敢えず標準的な物を全て decode できる様にする。
  %
  % [term] → [application]
  % [application] → [term]
  %
  % CSI は切り出す。DCS 等を送信する事はあるだろうか。ユーザーのキー入力
  % というのはつまり、端末から application への送信である。CUI ttty が動
  % いている時は外側の端末から ttty への送信である。という事を考えると様々
  % な request に対して report が帰って来得る。つまり DCS や OSC も処理
  % する必要があるという事である。
  %
  % 一方で CSI や OSC や DCS は 8bit で符号化すれば区別がつくのだ、とい
  % う提案も TWG で為されていた。他の人が賛同するとは思えないが。UTF-8
  % との兼ね合いでどのように処理するのかというので合意を形成するのは難し
  % い。或いは terminal-parsing で UTF-8 の取り扱いがちゃんと決まれば
  % 8bit C1 もちゃんと取り扱う事ができるという事を示す事ができるのかもし
  % れない。
  %
  % 何れにしても CSI,OSC,DCS は処理する。これが意味する所は M-[ M-] M-P
  % は使えないという事である (或いは modifyOtherChars にすれば使える)。
  % また、PM,SOS,APC 等はどうするか。M-X M-^ M-_ である。これらはオプショ
  % ンで有効無効を切り替えられる様にして、既定では処理しない様にすれば良
  % い。
  %
  % ledit を見ようかと思ったが生憎直ぐには見つからない。何処かに行ってし
  % まった。恐らくデスクトップを起動すれば中にある。どうするか、わざわざ
  % 起動するか。しかし時間を取ってしまう。と思ったが、こんな事をしている
  % 時点で時間は無駄にしているのだ。時間を取るという事を理由にしてそれを
  % 今はしないというのであれば、そもそもこれを今する事だって憚られるので
  % はないか。という訳で取り敢えずこれは今はしない事にする。
  %
  % 実装を確認してみた所既に input_decoder というクラスが存在している。
  % 中を確認してみると paste_begin, paste_end だけを処理している。これは
  % 何故だろうか。と思ったが勘違いだった。CSI もちゃんと処理している。
  % 一方で paste_begin が来たら paste_end が来るまで読み飛ばす処理で、
  % paste_end を一文字ずつ確認しているという事だった。
  % うーん。見た所、一通り実装されている気がする。

  確認した所、取り敢えず現在の要求に耐える物は既に実装されていた。

  * 少し csi_parameters を整理する事にする。

    * done: エラーコードを取得できる様にする。
      * done: result_code で公開する様にする。
    * done: エラーメッセージは呼び出し元で処理する様にする。
    * done: private parameter bytes を csi_parameters の側で処理する。

    * done: input_decoder で CSI > の形式のキーシーケンスも同様に処理する様に変更。

    取り敢えず実装は整理したがそもそも何をしていたのだったか。
    結局 input_decoder が実際に存在しているという事を確認できた。
    そして未だ対応していない部分はある物の、
    現在の書き換えを進める上では既に十分な機能を持っている事も確かめた。

* term: underline style で対応していない番号が指定されたら [#D0257]
  通常の下線にするべきなのではないだろうか。
  確認したら対応していない style が指定された時には下線をクリアする様になっていた。
  これは変なので普通に下線を設定する事にした。

* render: BUG blink が動かなくなっている。前は動いていた [#D0256]
  attr の移行で動かなくなったと思われる。

2020-06-20

* attr: 24bit の背景色を大量に出力していると途中で色がなくなってしまう [#D0255]
  最初は MNIST の CNN の kernel を端末に表示する為に 24bit color を
  使っていたら途中から一切の 24 bit color を表示できなくなった。
  また vtm のデモで再現する事を確認する事が確かめられた。

  これの原因として考えられる事は、拡張属性のリソース管理である。
  確認してみる事にする。

  一番最初に疑ったのは gc が呼ばれなくなっているのではないかという事。
  然し、ちゃんと呼ばれている。そして問題が起こってもちゃんと呼ばれている。
  然し、一端問題が発生すると gc_count が 2012 になって其処から動かなくなる。

  と。此処まで来て気付いたのだが gc_count は必ずしも、
  内部に保存しているデータの数に比例している訳ではないという事。
  つまり、解放されずに残っている項目が大量に発生しているという事を示唆する。
  そして、それが決して解放されないという状態に陥っている。

  と気付いたのが、table を compaction した後で table.resize するのを忘れている。
  これだと空いた領域が使われた状態のままで残されてしまう。
  table.resize(j) を追加しただけで問題は発生しなくなった。多分大丈夫。

2020-03-02

* attr: 描画属性の拡張に対応 [#D0254]

  先ず 32bit にどの様な属性を入れる事にするか。

  * selected は別の場所に記録したい。
    char か attr の常に使う bit 位置にする。

  * 実は拡張時と短縮時で配置は同じでなくても良い。

  * 背景色と前景色は記録したい。
    背景色と前景色が設定されていない状態もあるので、
    合計で 18bit 消費する。これが最低である。

    extended flag で 1bit 消費する。

    bold+ underline++ blink+ nega invis strike で 10bit

  [実装]

  * selected を何処に記録するか。
    char 側に記録する? → うーん。
    attr 側に記録する? → 本当に何も問題は起こらないだろうか。
    →取り敢えず aflags に移動した。最終的には attr_t に載せたい。

  x fill attr にも反映されるがそれで良いのか。
    →確認してみた所 bg だけ反映する様になっていた。
    つまり、特に extension がある場合には、
    また新しく属性を確保することになる?

    例えば前回と同じ fill_attr だったとしても改めて
    確保する事になるのである。これは非効率的である。
    fill_attr に関しても builder から取得する様にして、
    短縮 attr_t を使う時には前回の fill_attr を記録しておく
    様に変更するのが良いのではないだろうか。

    fill_attr はそれほどの頻度で使用される訳ではないので、
    そんなに細かく version を記録しなくても良い。
    例えば文字色を変更するだけであれば本来は fill_attr に
    影響はないはずなので fill_attr の再確保の必要はない。
    然し、それを細かく検出する様にするとその為に処理が必要になる。
    そういう事を考えれば文字色が変更されただけでも fill_attr は
    次に必要とする時に再確保するという仕組みにしても良い気がする。

  x done: 現在 version で管理しているがこれは単に dirty フラグで十分なのでは。
    version は同時に複数のインスタンス(任意の個数)の最新かどうかの判定を一つの変数で
    できるようにするための物である→修正した。

  * done: render については atable 経由で値を読み取る様に変更した。

  * done: line についてはどうだろうか。ssa_selected と
    それから has_blinking_... で使っている。
    has_blinkikng_cells では引数に atable を渡す様にしても良い。
    →取り敢えず line についても atable または簡単に移行できる様に変更した。

  * done: buffer に関しても書き換えた。

  * done: 取り敢えず cattr_t に切り替えた。汚い事になっているが追々綺麗にしていく。

  * done: 多少動かしてみた所あっという間に attribute_table を使い果たしてしまった。
    多少容量を大きめに取るという事と、mark/sweep を実装するという事。
    それからコンパクションの可能性も考える。
    コンパクションを考えると二回スキャンしなければならない。
    うーん。mark の度に呼び出すというよりは root へのポインタを列挙するのが良い?

    root obj は cur, board, snapshot である。

    取り敢えず実装した。mark漏れしないように今後は注意する必要がある。
    また、現在は描画する度に gc() を実行する様にしているが、
    もっと別の方針を考えた方が良い様な気もする。
    例えば SGR が来る度にカウントして或る回数確保したらその時に gc を実行する。
    描画に際してはそのカウントが一定以上の時に始めて gc() を実行する様にする。
    面倒なので取り敢えずは hard code している。

  * done: 実装を多少整理する事にしたい。

  取り敢えず実装した。遅くなるという事はなかったのでもう昔の実装は削除する事にした。

* attr: 拡張属性寿命管理の為 buffer.hpp の記録を term_t から見える様にする [#D0253]

  そろそろ本当に入れ替えても良いのではないだろうか。
  少し試してみた所 ttty/buffer.hpp で rendering 時に属性を書き換えている箇所がある。
  この書き換えを実行せずに実現する様に書き換えるのが現実的の様な気がする。

  或いは描画の時だけは attr を展開して取り扱うという手もある?
  全てを描画するのではなくて一部を描画する様にしている限りは
  これで良いのではないだろうか。然し、将来的には全てを出力する
  モードも用意したいような気もする。その場合には結局全てを出力するので
  毎回全てデータを展開して、という振る舞いは遅くなる原因の気がする。

  実際に実装を確認してみた所 cell の == による比較などを行っている。
  またキャッシュ(前回の描画内容)を行っているので mark&sweep する時にはこのキャッシュも
  含めて計算を実施しなければならない。これは実は ttty だけでなく render の方も同様の筈である。

  a attr_t のままで記録する。この場合は mark&sweep の root オブジェクトとして
    記録してある前回の描画内容も登録する必要がある。
    また default を背景色で置き換える操作に対して毎回拡張属性を再生成する
    必要があるのではないか。一応、拡張属性になるケースは少ないという事と、
    前回と同じ attr_t の時は再生成しなくても良いという様に工夫する事はできる。
    然し、何れにしても実装は面倒そうである。

    これは mark&sweep を誰が実行するのかという事にも関係してくる。
    manager などのレベルで呼び出すのだとすれば呼び出す時に、
    描画に使っているキャッシュなどをその時点で指定すれば良い。
    もし、term のレベルで一定の属性の変更が起こった時に
    自発的に mark&sweep を呼び出すのだとすれば、
    外部から root object を登録できる仕組みにするか、
    或いは外部のキャッシュ等についても管理できる仕組みが必要になる。

  b やはり拡張属性に解決して記録する?
    この方が現実的そうである、と思ったが微妙かもしれない。
    というのも拡張属性だけでなくて拡張文字も同様にコピーするのか
    という問題がある為である。特に sixel graphics 等の場合には、
    各文字毎に全体をコピーしなければならなくなってしまう。
    拡張文字に関しては参照を追跡する事にするという事であれば、
    拡張属性についてもちゃんと取り扱ってもさほどの違いはない。

  ? 同じ事が render で起こらないのは何故だろう。。

    | →render では単に変更してないから問題が起こっていないだけである。
    | 実は所有権の問題は実際に発生する筈。
    | 元々の計画では order_cells_in を用いて取得する時に、
    | 必要なオブジェクトや属性も一緒にコピーする筈だったのではないか。
    | これは行毎にリソースを持つという前提の話だった。
    | それならば一括で行を取得するという具合にしても良いのではないか。
    |
    | うーん。或いはその瞬間の "snapshot" というのを term の側で管理する
    | という手もある。そしてそれが削除される時に unregister する。
    | その様な構造にする為には、snapshot として "共通" のデータ構造を定義する必要がある。
    | 現在は render と buffer で似てはいるが異なるデータ構造を使っている。
    | これらを統一する事は可能だろうか。
    |
    | render では以下の様な構造になっている。
    |
    |   struct line_content {
    |     curpos_t previous_line_index;
    |     bool is_invalidated;
    |     bool is_redraw_requested;
    |     std::vector<cell_t> cells;
    |   };
    |   std::vector<line_content> lines;
    |
    |   うーん。render では line_tracer によって id を解決した後の値を
    |   記録する様になっている。然し、古い id を記録しないと trace できないのでは。
    |   と思ったら別の場所にも記録されているという事が判明した。
    |   うーん。これを snapshot として切り出せば良いのではないか。
    |
    |   struct line_trace_t {
    |     std::uint32_t id = (std::uint32_t) -1;
    |     std::uint32_t version = 0;
    |     bool has_blinking = false;
    |   };
    |   std::vector<line_trace_t> m_lines;
    |
    | buffer では以下のような構造になっている。
    |
    |   struct line_buffer_t {
    |     std::uint32_t id = (std::uint32_t) -1;
    |     std::uint32_t version = 0;
    |     std::vector<cell_t> content;
    |     int delta;
    |   };
    |   std::vector<line_buffer_t> screen_buffer;
    |
    | buffer の側の実装は古い気がするので改めて render の側の実装を
    | 使って実装し直すというのも手である様な気がする。
    | その為には先ず render の側の実装を整理する必要がある。
    |
    | うーん。書き換えている途中で思ったが status_tracer 自体が
    | snapshot に相当するのではないか。。戻した。結局対して変わっていない。
    | うーん。密結合を防ぐためには適度に小さく小分けしなければならない。
    | 然し、小分けに失敗すると本来一緒でいいものが沢山に分裂して、
    | 無意味に何階層にも分かれて分けることの意味が失われる。
    | 結局分けることが大切なのではなくて適切な分割点を見つけることが大切。
    |
    | 取り敢えず、現在の目的は term 側で snapshot の寿命を把握できる様にする事。
    | そして snapshot に関しては唯単にセルの管理というよりは、
    | その他の様々な端末の属性の変化の追跡を担わせたい。
    | これが混ざり合ってよく分からない事になっている。
    |
    | 更に line_tracer の実装と、
    | view.order_cells_in によってセルを取得するという部分をくっつけようとしている。
    | これらを上手にくっつけることはそもそも可能なのだろうか。
    |
    | →うーん。問題点が分かった。buffer.hpp の場合は行の内容の差分まで取って更新を行う。
    | 一方で、render の場合には行を完全に再描画する様になっているので行の内容まで記録しなくて良い。
    | これが実装の差異となって現れているのである。というより、render では一切のキャッシュを行っていない。
    | という事を考えると実は現在の書き換えは完全に無駄なのではないだろうか。。
    | 取り敢えず元に戻した。
    |
    | 将来的には両実装を統一するという事も考えられるかもしれない。
    | 例えば line_tracer の実装部分に関しては実は統一できるのではないだろうか。
    | と思ったが既に現在の実装で最適になっている様な気がするから動かしたくない気もする。
    | うーん。そのままにする事にしよう…。

    →結論としては render は行を完全再描画するので内容をキャッシュしていない。
    buffer.hpp に関しては行をキャッシュして差分で再描画しているのでキャッシュしている。
    (これは行を更新するのに通信が必要で、その通信量をできるだけ減らしたいからである。)
    この本質的な違いがあるので設計上全然異なる。これらを無理にくっつける事もできるが、
    既に実装してあるものの方が最適化した実装になっているので敢えてくっつける必要はない気がする。

  * 概念に名前付けを考えたい。

    | screen には session / layout / region / window という概念が在る。
    | tmux には session / window / pane という概念が在る。
    | ややこしいのは tmux window は screen layout に対応していて
    | tmux pane は screen region/window に対応している様だという事。
    | tmux では pane 毎に中身を選択する事はできない様である。
    | 後、複数の layout で pane を共有するのも難しいのではないかという気がする。
    | emacs には window / buffer という概念が在る。これもまたややこしい。
    | 結局それぞれのプログラムで window という語が乱用されていて何だかわからない。
    | ncurses には window という概念が在る。
    |
    |        | session | 配置   | 表示領域 | 端末   |
    | -------|---------|--------|----------|--------|
    | screen | session | layout | region   | window |
    | tmux   | session | window |        pane       |
    | emacs  | session | N/A    | window   | buffer |
    | ncurses| N/A     | N/A    | window   | N/A    |
    |
    | contra はどの様なモデルにするか。
    | session / layout / region / term ぐらいが分かりやすいのでは。
    | 或いは session / layout / pane / buffer だろうか。
    |
    |   term だと端末がないと行けない気がするが
    |   実際には直接其処にアプリケーションを走らせても良い。
    |   という事を考えると buffer の方が良いという気がする。
    |   と思ったが構造が面倒になるのでどのアプリケーションも結局
    |   term の上で動かす様にした方が綺麗であるというのが結論である。
    |   つまり、共通の board の上で term とアプリケーションを別々に実装するよりは、
    |   board を term の中に隠してしまって、アプリケーションは term の上で動かす。
    |   其処まで高機能が必要ないというのであれば term の高機能な仕組みは使わずに
    |   直接にデータを読み書きする様にすれば良い。
    |   その様に考えると term vs buffer で言えば term で良い気がする。
    |
    |   後、 region vs pane vs window だと何が良いだろうか。
    |   window は混乱の元なので使わない。region も emacs では選択領域を示す。
    |   pane も tmux で既に使われていて意味合いが微妙に異なる気がする。
    |   また、将来的には単純な分割ではなくて埋め込み矩形領域に端末を表示したり、
    |   そういう事ができるようになると良いなという気がする。
    |   という事を考えると HTML の連想で frame が良い気がする。
    |   或いは既に contra のコード内部に在る view? がそれに対応すると考えれば view?
    |   然し、これは部分的な表示を意識した物にはなっていない。やはり view ではない。

    取り敢えず、現状では以下の様な名前をつけて考える事にしたい。
    contra: session / layout / frame / term

    然し考え始めると layout の中に更に layout を入れて切り替える
    だとか frame の入れ子だとか色々考えられる気がする。
    そうすると上の様な一元的な 4 段階の概念が良いのかも謎である。
    うーん。例えば或るアプリケーションの中に子 term を配置して…。
    という場合にそのアプリケーションに属する term が操作できては変である。
    と思ったがそれは別の session の中の term とも考えられるし、
    余り深く考えなくて良い様な気がしてきた。
    入れ子にする場合には別の session という考え方で良い気がする。

  * さてキャッシュするのはどのレベルでキャッシュするのか。
    frame の内容をキャッシュするという事を考えていたが、
    本当にそれで良いのだろうか。実は term のレベルで
    キャッシュするべきなのではないか。

    というか現在の ttty の実装では manager を使っていただろうか。
    確認した所一応 manager を使っている様である。
    ではスクロールバック等に対応しているだろうか。
    view を使って実装していれば一応対応している筈である。
    →その様になっている。

    少なくとも行の追跡は term のレベルで行われている。
    行の内容が更にその一部だった時に行の内容を全てキャッシュするのか、
    或いは一部だけキャッシュするのかというのは良く分からない。
    うーん。考えるに一部だけをキャッシュするというので良い気がする。

    (現在は対応していないが) frame で切り取られた部分を
    キャッシュすると考えるのが良い気がする。

  * 取り敢えずキャッシュについては term_t に通知する仕組みに変更した。
    然し、よく考えてみれば term_t の方に実体を持たせて、
    それに対する参照を buffer の側で持った方が自然なのでは?
    と思ったが、その様にしたとしても参照が有効かどうかの管理は必要なので、
    結局同じ事になるのではないかという気がする。

    その場合にはどう管理するのが良いだろうか。
    index で管理する事にすると frame を破棄した時に
    その index の分だけ穴が空いた状態になる。
    データを詰める事ができないという事になる。
    詰める事ができる様にする為には一旦ポインタを挟む必要がある。
    その様にすると結局現在の実装と殆ど同じになる。

    また frame が別の term を表示する様に変更する時に
    snapshot を一旦破棄して再度別の term の上に確保する
    という事になるのは非効率の気がする。
    オブジェクトの寿命的にも frame の側で保持するのが自然である。

    取り敢えず現在の実装を使う事にする。
    →やはり分かりにくいので frame_snapshot_list
    というクラスを作成して其処で管理する事にした。

  * 次に背景色の書き換えを登録する?
    attribute_builder に機能を増やすのが良いだろうか。
    取り敢えず実装した。汚い気がするが仕方がない。
    後で整理する方法を思いついたらその時に整理する。

2020-02-19

* [考察] 属性の形式変更に関する考察 [#D0252]

  うーん。やはり属性についてはインデックスに変換したい気がする。
  そうするとやはり昔の実装に戻すという事になる。
  昔の実装では行毎にバッファを用意して属性を記録する事にしていた。
  そして参照カウントで管理することにしていた。
  新しい実装では参照カウントは用いない事にする。
  一定の周期で属性値を mark&sweep で解放する事にする。
  term 毎に属性値のバッファを管理する。
  スクロールバッファに送る内容は圧縮表現に変更するので、
  属性の明示的な参照は切れる。
  従って、mark&sweep は画面に表示している内容だけチェックすれば問題ない。
  但し、altbuf や pages も確認する必要がある。或いは、altbuf/pages も
  圧縮表現に変換するべきだろうか? まあ、これらは別に問題ない。
  pages の上限を例えば 100 に設定しておくと100行あったとすると
  10000行になってしまって大量にデータを食う。うーん。やっぱり pages は
  圧縮表現に変更して記録するべきの気がしてきた…。

  mark&sweep 性能を考えるとスクロールバッファを
  先に圧縮表現に変更するべきだろうか。

  一番最初に属性の形式変更にかかるコストについて調べるべきの気がする。
  ansi/line では xflags/aflags の使用は限られている。
  - xflags の使用は select の時に reserved を使って
    % dirty を検出するのに使っている?
    % これは実は char_t の方の余った bit を使っても良いし、
    % というか width の余った bit を使うのが良い気がする。
    protected 等を調べるのに使っている。
    これは実は width の余った bit を使えば良いという気がする。
    (逆に言えば width に関しても書き込み時に attr を適用する必要があるという事?
    書き込み時に単にコピーするだけでは済まなくなってしまう。
    然し、実際にコピーする必要があるのかどうかというのも疑問。
    特に fill_attr として selected を継承する必要性?)

    或いは、selection について操作するのは限られた状況である
    という事を考えると多少コストが増えても仕方がない?
    と思ったが選択する度に大量の attr を生成するのは
    それはそれで避けたい気がする。後で上書き変更する可能性が
    ある物に関しては width 等に追い出すべきではないかという事。
  - aflags の使用は has_blinking_cell の検出に使っている。

  というか本当に attr の処理が重荷になっているのかどうか
  確かめる為には試しにコピーを省略して見るというのも手なのでは。
  或いは逆に attribute のメンバを増やして見る。

    660ms 8x4 = 32B (cell=40B) 増やした時
    641ms 5x4 = 20B (cell=28B) 現在
    623ms 3x4 = 12B (cell=20B) 減らした時1
    623ms 2x4 = 8B (cell=16B) 減らした時2
    618ms 1x4 = 4B (cell=12B)

  実はそれ程のインパクトはない? 比較や初期化を削っても変わらなかった。
  つまりここを複雑化しても高速化には寄与しない?

  別のテストケースで試した方が良いかもしれない。
  前回は改行主体だった。今度は文字主体。

    782ms 1x4 = 4B
    910ms 5x4 = 20B

  結構影響は出る様である。14% 影響が出ている。
  元々端末の処理自体にかかる計算時間が分からないので
  何とも言い難いがこれは比較的大きいのではないか。

* [考察] セルサイズを 4B+4B の 8B にまで圧縮する可能性 [#D0251]

  文字幅と selected に関しては文字の側に記録できないか。
  今確認した所、殆ど使い切っている。

  Unicode/iso-2022 の文字の記録の為に25bit使っている。
  これは頑張れば 23bit まで減らせるかもしれない。

  他に、is_object, marker, wide ext, cluster ext がある。
  そして private1, private2 である。

  例えば、marker/wide/cluster は排他的なので2bitで済む。
  それぞれ文字幅も確定している。zenkaku もこれに追加すれば
  取り敢えず hankaku/zenkaku/marker/wide/cluster の5種類を表現できる。
  或いは is_obj についても同じ枠組みの中で表現して良いのでは。
  例えば3bitで8種類を表現する

    marker  幅0
    wide    幅0
    cluster 幅0
    hankaku 幅1
    zenkaku 幅2
    obj1    幅1
    obj2    幅2
    objX    Extended

  obj に関しては結局外部に記録するのだから、
  ここに幅情報を入れておく意味はないのではないか?
  と思ったが line.hpp の処理で高速に処理する為には、
  やはり幅情報はできるだけセルの中に埋め込んでおきたい。
  後、考えてみたら iso2022 についても分類の一つと思って良いのでは。

  取り敢えず mono モードでは wide, hankaku, zenkaku, obj が来る?
  wide_extension の幅はどうなっているのか。これは 0 の筈。
  文字幅は本当に 012 に制限して良いのだろうか。
  例えば 2 bit 使って 0124 に対応するという手もある。

  幅0の時には marker/cluster/wide/obj の区別に 2 bit 必要である。
  幅が有限の時には実は obj/char の二種類しか区別はない?
  obj の詳細をもっと入れても良いのかもしれない。

  1bit は is_object に使っている (拡張属性などは)。

  もっと特別な文字幅になった時に
  処理速度が低下しないのかというのが心配である。
  またもし仮に将来的に proportional に対応するのだとしたら、
  現状の取り扱いだと全ての文字について extended data
  が紐づく事になり、それはそれでコストが高い。

  * 文字拡張と属性拡張

    結論: それぞれ独立に行うべき。

    extended data をどの様に管理するのかというのも
    考察が必要になる気がする。番号で参照する?
    mark&sweep で良いのか? 複数のセルで同じオブジェクトを
    参照する事は可能だろうか? (矩形操作でコピーなどができる)
    例えば sixel で一つの画像を複数のオブジェクトで共有する事にした方が効率が良い。
    その場合には属性部分には追加の補足情報(オブジェクトのどの部分か)を入れるのが良い気がする。

    a [棄却] 実は extended は文字単位・描画単位で管理するのではなくて
      cell 単位で管理する可能性は?
      描画属性は多くのセルで共有されると期待される一方で、
      文字属性は文字毎に異なる物になると思われる。
      そう考えるとやはり別々に管理するのが良い。

    b [棄却] cell の中に param を記録する案

      | 或いは一番上の bit に 1 が立っている場合には extended cell として、
      | struct cell_obj {
      |   obj& objref;
      |   u4t param;
      | };
      | struct obj {
      |   attr& attr;
      |   様々の情報
      | };
      | struct attr;
      |
      | の様にして属性値はオブジェクトの中に埋め込むという方法?
      | 然し、それはそれで対応が面倒な気がする。速度的にはどうだろう。
      | もし obj の頻度が小さくて描画の頻度も小さいのだとすれば、
      | 属性を obj の側に移すというのは悪くない様な気がする。
      | そもそも属性が必要になるのは描画の時であり、
      | 描画の時には obj 全体が必要になる。
      |
      | obj の中に attr を展開する可能性?
      | それだと大きなオブジェクトを書き出した時に結局
      | 全て値をコピーしたりする事になるので遅い。
      | そもそも属性を使う機会が少ないのであれば、
      | やはり参照で保持しておくべきの気がする。
      |
      | この方法だと複数のセルで obj を共有している時に、
      | セルごとに attr を指定する事ができない。
      | 何らかの制御機能で後になって部分的に属性を書き換える
      | 時に困った事になるのではないかという気がする。
      | obj でも有効にしたい属性はある。decdwl 系統は必要。
      | invisible も必要。反転も或いは使うと良いのだろう。
      | 特に選択した時に使う反転の事を考えるとセルごとに指定できるべき?
      | 一応 selected で対応できない事はないが、multiplexer として動作
      | している時には反転属性を指定するのではないか
      | (或いは既に反転させた後の状態で出力する方が良いのかもしれない)。
      | invisible に関しては送信する必要がある。copy&paste する時に
      | やはりそこに文字がないと困るからである。
      |
      | attr の代わりに param を記録する事の利点について考える必要がある。
      | オブジェクトは可変長である。従ってメモリ上に確保される。
      | うーん。或いは objref -> handle -> obj という感じに二段にして、
      | handle は固定長にして一括で確保できる様にして、
      | 更にその中に param の情報を記録する事にする?
      | そうすると objref の空間を食う気がするが一方で、
      | それを食い潰す程に沢山のオブジェクトが設置される事はないと考えて良い。
      | 何れにしてもメモリの事を考えればオブジェクトの数に
      | 上限は設定するべきという気がする。メモリの事を考える前に、
      | 現実的な描画時間を考えてもそうするべき。
      |
      | うーん。何れにしても objref (整数) から実際のポインタへ写像する
      | 必要があって、その為のテーブルが必ずあるのだから、其処に param を
      | 記録しておくのが妥当である。同時に参照カウントも其処に設定できる?
      | 参照カウントは管理が大変なので余り考えない。考えるとすれば、
      | mark&sweep の時に使う flag を其処で実行するというぐらい。
      |
      | コードの複雑さについても考えるべきではないか。
      | param の意味が切り替わる様な実装になっているとコードが複雑になる。
      | 属性を確認する時に毎回 obj flag をチェックする必要が出てくる。
      | そもそも external attr flag をチェックする事になっているのに、
      | 更にチェックする物が増えるのは実装としては複雑過ぎる。

      [まとめ] cell の中に param を記録する案

      * cell = (char, attr) であるが char の中に objflag がある時は、
        cell = (objref, param) とする案である。

        動機: 例えば sixel 画像の様に一つの大きなオブジェクトを様々な
        セルから参照する方が効率が良い場合がある。この時、各セルがその
        大きなオブジェクトのどの部分に相当するかの情報をセル自身が持っ
        ている必要がある。DCH,ICH,IRM SU,SDなど様々な編集の結果そのセ
        ルが元々どの部分だったのかをオブジェクトの側から何もなしに判定
        するのは不可能だからである。その情報をparamに格納するのである。

        Note: オブジェクトであっても属性は持つ。この案ではそれはオブジェ
        クト本体に記録する。オブジェクト本体には属性本体ではなく4Bの属
        性を持つ。本体を記録するとデータの読み書きに時間がかかるし、実
        際に属性を使用するのは描画の時だけなので参照がかさんでも気にな
        らない。

      x 属性をセル毎に管理していないので全てのセルが同じ属性に固定され
        る。属性を変更する様な制御機能に対して予期した結果にならないか
        もしれない。

      x 状況によって第二フィールドの意味が変わるので実装が複雑になる。

      x そもそも objref は整数値であり、整数から実際のポインタへの対応
        を管理するテーブルが何れにしても必要になる。param の情報はその
        テーブルに一緒に記録すれば良い。

      o objref の空間を節約できる。
        x 然し、31bit あれば十分なのではないか。そんなに沢山の obj が
          存在しても描画に非現実的な時間がかかるだけである。メモリ的に
          も最低数GB食う事になる。

    c cell = (char/objref, attr/attrref)
      やはり文字部分と属性部分はそれぞれ独立に拡張を行うのが良い。

  * 文字拡張の cluster と object は平等に取り扱う

    | 文字拡張で obj の場合には大体これで良い。obj は可変長にしてメモリに
    | 登録する。セルからは整数で参照する。整数からポインタへの対応のテーブ
    | ルを用意する。セルの位置情報などの補助データはそのテーブルに埋め込む。
    |
    | 文字拡張で grapheme cluster 等を取り扱う時にどの様にするのが良いか。
    | 現状の実装では独立したセルとして延々と一緒に行データに埋め込む事になっている。
    | 然し、属性データは cluster extension には不要である。
    | 文字だけを記録する様にしても良いのではないか。
    | 然しその為にはやはり文字拡張をして外部にデータを記録しなければならない。
    | 特に4Bに本体の文字と拡張データへの参照の両方を保持するのは不可能なので、
    | 結局4Bには外部に対する参照を保持する事になる。結局 grapheme cluster も
    | 独立したオブジェクトとして管理する事になるのだろうか。
    | それはそれで管理コストが高い気がする。毎回メモリを確保するという事になりはすまいか。
    | 或いは消滅したデータに関してはバッファを削除せずに残しておくという様にしても良い。
    | 然し、sixel の様なデータは物凄く巨大で一方で典型的には grapheme cluster は小さなデータである。
    | 再利用するとしてもこれらを混合していると非効率的である。或いは再利用する時のバッファの大きさに上限を決めておいて、
    | ある程度以上大きなバッファに関しては sweep 時に shrink/release する。
    |
    | * cluster table と obj table を分ける可能性
    |   然し、cluster は obj と違って様々な計算で中身を参照する機会が多いのでは?
    |   と思ったが本当だろうか。例えば term.cpp や line.cpp の実装で、
    |   実際の文字の中身の値を気にする事があるだろうか。
    |   或いは、それが文字かobjかで振る舞いを変更する事があるだろうか。
    |   うーん。取り敢えずはclusterもobjも区別せずに実装する様にしたい。

    結論: objとcluster は同じ枠組みで取り扱う。
    取り敢えず現状の cluster の取り扱いはそのままにして、
    先にobjを実装する。その後でobjの一形態としてclusterを実装する。

    データを記録するテーブルには vector を並べて置いて、
    その vector の buffer を使い回せば良い気がする。
    buffer がある程度よりも巨大である場合には適宜解放する。

    取り敢えずの実装として cluster/object は ref 空間を共有し、
    同じテーブルに記録する事にする。必要と分かればその時に初めて空間を分ける。

  * 文字幅情報の他に marker である事を明示的に保持する必要はあるか

    うーん。ttty でその文字を送信するかどうかの判定に使っている。
    確かに SDS や SRS を表現する特別な marker については勝手に送信すると困る。
    然し、それを言うならその他の零幅の文字も同様ではないか。
    また、Bidi の計算をする時に marker だけ特別に処理している。
    単に0幅であるだけでなく特別に処理する必要があるという事を示唆する flag なのである。

    と思ったが、振り仮名など特別な物を零幅で埋め込む可能性もある。
    取り敢えず今の所は marker flag は残しておいて良いという気がする。
    後になってもし不要そうであればその時に削除すれば良い。

  * 既定の文字幅 0124 に当て嵌まらない場合にどの様に取り扱うか。
    これは grapheme cluster と同じ取り扱いにすれば良い。
    何れにしても現在の実装では 0124 に当て嵌まらない文字幅は存在しない。
    今の所はこれで良い。

  まとめると文字幅 2bit は欲しい。全角の dwl がある事を考えると0124
  更に isobj(extended) flag が欲しい。他に ismarker flag があると良い。
  wide_extension に関してはそれ専用の marker にすれば良い気がする。
  cluster_extension はその内に廃止するが過渡実装では残す。

  取り敢えず 6bit? wide_extension の取り扱いを変更すれば 5bit。

2020-02-18

* [考察] 最適化: ボトルネックの調査 [#D0250]

  cell_t に含まれる属性を 4B に短縮する事に関連して、
  実際に何処がボトルネックになっているのかちゃんと調べる必要がある。

  * 何がボトルネックなのだろうか。

    | 通信自体にかかる処理時間についても確認しておく。
    | これは sequence decoder を弄って特定の範囲だけ
    | 処理せずにスキップする事にすれば良い?
    | と思ったが、実は DCS 等を使えば良いのでは。
    | PM を使って処理してみた所
    |
    | $ time { printf '\e^' ; cat yes3.txt; printf '\e\\'; }
    |
    | 630ms 程度であった。つまり、910ms の内の殆どは端末の外の処理時間で、
    | 残りの 280ms が端末の処理時間。そして属性を 20B -> 4B に減らすと
    | これが 150ms にまで減る。半分近くにまで減っている。
    | 全体の処理時間で殆どを占めるのはもっと前の段階なのだ。
    | PTY からの読み取り自体の問題かもしれない。
    |
    | select/poll にすれば改善するだろうか。
    | そもそも select/poll を使ったとして、read は本当にブロックしないのだろうか。
    | 指定したサイズのバッファを満たすまで待ってしまうという事があると意味がない。
    | 実は poll を使うとしても nonblocking にする必要があるのだとしたら、
    | この方向での性能改善は期待できない。サンプルを探したが分からない。
    |
    | うーん urxvt はどうしているかと思って select/poll/epoll で探すが
    | 一つも当たらない。NONBLOCK で検索すると init.C, rxvtd.C で実行している。
    | pty->pty 及び fd に大して実行しているので contra と同じ作戦?
    | read は command.C で行っている。
    | 結論としては urxvt は現状の contra と同じ作戦である。
    | 従って、urxvt の速さの秘訣はこの受信方法にある訳ではない。
    | やはり構造の単純さに起因するのだろうか。

    PM として受信して捨てるのと端末で処理する時の処理時間の違いは、
    yes hello world {1..25} (100k) に対しては 630/910 であった。
    端末処理は 280ms (attr 32bit の時は 150ms) しかない。
    yes (1M) に対しては 260/640 であった。

    →1. contraは改行が遅い 2. 受信にも時間がかかっている

    urxvt の受信方法について確認したが contra と同じ。

  * 少し読んで気付いたのだが本当に std::move は内部でバッファを交換しているのだろうか。

    | もしかしてもう一方のバッファを移してその後解放していたりはしないか。
    | 実際に capacity がどうなっているか確認してみた所、
    | capacity が交換されている訳ではない様な気がする。80 が 0 に変化している。
    | swap する様に変更したらどうなるだろうか。。
    |
    | そもそも std::vector の std::move の実装は一体どうなっているのか?
    | →実際に確認してみたところ解放されていた。
    |   つまり100万行出力すると100万回のメモリの開放と確保が行われるという事になる。
    |   うーん。これは確かに重い気がする。確認する。
    |
    | 実際に簡単なプログラムを書いて試してみた所、
    | 1M 回の確保解放に対して 1s ぐらいかかっている。
    | (contra 内部での処理と比べてずっと遅いのは何故?)
    | これが意味する所は1回の確保に平均で 1us かかっている。
    | 2000 cycle ぐらいは消費しているという事である。
    | これは体感としては遅い。何かテスト方法を間違えている気がしないでもない。
    | (最適化を忘れていた。最適化してみた所 400ms ぐらいに減った気がする。)
    |
    | 何れにしても contra では swap に変更して見る事にする。
    | →うーん。640ms -> 528ms にまで処理時間が減少した。
    | 然し、それでも tmux 403ms には及ばない。tmux は 140ms で端末処理をしている。
    | 一方で contra は未だ 268ms の時間をかけている。

    修正した。swap する様に変更した所、端末の処理時間は 70% になった。
    メモリの確保・解放は本当に遅いのだという事を実感した。

  * 簡単なプログラムで static-libgcc 及び libstdc++ を指定して見た所、
    少し性能が向上した。と思って contra でも試してみたが変化はない。
    後、ファイルサイズが物凄く大きくなった。12MB である。strip 後でも
    1M ぐらいの差がある (345k -> 1.2M)。良い事はないので static はやめる。
    march=native もそれ程には効果はない。微妙に効果があるかもしれないが、
    気のせいかもしれない。

    -DNDEBUG は指定してみたが違いは見られない。結構チェックの為の
    コードを挟んでいる様な気はするが余り気にしなくて良いのかもしれない。

    取り敢えず -march=native -Os にする事にする。

  * 現状では 528ms(term:268ms) だったが
    試しにこの状態で attr_t を 4B にして見ると
    482ms(term:222ms) にまで減少した。多少の効率化は望める?

    文字数が多いケースでは attr28=899(term:259)->attr4=760(term:120ms)
    の様に端末の処理自体が半減する。従って、やはり将来的には属性を
    ID で取り扱う様にするというのに対応したい気がする。

  * 他に何処が計算時間を食っているのだろう。

    contra::encoding::utf8_decode(data, data + size, q1, q0 + size, w_printt_state);
    の部分を while (size--) *q1++ = *data++; に置き換えてみたが、
    これに関しては 20ms しか減少しなかった。つまり、余り関係なさそう。

    やはり sequence_decoder が遅いという可能性はあるだろうか。
    通常状態で通常文字が連続できた時にまとめて処理する機能。
    改行主体のデータでこれをコメントアウトしても 16ms 程度しか改善しない。
    一方で文字主体のデータの場合には 500ms も処理時間が増えたので、
    これに関してはそのままで良い。

    sequence_decoder で PM の時だけ先に検出してスキップする様にした所、
    640ms->585ms に減少した。更に改行も確認する。583ms
    # Note: 以下を sequence_decoder::decode に挿し込んで確認した。
    # if (m_dstate == decode_command_string && *beg!='\x1b'&&*beg!='\\') {beg++;continue;}
    うーん。これが意味する所は何かというと…。少なくとも 10% ぐらいは
    sequence decoder で食っているという事。

    うーん。default の時に CR LF が来たらどう処理されるのか辿ってみたが
    これは確かに面倒な事になっている。先ず初めに default と判定したら
    いきなり process default に入って良い気がする。
    取り敢えずこの修正で 528ms->505ms にまで短くなった。

    今の sequence_decoder の処理では一文字受信する毎に
    switch で現在の状態に入っていくが、これはいかにも遅い。
    書き直したほうが良い気がする。

  * rxvt のコードで ecb_* という変な物がたくさん使われている。
    ソースコードを検索しても定義が見つからない。
    どうやら ecb.h というヘッダを読み込んでいる様だ。
    調べると ecb.h には様々なコンパイラ特有の機能がマクロで定義されている。
    ecb_unlikely 等は最適化の時の分岐予測に供するために使われている。
    (if_unlikely 等の方が実は分かりやすいのではないかとも思ったが、色々)

  [まとめ]

  各部分の時間を計測してボトルネックを探す必要がある。端末処理以外の部
  分でも処理に結構時間がかかっている。端末の処理部分を除外するには例え
  ば PM で大量のデータを送信する等が考えられる。

  sequence_decoder 及び scroll_buffer に関連して多少修正した。幾らか速
  く動作する様になった。属性値の大きさは確かに影響がある。文字主体の内
  容の場合、端末処理部分だけ見れば2倍の速度差になる事もある (もしPMに
  変えて正しく端末部分の処理時間を計測できていれば)。

  現状で改行主体(y x 1M)の場合は最短505msでPMに変えると260msである。属
  性を4Bに短縮すれば更に60ms程度短縮できる気がする。因みにurxvtの処理
  速度は403msである。

2020-02-17

* [考察] 最適化: メモリ効率・処理効率の観点からのデータ構造 [#D0249]

  線の色 SGR(58;59) に対応するに当たって。
  このまま無節操に拡張し続けて良いのだろうか。

  メモリの使用量が増えるだけでなく行の
  初期化・文字コピーもどんどん遅くなる。
  或いは data stream のままで行データを保持する可能性?

  | | 拡張して行くとどんどんメモリ的にきつくなっていく。
  | | ここで思うのは制御機能をフルに解析する必要があるのだろうかという事。
  | | 表示する時もしくは何らかの特別な動作が必要になるまで
  | | 遅延させる事も可能なのではないだろうか。
  | |
  | | そしてそうする必要が生じる迄は data stream の形で保持しておく。
  | | 現在の実装だと文字+文字幅(8B)更に属性(8B)+色(8B)で、
  | | 今度線の色も付加すれば(4B)更に増える。28B(uchar 7文字分)である。
  | | もし解析を遅延させる事にすれば、そしてUTF-8 decodeすらさぼれば、
  | | メモリ使用量は実に1/28になる。もし日本語が混ざっていたとしても、
  | | メモリ使用量は1/9である。問題はどういう形式でそれを記録するのかという事。
  | | 行頭に於ける属性は記録しておかないといけないのでは。
  | | と思ったが属性を追跡していないのでこれは難しい。
  | | 従って属性まで欲しければ結局全て解析しなければならない。
  | | 属性の変更がない範囲で大量のデータを処理して、
  | | buffer から逃げた分の処理が省略できるという可能性があるが、
  | | そう言った状況は限られているし、それでどれだけ早くなるのかも分からない。
  |
  | * セルのデータ量がどんどん大きくなる。
  |   装飾色を実装すれば28Bである。無駄が多い。
  |
  | * data stream のままでデータを保持すれば処理も高速では。
  |   特に行データの初期化時間を稼げる気がする。
  |   ? 然し、現在の属性まで計算するには結局真面目な解析が必要なので
  |     処理の高速化には大してならないのではないか。
  |   o データ量は少なくて済む気がする。
  |   x 処理が複雑になる気がする。
  |
  | * 現状で cluster extension 等を保持しているのだから
  |   拡張属性については適当にオブジェクトを埋め込んでも良いのでは。
  |
  |   x cluster extension は特定の文字にしか適用されない。
  |     一方でSGRは受信する全ての文字に影響を与える物である。
  |     拡張属性を持つ場合、全ての文字の後ろに extension がつく
  |     事になりこれは非効率的である様に思われる。
  |     →然し特別な属性を使用する機会は少ない。
  |     そもそも特にこの項目で議論したいのは最悪時の処理量は
  |     多少増えても良いからよくあるケースでの最適化する事である。
  |
  | * 現在の設定の時点でかなりメモリを食らう気がする。
  |   COLUMNS=174 である。今は大きめに表示しているからこうだが
  |   以前の設定では210ぐらいだった。
  |   そして 5000 のスクロールバッファを用意するとすると、
  |   文字セルの数は 1M に達する。1セルに24B使っていると、
  |   24MB食うことになる。変だ。何故メモリをそんなに食っていないのか?
  |
  |   →確認した所 contra が 15MB 食っている。
  |   現在のスクロールバッファの設定は 1000 である。
  |   これは恐らく全てスクロールバッファである…。
  |   もしこれを 10000 に増やせば 10 倍に増えて 150MB になるという事。
  |   多すぎである。スクロールバッファにデータを入れる時に
  |   制御列による形式に変換するという手もあるが、それだと今度は動作が遅くなる。
  |   或いはスクロールバッファはファイルに書き込んでしまう?
  |   然しそうだとしても変換するコストがあるのは変わらない。

  [メモリ使用量の問題]

  改めて整理する。

  | * mintty で確認した。スクロールバッファは 10000 行である。
  |   起動時 5.8MB で以下を実行した後のメモリ使用量は 7.8MB である。
  |   $ yes $(seq 66) | head -10000
  |   以下を実行しても 8.1MB で遡ればちゃんと全て残っている。
  |   $ yes $(seq 63) | head -10000 | cat -n
  |   横幅は 189 である。
  |   文字数は 2M ある筈である。それなのにメモリ使用量は 7.8MB。
  |   これが示唆する事は何かというと mintty はスクロールバッファに
  |   必要再最小限のデータしか出力していないという事。
  |   或いはファイルにデータを書き出している。
  |
  |   それでも十分な速度が出ているというのは逆に言えば驚きである。
  |
  |   contra で同じ事を試すと起動時に3.5MBで1000行出力して8.5MBになった。
  |   10000行のスクロールバッファにしたら50MBになると予想される。
  |   これは一セル24Bである事を考えると計算通りである。
  |
  | うーん。mintty 方式が断然賢い気がしてきた。
  | これならセルのデータサイズを気にする必要もなくなる。
  | 速度が遅くなる気もするがまあ仕方がない。
  | 他の端末は一体どの様にしているのだろうか。
  |
  | * 例えば RLogin はどうだろうか。RLogin は 10k lines で 5.7->10MB になった。
  |   うーん。RLogin もスクロールバッファを変換して保持しているという事だろうか。
  | * urxvt は 8.1->10.5MB with 1k lines。安心した。
  |   これは contra と同じ様にデータを保持していると思われる。
  | * xterm は 7.1->20.3MB with 1k lines。これはやばい。
  | * contra は 3.8->8.5MB with 1k lines
  |
  | 以下にスクロールバッファ1行辺りのデータ量
  |   mintty   200B
  |   RLogin   430B
  |   urxvt   2400B
  |   contra  4700B ~ 200x24
  |   xterm  13200B
  |
  | 本当に mintty は中で変換しているのだろうか。
  | 実は初めからそういうコンパクトな表現になっている可能性は?
  | 丁度HTMLの様に複雑な構造でデータを保持している可能性。
  | 然し、よく考えてみれば前に mintty を確認した時には
  | そういった事は気づかなかった。複雑な木構造でデータを保持していたら
  | 内部構造を調べる時に気づくかそうでなければ内部構造が全く分からなかった筈。
  | という事はやはりスクロールバッファに移す時に変換をしている。
  |
  | ソースコードを見た。簡単に見つかった。
  | termline.c の最初に RLE-based compression をしていると書いている。。
  | makeliteral_chr, makeliteral_attr を使って圧縮を行っている。
  | makeliteral_chr は文字を3B以内に抑える様に頑張っている。うーん。
  | 特にエスケープシーケンスに変換する等の処置をしているという訳ではないのだ。
  |
  | つまり本当に表現を圧縮している。
  | 先ず文字は殆どの場合 ASCII である事を使って１Bにしている。
  | 属性に関しては殆どの場合無属性であるか或いは連続している
  | 事を用いてRLE圧縮している。

  mintty はメモリを節約する為に表現を簡単化して
  スクロールバッファに記録している。色もできるだけ圧縮している。
  メモリ使用量を観察する限り RLogin も同様の処理を実行している。
  そう考えるとセルデータが増大しても気にならないのかもしれない。
  速度がこれでどれだけ低下するのかについては考察が必要。

  逆にこの処理をしている限りはセルデータが大きくなっても
  そんなに気にならないという事なのだろう。
  然し色々考えるとだからと言って無節操に増やす訳には行かない。
  最近はディスプレイの高解像度化も進んでいるし画面分割も流行している。

  * 属性の様に複数のセルで共通になる可能性の高いものは
    別の場所に記録してインデックスで管理するという手もある。
    どうせ参照するのは描画時だけなのだから。

    x しかし、そうすると参照カウント等を管理しなければならない。
      + 或いは行単位で mark&sweep を実行しても良いし、
      + いっその事、確保したら解放しないという形式でも良い。
        行の初期化と一緒に消去されるのであるから。

        但し、行単位にすると行毎に必ず初期化しなければならないので、
        大量に改行を含むデータの時にはそれでも遅い。

      + 全体で確保して解放しないという手もある。
        自分の位置に対応する属性は必ず他の物が使っている事はない。
        と思ったがこれは駄目。他のセルが参照している時に上書きすると
        他のセルも一緒に影響を受けてしまう。なので mark&sweep するか
        空きセルのリストを作っておく必要がある。そして空きセルを
        管理するのだとすれば参照カウントを計算しなければならない。

    やはり管理コストを増やすぐらいであれば、
    巨大な属性を毎回初期化・コピーする方が良いのだろうか。

  [ASCII 直接処理による最適化]

  | * うーん。取り敢えず ASCII の範囲内であれば decode を省略できるという可能性はあるが…。
  |   然し、それだとUTF-8依存になってしまって良くない。
  |   現在の処理はどうなっているかと言うと、
  |   bytes -> [UTF-8 Decoder] -> chars
  |     -> [ESC Decoder] -> chars, controls, etc.
  |   という具合になっている。[UTF-8 Decoder] に入る前に
  |   処理を横取りする為には、[UTF-8 Decoder]や[ESC Decoder]
  |   にASCIIがそのまま通過する状態かどうかを問い合わせる必要がある。
  |   もしそのまま通過する状態であればいきなり insert_graphs を呼び出せる。

  * 高速化という観点からは CharDecoder 及び EscDecoder が
    普通の状態であれば ASCII 及び幾つかの一般的な制御機能 (CR LF HT)
    だけは直接高速に処理するという事を考えても良い気がする。

  考えてみたがこれはまた別の問題である。

  data stream の形式で保持するというのはデータの圧縮にもなるかもしれないが、
  それよりは処理を遅延して無駄な計算はしないという事の利点の方が有効である。
  然し、本当にそれによって高速化するのかというのは怪しい。

2020-02-15

* [考察] bit fields を使う可能性について [#D0248]

  bit 演算の面倒な所は、

  * 直に bit 演算で書いているとミスをする可能性が残る。
  * 複数 bit 幅を持つ要素の場合に記述が煩雑。
    毎回 a = (a & ~mask) | item1 と書かなければならないし、
    mask の型は元の型に合わせて置かなければならない。
  * どういうビット構成にしているのか丁寧に記録して
    置かなければ分からなくなる。

  bit fields の不便な所は、

  * 初期化の際に a| b | c の様にインラインで記述できないという事。
  * bit fields の配列にする事ができない事。
    例えば以下の様な操作は結局自分でビット演算で書かなければならない。
      shift = 2 * index;
      a = (a & ~(mask << shift)) | item1 << shift;
  * 唯値を取り出したいだけなのに内部的に shift まで実行される事。
    例えば (a & mask) == item1 をしたい時に、bit fields だと、
    (a >> shift & Mask) == Item1 という計算になる。

  勿論自分で便利なクラスを定義する事も可能かもしれないが際限がない。
  余りにその場だけの抽象化しても読むのが大変になるだけである。
  広く使える抽象化であれば問題はないが。

  取り敢えず現状のままにする。

* 何と xpixel と ypixel を今まで勘違いしていた [#D0247]
  文字の縦横の大きさだと思っていたが、実は画面全体の縦横の大きさらしい。
  →実際に RLogin でも動作を確認した。文字表示領域のサイズを返してくる。

  プログラム中の xpixel, ypixel は全て xunit, yunit に改名した。
  同時に ws_xpixel, ws_ypixel を設定・読み取りしている箇所に変換を入れた。
  書き換えは実は簡単だった。疎結合だった。

* Kitty/mintty の styled underlines (\e[4:0m..\e[4:5m) に対応した [#D0246]
  mintty の 73..75 による PLD/PLU の設定にも対応した。

* [OK] render: 行の方向性が変更になった時にちゃんと再描画されるのか? [#D0245]
  と思ったがセル内容が変化すれば再描画される。
  現在は描画内容はセル内容だけに依っていて、
  方向性に依存した修飾などはないので気にしなくて良い。

  (本来は回転方向などに気をつけなければならないのかもしれない?
  と思ったが回転方向は文書の方向とは関係なく定義されているので、
  これについても気にしなくて良い。)

* impl1-test に失敗している [#D0244]

  impl1.cpp:399
  result: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@r
  expect: @@@@@@@@@@@@@@@@@@@@@@rqpoefhgijlkmndcba

  何かと思ったら 11cc275 で壊れている。
  11cc275 では SPD の表示に対応している。
  テストケース impl1:399 を確認する。
    \r\x1b[2Kab\x1b[2]cd\x1b[1]ef\x1b[2]gh\x1b[0]ij\x1b[2]kl\x1b[0]mn\x1b[0]op\x1b[0]qr
    CR EL(2) ab SDS(2) cd SDS(1) ef
    SDS(2) gh SDS(0) ij SDS(2) kl SDS(0)
    mn SDS(0) op SDS(0) qr

    ab [cd [ef [gh] ij [kl] mn] op] qr

  という具合になる。結果として以下の様になる筈。

    rq[op[ef[hg]ij[lk]mn]dc]ba

  テストケースは正しい気がする。というか今までちゃんと動いていたのだとしたら、
  SPD は単に既存のちゃんと動いていた物を破壊したのに過ぎない?
  じゃあ SPD では一体何に対応したのだったのか。
  確かに何かに対応できていなくて新しくそれに対応した筈だった。


  * get_cells_in_presentation
    記録を見てみると mono は対応したが prop は適当に対応したと書かれている。
    どういう事か。見た所そんなに大きく変更はしていないが処理を多少変更している。
    というかどういうアルゴリズムで動いているのか分からない。
    改めてどう動いているのか読む必要がある。

    1 取り敢えず data component で順番に文字を読んでいく。
      開始マーカーが現れたら _push する。
      終了マーカーが現れたら対応する物が現れる迄 _pop する。
      NUL が現れるか行幅に達したら全て _pop する。

    2 文字の挿入は以下の様に行う。現在が r2l context の時、
      最後に reverse するという事を見越して extension は逆順に挿入する。
      つまり、data: C1 C2 X1 X2 X3 に対して最終的に C2 X1 X2 X3 C1 を得たいので、
      取り敢えず C1 X3 X2 X1 C2 となる様に挿入を行いたい。

      x fixed: うーん。これ間違っている。C1 C2 の次に C1 X1 C2 になる迄は良いが、
        その後 C1 X1 X2 C2 / C1 X1 X2 X3 C2 等となってしまう。
        "取り敢えず前の文字に移動して、それから X が左にある限り後退する"
        というのが正しい実装である。

    うーん。実装は正しい気がする。最後に fill する所で幅を間違えている?
    うーん。不思議だ。と思っていたらそもそも get_cells_in_presentation が
    テスト中に呼び出されていない。どうも to_data_posision を使って変換している?

  * to_data_position 及び convert_position の実装を見る。
    うーん。この実装を見る限りは to_data_position,
    to_presentation_position という関数は実際の x,y 座標を変換するというよりは、
    presentation 座標(行・列)を変換するという実装である。
    つまり、前の実装の修正は不要だった。

  代わりにマウスで選択する時に先に x,y を l,c に変換するべきだったのだ。

  その様に考えると get_cells_in_presentation の関数名は変更するべき気がする。
  SPD の時にはそれに応じて反転した内容が取得される様になっているからである。
  うーん。まあ取り敢えずこれで良いのだろうか…。
  →やはりちゃんと様々な座標でセルを取得できる様に改良した。

  x fixed: 選択範囲が変だ。常に列2になってしまっている。関数の引数を間違えている?
    →古い同名の関数が呼び出されていた。edge_type も指定しなければならない。
  x fixed: カーソルの表示位置がずれている。これも変換しなければならない。

2020-02-13

* ansi: contra のキーボード入力の振る舞いは xterm のそれと微妙に異なる [#D0243]
  時々キーボードが効かなくなる。
  xterm がどの様に振る舞うのか詳細に調べる必要がある気がする。

  xterm には様々な設定の項目が存在している。
  modify*Keys もそうだし、DECSET(1050..1061) もそうである。

  * done: DECSET(1050..1061) は対応した。
  * done: DECKPAM の時の kp keys に対応した。
  * done: DECBKM に対応。

  * modify*Keys の振る舞いはどうなっているのか。
    これは文献は端末によって振る舞いが全然違う気がする。

    先ず CSI > Ps1 ; PS2 m の Ps1 について。
    RLogin は以下の様に説明している。
      Ps1 = 1: modifyCursorKeys (cursor keys)
      Ps1 = 2: modifyFunctionKeys (fn keys)
      Ps1 = 3: modifyKeypadKeys (kp keys)
      Ps1 = 4: modifyOtherKeys (ESC, RET, BS, TAB, SP)
      Ps1 = 5: modifyStringKeys
    xterm は 0,1,2,4 しかない。
      Ps1 = 0: modifyKeyboard

    詳細は escseq.html にまとめた。

  実際に動かしてみると全然動いていない。

  x fixed: 1050..1061 で矢印キー等が全く何も送信しない。
    →これは最後に return pc_style... を呼び出すのを忘れていた。
  x fixed: \e[>n が効いていない気がする。
  x fixed: \e[>2n で fn shift が効いていない。
  x fixed: \e[>2n の時の番号がずれている。
  o ok: \e[>3n, \e[>3;Xm は動いている。
  x fixed: \e[>4n だと C-q だとか普通の物まで修飾が消滅している。
    然し、この取り扱いは違う気がする。実際に xterm ではその様な振る舞いはしていない。
  x fixed: \e[>4n で C-S-q が q になってしまう。C-q になるべき。修正した。

  更に改めて xterm を動かして気付いたのだが、
  x 既存の f21..f24 は間違っている。
  x 上で直した \e[>2n の番号のずれは実はずれていなかった。

* ansi: DECKPAM の時の kp keys [#D0242]

  実装していて気付いたが kp の DECKPAM に対応していない気がする。
  SM の時 AM である。既定では false にしている。
  SM にして見る。やはり何も入力できない状態になる。
  但し、home 等は動く様である。うーん。

  取り敢えず実装した。xterm default の pc-style function-key の時は
  kp0,kpdec,kp1..9 はそれぞれ DECKPAM の時、ins,del,home..next
  のエスケープシーケンスを送る様だが、その処理は contra ではもっと
  前の段階で実施している。ここで function key に翻訳する必要はない。
  従って、vt220 モードと同様に kp0..kp9 をそれ専用の絵シーケンスで
  符号化して送る実装にする事にした。

* ansi: support function-key modes [#D0241]

  | 他に DECSET 1051..1053, 1060,1061 が存在している。
  | 愚直に考えるとこれだけで 32 パターンある。
  |
  | 先ずそれぞれの状態が排他的なのかどうか調べる必要がある。
  | * 然し、1052,1053 について DECRQM すると存在しないという返事。
  |   どういう事か。xterm version は 348 である。
  |   →xterm のマニュアルに hp-style function key (1052) はコンパイルできる、
  |   と書かれているので既定ではコンパイルされないという事なのだろう。
  | * 初期状態は 1051,1060,1061 何れも RM である。
  |   1060 と 1061 は排他的である。一方を set すると他方は reset される。
  | * また面白い事にどちらをクリアしようとしても両方 reset される。
  |   →この振る舞いは他の mouse のモードと同じの様だ。
  | * 1060,1061と1050,1051も排他的だった。

  1050,...,1061 に関しては全て排他的と考えて良いだろう。

* tx11: 文字の大きさの調整 [#D0240]

  前に調整した時には自体が詰まって見えたがこれは
  使っているフォントに依存するようである。
  設定として tx11_font_padding で調整できる様にした。
  (本当はフォント毎に調整できる様にするべきなのかもしれない)

2020-02-06

* tx11: high DPI で小さい [#D0239]
  そもそも X11 で DPI を取得する事は可能なのだろうか。

  色々調べたが Xft.dpi という Xresource で取得できるらしい。
  然し、Xresource で検索してもユーザ設定の話しか出てこない。
  アプリケーション側で取得する方法が見つからない。
  https://stackoverflow.com/q/54377212/4908404 によると、
  XGetDefault(display, "Xft", "dpi");
  または XResourceManagerString/XrmGetStringDatabase/XrmGetResource
  を使うらしい。何故二種類の方法がある? 前者と後者の違いは何だろうか。
  前者に罠があったりしないのだろうか?

  | 分からないが取り敢えず前者で試してみる事にする。
  | https://github.com/Oblomov/xdpi/blob/master/xdpi.c#L345-L354
  | に実際に使っている例がある。文字列で取得できる様だ。
  |
  | →実際に試してみた所、値は取得できなかった。
  |   XGetDefault(display, "Xft", "dpi") は NULL を返してくる。
  |
  | どうも自分で設定しなければならない?
  | 設定の方法は? ファイルを書いて読み込ませなければならないらしい。
  | https://docstore.mik.ua/orelly/unix3/upt/ch06_08.htm
  |
  | 適当に ~/.Xresources を作成する。コメントは ! だそうだ。
  |   ! High DPI
  |   Xft.dpi: 144
  |
  | ファイルを読み込む。
  | $ xrdb -merge ~/.Xresources
  |
  | 現在登録されている項目を見ようと思って以下を実行してみると、
  | 実は何も登録されていなかったのだという事が判明した。
  | $ xrdb -query

  取り敢えず dpi は取得できる様になって配置もちゃんと大きくなったが、
  どうもフォントサイズがおかしい。小さいままだ。
  →フォントサイズの更新も一緒にしなければならなかった。
    修正した。動く様になった。

2020-02-05

* 2019-05-03 twin: DECARM (キー長押しによる連続入力) の制御は面倒だ [#D0238]
  そもそも対応する意味があるのかもよく分からない。
  長押しで連続入力できるのが普通の感覚である。
  →これは対応した。

  WM_KEYDOWN の lParam に含まれる下位15bit repeat count は
  実は今迄の autorepeat の回数ではなくて、処理しきれなかった repeat を一つの
  message にまとめた時に使われるだけの様だ。
  つまり、処理が重くない限りは常にこれは 1 である。使えない。

  代わりに autorepeat の時には keyup が呼び出されない事を利用した。

  * tx11: autorepeat 検出 (modifier_autorepeat を付ける)

    https://stackoverflow.com/questions/2100654/ignore-auto-repeat-in-x11-applications
    https://stackoverflow.com/questions/39939478/x11-key-held-down-leads-to-key-pressed-and-released
    XkbSetDetectableAutoRepeat を呼び出して置けば KeyRelease が発行されなくなるとの事。

    以下 (X11R6 12.7) によると KeyCode は [8,255] の範囲に入る。
    https://tronche.com/gui/x/xlib/input/keyboard-encoding.html
    →と思ったらそもそも KeyCode は (unsigned?) char だった。

    twin と全く同じ作戦で行けそうな気がする。実装した。
    動かないと思ったら KeyRelease から関数を呼び出すのを忘れていた。
    と思ったがやはり動かない。調べるとそもそも KeyRelease が来ていない。
    調べたら KeyReleaseMask を忘れていた。多分これで動く。

* [対応済] 2019-05-03 twin: C-scroll で文字の大きさを変更したい [#D0237]
  文字の大きさの変更に関しても端末に通知する。
  確認したら mintty はこの機能に対応している。

* [対応済] 2019-05-03 twin/draw: 高速化(部分描画に対応する) [#D0236]
  今までは行の高さを求める等の事を考えていたが面倒すぎる。
  特に新しく描画する行に関しては行の高さを求めてから被る先を決定しなければならないが、
  行の高さを求めるだけでもかなり処理が必要になるのではないか。
  その様に考えるともう一つの代替案として、隣の行までは一律に被る可能性があるとしてしまう事。

* [対応済] 2019-05-03 ansi: マウス機能 [#D0235]
  これは Poderosa に前に実装したのがある。

* [対応済] 2019-04-30 twin: ダブルクリックで起動すると一瞬で終了する [#D0234]
  多分、途中で何かのエラーが起こってそれで終了しているのだと思う。
  ファイル等に出力しながら何処で止まっているかを探る必要がある。

* [対応済] 2019-04-29 ansi: IRM 対応。vttest (8) の insert mode が A...A になってしまう [#D0233]
  これは SM(4) を実行していた。IRM である。対応していない。

* [対応済] 2019-04-28 カーソル形状等に関しては表示の瞬間に前回と変更がないかを見て変更すれば良い [#D0232]
  また decscnm (背景・前景反転) に関しても。描画の瞬間にチェックすれば良い。

* ansi: Mode 2 と 12 に殆どの端末が対応している [#D0231]

  Mode 2 は "一部の端末入力を有効・無効にする" という曖昧な物だ。
  具体的にどのような実装になっているかは xterm にでも従えば良い。
  と思ったが xterm には何の説明も書かれていない。
  RLogin の説明によるとキー入力を無視・有効と書かれている。
  これが意味するところはあらゆるキー入力を受け付けなくなるという事だろうか。
  →試してみた所、実際にそうなった。あらゆるキーが消滅している…。
    これは危ない機能である。fuzz したら簡単に引っ掛けそうである。

  Mode 12 はローカルエコーと書かれている。
  ローカルエコーに関してはどうもキーのエスケープシーケンスも含めて
  その場で端末の入力になる様である。これらのモードが一体何の役に立つのかは謎だが、
  或いは端末のテストをするのに使えるという事なのかもしれない。
  取り敢えず対応してみる事にする。

  対応した。取り敢えず同様に振る舞っている気がする。OK

* ok: do_insert_graph: 現在の実装だと最初のカーソル位置で決まった [#D0230]
  slh, sll が次の行に行っても保持されたままになるのでは。
  次の行に行ったら改めて slh, sll を計算するべきの気がする。

  →と思ったらちゃんと _next_line の中で
    改めて slh, sll を計算し直していた。OK

* ok: do_ich_impl で HEM の時、x1 + 1 と指定しているが [#D0229]
  ここは x1 + char_width であるべきではないのか。

  結論: SIMD の時は文字挿入が x1+1 を右端として行われるのでこれで良い。

  | というよりそもそも他の実装では全角文字等がある時にどの様に実装しているのか?
  | RLogin で試してみた所そもそも Mode 10 HEM に対応していない。
  | xterm も試してみたが対応していない。mintty も対応していない。
  | もしかして機能を勘違いしている? screen も対応していない。
  | contra では動いているのでテストケースが間違っているという訳ではない。
  |
  | xterm のマニュアルを見ると Mode 2, 4, 12, 20 しか対応していない様だ。
  | RLogin は 2, 4, 6, 12, 18, 20 に対応している。
  | mintty はマニュアルがない。ソースコードを見ろと書かれている。
  | 以下の部分を見ると 4, 8, 12, 20, 33, 34 に対応している。
  | https://github.com/mintty/mintty/blob/master/src/termout.c#L1864-L1887
  | screen は 4, 20, 34 に対応している。こうして見た所、10 を実装している端末はない。
  | Tera Term は 2, 4, 12, 20, 33, 34 に対応している。
  | mlterm は検索したがシーケンスの頁がないので例によってソースコードを見る。
  | 2, 4, 12, 20, 33, 34 で Tera Term と同じ。
  | urxvt はシーケンスの頁があるのに SM/RM の解説がない?
  | と思ったら 4, 20(部分対応) しか対応していないので見落としていた。
  |
  | 結局世の中には HEM に対応している端末はない。
  | もし対応している物があったとしてもそれを標準としなくても良い。

  では自然さという観点から考えると HEM でどの様に対応するべきだろうか。
  →何れにしても文字挿入は x1 + 1 を右端とする様に行われる。
  という事を考えると現在の実装通りそこにある文字に拘らず x1 + 1 からずらすべき。
  もし其処に文字があればその文字は消去される。

  否、しかしよく考えたら文字挿入で x1+1 を右端とするのは SIMD の時だけである。
  そしてSIMDに実装しているケースは少ない。
  問題は HEM(PRECEDING) を SIMD(0) で使う事があるのかという事。
  それはどの様な場合なのかという事。或いは単に文字挿入とは関係なく、
  空白の領域を確保するのが目的という事?
  その様に考えると其処にある文字に関係なく領域を確保したいから、
  結局はやはり x1 + 1 を右端として挿入するとするのが自然の気がする。

* 2020-01-07 FreeBSD にログインしたら振る舞いが変だ [#D0228]
  bash の編集で先頭に戻って文字列を挿入しても上書きになる。
  FreeBSD の term 機能で DCH か ECH かその他で実装されていない物が使われている?
  少なくとも他の terminal では動いている (と思ったが console でしか試していない)。

  然し、DCH も ICH も実装している筈。だとすると IRM だろうか。
  実際に確認してみると IRM は未実装である。実装してみる事にしようか。
  どの様な物を実装する必要があるだろうか。既に文字を挿入する機能は実装した様な気もする。

  line.hpp を見ると以下の様な関数が用意されている。
  これらの関数を用いて文字を挿入すれば良いのではないだろうか。
    void write_cells(curpos_t x, cell_t const* cell, int count, int repeat, int implicit_move);
    void insert_cells(curpos_t x, cell_t const* cell, int count, int repeat);
    void delete_cells(curpos_t x1, curpos_t x2);
    void replace_cells(curpos_t x1, curpos_t x2, cell_t const* cell, int count, int repeat, int implicit_move);
  そもそも現在の実装では文字の書き込みはどの様に処理しているのだったか。
    term.cpp の do_insert_graph 及び do_insert_graphs という関数で実装している。
    中では write_cells を用いて書き込みをしている。

  色々振る舞いについて確認する必要がある。

  | ? そもそも write_cells が引数に implicit_move を受け取っている理由は何か?
  |   境界上の零幅文字を残すか削除するかを判定するのに使っている。それだけ。
  |
  | ? 実装を辿っていくと _prop_lub に行き着く。
  |   これは一体どういう関数だったか。もう思い出せない。
  |   そして結構複雑な事をしている筈なのに何の説明もない。
  |   →取り敢えず説明を書いた。
  |
  | ? IRM を実装するとしても暗黙的移動が逆方向になっている場合はどの様に振る舞うべきか。
  |   またその他の左右の方向性はどの様に取り扱うべきだろうか。
  |   取り敢えずデータ部での話なので暗黙的移動だけ意識すれば良い気がする。
  |   暗黙的移動の向きは SIMD で変わる。他の部分で SIMD をどの様に参照しているか確認する。
  |   特に do_insert_graphs? でどうやっているかを確認する。
  |
  | ? do_insert_graphs でちゃんと暗黙的移動の実装が行われているだろうか?
  |   調べてみると書き込みの前に reverse している。
  |   そんな実装で良いのだろうかと思ってよく見るとそもそも零幅文字の書き込みに対応していない。
  |
  | ? HEM の影響は受けないのだろうか。これも確認する必要がある。
  |   調べてみたが影響は受けなそうな雰囲気である。
  |
  | ? insert_cells が implicit_move を受け取らない理由は何か。
  |   これは調べてみると内部で implicit_move = 0 にしている。
  |   この時にどう振る舞うかというと零幅文字の左側を挿入点とする。
  |   この振る舞いは自然だろうか。ある位置に挿入を実施しようとした時に、
  |   何故右側でなく左側なのか。
  |   因みに現在の実装だと implicit_move > 0 だと零幅文字の右側になる。
  |
  |   →これは範囲 [...] の末尾に追記しようとした時にちゃんと範囲の
  |     内側に追記される事を保証する為である。
  |     逆に範囲の先頭に文字列を挿入するのはこの仕様ではできなくなる。
  |   →考えるにそもそも挿入して編集しようという事自体が
  |     余り良い方策ではない。端末では零幅文字の間の位置を制御する方法が
  |     与えられていないからである。もしくは一般的な端末では、
  |     文字単位の移動ではなく座標位置単位の移動になっている。
  |   →うーん。然し、IRM off の時の振る舞いを考えるとやはり
  |     零幅文字の右側に挿入するべきの気がする。
  |     insert_cells が何処で使われているか確認する。
  |     と思って確認してみた所一箇所でしか使われていない。
  |     なる程。よく考えたら ICH 等を使っている時でも右端
  |     から出て行った文字列を消去しなければならないので、
  |     単に insert_cells を呼び出せば良いという訳ではないのである。

  A IRMの時は HEM(PRECEDING) と同様の動きにしたい。
  A do_insert_graphs は零幅文字の書き込みに対応していないので SIMD の時は単に順序を反転する。
  A HEM の影響はない。
  A insert_cells は単純過ぎる。shift_cells を用いて実装する。

  do_ich_impl を流用しようとしたが色々分からなくなった。
  そもそも文字挿入は dcsm で実行する物だから余り細かい事は考えなくて良い。
  等と考えて単純化して行くと結局 do_ich_impl を経由しない方が楽だ。
  という訳なので、do_ich_impl に対して行った変更は忘れる事にする。

  取り敢えず実装した。SIMD の時の振る舞いを他の実装ではどうしているだろうか、
  と思って確認したが、どうもそもそも SIMD に対応している物が見つからない。
  まあ、自分で動かしてみた範囲では何となく動いているのでよしとする。

  FreeBSD でのカーソル位置の変な振る舞いもなくなったのでOK。

2020-01-25

* フォントがぼけぼけなのは何故だろう [#D0227]

  | mintty と同じフォントを使っている筈なのに contra の描画はぼけぼけである。
  | というか前からこうだったろうか。或いは最近何かが変わった?
  |
  | GDI を直接使っている事が関係しているだろうか。
  | 一応確認したがちゃんと CLEARTYPE_QUALITY は指定している。
  | その他の LOGFONT の項目も確認したが関係なさそう。
  | Precision は結局、ラスターかアウトラインかの選択や、
  | その他の操作の時にどう取り扱うかというのの選択であり、
  | 具体的に綺麗に表示するとかそういうのには関係なさそう。
  |
  | GDI+ や最近の他の方法を使うと綺麗になるのだろうか。
  |
  | メモ帳ですら contra よりも綺麗に表示している。
  | メモ帳が内部で何を使っているか知らないがやはり GDI なのでは?
  | だとすると何がいけないのだろう。
  |
  | * もしかして CLEARTYPE_QUALITY を自分で指定してるのがいけない?
  |   DEFAULT にしておけばそれなりに綺麗に表示してくれるという可能性もある。
  |   →DEFAULT にしても変化はない。ANTIALIASED と NONANTIALIASED も
  |   試してみたが横位置を微妙に調整して来るのでバランスが変になっている。
  |
  | * lfPitchAndFamily に FIXED_PITCH を設定しているからかもしれないと思ったが
  |   それを外しても何も変化はなかった。
  |
  | 猫でも分かるのプログラムをコンパイルして実行してみる。
  | 何でか分からないけれども拡大されて描画されている?
  | ラスタフォントの筈なのに何だか拡大されている。
  |
  | WinSDK 27章を見て明示的にフォントを指定して実行してみる。
  | やはり変だ。{PROOF,DEFAULT,CLEATYPE}_QUALITY の何れを選んでも
  | MS明朝がラスターなのにぼやけて見える。
  | 更に表示の高さを確認してみると 12 と指定しているのにもかかわらず 17px ある。
  |
  | と思ったら Window のディスプレイ設定で [テキスト・アプリ・その他のサイズを変更する]
  | というのに 150% の設定が為されていた。
  | メモ帳や他のアプリケーションはどうやってこれを回避しているのだろうか?

  調べると高DPI対応というのをしなければならないらしい。
  https://qiita.com/felis_silv/items/efee4b1a397b0b95100a に詳しく説明がある。
  SetProcessDPIAware() という関数を呼び出せば良いらしい。
  然しこの関数は Windows Visa 以降でしか使えないらしい。
  Windows Vista 以降の設定は以下でする。

    #define _WIN32_WINNT_WIN6 0x0600
    #define WINVER        _WIN32_WINNT_WIN6
    #define _WIN32_WINNT  _WIN32_WINNT_WIN6

  現在の解像度に関しては以下の関数で取得できる。
  既定の解像度はこれでスケールする様にすれば良い?
  https://gist.github.com/retorillo/4e0c4a3cf4c7096e05ac

* 2020-01-17 cygwin を更新したら一瞬 window が沢山表示される様になった [#D0226]
  →これは結局 cygwin のバグだった。 https://cygwin.com/ml/cygwin/2020-01/msg00161.html

  | 何故か contra の中の bash から何か起動すると
  | 物凄く点滅してカーソルも考え中と普通の状態を振動する。
  | ble.sh の問題かと思ったが bash --norc でもコマンドを起動するとなる。
  | mintty では起こっていない。screen の中でも問題は起こらない。
  |
  | これは contra が受け取った escape sequence に問題があるのか。
  | 或いは何らかの端末の設定が間違っているのか。
  | うーん。端末の設定の気がする?
  |
  | ビルドし直したら治るかと思ってやってみたが直らない。
  | また mintty の中で contra を起動して終了したら
  | mintty でも同様の状態になった。しかしその後は再現しない。
  | →./contraexe ttyを起動してそれから終了したら再現する
  |   screen の中で実行していても再現して、
  |   他の sty の中で同様の事をしても問題は発生しない。
  |   古いバイナリ ttty.exe では起こらない。twin.exe でも起こらない。
  | →contr.exe tty の再現性はある。
  | →contra.exe x11 だと問題は発生しない。
  | →contra.exe win でも問題は発生しない。
  |
  | →screen の内部から contra を起動しても問題は発生しない。
  |
  | これはやはり端末の設定の様に思われる。然し不思議なのは
  | x11, win では起こらなくて tty では起こるという事。
  | 端末の作成部分は全く同じで表示先が同じか違うかの問題。
  |
  | では表示の為の初期化が問題なのかと思うと、
  | contra を直接起動した時にはやはり問題が発生する。
  | また tty も tty で動いている間には何も問題が起こらない。
  | うーん。minimal program を作成するとどうなるだろうか。
  |
  | 取り敢えず ttty/screen.hpp の中で setup_tty, reset_tty
  | して直ぐに戻る場合でも駄目という事が分かった。
  | 以下を実行するだけでも駄目みたいだ。
  |
  |   tcgetattr(fd_in, &this->old_termios);
  |   tcsetattr(fd_in, TCSAFLUSH, &this->old_termios);
  |
  | と思ったが自分でそれだけを実行するプログラムを書いても再現しない。
  | 他に何か弄っている事はあるだろうか。
  |
  | うーん。結局 tcgetattr,setattr は全く関係なく再現している。
  | 然し fprintf するだけで再現するという事が分かった。

  うーん。再現方法が分かった。
  -mwindows を指定してコンパイルしたプログラムで何か出力すると駄目なんだ。
  以下を実行するだけで端末が変な状態になる。

  $ gcc -mwindows -xc - <<< 'main(){puts("hello");}' && ./a.exe

  更に mintty --version でも再現する事が分かった。
  但し mintty は cygwin console の中にいる時には Dialog を出すのであった。
  更に cygwin console の中にいる時には puts しても何も出力されないが、
  代わりに問題も発生していない。

  然し、xterm や lxterminal の中にいる時には mintty はちゃんと文字列を出力する。
  そして xterm や lxterminal のウィンドウが駄目になる。
  これは cygwin の問題の様な気がする。
  少なくとも contra の側でどうにかできる問題ではない。

2019-10-04

* 2019-09-21 contra: スクロールバックした時に multiple-click による選択ができない [#D0225]
  当初は画面外に流れた部分について multiple-click が効かないのだと思ったが
  試してみると画面内にある部分についても multiple-click が効かない様だ。

  →これは改めて試してみると選択が起こる行がスクロールした分だけ
  ずれる事によって起こっているという事が分かった。
  つまりスクロールの計算が二重に行われてしまっている。
  調べてみると簡単なミスだった。修正した。

* 2019-09-24 時々 paste が変になる原因が分かった [#D0224]
  \n は \r に変換しなければならないのだ。

  % →twin/twin.cpp の get_clipboardを修正した。

  と思ったが修正するべき箇所は此処なのだろうか。
  辿ってみると get_clipboard から
  app.input_paste, term.input_paste に文字列が渡される。
  term.input_paste の中で bracketed paste の時とそうでない時で処理を分けるべき。
  →その様に修正し直した。

  どうやら contra は bracketed paste に対応しているけれども
  screen は対応していないという事だった様である。

2019-09-09

* ttty: 座標計算が xenl ではない端末に対応するという事 [#D0223]

  やはり端末のデータにアクセスするには ncurses に依存しなければならないのだろうか…。

  端末のデータベースのバイナリ形式はなかなか見つからないが以下に見つけた。
  https://www.systutorials.com/docs/linux/man/5-term/

  早速これに従って読み出してみる。どうやら読み出せてはいる様だが、
  何番目の cap が何の cap に対応しているかの表がないので微妙である。
  更にその対応は OS によって異なるのだとも書かれている。面倒である。
  その様な事を考えるとやはり ncurses に依存するしかないのだろうか。
  或いは SVr1 の cap だけを使うならば互換性はあるとも読める。

  結局 /usr/include/term.h を見る事にした。以下が SVr1 の対応である。

  | #define auto_left_margin               CUR Booleans[0]
  | #define auto_right_margin              CUR Booleans[1]
  | #define no_esc_ctlc                    CUR Booleans[2]
  | #define ceol_standout_glitch           CUR Booleans[3]
  | #define eat_newline_glitch             CUR Booleans[4]
  | #define erase_overstrike               CUR Booleans[5]
  | #define generic_type                   CUR Booleans[6]
  | #define hard_copy                      CUR Booleans[7]
  | #define has_meta_key                   CUR Booleans[8]
  | #define has_status_line                CUR Booleans[9]
  | #define insert_null_glitch             CUR Booleans[10]
  | #define memory_above                   CUR Booleans[11]
  | #define memory_below                   CUR Booleans[12]
  | #define move_insert_mode               CUR Booleans[13]
  | #define move_standout_mode             CUR Booleans[14]
  | #define over_strike                    CUR Booleans[15]
  | #define status_line_esc_ok             CUR Booleans[16]
  | #define dest_tabs_magic_smso           CUR Booleans[17]
  | #define tilde_glitch                   CUR Booleans[18]
  | #define transparent_underline          CUR Booleans[19]
  | #define xon_xoff                       CUR Booleans[20]
  |
  | #define columns                        CUR Numbers[0]
  | #define init_tabs                      CUR Numbers[1]
  | #define lines                          CUR Numbers[2]
  | #define lines_of_memory                CUR Numbers[3]
  | #define magic_cookie_glitch            CUR Numbers[4]
  | #define padding_baud_rate              CUR Numbers[5]
  | #define virtual_terminal               CUR Numbers[6]
  | #define width_status_line              CUR Numbers[7]
  |
  | #define back_tab                       CUR Strings[0]
  | #define bell                           CUR Strings[1]
  | #define carriage_return                CUR Strings[2]
  | #define change_scroll_region           CUR Strings[3]
  | #define clear_all_tabs                 CUR Strings[4]
  | #define clear_screen                   CUR Strings[5]
  | #define clr_eol                        CUR Strings[6]
  | #define clr_eos                        CUR Strings[7]
  | #define column_address                 CUR Strings[8]
  | #define command_character              CUR Strings[9]
  | #define cursor_address                 CUR Strings[10]
  | 中略
  | #define tab                            CUR Strings[134]
  | #define to_status_line                 CUR Strings[135]
  | #define underline_char                 CUR Strings[136]
  | #define up_half_line                   CUR Strings[137]
  | #define init_prog                      CUR Strings[138]
  | #define key_a1                         CUR Strings[139]
  | #define key_a3                         CUR Strings[140]
  | #define key_b2                         CUR Strings[141]
  | #define key_c1                         CUR Strings[142]
  | #define key_c3                         CUR Strings[143]
  | #define prtr_non                       CUR Strings[144]

  この範囲で頑張って実装する事に意義は在るだろうか。
  その様に考えていくとやはり ncurses に依存するのが賢明なのだろう。

  ./configure 的な物に対応する必要があるだろうか。
  というか実は ./configure を手書きで作っても良いのではないか。

  * 実は既に mcxx という枠組みがあるのでそれを使うという手もあるが複雑になる。

    mcxx は更にキャッシュする仕組みだとか色々ある。
    やはり複雑になってしまうので再実装するか。
    或いは mcxx の cxx_conf.sh を改造して一般化するか?
    何れにしても mcxx を整理するのが良い気がする。
    その後で使えそうな部分だけ抽出するのでも良いし、
    そのままコピーして使うのでも良い。

    整理しようとしたが cache 付きの枠組み前提で
    H や諸々の機能が実装されている。これを分離するのは困難である。
    という事を考えると cache 機能の on/off を実装する事になるのだろうか。。
    →取り敢えず mcxx の枠組みは mconf.sh に分離した。
      これで手で ./configure を書く準備は整った気がする。

    ./configure から config.mk を生成して、
    それを source するのが良い気がする。

2019-09-07

* 2019-08-11 iso2022: 色々細かい事で放置している事 [#D0222]

  * done: res/iso2022.def の配置する位置をカレントディレクトリに決め打ちにしている。
    これは config directory または、設定によって設定できる様にする。
    →うーん。これは share/contra に配置するべき物の気がする。

    データを保存するディレクトリを最初に解決して、
    それからそのディレクトリにあるファイルを読み取る事にした。
    データを保存するディレクトリは以下の順に探す (但し BINDIR は $0 のあるディレクトリである)。

    1 $XDG_DATA_HOME/contra
    2 $HOME/.local/share/contra
    3 $BINDIR/../share/contra ($BINDIR == */bin の時)
    4 $BINDIR/res
    5 res

  * [保留] iso2022_charset_registry をグローバルに配置しているがこれで良いのか?
    twin.conf 等を参照したければ実は設定もグローバルに配置する必要がある?
    まあ、それも一つの選択肢である様には思う。

    取り敢えずグローバルに設定を置いておいて、
    もし後で必要になるのであればローカルの設定を持てる様に拡張すれば良い気がする。

  * done: jisx0213 は今は適当に読み込んでいるが、
    本当はちゃんと文字集合の定義に従って適切な JIS ver の物を読み込む様にしたい。
  * done: jisx0213 は本当は遅延ロードしたい。
    遅延ロードの枠組みを作る必要がある。
  * done: jisx0213 の定義は現在はテキストファイルにしているので容量が大きい。
    有効な範囲だけバイナリで保存する事によって効率化出来ないだろうか。
    特に UTF-16LE が良い気がする。定義されていない文字に関しては、
    適当に特別な値を設定しておく事にすれば良い。
    まあ U+FFFF 辺りを設定して置くのが良い気がする。
  * done: acs などの特別描画に関しては現在は acs である事を確かめて特別描画している。
    然し、最終的には character_t の特定の領域に特別描画の指令を
    埋め込む様にしたいのである。

* manager: width/height整理 [#D0221]

  何れにしても作りながら仕様をあっちこっち変えたりして作って来たのでバグが沢山ある。
  改めて再実装するなり何なりしてバグを解消する様にする必要があるのではないか。
  term.cpp 関連に関しては一回再実装した。大体の構造的なバグはそれで一掃された気がする。
  今バグが沢山発生しているのは
    terminal - manager - app - view - term - board
  の間の情報の同期である。何故この様に複雑な事になっているのか。。

  * terminal - manager については 1 対 1 に対応しているので、
    manager の側で width/height を保持するのは理に適っている。

  * app - view - term - board に関してはどうだろうか。
    app が width/height を保持していて、
    view が width/height を保持していて、
    board が width/height を保持している。
    app が width/height を保持する理由はあるだろうか。
    うーん。app では xpixel, ypixel の情報を保持している。
    一方で board は xpixel/ypixel の情報を保持していない。

    app が xpixel/ypixel を保持しているのは、
    terminal_session_application の場合には
    winsize で xpixel, ypixel も設定できる様にしなければならないから。
    その様に考えて行くと実は board の側に xpixel, ypixel を記録した方が良いのでは。

    →分かった。app が width/height を保持しているのは、
      app の基底クラスの初期化の段階では term を初期化したくないからである。
      初期化を実行する時点で漸く width/height を割り当てたいという事なのである。

    さて、実は何と app の width/height/xpixel/ypixel は初期化に使っていただけで
    他からは全然使われていなかった。という訳でインターフェイスも残さずに消す事にした。

* ttty: 描画がおかしい。消滅する行が色々ある [#D0220]

  [状況]

  或る程度の行数だけスクロールすると直る。
  然し window size を変更するとまた再現する。
  そして再び或る程度の行数だけスクロールすると直る。
  contra win -> contra tty でも発生するし、
  xterm -> contra tty でも発生する。
  つまり ttty の出力部分の問題と思われる。

  xterm で実行すると縦に滅茶苦茶にスクロールしている様子が見える。
  trace_line_scroll() を実行しない様にすると改善する。
  (但し、それでも残像が残るなどの問題が発生しているが、
  これはまた独立に解決するべき問題だろう。)

  x xterm ではスクロールは IL/DL ではなくて
    DECSTBM を使って実行するべきなのではないだろうか。
    そうしないと縦に色々にスクロールしてしまってちらつく。

  trace_line_scroll() の中で何が起こっているかを調べると、
  大局的に DL/IL が実行されている様だ。
  殆どの行が保持される筈なのに沢山削除されて沢山挿入されている。
  或る程度スクロールをすると突然実態に合った量だけ削除・挿入される様になる。

  移動量の計算が滅茶苦茶になっているなどの事だろうか。
  移動量の計算を見てみると -1, -2, -3 ... という事になっている。
  これは一体どういう状況に相当するのだろうか。
  つまり、元々或る範囲にあった行が全て同じ行に移動したと見做されているのである。
  本来その様な事は想定していない筈なのである。
  取り敢えず同じ行に移動してしまうという事がないように修正した。
  そうしたら現象としては直ったが、しかし何かが間違っていたのは確かである。
  そもそもこれが意味する所は同じ id の行が沢山登録されているという事。
  何故この様な事が起こるのだろうか。確認する事にする。

  調べてみると id = 0 の行が沢山になっている。何処にも id = 0 になる要素はない気がする。
  と思ったら、どうやら line.id() の実行結果が 0 になっている様だ。何故?
  どうも line_t の m_id の初期値が 0 であり、更に id が明示的に割り当てられていない様だ。

  x fixed: line_t の m_id の初期値を -1 に変更する必要がある
  x fixed: id の割り当てられていない line_t が存在するのは何故か?
    →board_t::resize の時に新しく resize で挿入された line_t に対して
    id が割り当てられていなかったのが原因であった。
    ちゃんと割り当てる様に修正したら初期値がそのまま line_t に
    入ったままになっているという問題は直った。

* ttty: SIGWINCH をチェックするという事 [#D0219]
  というか現在の様に termios を弄っている状態で SIGWINCH を受信できるのか?
  実際に試してみた所ちゃんと受信できる様子である。
  →チェックする様に修正した。

* tx11/twin/ttty: 実装をくっつける? [#D0218]

  殆どのコードは重複していて描画が異なるだけである。
  別のバイナリとして提供する意味はあるのだろうか。
  という事を考えるとくっつけてしまっても良い気がする。
  オプションで切り替えられる様にするのである。


  実際に実装してみる。ttty については端末画面に一杯に広げる事にした。
  然し、変である。大きさが 80x24 に固定されてしまっている。
  調べてみるとちゃんと一旦は 182x74 になっているが途中で 80x24 になってしまう。
  is_alive の中で変化している。調べると select_app を実行した瞬間に変化している。
  これが意味する所は複数の term が初期化されて 182x74 の方が閉じてしまっているという事?
  と思ったがそうでもない。分かった。select_app した時に foreground に来た app に対して
  新しいサイズを設定している。ここでの問題点は二つ在る。

  x fixed: 一つは選択されている app が変化していないのにサイズが再設定されているという事。
    本来は app が変化していなければ改めてサイズ再設定を呼び出す必要はないのではないかという事。
  x fixed: もう一つの問題点は manager の m_widht, m_height が何故か 80x24 になってしまっているという事。
    先に確認したときには一旦は 182x74 になっていた筈だがそれは幻だったのだろうか。
    これについては確認した所、全く更新していなかったのだった。

2019-09-06

* iso2022: 表を作ったのは良いが流石に使えなければ意味がない [#D0217]

  * done: term_t の文字幅の対応 #D0194
  * done: sequence_decoder の対応 #D0193
  * done: iso2022.def の読み込み #D0197

  * 表示する時だけでなくクリップボードにコピーする時にも
    表を参照して変換する必要がある。

    | クリップボードにコピーする場合には、
    | 自前描画と文字の対応もつけて置く必要がある。
    | 一回自前描画の文字に map してから、
    | 更に自前描画から Unicode に対応させる事を考えたが、
    | 本当にそれで良いのだろうか。
    |
    | 例えば、罫線の自前描画を Unicode に対応させてしまうと
    | 横幅がずれてしまって面倒な事になってしまう。
    | 常に半角という事であれば Unicode 罫線文字に対応させずに、
    | +|- に対応させるという手もあるが、それだと、
    | 本当に Unicode 罫線に対応させたい場合に困るのではないか。
    | とも思ったが Unicode 罫線に対応させたいケースというのは実際にあるのか。
    |
    | 色々考えると適当に半角文字に対応させてしまうのが良い気もする。
    | うーん。ポンド記号や円周率記号や等号の類の事も考えると、
    | 横幅がずれてしまうのは仕方がない様な気もする。
    | うーん。ACS に関してはやはり罫線は + や - にしたいという気がする。
    |
    | その様に考えるとやはり自前描画から Unicode に対応させるのではなくて、
    | 元々の文字から Unicode に対応させる様に実装したい様な気がしてきた。
    | 或いは自前描画は完全に + だとか | だとか # だとかにして、
    | 実際の文字の情報は失ってしまっても良いという風に考えるか…。
    |
    | そもそも Unicode 罫線を使わずに ACS を使う状況というのは、
    | Unicode 文字を使えない時と考えるのが自然である。
    | つまり全ての文字幅が半角であるという想定である。
    | うーん。然しだからと言ってどうという事がある訳でもない。
    | 結局 ACS が使われるのは基本的に罫線を引く場合が殆どである。
    | πだとかポンドだとかの記号を出力するのに ACS を使う事は余りない。
    | なので ACS は単に + だとか - だとかに写像してしまっても良いだろうか。
    |
    | 或いは、コピーペーストされる時には文字内容の意味を優先して、
    | 横幅などがずれてしまっても問題ないと言う事にするか。

    * 問題が複数ある。一つ目の問題は ACS 罫線を Unicode 罫線にするか、
      或いは + や - | を用いて表現するかという事。
      これについては表示が乱れるのが嫌なので、 + | - を用いて表現する事にする。
      その他の ACS 記号についてもアルファベットで代用する。

    * もう一つの問題は、
      a. 自前描画記号から Unicode に写像するのか、
      b. 或いは元の文字から特別なテーブルを用いて Unicode に写像するのか、という事。

      ACS 罫線は半角文字にする事にしたので、前者だと都合が悪い。
      自前描画記号の時には別のテーブルを用いて変換する様にする必要があるだろうか。

      c. reject: 或いはもう一つの選択肢として iso-2022 の制御機能も一緒に
        抽出してしまうという事。これだと文字セットの情報が保たれるが、
        一方で受信側のアプリケーションが iso-2022 に対応していなければ意味がない。
        そして実際に対応しているアプリケーションはほぼ皆無であろう。

      面倒なので取り敢えず実装してしまう事にする。
      本来は b. で実装する方が動作としては自然なのかもしれないが、
      実装の簡単さを考えると a. で実装してしまうのが良い気がする。
      取り敢えず自前描画記号から Unicode への対応表は書いた。
      と思ったが本当に a. の方が実装として簡単なのだろうか。

      結局 a の場合にも特別の動作を指定する事になるのである。
      つまり、解決された文字が自前描画記号だった場合には、
      更に其処から対応する記号を取り出す為に別のテーブルを参照する訳である。
      結局別のテーブルを参照するのであれば、
      それは自前描画記号専用のテーブルではなくて、
      コピーペースト用のその記号専用のテーブルであっても良いのではないだろうか。

    コピーの際にどの様にデータを抽出しているかについて確認する。
    manager.hpp からは line_t::extract_selection を呼び出している。
    line.cpp に実装があって其処からは character_t::get_unicode_representation
    を呼び出している。

    これは都合が悪い。現在の文字コードのデータがないと変換できないので、
    character_t の中から iso2022 を参照しなければならなくなる。
    幸いに character_t::get_unicode_representation は一箇所からしか
    呼び出されていないのでこの関数は別の場所に移動する事にする。
    もしくは、この関数はそのままにしておいて、
    line_t::extract_selection から呼び出す時に iso2022 経由で変換する事にする。

  * 何だか実装が汚い。文字コード周りはやはり整理したいのである。
    現在の構造がどうなっているのかを確かめる。
    特に iso2022 周りの処理はどうなっているか。

    * sequence.hpp 受信時は ISO-2022 の制御機能に従って文字集合を切り替えて受信する。
      文字集合の情報も一緒に記録して character_t に変換する。
      つまり character_t は文字集合の情報も含めた型になっている。
    * render.hpp 描画時は character_t をそのまま受け取って其処に格納されている
      値によって描画の方法を切り替えている。通常の Unicode の場合には普通に
      文字列として描画する。iso2022 文字集合の場合には Unicode に変換して描画する。
      その他のオブジェクト等の場合には未実装であるがそれに応じた描画を行う予定である。
    * line.hpp コピーペーストの時には extract_selection 経由で
      文字列に変換しなければならない。
    * 更に iso2022.def では自前描画との対応をつけている。

    問題はコードが様々な場所に分散しているという事である。

    * render.hpp は分離するのは難しい。というかその分離をする為に
      自前描画の文字集合を用意したのではなかったか。
      然し、結局自前描画の文字集合も iso2022 文字集合として登録したので、
      結局 iso2022 の枠組みからは分離できていない様な気もする。
      まあ render.hpp に関してはそれで良いという事にする。

    * sequence.hpp では文字集合の詳細には触れずに
      そのままバイト数 = 文字幅で計算しているが、
      実際には零幅文字も存在している事から、
      本来は文字幅を計算しなければならない気がする。
      これはまた別項目で考察するべき問題の気がする。

    * line.hpp に関しては iso2022 の関数を呼び出すか、
      或いは character_t の関数を呼び出す事で実装するべきである。
      現状の通り character_t の関数を呼び出す様にしておいて、
      もし iso2022 の文字が含まれていたら line.cpp の方で
      実装するという具合にするのが良い気がする。

    分散している時にそれがどうしようもないという場合には、
    また新しくヘッダファイルを作って其処で色々と定数などを定義して、
    その定数などを利用して実装するのが正しい筈である。

    [実装の方針]

    line.hpp (character_t) に文字への変換を実装する。
    通常の変換については line.hpp で実装して、
    iso2022 を使った変換については line.cpp で実装する。

    と思って実装しかけたが iso2022 の変換に際しては buffer が必要になる。
    一つの文字に対して複数の unicode が対応している可能性があるからである。
    という事を考えると実は文字毎に変換するというよりはまとめて
    変換する為のクラスが必要になるのではないだろうか。

    そもそもインターフェイスも char32_t を返すだけでは済まないのである。
    →std::vector<char32_t> に結果を格納して、
      文字列取得が成功したか失敗したかは bool 戻り値で返す事にした。

    取り敢えず変換は実装した…。
    実装としては汚いのかもしれないが、取り敢えず動いているので良い事にする。

  * iso2022_graphics としている物の実装は以下の場所に分散している。
    - iso2022.def これは ACS と graphics の対応付け。
    - render.cpp  これは graphics から実際の描画への対応付け。
    - iso2022.cpp これは graphics から Unicode への対応付け。

    一つ目については仕方がない。
    二つ目と三つ目に関しては定数の定義などを通じて
    マジックナンバーを避けるべき気がする。
    然し、どのヘッダに定義を書くのが良いだろうか。

    iso2022_graphics という名前は紛らわしい。
    恰も iso2022 で定義されていそうな印象を与える。
    a contra_graphics 等の名前にした方が良い気がする。
      然し contra_graphics だと general 過ぎる気がする。
      これだと render で用いている graphics と紛らわしい。
    b contra_special_graphics だと長い。
      VT の場合は "DEC Special Graphics" もしくは
      "VT100 Line Drawing charset" 等の名前になっている。
    c contra_mosaic 等の名前が良い気がして来た。
      或いは mosaic でも良いのかもしれない。
    取り敢えず mosaic に改名する事にした。

2019-09-05

* [保留] tx11: padparadscha で動かしてみた所動作が遅い [#D0216]
  何故だろうか。Cygwin X Server の上で
  padparadscha tx11 を動かしてみるとそんなに遅くない。
  という事は Linux の X Server 上で動かすと遅いという事なのか。

  或いは 32 bit が悪いのか何なのか。何れにしてももう少し描画
  ルーチンに関しては改良ができるかもしれない。
  特に一番最後の転送部分に関しては更新のあった部分だけ転送する様にできる筈。

  と思って今試してみたが実はそんなに遅くなかった。
  取り敢えずこれについては気にしない事にする。

* 2019-08-09 iso2022: マルチバイト文字のデータベース [#D0215]

  これらはさすがにメンテナンスされているだろうから何処かで表を拾ってくれば良い。

  * done: CNS 11643 について
    CNS 11643 は実際に使われているのか謎なので危ないと思ったが一応表はない事はない様だ。
    http://kanji-database.sourceforge.net/charcode/cns.html

    個人でデータを公開している人もいる。どれだけちゃんとした物かは見ただけでは分からないが。
    何れにしても複数のテーブルを集めて比較する必要はあるのだろうという気がする。
    http://kanji.zinbun.kyoto-u.ac.jp/~yasuoka/CJK.html

    これは売り物なのでテーブルを抽出する事はできない。
    https://www.basistech.jp/text-analytics/rosette/unicode/#%E3%82%B9%E3%83%9A%E3%83%83%E3%82%AF

    取り敢えず最初の物を元にする事にした。
    照合に関しては後で余裕があれば行う。

  * done: IR 202 DPRK について
    KPS9566 これは直接 ISO-IR-202 から生成したそうだ。
    https://www.asahi-net.or.jp/~ax2s-kmtn/ref/kps9566-97.html
    https://www.asahi-net.or.jp/~ax2s-kmtn/ref/index.html 更に最新版もある。

    というか他にも JIS の表などもちゃんと持っていて使いやすそう。
    ライセンスとかは記述してあるだろうかと思ったが何処にも書かれていない。
    まあ対応表示帯は歴として存在する固定した情報なので著作権はないのかもしれない。
    然し表を作ったという労を考えるとやはり言及するべき気もする。よく分からない。

  * done: GB 2312-80 についても上のサイトに丁度載っている。

  * done: JIS について。
    https://www.asahi-net.or.jp/~ax2s-kmtn/ref/jisx0213/index.html
    此処に載っているのは JIS X 0213:2004 の様である。
    1-14, 1-15, 1-47, 1-84, 1-94 に JIS X 0213:2004 で追加された文字 8 文字が赤く塗られている。
    ISO-IR-233 には10文字追加されたと書かれている。
    というか ISO-IR-233 の attachment B にそれらの文字が書かれているのであった。

    どの様にデータを表現するのが良いだろうか。

    (1) JIS X 0213 と JIS X 0212 を併せた Plane 1/Plane 2 を作成する。
      その為には区の情報も保持したテーブルを作成する必要がある。
      →確認してみた所、既にちゃんとその様な実装になっていた。

      JIS X 0212 のデータを変換するスクリプトを書く。

2019-08-25

* 2019-08-11 bidi の時の描画が全然駄目 [#D0214]

  SPD(3) を実行してみると変な事になるのである。

  * fixed: 先ず get_cells で画面幅一杯になるだけセルが取れる時は良いが、
    画面幅に満たない時の描画が駄目になっている気がする。
    →取り敢えず get_cells_in_presentation で padding する事にした。
    render 側で処理する事も考えたが ttty 等も一緒に実装しなければならないので、
    面倒なので get_cells_in_presentation 側で padding するという判断にした。
    →_prop の場合も実装した。但しちゃんとはテストしていないのである。

  * fixed: 更に範囲選択の時の座標計算もデータ部での座標位置に変換している気がする。
    これも修正しなければならない。
    →調べてみるとちゃんと to_data_position で変換している様な気がするが、
    to_data_position を通しても値が変化していない。to_data_position は
    ちゃんと m_presentation_direction を考慮している。
    と思ったら line::to_data_position の実装が駄目だった。
    !m_prop_enabled の時は逆方向になる事はないと仮定していたが、
    実際には r2l による変換もあるのだという事が看過されていた。直した。

  * done: SPD が変化した場合は full update にしなければならない。

* manager: 選択ができなくなっている… [#D0213]
  →これは直した。

2019-08-18

* 2019-08-13 ttty: BUG 終了する時に core dump する様になっている [#D0212]
  impl2 の場合もそうである。
  これは screen.do_loop を抜けた時点で board も app も破棄されているのが原因である。
  そもそも現在の端末内容を画面に出力する必要はあっただろうか。
  面倒なのでこの最後の端末内容を画面に出力する機能は削除する。

  うーん。或いは別の方法はあるだろうか。ttty_screen の do_loop で
  is_alive を呼び出した瞬間にもう終了したセッションは削除してしまう事になっている。
  そもそもこの機能を保持する理由もないしメンテナンスするだけ面倒である。
  そもそも一番最初期に board の内容がちゃんとなっているか確認する為の物だった。
  やはりこの機能は削除してしまう事にする。

* 2019-08-13 manager: 右クリックがなかなか効かないのは [#D0211]
  右ダブルクリック等の判定を行っているからである。
  また少しでも移動するとやはりドラッグになってしまって右クリックでなくなる。
  drag_start 的な操作をしない限りはドラッグを有効にしない様にする必要がある。

  drag の設計をどの様にするのが良いのか分からなくなった。
  現状の振る舞いについて整理する。

  先ず初めに mouse_down が来る。
  単一マウスボタンの時は此処でいきなり on_select_initialize を呼び出している。
  これはそもそも変である。最初から考え直す事にする。

  mouse_down → mouse_move → mouse_up だけからどの様に様々なイベントを構築するか
  というのが問題である。特に drag でない場合には mouse_move を無視するというのが
  今回新たに考えなければならない事柄である。

  うーん。select_initialize を呼び出してはいるが、
  これは実際に利用するかどうかはさておき取り敢えず提供しているという事だろうか。
  問題は選択している時と選択が有効になっていない時で
  本当は発生させるイベントの集合が異なるのではないかという事にある。

  改めて現在の振る舞いについて調べる事にする。

  * 選択の処理に関して
    down でボタンが一つの時には選択を開始する。
    それ以上の時には選択をキャンセルする。

    move でボタンが押されている時には process_mouse_drag で処理する。
    drag がキャンセルされていなければ drag_state = 2 になる。
    此処で select_update を初期化しているのであった。
    途中で select_update に失敗したら drag をキャンセルする。

    up では選択が実行されていれば drop を実行し、
    そうでなければ click を実行するという様になっている。

  * 複数クリックについても down で判定する。
    ボタンが一つの時には前回と同じボタンの時に数を累積する。
    それ以外の時には複数クリックはキャンセルする。
    drag で複数クリックのカウントをクリアしている。
    up ではボタンを離した時刻を記録する。

  先ずどの様に書き換えるか。直接 "選択" を実行するのではなくて、
  先ずは drag/drop の仕組みを整えて、その上で選択を実装する事にする。
  →その様に書き換えた。on_select_initialize は on_drag_start にして、
  on_drag_start で bool を返す様にした。true を返した時にだけ drag を開始する。

2019-08-17

* iso2022 (iso2022_definition_reader): savebin はファイルを書き換える [#D0210]
  ことが可能なので特定の条件でしか使えない様にするべきなのでは。
  →これも取り敢えず実装した。
* iso2022 (iso2022_definition_reader): 遅延ロードを設定できる様にしたい。 [#D0209]
  取り敢えず実装した。
* iso2022 (iso2022_definition_reader): save_cpp, save_txt が [#D0208]
  multi-byte charset に対応していない→対応した。
* iso2022 (iso2022_definition_reader): loadbin/savebin は cwd ではなくて、 [#D0207]
  現在読み取っているファイルを起点にするべきな気がする。
  include も含めて現在のファイル名からの相対パスで読み取る様に変更した。

2019-08-16

* [自然解消] 2019-07-26 twin: Console window を隠す方法 #D0122 に関して [#D0206]

  https://social.msdn.microsoft.com/Forums/en-US/e004a394-c6af-46f2-9158-acc200f3acfc/hiding-a-console-window?forum=vcgeneral
  % http://www.cplusplus.com/forum/beginner/12001/

  SW_HIDE で自分自身を起動し直して一番初めに起動した物はすぐに終了する、という方法が書かれている。
  今回の場合にそれでちゃんと動くのかというのは試していない。
  というか Cygwin の場合だとプロセスの親子関係を切断する事にならないだろうか。
  もしくは親プロセスがゾンビになって生き続けるという事があったりするだろうか。

  2019-08-16 #D0204 によって解決したので Console window を隠す必要はなくなった。

* [自然解消] 2019-05-03 twin: 普通に起動すると一瞬ウィンドウが表示される問題 [#D0205]
  ref #D0122 #D0145

  これは今の所解決できていない。

  * PE ヘッダの Subsystem を Windows (2) に書き換えると、
    何故か /bin/bash が対話モードに入れなくなってしまう。
    (Note: mintty は Windows Subsytem でちゃんと動いている)
  * 現在は Subsystem は Console (3) のままで
    表示されたコンソールは SW_HIDE して消す事にしている。
  * ショートカットの設定を弄って目立たなくする方法について #D0123 で考えたが、
    精々ウィンドウの大きさを小さくして不透明度を 30% まで下げるのが関の山。
    ショートカットをバイナリで無理やり編集して不透明度を 30% より小さくすると、
    何らかのチェックに引っかかって、寧ろ不透明度 100% になってしまう。

  何と検索していたら gcc に -mwindows を指定せよとの事…。
  https://stackoverflow.com/questions/18260508/c-how-do-i-hide-a-console-window-on-startup
  然し、これは自分で PE ヘッダを書き換えた時と同じ症状になるだけで問題は解決しなかった。

  2019-08-16 #D0204 で解決した。

* twin: -mwindows で改めて動かしてみる。login_tty 等を使ったら解決するのだろうか [#D0204]

  結論: 実は原因が分かった。master/slave が丁度 0,1,2 になっていて、
  close(masterfd); close(slavefd); で折角作った標準入出力を閉じてしまっていた。
  login_tty は余り関係がなかった様である。

  (或いは login_tty が注意深く実装されていれば login_tty を使う事で回避できたのかも知れない)
  →実際に試してみた所 login_tty はちゃんと fd が被っている場合に対応していた様である。
    つまり初めから login_tty を利用していれば問題は発生しなかった。

  | 調べてみると、先ず std::fopen をしていないとそもそも nanosleep が sleep しない。
  | 不思議だ。CRT の初期化との兼ね合い等があるのだろうか。std::fopen していると
  | 途中までは起動する様になる。然し、今度は Bash の出力を読み取ることができない。
  | 調べてみると一応何かしらは読み取られている様にも見えるが…。
  |
  | | うーん。調べてみると echo back は表示される様である。
  | | C-d で終了する。echo は反応はない。ls も何も表示されない。
  | | exit は効く。echo や ls を ~/a.txt に出力すると実は何か出力されている。
  | | つまり、標準出力の先が変なことになっている気がする。
  | | というかここまでは前に調べた時に分かっている事だった様な気もする。
  | |
  | | echo hello > /dev/tty とすると何とちゃんと出力された。
  | | うーん。見てみると…何と…fd が一個しかない…。
  | |
  | |   $ \ls -la /proc/2770/fd
  | |   合計 0
  | |   dr-xr-xr-x 2 murase なし 0 2019-08-16 17:07:45 .
  | |   dr-xr-xr-x 3 murase なし 0 2019-08-16 17:07:45 ..
  | |   lrwxrwxrwx 1 murase なし 0 2019-08-16 17:12:41 0 -> /dev/pty5
  | |
  | | exec 1>&0 2>&0 してから bash を起動したら普通に使える様になった。
  | |
  | | close(slavefd) している部分をコメントアウトしたら普通に起動する様になった。
  | | 然し、bash redirection error というエラーが表示される。以下の通り。
  | |
  | | bash: redirection error: cannot duplicate fd: Bad file descriptor
  | | bash: 1: Bad file descriptor
  | | [murase@magnate2016 0 ~]$
  | | -- INSERT --
  | |
  | | ble.sh をロードしない様にする。bash --norc で起動してみたが、
  | | そうすると起動時はエラーは出ないが、何かコマンドを実行するとエラーになる。
  | | 他のセッションから /proc/3115/fd を観察してみると 1 番が消滅している。
  | | close(masterfd) も実行しない様にしようとしたら、今度は普通に動く様になった。
  |
  | つまり何が原因だったかというと、実は fd が一個も開かれていなかった為に、
  | masterfd 及び slavefd が 1, 2 になっていて、close で閉じてしまっていたという事。
  | →一応確認してみたところ、やはり master/slave が 1/2 になっていたのであった。
  |
  | ? Cygwin で強制的に stdout stderr を初期化させる方法はあるのだろうか。うーん。
  |   例えば、試しに stdout stderr に何か文字を書き込んで見る事にする。
  |   うーん。以下については何の効果もなかった。
  |     std::fprintf(stdout, "A\n");
  |     std::fprintf(stderr, "B\n");
  |     std::fflush(stdout);
  |     std::fflush(stderr);
  |   やはり自動的に開かれるという事はない様である。
  |
  | * 更に openpt する前に ls -la /proc/$$/fd を出力してみて分かった事は、
  |   0 は dbgout の出力先に紐付いていたのであった。つまり、
  |   "std::fopen をしないと nanosleep が sleep しない" というのは、
  |   fd 0 を使って nanosleep が実行されていたからという事なのだろうか。
  |
  | 対応方法としては二種類考えられる。
  |
  | a 一つは -mwindow でそのまま起動した場合には、
  |   自分で fd 0 1 2 を割り当てるという事。
  | b もう一つの対応は master/slave が fd 1 or 2 になっている時の対応。
  |   二つ目の対応に関しては何れにしてもしなければならない気がする。
  |   そうとなれば実は前者は対応しなくても良い気がする。
  |   →直った。
  |
  | 初めの症状を考えると a を実行しなければそもそも
  | bash が開く前に終了してしまうのではないかとも思ったが、
  | 実際にやってみると b の対応だけでちゃんと bash も起動する様になった。
  | 恐らく bash は stdin が開けないとすぐに終了する、という具合になっていたのだろう。

* 以下を見てみると login_tty は [#D0203]
  setsid(); や dup2 等を包含している様である。
  https://android.googlesource.com/platform/bionic/+/master/libc/bionic/pty.cpp

  そして実行していない物は何かというと、以下の物である。
  if (ioctl(fd, TIOCSCTTY, 0) == -1) return -1;

2019-08-13

* twin: カーソル形状が変な問題 [#D0202]
  どうも必ず App-2 で初期のカーソル形状が変な様である。
  カーソル形状を取得するコードが怪しいか、
  或いはカーソル形状の初期化を忘れているかのどちらかである。
  取り敢えず最初に後者を確認する事にする。
  →確かに初期化されていなかった。
    然し、そもそも再現性がないのでこれで直ったのかどうかが良く分からない。

  - それに、もし最初に変な値が入っていたとしてもやはり ble.sh 起動時に
    DECSCUSR が実行される様な気がするのでそれが効いていないというのも変である。
    と思ったが、少なくとも ble.sh で起動後にカーソルの形状の変更を行った時には、
    ちゃんとカーソルの設定が反映される。という事は ble.sh の側でも、
    ちゃんとカーソル設定の制御機能を出力していないという事になるのだろうか。

  →取り敢えずまた再現したら考える事にする。今はこれで良しとする。
  後は、ble.sh の方でもやはり何かが間違っているという事なのだろう。
  これについては ble.sh の方で改めて考える事にする。

* twin: やはり暫くすると新しい window を作る事ができなくなる [#D0201]
  →これは Windows 上で実行中の実行ファイルを上書きすると起こるのだった。

  | どうもカーソルの動きや遅延などを見るに App-c は効いては居るけれども、
  | その後の session の生成で問題が起こっているという気がする。
  | 然し、再現する迄に時間がかかる。何でだろうか。
  |
  | 原因として考えられる事は何だろうか。
  | 同じ操作をしている筈なのに結果が異なってしまう。
  | 途中で何かを破壊しているという事なのだろうか。
  |
  | - 或いは、中で twin を起動すると動かなくなるという事なのか。
  |   色々試してみたが ./ttty ./tx11.exe ./twin の何れを実行しても
  |   特に動かなくなるという事はなかった。更に孫を作ってみても同様だった。
  |   source demo.sh が悪いのかも知れないと思って実行してみたが特に問題はない。
  |
  | - Note: 現在の twin を起動したのは 8/7 であり、
  |   これは /dev/tty の問題を修正した 8/6 9:00 よりも後である。
  |
  | 2019-08-13 08:10:26 再現した。
  | 新しい binary で試したら一瞬だけ画面が表示されて、
  | その後で直ぐに閉じてしまうという様子が見える様になった。
  | 恐らく描画の dirty を修正した時に直ったのだろう。
  |
  | 然し、今何を実行していただろうか? ソースコードを修正した。
  | つまり、binary を上書きしてしまうと動かなくなるという事だろうか。
  | 試してみる必要があるのである。
  |
  | 2019-08-13 08:16:09 やはりこれが原因だった。
  | これはバグというよりも、そういう物なのである。
  | バイナリを上書きしたら動かなくなるのは或る意味当然である。
  | そもそも Windows なのに何故バイナリを上書きできるのかが謎である。
  | という訳でこれは良い。起動する時にコピーを作成して起動する様にすれば良い。

* [保留] LF の性能が悪い? [#D0200]
  やはり他の高速な端末と比べると LF の性能が悪い気がする。
  と思って調べてみると do_lf → do_generic_ff → do_vertical_scroll →
  shift_lines という具合の処理になっている。汎用的な処理ではなくて、
  LF に特化したコードを書いても良いのではないだろうか。
  と思ったが、確認してみると LNM, DCSM や DECSTBM, DECSLRM と SPH SLH
  等を参照して処理を切り替えている。結局複雑な処理は避けられないのである。

  それでも既定の設定の場合には高速化する事ができるかもしれない。
  と思って既定の設定になっているかどうかだけ先に確認して、
  もし既定の設定であれば大幅に簡単化できる様に書いてみた。

  | term.hpp (board_t) に以下を追加
  |
  |   // shift_lines(0, m_height, 1, fill_attr, scroll_buffer (!= nullptr)) に等価
  |   void shift_lines_for_default_lf(attribute_t const& fill_attr, term_scroll_buffer_t* scroll_buffer) {
  |     scroll_buffer->push(std::move(m_lines[0]));
  |     m_lines[0].clear(m_width, fill_attr);
  |     m_lines[0].set_id(m_line_count++);
  |     m_lines.rotate(1);
  |   }
  |
  | term.cpp (do_lf) を以下の様に書き換え
  |
  |   void do_lf(term_t& term) {
  |     tstate_t& s = term.state();
  |     bool const toCallCR = s.get_mode(mode_lnm);
  |     if ((toCallCR || s.dcsm()) && s.page_limit < 0 &&
  |       s.dec_bmargin < 0 && s.dec_tmargin < 0 &&
  |       s.dec_rmargin < 0 && s.dec_lmargin < 0
  |     ) {
  |       board_t& b = term.board();
  |       b.cur.adjust_xenl();
  |       if (b.cur.y() + 1 < term.height()) {
  |         b.cur.set_y(b.cur.y() + 1);
  |       } else {
  |         b.shift_lines_for_default_lf(term.fill_attr(), &term.m_scroll_buffer);
  |       }
  |     } else {
  |       do_generic_ff(term, 1, true, !toCallCR && !s.dcsm());
  |     }
  |     if (toCallCR) do_cr(term);
  |   }

  しかし、時間を計測してみると全く効果はない様に見える。
  yes | head -1000000 | cat -n で 1.599 → 1.550 とかいう感じである。
  一方で yes | head -1000000 では 3.999 → 4.008 とかそんな雰囲気で
  恐らく誤差の範囲内である。
  改行自体が遅いという事なのだろうか。うーん。多分分岐予測が効くから
  条件分岐で特別に遅くなっているという事はないのだろう。
  ただ単に処理する命令の数が増えているという事なのだろう。

  * 或いは、ストリームからの読み出しが律速しているのだろう。
    そちらを改善しなければ何の意味もないのである。

    % →と思ったが…よく考えると改行の数で 1.6 → 4.0 秒に大きく
    % 時間がかかるという事を思い出せば律速しているのは
    % ストリームからの読み出しではない。

    分かった…。head から読み出すと多分一行ずつデータが送信されてくる。
    つまりやはりストリームからの読み出しが悪いのである。
    1.6 → 4.0 に変化したのは | cat -n を付加するかしないかの問題。
    | cat -n を消す代わりに | cat にしたら高速になった。
    0.435 とかそれぐらいにまで短くなった。

    これに関してはどうしようもないのである。
    また、これについては | cat を付加する事で避けられる。
    その上でも未だ urxvt と比べて遅いというのである。

  * reject: 多分、問題になっているのはメモリなのではないかという。
    % つまり scroll_buffer に転送する時にメモリのあらぬ所を触っている。
    % そう思って transfer_lines をコメントアウトしてみたが全く変わらない。

    $ time yes '' | head -5000000 | cat で試した。
    transfer_lines あり → 1.297
    transfer_lines なし → 1.167

    これは関係ない感じがする。10%程度しか寄与していない。

    では何が律速しているのだろうか…。もしかして CR?

  * 或いは文字挿入それ自体なのかもしれない。

    % "y" という文字挿入自体が重いから時間がかかっている。
    % そう思って yes '' | head -1000000 で試したが、やはり変わらない。
    % 一応 3.950 程度にまでは短くなったが誤差の範囲である。
    % 寧ろ文字挿入が余りコストなくできているので喜ばしい事である。

    改めて計り直してみると以下の様な感じである。
    やはり文字挿入自体のコストも看過できないのである。
    より文字数の多い処理で気にならなかったのは、
    contra が図形文字を一括で挿入しているからである。

    mag$ time yes y  | head -5000000 | cat → 3.138
    mag$ time yes '' | head -5000000 | cat → 1.297

    chat の上で調べてみると contra は大量の図形文字の挿入では alacritty に勝っている様だ。
    chat$ time yes {1..100} | head -100000 | cat
    これで alacritty は 0.453 で tx11 は 0.400 である。最適化は -Os にしている。
    再度試すと ala は 0.382 で tx11 (-O2) は 0.336 であった。

    改行性能についても確認してみる。
    chat$ time yes '' | head -1000000 | cat
    ala 0.153 tx11 0.222 urxvt 0.143 である。
    うーん。そんなには悪くないのかも知れない。

    xterm は計測できない…画面に大量に出力する所為で結果が見える迄に時間がかかる。
    実は ala と同様で処理だけはあっという間に終わっている様にも見える。
    10k 行だと  0.006 だが 100k 行だと 22.259 に増える。
    これは端末自体の処理ではなく通信に依る律速であろう。

  性能については考えても仕方がない気がしてきた。
  そもそも実装が複雑なのであるから無理して高速化しようとしても
  余計に実装が複雑になって手に負えなくなるだけである。
  という訳なので取り敢えずはそのままにしておく事にする。

2019-08-12

* iso2022: ECMA を読んでいたら96文字集合を呼び出している間は [#D0199]
  SP 及び DEL は本来の意味を失って 96 文字集合の文字に化けるのだと書かれている…。
  これについてちゃんと取り扱う様にしなければならない。
  特に対応が必要なのは 94 文字集合の方である。

  * done: 取り敢えず GL/GR に関係なく SP/DEL は両方とも処理する。
    現在は明示的に 0x20 と 0x7F を刎ねているがそれを削除するだけで良い。

    取り敢えず規格を読んでちゃんと実装する事にした。

  * done: うーん。94^n 文字集合の場合にはどうも SP が来た時は1バイトだけで文字にして、
    それ以外の時は n バイト読むという事になっている様な気がする。
    つまり単に SP/DEL の位置に SP/DEL を置いておくだけでは駄目なのである。
    対応が面倒である。更に、現在の実装だと charset が 94 文字集合なのか、
    或いは 96 文字集合なのかの判定がすぐにできない。
    charset のフラグに含めてしまうのが良い気がする。

    SS 94文字集合 の時には SP/DEL は駄目の様である。

  * done: また GL/GR が混ざっている表現の仕方は許さない様に変更した。

  * 96文字集合をGLに呼び出すと SP/DEL ではなくなる様なので、
    ちゃんと処理しなければならない。現在は強制的に DEL を無視しているのが駄目。
    うーん。やはり符号化として解釈できない DEL に関しては無視する事にする。
    符号化に関与する DEL はちゃんと処理する事にする。

2019-08-11

* iso2022: 様々な文字集合の対応 (4) 描画の対応とコード整理 [#D0198]

  * 描画時の対応

    実は描画の際に初めて encoding 情報が必要になるのである。
    code -> unicode の変換は何処で実施するべきか。
    get_cells を実行する瞬間に変換すれば良いだろうか。
    或いは実際に描画する所で変換すれば良いだろうか。

    うーん。文字コード毎にフォントを切り替えたいという需要もある。
    という事を考えると実際に文字を一つずつ描画する時に処理すれば良い気がする。

    そしてこの段階で具体的な文字の対応表が必要になる。
    もしシステムがフルに iso-2022 の描写に対応していれば気にしなくて良い。
    もしシステムが unicode に対応しているのであれば変換表を使って変換する。
    何れにしてもシステムは何らかの文字コードには対応している筈なのであるから、
    unicode から更にその文字コードに変換してその上で描画すれば良いのである。
    もし対応する文字がない場合には仕方がないので諦めるのである。

  * 特別描画用の表とクリップボード用の表

    もしモザイク集合などについて owner draw を実行するとすれば、
    描画に対してはそれを指示する特別な変換先をテーブルに入れておきたい。
    一方でクリップボードに対するコピー等の場合には、
    普通に Unicode への変換をテーブルに入れておきたい。

    a そう考えると実はテーブルは二種類必要になるのではないだろうか。
      しかも殆ど同じで一部だけ違うという形になっている。
      これを効率的に表現するにはどうしたら良いだろうか。
      owner draw 的な事の実行の為には別の処理を行う?

    b というか表に記録する char32_t に
      両方の情報を無理やり入れることは可能だろうか。
      まあ、それが現実的な気がしてきた。
      →と思ったが微妙な気がしてきた。
      既に Unicode だけで 21bit は使う。
      残りは 11bit しかない。

      - 既に使用しているフラグ等の類を除くともっと少なくなる。
        或いはこの文脈では既に定義したフラグの類は使わないという事にしても良いが、
        そうすると文脈依存で意味が色々に変わって分かりにくい事この上ない。
        そもそも直積で情報を表現しようという事自体が非効率的なのである。

      - もし11bitフルに使えるとしても 2096 種類しか登録できない。
        様々な物を登録する可能性を考えると実はこれでは足りないかもしれない。
        と思ったが、様々な組み合わせで色々な物を登録しようとするのが行けないという
        考え方もできる。2096種類で十分なのではないだろうか。
        然し、罫線などの様々な組み合わせを考えると冪乗で数が増えてしまう。

      そういう事を考えるとやはり無理やり二つの情報を直積で入れるのは無理がある。

    c 別の方法としては表中では取り敢えず "特殊描画文字" に対応させる事にして、
      特殊描画文字から描画関数や Unicode 代替文字へ解決できる様にするという物。
      この様にすると複雑になってしまって嫌な気もするが、
      まあ、面倒なのでそれぐらいの実装で良いという気がしてきた。

      少なくとも全ての charset について表を二重化するよりはましなのである。
      さて、特殊描画文字に関する表も作る必要があるだろうか。
      うーん。作る事にする。モザイクの類もあるのだから、
      それも考えて系統的に作る事にするのが良いのである。

    何れにしても取り敢えず表を作る必要があるのである。
    うーん。やはりどうしたら良いだろうか。
    文字コードのどの範囲に割り当てるのが良いだろうか。
    96 や 96*96 を単位にしたので判定にビット演算が使えなくて面倒である。
    と思ったが、普通に "範囲" として予約しておけば良いのである。
    簡単な事だった。

  * done: charbuff は progress ではなくて絶対位置で文字の位置を指定するべき。
    うーん。汚い。文字描画のコードが滅茶苦茶になっている。
    整理しなければならない。先ず初めに charbuff に progress を
    入れているのが間違いの元である。どうせ自前で位置を計算しているのだから、
    取り敢えずは希望の座標位置を代入して置いて、
    その後で progress を計算する様にすれば良いのである。
    その様に書き換える。

  * done: get_displacement も分かりにくい。これも簡単にする。
    まあ、これの修正は簡単だった。そもそも dx, dxW を使っている箇所は2箇所しか無かった。

  整理していく内にどんどん複雑になっていく。
  というかただ単に盥回ししているだけみたいな状況になっている。
  リファクタリングとは構造を複雑にする事ではなくて、
  構造をフラットに分割するという事であるべきなのである。
  と思ったがやはりカプセル化も大切である。

  * done: ACS 関連に関しても整理する。取り敢えず ACD で書く文字は整理した。
    然し、やはり文字が小さくなってくると自前での描画は汚くなってしまう。
    ビットマップフォントを用意したくなる気持ちは分かる。
    一方でちゃんと表示できているフォントまたはラスタライザはとても凄い。
    或いはアンチエイリアスの効果なのだろうか。

  * done: ACS関連の罫線に対応する。対応した。

  * done: 残りの ACS にも全て対応した。

  * クリップボードに貼り付ける時に写像するのは更に
    charset iso2022 graphics から取得する事にする。
    この写像の作成は後で行えば良いのである。

* iso2022: 様々な文字集合の対応 (3) iso2022.def の読み込み [#D0197]

  * これ以上の対応には実際に iso2022 の表をロードしておく必要がある。
    取り敢えずその辺にある iso2022.def を読み取る仕様にしてしまう。
    iso2022-dump.cpp を改造する形で実装すれば良いだろう。
    特に読み取り部分を分離できる様にする。

    sequence.hpp の中の iso2022_charset_registry から
    使う事ができる様にする。取り敢えず single byte charset
    だけでも対応すれば良い。

    うーん。JIS X 0213 だけでも対応する事にする。
    当初はデータ作成に awk を使おうと頑張っていたがどうも限界がある。
    gawk で処理するのは対応関係の抽出だけにして、
    残りは C++ で処理してしまうのが良いという結論になった。

    然し対応関係の抽出をするとしても複数文字に変換される文字もある。
    そういった物も分かりやすく表現できる形式は何だろうか。
    勝手に変な記号とかを導入して処理すると後で見て分かりにくい。
    しかし、だからといって複雑な記法にするとそれはそれで処理を記述するのが面倒だ。
    またどんどん新しい言語をその場で作っていくというのは不毛である。
    という事を考えると既存の .def 形式を使う事にするのが良い気がしてきた。
    全ての処理は iso2022-dump.cpp を改造して実行すれば良いのである。

    というか最初は gawk の出力した無駄の多い巨大な
    .def ファイルをそのまま使って処理を実行しても良いのだという気がしてきた。

  取り敢えず実装するには実装した。色々とごちゃごちゃしている所はあるけれども。
  また描画についても簡単に対応した。

  取り敢えずこの時点で commit する事にする。
  また後で修正しなければならない事についてまとめる。

* iso2022: [考察] 現在の実装では NUL 及び DEL は iso-2022 の途中であっても [#D0196]
  無条件に無視しているがこの振る舞いで良いのだろうか。
  もしこれが普通の encoding の話であるのであれば無視してはいけない。
  一方でこれは端末であるという事を思えば無視しても良い様な気もする。

  * 通信の途中で変な事が起こったりすればキャンセルしたくなる事もある物である。
    と思ったが良く考えたら NUL 及び DEL というのは UTF-8 decode の後の文字である。
    通信の途中で変な事が起こって打ち消してもそれが UTF-8 decode で NUL/DEL に
    なるとは限らない…と思ったがよく考えたら NUL/DEL というのは 7bit なので、
    UTF-8 で透過するのである。なので UTF-8 decode とは独立である。
    とは言っても他の符号化方式を考えると必ずしも透過的ではないのである。
  * 後、DEL が打ち消しとして意味があるのは 7bit の時だけである。
    8bit の時には DEL のビットパターンは別に特別な物ではないのである。
  * また打ち消しに使うと考えてもそもそも打ち消しというのはパンチカードなどの
    話である。通信時の信号の 0/1 はパンチカードと違って不可逆な変化ではないので、
    別に打ち消しが 01111111_2 である必要はないのである。
    つまり、DEL のコードというのは歴史的な経緯にのみ拠っている。
    結局、実際の用途としては time fill に使うという事なのだろう。
  * もし time fill に使うのだとしたら、
    例えば複数バイト文字の途中で timefill を挿入する等の事に意味はあるだろうか。
    元々の送信者が途中で NUL/DEL を挟むという事は考えにくい。
    一方で、途中経路で何らかの同期を取る為に NUL/DEL を挟む事はあるのかもしれない。
    その時にはわざわざ復号して挿入してから符号化するというのは複雑なので、
    実際には文字の途中で挿入する事を許しても良いのではないだろうか。
    と思ったが、やはり UTF-8 decode 後の話なので、
    その意味ではやはり UTF-8 decode してから挿入してそれから encode する、
    という事になってしまう。
  * そもそも通信の timefill だとかそういうのはもっと下層レイヤーで解決されている
    筈のことである。それを通過して到着した NUL/DEL に対して特別な処理をする
    意味はあるのだろうか。と思ったが、少なくとも ECMA-48 に書いてある以上は
    その様に振る舞う必要があるのである。

  まとめると NUL/DEL に対する特別な処理はこのレイヤーでは実際的な根拠はない。
  ただ ECMA-48 に対する準拠の為に特別な処理をしているのだと考えるのである。
  その上で自然な振る舞いは何だろうか。

  ISO-2022 の処理の途中に入る NUL/DEL をどうするのか。
  ECMA-48 には LS1R だとか SI/SO だとか ISO-2022 の制御機能も挙げられている。
  UTF-8 decode した後での振る舞いを記述していると解釈しても、
  それらの処理はその場で一緒に処理しても良いようにも思われる。

  初めの UTF-8 decode の段階を char decode と呼んで、
  次の escape sequences の処理の段階を escape decode と呼ぶ事にする。
  char decode の段階の NUL/DEL を無視する必要はないが、
  escape sequences の段階の NUL/DEL は無視する。
  その時に複数バイトで構成される escape decode で生じる "文字"
  の途中に NUL/DEL が含まれていても無視するという振る舞いは
  それはそれで良い気がする。という結論。

2019-08-10

* term: csi_sequence の parameters を処理する度に [#D0195]
  メモリを確保している気がする。
  class sequence と同様に何処かで一つインスタンスを持っておけば良いのでは。
  例えば画面一杯に色を変えて描画しようとすると数万回のメモリ確保・開放が起こる。
  これは損であるという風に考えなければならない。

* iso2022: 様々な文字集合の対応 (2) term_t における挿入処理 [#D0194]

  取り敢えずは簡単に実装した。
  つまり1B文字は半角で2B文字は全角である。

  色々と議論が複雑になったが少し実装して整理された気がするので、
  以下の議論は取り敢えず此処に移動する事にする。

  | ? 文字コード表はどの様にするか。
  |
  |   a そのままソースコードに埋め込んでしまう。
  |   b ファイルから読み取る (iso2022.def)
  |   c ファイルから読み取る (binary dump)
  |   d ソースコードに (binary encoded form を記録する)
  |     そのまま binary 配列として埋め込むと容量を食う。
  |     なので iso2022.def に相当する内容を binary で表現して、
  |     実際に必要になった時に構築するという方法を使う。
  |
  |   うーん。これは取り敢えずはファイルから読み取るという形式で良い気がする。
  |   特にバイナリだとか複雑な事を考え始めるとまたバイナリ形式の最適化などに
  |   ついて考え始めてしまう。何も考えずに初めはテキスト形式で良いだろう。
  |
  | ? 実行時の文字コード表はどのように管理するのか?
  |
  |   DRCS で定義できる空間についても確認しておく
  |   と思って調べると DRCS で定義できるのは規格上は
  |   SP で始まる文字集合だけであるそうだ。
  |   従って既存の文字集合を書き換えることができるようにする必要はない。
  |   所で説明を読むと 94n 集合や 96n 集合すら定義できる様だ。
  |   但しそれぞれの文字集合で n として何を使うかを指定する方法はない気がする。
  |
  |   つまり、既存の文字集合を動的に変更するという事は考えなくて良い。
  |
  | ? DRCS で定義できるのは"文字"の対応なのか、それとも"字形"の対応なのか。
  |   特に Unicode への変換を考える時に問題になる。
  |
  |   a 様々の NRCS を考えるとコードから "文字" への対応と考えるのが良い。
  |     その時には画面上に既に出力している文字は、
  |     DRCS の組み換えによって変化する事はない。
  |
  |   b 或いは"字形"の定義と見做すことも可能だろうか。
  |     その場合には後で DECDLD で文字に対応する画像を差し替えると、
  |     既に出力された文字も再表示の際に表示内容が変化する。
  |
  |   もとの DEC VT がどの様に動作していたのかは分からないが、
  |   Unicode を考えるとやはり "文字" と思うのが良い気がする。
  |   DEC VT のリソースの制限に依る振る舞いまでも再現する必要はないのである。
  |
  |   →少なくともこの実装では "文字" と解釈する事にする。
  |   つまり、画面に表示するのは画面に出力した瞬間の字形である。
  |   DRCS Sixel 等の場合にも画面に出力した瞬間の画像を使う事にする。
  |   DECDLD で別の画像に差し替えた時に既存の表示を更新するなどの事は実施しない。
  |
  | ? 文字幅を真面目に実装するという事?
  |   ISO-2022 に関しては1B文字は幅1で2B文字は幅2で良いという様に考えたが、
  |   2B文字集合に含まれているアルファベット等はどの様に取り扱えば良いのだろう。
  |   と思ったが、もしかすると2B文字集合に含まれているアルファベットこそが、
  |   全角アルファベットなのだろうか。。
  |
  |   例の JIS X 0213 の表を観察してみる…。
  |   と思ったがどうも半角で変換表が構成されている様子だ。
  |   然し、JIS X 0213 の枠組みの中ではアルファベットは一種類しか存在しない。
  |   ？Ａやはり確かに全角アルファベットや記号は存在している。
  |   うーん。混乱と実装の煩雑化を避ける為にも JIS X 0213 に現れる記号や
  |   アルファベットのたぐいは全て全角の形に変換して取り扱うのが良いだろう、
  |   という気がする。
  |
  | * 取り敢えずの実装としては iso-2022 の1B文字は半角で取り扱う。
  |   iso-2022 の2B文字は全角で取り扱う事にする。
  |
  |   # 所で今気づいたのだが ble.sh での斜め矢印の幅と、
  |   # 端末の上での斜め矢印の幅の計算がずれている?
  |   # screen の外でも同じ様にずれてしまう。
  |   # contra の上でだけだろうか…。
  |   # Poderosa でもずれてしまう。
  |   # emacs ではずれない。という事は仲間はずれは ble.sh である。
  |   # ble.sh だけ曖昧文字幅の取り扱いがずれてしまっている…。
  |   # これについては後で処理する必要があるという事。
  |   # →これに関しては ble.sh の todo に入れておいた。OK

  問題が複雑になっている。同時に複数の事を考えている。
  問題を切り分けなければならない。

  * done: sequence_decoder 側での対応
    これに関しては単に文字を charset 情報付きで転送すれば良い。

    CZD C1D によって置き換えられた制御文字に関しては
    ちゃんと対応する制御コードに変換する必要がある事に注意する。
    但し、これに関しては未だ対応する予定はないのである。

    この時点で必要になるのはどの様な文字コードが存在しているのか、
    という情報だけなのである。対応する文字が存在しない領域で
    勝手にコードが送られてきたとしてもそのまま読み取ってしまえば良い。
    現に、Unicode の場合でもこの段階ではその code が実際に定義されて
    いる物なのかそうでないのかを判定するという事はしないのである。

    然し、これだと DRCS 等の場合に、文字コード情報が
    書き換えられた時に表示される内容も一緒に化ける様になってしまう。
    まあ、実装が自然な方を選択するという事で良いのかもしれない。
    後、DRCS で文字データが書き換えられた時に全体を再描画する
    必要が生じてしまうという事に関しては注意するべき。
    その為には DRCS のテーブルに version をつけて管理する必要がある。

  * done: term での対応
    これも文字の中身は確認せずにそのまま図形文字として処理すれば良い。
    文字幅は 1B 文字か複数バイト文字かだけで判定すれば良い。
    つまり複数バイト文字かどうかは character code を見て判断できる様にする。
    (制御文字に関しては普通に変換後の制御文字として送るので関係ない)

    この段階では文字コードの表は全く必要ないのである。

* iso2022: 様々な文字集合の対応 (1) sequence_decoder の一般化 [#D0193]

  [取り敢えず decoder だけでも対応する]

  ? reject: もしかするとどの様な文字コードが存在しているのかという事すら意識する必要はない?
    final byte の情報だけで全て encode してしまっても良いのではないだろうか。
    然し、その時に必要になる空間の大きさについては考えておく必要がある。

    そもそも IR に登録される文字コードが今後増えるとは考えにくい。
    増えるとしても何十も増えるという事は考えにくいだろう。
    という訳で 94 文字集合は Ft 及び 1Ft 型 だけに留まると仮定する。
    また 96 文字集合は Ft 型に留まると仮定する。
    94文字集合は残り56個の余裕がある。96文字集合は18個の余裕がある。
    96文字集合は少し危ないかもしれない。然し何れにしても
    文字コードの割当方法を contra の内部で変更するだけなので
    まあ問題はないだろうという様に思われる。
    94^n集合に関しては44個空きがある。96^n集合に関しては今後使われる予定はあるのだろうか。
    94^n集合で十分に大きいので、そして94^2と96^2を比較した時に差は2%程度に収まるので、
    結局は94^2集合が使われるのだろうという気がする。その様に考えると、
    まあ96^n集合の事は考えなくても良いのではないかという様に思う。
    というかよく考えたら94^n集合に関しては未だ一切対応していない。
    枠組みとしては対応して置かなければならない様な気がするのである。
    何れにしても複数バイト集合を対応する時に後で考える事にする。

    取り敢えず。面倒なので 96 文字単位で考える事にする。
    登録可能な文字集合の数は。64x3 で 8bit 使う。
    うーん。96文字格納するのに7bit使うとして、
    必ず 15bit は必要なのである。

    というか、よく考えたら私用文字コードの類も沢山ある。
    それらについても同様にコードの変換をしなくて済むように sparse
    になる様に配置すると考えると無駄な事になってしまう。
    更に、そもそもその文字集合が存在するかどうかの確認は結局する
    のであるから、それを考えると実はやはり各文字集合毎に
    文字集合に連続する一意のIDを振るというのが良い気がしてきた。
    94/96を区別する意味もない様な気がするので、区別せずに対応する。

  ? 各文字集合の識別と、更に中の文字をどの様に character_t で表現するか

    | というか変換が必要ないように sparse に対応するというのも何だか分からなくなった。
    | 別に掛け算・割り算を一回ぐらいけちった所で効率に差が出るとも思われない。
    | という事を考えると 128 単位ではなくて 96 単位で変換して良いのではないか。
    |
    | ? 前半 32 を制御文字の特別な文字集合に割り当てる事も考えたが、
    |   そもそも制御文字は変換するという事にしたのだったから関係ない。
    |   制御文字はその性格上その場で処理しなければならないのだから、
    |   必ず何らかの制御機能にその場で委譲しなければならない。
    |   従って code に符号化するという事は考えにくい。
    |
    |   また、前半 32 と後半 96 で用途を分けるというのは分かりにくい。
    |   その様に考えるとやはり 128 で 96/94 専用に領域を取るか、
    |   96単位で 96/94 専用に領域を取る事にする。
    |
    | * そもそも 128 がそんなにきりが良いのかという問題もある。
    |   処理的にはきりが良いので効率的に処理できそうな気がするが、
    |   仕様としては 256 なら未だしも 128 はそんなに分かりやすくはない。
    |   文字集合の識別がバイトを跨ぐ事になってしまう。
    |   然し、256単位にするとそれはそれで無駄にしている気がする。
    |
    | * また 94^n 集合の事を考える。特に94^2集合である。
    |   94集合の時には 128 の中に 94 文字を配置しても 3/4 の効率であったが、
    |   94^2集合の時には 14bit の中に配置すると 9/16 の効率になってしまう。
    |   更に、そもそも 16bit でなくて 14bit としている所が分かりにくい。
    |   だからと言って16bitにすると益々効率が悪い。1/6以下の効率になってしまう。
    |
    |   或いは 94^n 集合の時だけ 96x96 に収めて、
    |   94/96集合は128に収める?とも考えたがそれはそれで変だ。
    |
    | 結局潔く 96 単位で記録する事にする。

    結局以下の様に対応する。

    先ず iso-2022 に含まれる文字として読み取った物は charflag_iso2022 フラグを立てる。
    文字集合の識別番号を icharset として、文字の番号を ichar とする。
    この時、文字のコードは以下の様に計算する事にする。

    code = charflag_iso2022 | icharset * 96 + ichar

    94^2 文字集合に関しては、以下の様な具合にすれば良い。

    code = charflag_iso2022 | charflag_iso2022_mb2 | icharsetM * 96 * 96 + (96 * ku + ten)

    charflag_iso2022_mb2 についてはどの様に定めようか。
    適当に収まる様に定めれば良いのである。

  ? DRCS の文字はどの様にするのか?

    | これは予め領域を確保しておく必要があるだろうか。
    | 或いは動的に割り当てが決まってから使い始める事にすれば良いだろうか。
    | iso-2022 では DRCSはSPで始める事を要求しているらしいが本当か。
    | DECDLD に従うと designator は F か I F か I I F の形式だそうだ。
    | もし完全に自由に指定する事が可能だとすれば、
    | (1 + 16 + 256)*80 = 273*80 = 21840 個の領域が専有される事になる。
    | 或いは SP F もしくは SP I F の形式が許されるのだとすれば、
    | (1+16)*80 = 1440 個の領域が専有される事になるのである。
    | というかそんなに使う事があるのだろうか…。
    | うーん。DRCS Sixel の提案に従うと SP F の形式だけ mapping されるそうだ。
    |
    | 21840*96 = 0x1ffe00 だそうだ。なので 21bit あれば表現可能なのだ…。
    | うーん。然し、これだけの広大な空間に対応する必要はあるのだろうか…。
    | 後、そもそも DRCS が定義されていない時にどう振る舞うべきなのかも気になる。
    | 結局色々と ECMA-35 を参照する必要がある。
    |
    | ★ECMA-35 によると文字集合の定義方法は事前に定められた方法で行うとされ、
    | 具体的にどのような方法を用いるかについては指定されていない。
    | また、94, 94^n, 96, 96^n のそれぞれに対して独立に定義する事ができる。
    | SP Ft の形式の場合には "SP @" - "SP ~" の 63 個を使う事が推奨されている。
    | 更に SP I Ft やもっと沢山の I を含める事も許されている。
    |
    | うーん。これは難しい。仕様上は無限に定義できる事になっているので、
    | 事前にどのコードにどの文字列を割り当てるのかというのを定めるのは難しい気がする。
    | 或いは動的に割り当てるという事にすれば良いのだろうか…。
    | そちらの方が現実的なのかもしれない。というのもユーザが不意に &%c だとか、
    | 変な物に対応しようとかする可能性があるからである。
    |
    | 決めた。Unicode DRCS mapping (DRCSMM) の対象になっている部分に対しては
    | 固定した領域を与える事にする。それ以外の領域は動的に割り当てる事にする。
    | DRCSMM では94文字集合については SP F の形式で 80 種類登録可能である。
    | 96文字集合についても SP F の形式で 80 種類登録可能である。
    | 合わせて 160 * 96 文字の領域を割り当てたいという気がする。
    |
    | 従って DRCS 領域の初めの 160 に関しては予約しておく事にする。
    | それ以降に関しては実際に文字集合を定義した時に動的に割り当てる事にすれば良い。
    | 94^n/96^n 集合を定義できる様にする余地はあるのだろうか。
    | 調べてみると DECDLD では Pscs という引数で 94, 96 文字集合を選択できる様だ。
    | 定義されているのは 0, 1 のみだが実はこれは 2, 3 等にも拡張する事ができるのではないか。
    | 例えば 2, 3 がそれぞれ 94^2, 96^2 文字集合で、
    | 4, 5 が 94^3, 96^3 文字集合でという具合に拡張できる。
    |
    | * 所で 96^3/94^3 文字集合について考えてみると、合計で88万字 (~1M) 登録する事になる。
    |
    |   x 現実的でないし、更に一文字に対して数バイトは必要と考えると
    |     10M ぐらいのメモリを絶対に食う。やはり現実的ではない。
    |
    |   x というか、文字の定義をどの様にするのか謎である。10M ぐらいのデータを
    |     送りつけないと有効に初期化することができないのではないだろうか。
    |     勿論形式を工夫すれば sparse に定義する事ができるかもしれないが、
    |     その様にするぐらいであれば 94^2 を複数登録するのが現実的である。
    |     これは実際の複数バイト文字集合が 94^2 しかない所以であろう。
    |
    |     # 因みに 94^2 集合の場合には仕様書は典型的に 12p 使っている。
    |     # 94^3 集合を考えると 94*12 ~ 1000p ぐらいの仕様書になってしまう。
    |     # まあ、実際には全ての面を使う訳ではないのだから大分圧縮する事は可能だろうが。
    |
    |   x 更に 96^3 = 884736 = 0xd8000 なので、一つの文字集合を定義するだけで
    |     20bit 使ってしまう。現在の character_t の配置だとたった1回で
    |     DRCS 用に用意した領域を使い果たしてしまう。
    |
    |   そういう事を色々考え合わせると 94^3 集合以上には対応しないというのが自然である。
    |
    | * DECDLD の説明を改めて読んでみると、別に文字を新しく定義するというよりは、
    |   既存の文字の表示方法を変更するという意味で、既存の登録された文字集合に対する変更も
    |   可能になるという雰囲気である。或いは登録されていない文字集合に対しても
    |   適当に文字集合を定義する事が可能になっているのである。

    結論としては DRCS Sixel 提案における mapping が定義された領域については
    予約領域として最初から確保しておく事にする。それ以外の文字集合に関しては、
    実際に定義された時に初めて動的に確保する事にする。
    文字集合を使い果たした時には確保に失敗するという事にする。
    或いは最近使われていない文字集合を勝手に削除してしまうという事も考えられるかもしれないが、
    然し、一旦表示できていたものが後でいつの間にかに見えなくなっているというのは凶悪なので、
    それよりは表示できないという事がその場で分かった方が良いのである。

  ? 考えて見るに DRCS Sixel というのが本当に便利なのかは分からない。

    | 複数のアプリケーションが動いている場合にどうやって
    | 互いに使っている DRCS の範囲を被らない様に管理するのだろうか。
    |
    | 結局前面に出ているアプリケーションが全てを支配するという事になる。
    | 一旦裏面に行ってそれから表に出てきた時には改めて全て初期化しなければ、
    | ちゃんと動作するという事を保証する事ができない。
    | つまり描画の度に毎回全データを送る必要があるのである。
    | 然し、考えて見るにまあどうやっても元々そんな物なのかもしれない。
    |
    | * 文字を外字として登録するのに限るのであればそんなに沢山の文字を定義する事はないから
    |   現実的に効率的な問題になる事はないのではないかと思われる。
    |
    |   然し、効率的な問題は置いておくとしても
    |   DRCS 空間の取り合いというのを自然に解決する方法があるのかは気になる。
    |   結局 unicode の私用領域と同様に特定用途でしか使わない端末だとかで使われるか、
    |   或いは vendor 等が定義した文字をユーザはそのまま受け入れて固定的に使う、
    |   という具合に使われるしかないのではないかという気がする。
    |
    | * 一方で、画像を表示したりする目的で沢山の DRC を定義するのであれば、
    |   そもそも毎回画像データを送るというのは仕方のない事である。
    |   其処をけちるという事の意義も余りないように思われる。
    |   というか、そういう用途は本来は異常な用途であり、
    |   そういう使い方を想定して設計を論ずるのは間違っている気がする。
    |
    | というか DECDLD を使って "新しい文字集合" を定義できるかと思ったがそうでもない。
    | 改めて仕様を観察してみると文字の定義は飽くまで sixel を通じて行わなければならない。
    | つまり、新しく unicode への mapping を定義できる訳でもない。
    | RLogin が対応している Pt = 3 というのは一枚の画像を分割するという意味なのだという事。
    | 因みに Pt = 1 は自動的に centering をして各文字の glyph とするもの。
    | そして Pt = 2 は全てのピクセルに対して定義を与えるというもの。
    | 実は stroke フォントだとか outline フォントだとかを此処にエンコードして送信しても良いのかもしれない
    | 等と、そんな事を考えている。現代的な事を考えるとピクセルで送信するよりも outline フォントの
    | グリフデータを送る方が現実的なのではないかなどと考えるのである。というか SVG ?
    | 検索してみたがそういう議論は為されていない様子である。まあ良い。

    結局端末アプリケーションは自分が前面に現れた時に
    再度 DRCS で自分の使う文字の字形を全て初期化しなければならない。
    然し、変な使い方をしない限りはこれで特に問題になる事はないのではないかという気がする。

  うーん。文字集合の定義はどのレベルで共有するべきなのだろうか。
  term_t インスタンスが複数あった時にその間で共有できる様にする必要性はあっただろうか。
  例えば親 term に子 term から範囲を切り出す必要性が生じた時など?
  然し、そういう時には端末シーケンスに一旦変換してからにした方が良いだろうか?
  うーん。然し、登録されている文字集合はしかし独立であって欲しい。
  うーん。まあ、取り敢えずは文字集合の存在とかに関しては
  全体で共有という形で良い様に思う。後で独立に管理したくなったらその時に
  各 term_t もしくは sequence_decoder で文字集合の定義を持つ事ができるようにすれば良い。

2019-08-09

* iso2022: 94文字集合 [#D0192]
  うーん。対応している内に不毛な気がしてきた。
  既存の表が存在しないのが謎である。
  よく考えたら mlterm だとか RLogin は実装しているのではないか。
  中にあるデータを抽出すれば良いのではないだろうか。

  * iconv -l で探してみたが ISO 6438 等は登録されていない様だ。
    というか DIN で検索しても一つしか当たらない。
    実は iconv は iso-2022 に関しては網羅していないという事なのか。
    まあ、実際には ISO だとかの規格よりは IBM や Microsoft の実装の方を
    優先するのが現実的なのだろう。

  * mlterm の中を見てみる。文字コードの表は
    mlterm/encodefilter/src/ef_charset.h にハードコードされている。
    良く見ると残念な事に 94 文字集合については10個しか実装されていない。
    0@ABCEGHIJ に対応している。雰囲気として表の上の方にある物から実装して行って、
    途中まで実装して不毛であると判断して諦めたという事なのかなという様に思われる。

  * RLogin の方も確認してみる事にする。
    RLogin/RLogin/TextRam.cpp の void CFontTab::Init()
    という関数に様々の文字集合がハードコードされている。
    こちらも 94 文字集合は 10 個しか実装されていない。

    面白い事に対応している文字集合の種類は mlterm とは少し異なる様だ。
    012@BIJT と &5 %2 に対応している。12 及び &5 %2 の出典は何処だろう。
    実は private charset にも沢山の charset の宇宙が広がっているのだろうか。

  うーん。結局何処にもデータはないのである。
  自分で作るしか無いという事なのであろう。。。

  emacs で編集したら combining characters を入力した所で表示が乱れる様になってしまった。
  まあ、仕方がないのである。combining characters の文字幅までちゃんと実装するのは面倒である。
  それに combining characters を実装したとしても端末上の操作で難が生じる。
  そもそも記号が見えないし、combining 部分だけを選択する事もできない。
  emacs が combining を解釈しなければそれはそれで良かったのだが、
  この様に対応しているという事が分かった以上はもっと別の表現方法を考えても良いのかもしれない。
  文字によっては直接入力するのではなくて <U+301> 等の様に表現する事を許す様にする?
  うーん。その形式が良い様な気がしてきた。

  既にある物を変換しなければならない。プログラムを書いて変換した。OK

  * ISO-IR-59 について
    これは難しい。アラビア語が分からないと駄目。また結合文字も色々ある

    * "ISO-IR-59" で検索するとそもそも以下のサイトしか存在しない。
      https://www.mirai-ii.co.jp/moji/mojikan/code2.html
      更に同じ著者の https://miraicorp.blog.fc2.com/blog-entry-73.html
      を見るとアラビア語については断念したと書かれている。

      そもそも対応するとかしないとかいう事は何かソフトウェアなのかと思ったら
      以下に公開されている "もじかん" というソフトウェアなのだそうだ。
      http://www.mirai-ii.co.jp/moji/mojikan/

    * "CODAR-U" unicode table で検索してみた所、Google の検索 summary に

      Table 1 7-bit Arabic character set (ASMO-449) The final product was a
      7-bit unified code (known as CODAR-U/FD '1, which was later agreed
      ..... ACM 33 (5) (1990) 495-504. ml The Unicode Consortium, The
      Unicode standard: (Version 1.0).

      の様な文章が載っている。然し、リンクに入ってみると色々と
      Google アカウントだとかの認証を迫られるので入らなかった。
      何れにしても ASMO-449 で検索してみる事にしたのであった。

      Wikipedia に記事がある。うーん。似ていない。
      と思ったらこれは ISO-IR 89 と書かれている。実は既に登録していた物だった。
      https://ja.wikipedia.org/wiki/ASMO_449

      検索して出てきた 067225freo.pdf というフランスの文書
      (IERA アラビア支援プロジェクト?) の p85 に CODAR-U の表がある。
      何か文字情報が埋め込まれていると思ったが OCR による適当な読み取り結果だった。
      普通に変なアルファベットやらASCII記号類が割り当てられていたので役に立たない。
      後分かった事は CODAR-U/FD というのはまた CODAR-U とは異なる物の様だという事。
      CODAR-U/FD はそのまま ASMO になったのではないかという気がする。

    * 何れにしても CODAR-U は謎である。一つずつ解明していくしかないのか。
      調べるとアラビア語は基本的には子音だけであって母音は結合記号として補足する様につける。
      文字の上に斜め線が a であり下に斜め線が i である。w みたいな物は子音重複を表し、
      これがある時には文字本体ではなくて w の上下に a または i を置くのである。
      9みたいな形をしたのが u である。
      更に二重線にすると an in になって 9 の尻尾を上に上げたのが unである。

      ? 横棒が一体何であるのかは謎である。棒のあるなしは名前的には
        sur barre と sans barre として区別されている様に見える。
        というかこれは単にフランス語で over bar, without bar の事である…。
        つまり横棒は本当に横棒であって何らかの placeholder とかではない様だ。

        % →https://de.wikipedia.org/wiki/Zwarakay に説明があった。
        %   この横棒は Zwarakay というらしい。あいまい母音?
        %
        % アラビア語の母音は Fatha (a) Kasra (i) Damma(u) Zwarakay (e) だそうだ。
        % 何れにしても記述の順序が良く分からない。
        %
        % https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%A3%E3%82%AF%E3%83%AB
        % うーん。此処には Zwarakay の事は載っていない。morocco のアラビア語、
        % もしくはパシュトゥーン語特有の記号なのだろうか。何れにしても、
        % U+0659 ARABIC ZWARAKAY (Pashto) であるそうだ。
        % 今調べたらモロッコはアフリカの西の端にあってパシュトゥーン人は
        % アフガニスタンに住んでいるそうだ。全然関係なさそうだ。
        %
        % うーん。メモ帳で調べてみているが分からない。
        % w と aiu の入力する順序は実はどちらでもよいらしい。
        % 然し zwarakay とその他の母音を組み合わせる事はできない様だ。
        % 本当に横棒は zwarakay なのだろうか。実は違うのではないかという気がしてきた。
        % 棒があるかないかというのは他の音素と組み合わせた時に、
        % 字の形的に棒があると便利とか不便とかそういう事だったりするのではあるまいか。

        分かった。zwarakay は全く関係なかった。
        これは tashkil もしくは kashida と呼ばれている物の事である。
        アラビア文字を伸ばすのに使われる棒であるが、
        実は母音を単体で表記する時にも用いられるのだそうである。

        従って、
          A = <kashida><shadda><fatha>
          B = <shadda><fatha>
        という具合に複数の文字から為る文字として変換する必要がある。
        現状の枠組みでは一つの文字に一つの文字しか割り当てられない。
        これは修正する必要があるのである。

    結局 Unicode の表と ISO-IR の表を比べつつ、
    アラビア文字を調べつつ最終的に対応表ができた。

  * ソフトウェア "もじかん" に関して

    % 上記の ISO-IR-59 の検索で見つけたソフトウェア。
    % https://web.archive.org/web/20130621141320/http://www.mirai-ii.co.jp/moji/mojikan/download.html
    % 試しにダウンロードして動かそうとしてみたが Authentication failed となってしまう。
    % やはり購入しなければならないのだろうか。
    %
    % $ strings gtef.dll | grep Authentication
    % LibAuthentication
    % LibAuthentication
    % LibAuthentication
    % Output DLL: Authentication failed
    % LibAuthentication
    % Input DLL: Authentication failed
    %
    % つまり gtef.dll の中で認証を確認しているのである。
    % ところで Authentification と authentication は違う単語なのだった。
    % https://srad.jp/~oku/journal/491695/
    %
    % バイナリエディタでアドレスを確認する。
    % 2c0f0 "Output DLL: Auth..."
    % 2c480 "Input DLL: Auth..."
    %
    % * これを $ objdump -dCM intel gtef.dll > a.s した結果と比較する。
    %   というか目盛り上のアドレスとの対応が分からない。
    %   10001f00 にある e8 4b 55 00 00 という命令列はファイル上では
    %   00001300 に置いてある様である。もしバイナリが丸ごとメモリ上に乗るのであれば、
    %   同様にずれている筈である?
    %   確認してみる Output は 1002ccf0 にある筈である。
    %   と思って確認しようとしたらファイルは 1002c5ed で途切れていた…。
    %   うーん。リソースに埋め込まれているという事の気がする。
    %   a.s は 1002c5ed+5 = 1002c5f2 で終わっているので
    %   ファイル上では 1002b9f2 で終わっている筈である。
    %   確かにそうなっている。というかアドレスを見るまでもなく
    %   バイナリとしてデータが一致している。
    %
    %   念の為 1002ccf0 で a.s を検索して見る。やはり何も見つからない。
    %   やはりデータはリソース等として別に保存しているという事なのだろう。
    %
    % * うーん。そもそも DLL の関数呼び出しも見えない。
    %   $ dumpbin /DISASM gtef.dll で試してみても見えない。
    %   depends で見ると CloseHandle 等呼び出している様なので
    %   検索するが .s には出力されていない様だ。
    %   デバッガと一緒に起動するしかないのだろうか。
    %
    % * 或いは別の手法があっただろうか。gdb で DLL 呼び出しにトラップできただろうか。
    %   然し、そうだとしてもどうやってその目的の位置で呼び出している関数を特定するのか。
    %   strace を実行してみたがどうも有用な情報は何も出力されない。Cygwin だからだろうか。
    %
    % * どうも Dynamic に DLL を読み込んでいる様だ。
    %   後 components の中にあるどの DLL も LibAuthentication という関数を export している。
    %   これに失敗すると駄目という事なのだろうと思われる。
    %
    % * 目的は何だったか。テーブルを入手する事だった。
    %   それならばリソースを見たら良いのではないか?
    %   と思ったがリソースに登録されているという訳でもない様だ。
    %   つまり、ソースコード中に直接巨大なテーブルを記述しているという事だろうか。
    %   うーん。少なくとも objdump -d した中には含まれていない気がする。
    %   巨大な lng_zh.dll を -d しても其処までは巨大にはならなかった。
    %
    % * GUI 版も動かそうとしてみたがそもそも選択肢が少ない。
    %   というか結局 DLL エラーと表示されて実行できないのであった。
    %   gtefapi.h にも何も関数の呼び出し方は書かれていないし、
    %   depends で見ると幾つか関数は export されている様だが引数が分からない。

    もじかん からデータを抽出するのは諦めた。時間の無駄である。
    そもそもデータだって信用できるか分からないので、
    結局で自分で目で見て確認する事になる。
    と思ったがやはり目で見て確認するだけというのは楽なのである。

  * 何と iconv -l | grep ISO-IR したら幾らか出てきている…。
    うーん。幾つかは iconv からテーブルを作る事もできるのではないか。

    linux の iconv と cygwin の iconv ではまた対応しているコードに差がある。
    以下は cygwin の iconv だけで対応している文字集合である。後で調べる
    ISO-IR-58  MB94 Chinese Character Set Chinese Standard GB 2312-80
    ISO-IR-87  MB94 Japanese Character Set JIS C 6226-1983
    ISO-IR-149 MB94 Korean
    ISO-IR-159 MB94 Supplementary Japanese Graphic Character Set for Information Interchange
    ISO-IR-165 MB94 CCITT Chinese Set
    ISO-IR-230
    →結局230しか有用なデータは取得できなかった。
    →これは他は全て MB94 だったからであった。

  * ISO-IR-147 で検索したら以下を見つけた
    https://github.com/winlibs/apache/tree/master/2.4.x/srclib/apr-iconv/ccs
    他にも色々あるようである。対応している番号は以下の通り。今までで一番充実している。
    公式だと https://github.com/apache/apr-iconv/tree/trunk/ccs ここにある。
    然し、結局ちゃんとメンテナンスはされていない様だ。12年前から変化がない。

    2 4 8-1 8-2 9-1 9-2 10 11 13 14 15 16 17 18 19 21 25 27 37 47 49 50 51
    54 55 57 60 61 69 70 84 85 86 88 89 90 91 92 93 94 95 96 98 99 102 103
    111 121 122 123 128 139 141 142 143 146 147 150 151 152 153 154 155 158

    中でも以下については未だ実装していない物であるので参考になる。
    111 123 139 142 143 146 147 152 153 154 155 158

    iconv にも登録されていないのが以下である。
    123 142 152 154 158

2019-08-06

* acs: DECDWL, DECDHL に対応する [#D0191]

* acs: 矢印、ダイアモンド、不等号、π などは自分で描画する? [#D0190]
  その場合には色々のフォントの効果を考慮に入れるかどうか…。
  実は大体 Ambiguous なのではないか…。
  調べてみると殆ど Ambiguous である。

  というより ACS_STERLING が幅1である事以外は、
  ACS_LANTERN が対応する文字がないという事と、
  ACS_DIAMOND で diamond suit を対応させた事を除いて、
  全て Ambiguous である。

  これらの記号に関してはフォントの効果によって位置や大きさを変更したい。
  という事を考えるとやはり自前で描画するよりは文字列として描画したい。
  然し、日本語フォントは Ambiguous = 2 が普通なので、
  ACS が幅 1 である事を考えるととても都合が悪いのである。

  * CreatePatternBrush
    https://docs.microsoft.com/ja-jp/windows/win32/api/wingdi/nf-wingdi-createpatternbrush
    CreatePatternBrush というのがあるらしい。
    1bit bmp を指定すると textcolor/backcolor にしてくれるそうだ。
    然し、backcolor として transparent にしてくれるのだろうか。

    http://www.kumei.ne.jp/c_lang/mfc/mfc_10.htm
    ここを見ると SetBkMode(TRANSPARENT) にしておけば背景色を塗らない様にできそうな気もする。
    →実際に試してみた所、駄目だった。

  * CKBOARD を CreatePatternBrush で実装してみた。
    然し、背景色も一緒に書き込まれてしまう。
    SetBkMode(hdc, TRANSPARENT) も効果はなかった。
    結局、自分で斜めの線を一本ずつ書くしかないのだろうか。

    void checked_rectangle(coord_t x1, coord_t y1, coord_t x2, coord_t y2, color_t color) const {
      UINT pattern = 0x5555AAAA;
      HBITMAP hbmp = CreateBitmap(2, 2, 1, 1, &pattern);
      HBRUSH hbrush = CreatePatternBrush(hbmp);
      RECT rc;
      ::SetRect(&rc, x1, y1, x2, y2);
      ::SetTextColor(hdc, contra::dict::rgba2rgb(color));
      ::SetBkMode(hdc, TRANSPARENT);
      ::FillRect(hdc, &rc, hbrush);
      DeleteObject(hbrush);
      DeleteObject(hbmp);
    }

  * X でも CKBOARD を Pixmap を使ってできないか? という事。
    fill_style = FillStippled 及び stipple = pixmap でできそうな気がする。
    調べると丁度同じことをしているらしいコードが見つかる。
    https://github.com/redsPL/amiwm/blob/master/requestchoice.c

    状態を復元しようとして以下の様にすると BadPixmap エラーになってしまう。
    仕方がないので GCFillStyle だけ元に戻す事にした。

    | XGCValues params_old;
    | XGetGCValues(m_display, m_gc, GCForeground | GCStipple | GCFillStyle, &params_old);
    |
    | ...
    |
    | XChangeGC(m_display, m_gc, GCForeground | GCStipple | GCFillStyle, &params_old);

  取り敢えずポンド記号以外は全部自前で描画する事にした。

* ACS 対応? [#D0189]
  特に罫線には対応したいという気がする。
  先ず term 側の対応として。ACS の時には acs のフラグを立てて文字を挿入するという事が必要。
  insert_graph の側で対応が必要だろうか。

  terminfo の説明に acs に使われる文字の一覧が在る。
  }.,+-h~af`z{qinymj|goprs0wutvlkx
  これらの文字だけ別の文字に交換して表示するのである。
  然し、ここに全てが載っている訳ではない気がする。
  というかうーん。xterm で試してみた所 .,+- は使っていない…。
  取り敢えず xterm では \u0060-\u007D (英小文字および`{|}~) に割り当てられている。
  terminfo 的には \u0060-\u007D の内 bcde 以外と .,+-0 に割り当てられている。

  何れにしてもACSは \e(0 と \e(B という iso2022 の仕組みを使って実装されているので、
  微妙といえば微妙である。これに中途半端に対応するよりは一応 iso2022 にちゃんと
  対応する方向性で拡張を加えた方が良いのだろうか。

  何れにしても描画の際には Unicode に変換して描画するか、
  或いは何らかの描画コマンドに変換して描画するのである。
  そう言えば太字だとかイタリックだとかにも反応するべきなのだろうか。
  うーん。Unicode に変換して描画する際にはそれに応じて描画するべきである。
  というか、DECDWL 等の場合にもそれに応じて描画するべきである。
  という事を考えると描画コマンドに変換して描画するというのは結構面倒である。
  色々な事を考慮に入れて実装しなければならないのであるから。
  まあ、描画に関しては取り敢えず置いておく事にする。

  * [文字集合] うーん。取り敢えず色々な文字集合を取り扱う事ができる様にする?
    元々使っている文字集合以外の文字に関しては flag_acs_character を使う事にする。
    その上で 24bit の中に様々な文字集合を詰め込む事ができるだろうか。。
    レンダリングの問題は置いて置くとして兎に角挿入するという事。
    文字幅の判定はどの様にするのが良いだろうか。
    一旦 Unicode に変換してその上で文字幅を設定する?
    或いは独自にテーブルを用意して判定する?

  * [文字集合] 問題は文字コード (iso2022) の処理をどのレベルで実行するかという事

    | a sequence_decoder のレベルで文字コードの decode も処理してしまうか、
    |   うーん。これは違う気がする。やはりエスケープシーケンスと
    |   その他の制御シーケンスは同列に扱いたい。
    |   少なくとも sequence_decoder の実装に含めたくはないのである。
    |
    |   というかこの辺りの議論は #D0008 及び #M0001 も関係してくる。
    |   当時は文字コードの処理は先に処理してしまえば良いという事にしていた。
    |   それに従うと acsc やその他の iso2022 の文字集合に関しては、
    |   Unicode に map して処理する事になっている。本当にそれで良いのか。
    |
    | b 或いは terminal のレベルで文字コードの処理を実施するか。
    |
    | c 或いは間に一枚層を入れて処理するべきなのかもしれない。
    |   間に層を入れるとより一層処理に時間がかかる様になってしまう。
    |
    | 何だか分からなくなった。改めて考える事にする。
    | 問題は文字符号化方式を完全に端末の処理と分離しようとした事にある。
    | 然し、本当にそれで良いのだろうか。UTF-8 や SJIS の様な文字符号化方式の場合には
    | 制御シーケンスやエスケープシーケンスと相容れないので先に処理する必要があった。
    | 一方で iso2022 の場合にはちゃんと制御シーケンスとエスケープシーケンスが独立に
    | なる様に設計されているのである。この場合にどの様に振る舞うべきなのかというのは
    | 非自明である。使っている文字コードの種類に応じて振る舞いを切り替えるべき?
    |
    | うーん。というか iso2022 の場合には CSI seq もちゃんと認識して、CSI seq の中に
    | 含まれている文字を不用意に変換してしまわない様に注意しなければならない。
    | 或いは Unicode に適当に mapping してしまうとそれでもう破壊されてしまう。
    | そういう事を考えると iso2022 の処理と制御シーケンスの処理はやはり一緒に行うべきだろうか。
    |
    | 一方で utf-8 の事を考えると…。UTF-8 の上で iso2022 のシーケンスが載っている場合に、
    | 実装はどの様に振る舞うべきなのだろうか。iso2022 のシーケンスは無視してそのままの形で
    | 文字を出力するのが良いのか、或いはちゃんと認識して iso2022 に従って変換した文字を挿入するのか。
    | 端末上では acs を処理する事になっている。これは iso2022 に従って変換を行う事を示唆する。
    | 少なくとも acs の自然な拡張が iso2022 の変換処理に繋がっている。
    |
    | 其処で問題になるのは acs の処理は UTF-8 の上で記述されているのか、
    | 或いはその前のレベルで記述されているのかという事である。
    | a 何れにしても 8bit iso2022 の処理を認識する様にしてしまうと、UTF-8 を破壊する。
    | b 7bit iso2022 の処理に制限するという事も可能であって、その時には UTF-8 の処理と前後しても問題ない。
    |   つまりどちらかを先に処理してどちらかを後で処理しても問題はなさそうな気がする。
    |   % と思ったが本当だろうか。iso2022 で勝手に文字を変換するとやはり UTF-8 の復号の時に分からない事になる。
    |   % 文字を変換するとしたらやはり UTF-8 の復号は行った後に適用するべきなのではないか。
    |   % →G1の文字を使い出すと変な事になってしまうが、G0の文字だけしか iso2022 で対象としないのであれば、
    |   % UTF-8 を後で処理する事にしても問題はないのだという気がする。
    | c iso2022 で 7bit しか取り扱わないのだとすれば、
    |   UTF-8で複合した後の 128-255 の値はどうするのが良いのだろう。
    |   実はこれについて iso2022 8bit として取り扱うという選択肢がある。
    |
    | 問題を整理すると
    |
    | a iso2022 を 7bit に制限するのであれば UTF-8 復号と前後しても問題は生じない。
    | b iso2022 を 8bit まで拡張して取り扱い UTF-8 復号より優先させるとすると、
    |   UTF-8 の解釈を破壊して滅茶苦茶になってしまうので良くない。
    |   つまり UTF-8 を使わない時には iso2022 でそのまま取り扱っても良いのかもしれない。
    | c もし UTF-8 と iso2022 8bit を両立させるのだとすれば
    |   UTF-8 を先に復号してから iso2022 の解釈を適用させるしかない。
    |   その他の文字コードの場合にはどうかは分からない。
    |   EUC-JP や iso2022-jp の場合には iso2022 の部分集合になっているので問題ない。
    |   SJIS や UTF-16 等の場合にはやはり先に文字コードの復号を行ってから処理するべきの気がする。
    |   これらの符号化方式の中には iso2022 を混乱させる要素が含まれている。
    |   また、UTF-8 の時と同様に文字が勝手に変更されたりすると訳が分からない事になる。
    |
    | iso2022 7bit に制限すれば UTF-8 とは互換である。
    | つまりどちらを先に処理しても問題は発生しない。
    | 然し、sjis 等は続きバイトとして 7bit 文字も使うので、
    | iso2022 で変換されてしまうと文字が変化するなど問題がある。
    | UTF-16 等に関しても2バイト目に制限はないのでやはり iso2022 で変化してしまう。
    | 従って、iso2022 と互換でない文字コードに関しては先に復号しておく必要がある。
    |
    | 先に UTF/sjis 等を復号してしまう事に決めれば実は
    | iso2022 8bit 迄解釈しても良いのではないかという事になる。
    | 因みに ACS は 7bit の範囲内で完結する様になっている。
    | というか逆に 8bit の範囲で取り扱える実装が存在するのかは不明である。
    | →RLogin で試してみた所ちゃんと動いた…。
    |   $ printf '\e)0\u00E1\e-A'
    |   更に、RLogin は \u00A0-\u00FF を G1 として使用しているという事。
    |   つまり UTF-8 の復号の後で iso2022 の処理を実行している。

    取り敢えず実装としては
    1 UTF/sjis 等のステートレスな文字符号化方式については先に処理する。
    2 iso2022 や acs 等の処理は端末の処理の一部として実施する。
      特に取り敢えずは文字に mapping してしまって良い様な気がする。

    # 因みに RLogin も上記の様な方針を取っている様子である。
    # mlterm については具体的には確認していないが、
    # どの iso2022 文字集合の文字かという情報も一緒に記録している様子である。
    # つまり unicode に写像せずにそのまま文字集合の種類と一緒に記録している。

  * iso2022 部分実装

    実装の方針が固まったので少し実装して様子を見てみる事にする。

    | うーん。やはり分からない。マルチバイト文字の場合、
    | 途中で別の文字(制御文字)を受信したらエラーとして取り扱うべきなのでは。
    | 然し、別の文字が現れたかどうかについてはどの様に判定したら良いだろうか。
    |
    | 結局、sequence decoder の側で良い様に取り扱う必要があるのではないか。
    | 上の議論で決定したのはUTF復号化が先に行われるべきという事だけであって、
    | sequence の処理を sequence_decoder のレベルで行うか、
    | 或いは端末のレベルで行うかに関しては何も決めていなかったのである。

    うーん。端末のレベルで実装すると色々と面倒な事になりそうなので、
    取り敢えず sequence_decoder の方で実装する事を考える事にする。

    sequence_decoder で実装するとしてどの様な解析状態を用意するべきだろうか。

    | 状態としては G0-G3 にそれぞれどの文字集合が割り当てられているかと、
    | GL, GR に現在どの文字集合が割り当てられているのかという事と、
    | それから Single Shift の状態である。
    | 更に GL,GR に割り当てられている文字集合が複数バイトの時には、
    | 現在何バイトまで読み取ったのかという事も考慮に入れなければならない。
    |
    | 先ず初めに文字集合の割当が普通で SS でもない時には特に処理しなくて良い様にする。
    | 今まで通り decode_default をこの用途で使う事にする。
    | 文字集合の入れ替えが起こっている時は decode_iso2022 を使う事にしようか。
    | 然し、そうすると制御シーケンス等から戻った時に decode_default になってしまう。
    | 制御シーケンスから戻る時にどの状態に戻るかを変数に持っておく事にしようか。
    | それが良いという気がする。

    取り敢えず好い加減に実装した。最低限動作している気がする。
    ACSを端末画面に挿入することはできるようになった。
    rendering に関しては未実装である。

  ? 然し、思うに input_decoder の方はまた色々と事情が異なる気がする。
    ESC に続いて好きな文字を入力する事ができてしかるべきなのである。
    これが丁度文字コードに対する指令の様になってしまっている可能性もあって、
    その様な場合に input_decoder はどの様に振る舞うべきなのかなどよく分からない。
    文字コードに関する指令になっている場合にはそう解釈して、
    文字コードとしての解釈に失敗したらばらして Meta 修飾なり何なりと解釈するという作戦で良いのだろうか。
    取り敢えず input_decoder の事は忘れる事にする。

  取り敢えず ACS に対応するだけは対応した。

* manager: multiple click selection の時に [#D0188]
  幅がそれで広くならない場合にはスキップして次の大きな範囲を選択する?
  幅が広くならないという事は dirty を見れば分かる、
  と思ったが実際に試してみると常に dirty になっている。
  line_t::set_selection はちゃんと現在の状態も考慮に入れて dirty を更新する筈だが。
  と思って具体的に動作の様子を調べてみると実は set_selection を呼び出す頃には
  ssa protected の属性は解除されてしまっている。何故だろうか。

  うーん。on_select_initialize が呼び出されて其処でクリアされている気がする。
  そもそも on_select_initialize でクリアする必要もないのである。
  という訳で寧ろ multiple_click の初回 (つまり最初の単独ボタン mouse down) で
  selection_clear() する様に変更した。

* twin: bash 以外のシェルを起動しようとすると tty が変な状態 [#D0187]

  zsh を起動してみたら以下のエラーが出てちゃんと起動しない。使えなくはないが
  $ zsh
  zsh: can't set tty pgrp: operation not permitted
  この中でコマンドを実行すると実行できるコマンドもあるが、
  然し bash 等を起動する事ができない。

  dash も駄目な様だ。tty はちゃんと文字列を返す。posh も駄目。ksh も駄目
  $ dash
  dash: 0: can't access tty; job control turned off
  $ tty
  /dev/pty19
  $ posh
  /bin/posh: No controlling tty (open /dev/tty: No such device or address)
  $ ksh
  /bin/ksh: No controlling tty: open /dev/tty: No such device or address
  /bin/ksh: warning: won't have full job control

  /bin/sh は大丈夫。また、/bin/sh, /bin/bash を起動してから
  中で zsh, ash, dash を起動した場合には問題は発生しない。
  zsh, ash, dash, posh, ksh から始めると sh, bash は起動できない。
  exec sh, exec bash ならば起動できる。一度 exec sh, exec bash すれば、
  後は zsh, ash, dash, posh, ksh も普通に実行する事ができるようになる。
  何故 bash だけ大丈夫なのだろうか…。
  何れにしても何か変な事をしているのだという事は確かである。

  色々試すと vim, top は起動できる。emacs, emacs-nox は起動できない。
  然し vim, top も、Window サイズ変更に追随して来ない。
  端末の中で起動していない設定になっているのだろうか…。

  Linux 上で試すとどうなるか。
  ok: sh bash zsh ksh ksh93
  駄目: dash tcsh csh fish yash

  これらの振る舞いを観察するとどうも /dev/tty が開けないという問題の様だ。

  検索すると何か出てくるが…。うーん。grantpt, unlockpt はちゃんとやっている。
  所で forkpty なる関数も存在する様である。
  https://stackoverflow.com/questions/9363652/c-fork-a-new-tty

  https://linux.die.net/man/3/forkpty
  forkpty で検索するとこの関数は openpty, fork, login_tty の組み合わせらしい。
  login_tty は呼び出していない。調べてみる。posix では定義されていない関数の様だ。
  然し、これを見てみると utmp.h に定義されているという事から、
  w で見える様にするというそれだけの関数の様にも見える。
  →これを実行したら直った…。

  また w で追加されるかどうかを確認してみたが特に追加されるという事はない様だ。
  所で bash は /dev/tty が見つからない時は勝手に
  login_tty を実施してしまうという事なのだろうか。賢いといえば賢い。

  Cygwin では何もしなくても login_tty は使えるが
  Linux では -lutil を指定しなければならない。
  Cygwin でも -lutil を指定してもコンパイルできた。
  なので -lutil は入れる事にする。

2019-08-05

* tx11: configure/initialize/ctor が分離している現状の実装は微妙なのでは [#D0186]
  そもそも初期化した後で context をファイルから読み取っているのが変である。
  先に context を読み取って、その後で初期化を実行するべきなのではないか。

* twin: 色々フォントを試していたら幅が変な事になるものがある [#D0185]
  例えば "UD Digi Kyokasho N-R" は半分になってしまう。
  検索するとどうもデフォルトでは lfWidth = 0 を指定する物らしい。
  自分で lfWidth を設定すると勝手に変形されてしまうという事の様だ。
  http://vcpp-ml.ldblog.jp/archives/1160416.html

  http://forums.codeguru.com/showthread.php?552383-Calculating-the-real-lfWidth-value-of-LOGFONT-when-lfWidth-0
  然し自分でどの値がそのフォントの標準なのかを調べようとしても出てこない。
  上のページではその方法を探しているが結局わからない様だ。

  https://programdoria.com/tag/windowsapi/
  ここに正に欲しい情報が書かれていた。
  取り敢えず EnumFontFamiliesEx を呼び出して調べてみることにしようか。
  というかこれは今の書き換えを commit してからやる。

  % 取り敢えず此処のサンプルプログラムを参考にしてフォントの情報を取得してみると…。
  % 三つしかフォントが表示されない。 Courier, MS Serif, MS Sans Serif である。うーん。
  % lfCharSet を DEFAULT_CHARSET にして見た所、代わりに System, @System, Terminal になった。
  % 更に lfFontFace を目的の物にしようとしたところ segfault した。
  % - どうも NEWTEXTMETRICEX に変換できるのは truetype の時だけの様だ。
  % - 後 lambda で指定していた所 __stdcall になっていなかった様に思われる。
  %   segfault の原因はこれである。

  呼び出し方が悪かった様である。ちゃんと修正したら大量のフォント情報が出力される様になった。

  - また、lfFaceName 及び elfFullName は英語ではなく日本語で取得される。
    しかし日本語で指定するとそもそも列挙されない。これは難しい。
  - 取得される情報は大量なので全てのフォントを列挙するのは諦める事にする。
    必要になったフォントから順に一つずつ情報を読み取る様にすれば良いのである。

  取り敢えず修正した。更に描画位置の補正も必要になるだろうか…。
  →まあ、これに関しては現状で問題に鳴っていないし baseline を乱すのも嫌なので取り敢えずは補正しない。

* manager: 複数画面対応 [#D0184]

  取り敢えず試しに実装してみた。

  * App-c App-Num App-p App-n に対応した。
    - 再描画を促す為に切替時に m_dirty をセットする。
    - 更にサイズの変更通知を切り替え後の画面に通知する。
    どうもちゃんと動いている気がする。

  * done: 動いている terminal_application が死んだら
    その時点で m_apps のリストから削除する様にする。

  x fixed: 起動時の大きさが manager に反映されていない気がする。

  * done: modifier key 及び scroll lock の効果について設定可能にする。

  * done: App-v でペーストしたい。
    → App-C-v 及び App-C-c でコピー・ペーストに対応する事にした。

2019-08-04

* render: 範囲外の領域の invalidate も考慮に入れるべきなのでは… [#D0183]

  cat urandom するとやはり範囲外にごみが残ってしまう。
  そういう意味で必ず一番上の行と一番下の行は毎回描画する必要があるのだろうか?
  一番上の行と一番下の行に変更がない場合には再描画はしなくても良い筈。
  結局、他の行と同様に取り扱う必要があるという事になるのだろうか。
  取り敢えずコードを見てみる事にする。
  →実装した。

* render: decorationも一緒に blink するべきなのでは [#D0182]

* render: 変更範囲の特定で点滅属性を考慮に入れる必要がある [#D0181]

* render: 背景色が変更になった時には full_update しなければならない [#D0180]

* tx11: リモートでの ble-color-show が矢鱈遅い。何故? [#D0179]
  先に大量の信号を送信してそれがバッファに溜まっているという事だろうか。

  1 改善の方法は二つある。一つは通信を軽くするという事。
    つまりできるだけ描画を省略する様にする。
  2 更に根本的な解決としてフレームレートを強制的に調節するという事。
    例えばフレームレートに上限を設けるなどしても良いのかも知れないと思う。

  →どうも nonblock で受信できないからとすぐに戻るのが良くない様だ。
    データがすぐそばに来ていても nonblock で連続で読み取ると途切れる様だ。
    そして途切れる度に再描画をしているから遅くなってしまうという事。
    取り敢えずデータが来ていなくても 20msec は待つ様に変更してみた。
    本当はもっと賢い方法を取りたいが面倒なので取り敢えずの実装はこれで良い事にする。

* render: 遅いので部分更新を実装する [#D0178]

  先ず初めに影響範囲を計算して必要に応じて bitblt を実行して、
  という機能を実装しなければならない。
  取り敢えず tracer の方でどの行が保存してどの行が保存しないのか、
  というのを調べる様にしたい。と思ったが本当に実装するべきは
  tracer の方だろうか。bitblt の事を考えると実は
  renderer の方で実装した方が良いのかもしれない。

  [考察]

  先ず初めにどの様に実装しようか。
  考えなければならない項目について確認する。

  ? 行が隣の行に被る時の処理をどう実装するか
    - 前の表示の時の各行の高さ
    - 新しい状態の時の各行の高さ
    これに関しては移動まで考えると相対距離などが
    出てくるのでより複雑になる。

    というか移動したら基本的には全てクリアという事になるだろうか。
    そもそも本当にそういう機能を提供するかどうかも現時点では定かではない。
    現時点では ±1 行しか被らないという仮定で実装するという事で良いのではないか。
    と思ったが、問題はその様な実装にした時に将来的に拡張ができる様に
    余地を残して置かなければならなくて、どのように設計したら良いだろう、
    というのが現時点での問題になっている。

    行の移動と一緒に少し真面目に考えてみる必要があるだろうか。
    というか前に考えた様な気がする。と思って探したが見つからない。
    改めて考え直す事にするのが良いだろう。という気がする。

    取り敢えず行の移動などの追跡が実装完了したとする。
    つまり各行について移動量が計算できたと仮定する。
    その時に各行の再描画が必要かどうかをどの様に判定すれば良いか。

    行の再描画が必要になる理由は3種類ある。
    (1) その行自体が変更されたので再描画する。
    (2) 上に被る別の行が変更されたの再描画する。
    (3) 上に被る別の行が被らなくなった
      or 新しく被る様になったので再描画する。

    理由(1)に関しては簡単である。
    理由(2)と(3)は一緒に考えたほうが良い気がする。
    というより(3)に含まれている気がする。

    | 取り敢えず行の組で考えるのが良いかもしれない。
    | A = 現在描画しようとしている行
    | B = 移動前に其処に被っていた行
    | C = 移動後に周囲にある行
    |
    | - A 自体に変更があった場合には当然更新の必要がある。
    |
    | - 先ず移動前にBがAに被っていなければ更新の必要はない。
    | - それ以外の場合、Bに変更があればAを更新する必要がある
    | - それ以外の場合、Bとの相対距離に変更があればAを更新する必要がある
    |   これにはBが消滅した場合なども含む。
    |   % 後で移動後の判定をするとすれば、ここでは特に消滅した場合についてチェックすれば良い?
    |   % →移動によって影響範囲外に逃げた場合には移動後の判定では考慮されないので、
    |   % やはりこの時点でも相対距離変化の判定を行うべきである。
    | - 被っていてもBに変更もなく相対距離の変更もない場合は、
    |   これが理由でAを更新するという事はない。
    |
    | 次に移動後の判定を考える。
    | - 移動後にCがAに被っていなければ考えなくて良い
    | - それ以外の場合、Cに変更があればAを更新する必要がある。
    | - それ以外の場合、Cが新しく現れた行であるか、
    |   または相対距離が変化した行である場合には、Aを更新する必要がある。
    | - それ以外の場合にはAを更新する必要は生じない。

    これで再描画が必要な領域の集合が分かる。
    更に次に問題になるのは再描画が必要な領域に影響を与える
    行たちの集合である。これは移動後の配置を見て
    その領域に触れている行たちの集合を求めるという事をしなければならない。

  [実装]

  実装方法について考える。

  1 done: 先ず初めに行の追跡を行う。
    各行について消滅したか現れたか移動したかという情報がある。
    移動した場合には移動の距離についても記録しなければならない。
    もしくは移動前と移動後の位置について調べれば良いだろうか。
    またその行自体が変更を受けたかどうかという情報がある。

    取り敢えず移動後の行の集合に対応して表を作って、
    それとは別に移動前の消滅した行についてのリストを作るのが良い気がする。
    即ち、

      struct line_trace { changed, y0, a, d }
      // changed がその行に変更があったかどうか。
      // y0 が移動前の位置で、a と d が上下にどれだけはみ出ているか。

    と思ったがよく考えたら移動と同時に a/d も変化する場合が考えられる。
    そういう場合は changed=true になっている筈だが
    ちゃんと考慮に入っているだろうか。
    うーん。多分 changed の判定の方でちゃんと処理されるから大丈夫。
    何れにしても移動前と移動後の両方で a/d のチェックを行う必要がある。

    やはり line_trace の配列を移動前と移動後の両方計算するべきである。

    うーん。実は変更のあった行は消滅した物ととして取り扱って良いのではないか。
    変更があってどうせ上書きされるのに bitblt する必要性はあるだろうか。
    と思ったが再描画するとしたらやはり bitblt の対象ではないのかも知れない

  2 done: 次に上に実装した様に再描画の必要性がないかどうかを計算する
    と思ったがどの様に実装するのが効率が良いだろうか。
    old_trace をループで回して変更があった場合に前後 a/d だけ invalidate する。
    相対距離が変化した場合についても invalidate する。
    という事を考えると old_trace でループを回すのが良い気がする。

    改めて invalidate の条件について考える。

    | 移動後の行Aについて
    | - Aが新規出現または変更された行である場合には invalidate
    |
    | 移動前の行 B について考える。
    | - Bが消滅または変更される行である場合には、
    |   Bの前後a/dの行について (もし移動後に残るならば) invalidate が必要である。
    | - Bが移動するだけで変化しない場合には、
    |   Bの前後a/dの行について相対距離が変化した時に invalidate が必要である。
    |
    | 移動後の行Cについて考える。
    | - Cが新規出現または変更された行である場合には、
    |   Cの前後a/dについてやはり invalidate が必要である。
    | - Cが移動するだけで変化しない場合には、
    |   Cの前後a/dの行について相対距離が変化した時に invalidate が必要である。
    |   ※これは前のBによるチェックと重複している気もするが、
    |   a/dの長さの変化がある場合などもあるので両方でチェックしておく。

    取り敢えず実装した。(traceline_invalidate)

  3 done: 次に再描画が必要な行を決定する。
    つまり invalidate 領域に影響を与える様な行は全て登録する。

    うーん。然しこれだと複雑な clip を要求するのではないだろうか???
    或いは新しい layer に書き込めばOKという事だろうか。
    書き込んでおいてから必要な部分だけコピーすれば良い。

  4 次に実際に描画を行う際にどの様に実装するか。
    やはり絶対何処かで考察したはず。と思って調べると
    2019-05-02 の考察として残っているのを発見した。#D0177 とした。

    読んで見る。成る程…。よく出来ている。
    取り敢えず ctx0 の上で構築して、
    カーソルを描画する直前に ctx1 に転送するという作戦である。

  実装したし動いている様に見えるのは良いが
  実際にどれだけ描画が省略できているか観察すると変だ。

  x fixed: 先ず一行でもスクロールが起こると全体の再描画になっている。
    行を一つも追跡できていないという事になる。
    調べてみると追跡まではできている。invalidated の判定で変な事になっている。
    と思ったら shift 量の計算が逆になっていた。直した。

  x ok: またスクロールしなくても一文字でも変更があると4行再描画される。
    と思ったがこれはこれで正しい動作である。一文字でも変更があると、
    上下の行も含めた三行を更新する必要がある。
    そして三行を更新するためには更にその隣の行の再描画も必要で、
    合計で5行の再描画が実施される。但し、ble.sh で下から2行目に位置していたので、
    4行だけで済んでいたという訳である。

* twin/draw: 行をはみ出る描画がある時の実装方法について考察 [#D0177]

  % | 実のところ、行をはみ出ている文字が存在する時には、
  % | BitBlt が使えなくなるなど色々と問題がある気がするが、
  % | まあ、仕方がないのである。或いは、被っている行とそれに対する参照を
  % | 記録してもし変更がなければ大丈夫という具合にするのだろうか。。
  % | さて、実際にその様にしたとしても更新のなかった部分に関しては、
  % | 上書きしないように気をつけないといけない。その様にしないと、
  % | 二重に文字が書かれたりしてアルファを指定しているときなどに色の濃さが変化する。
  % | アルファを指定していなかったとしても ClearType や Anti-alias で色の濃さが変化してしまう。
  % | うーん。描画範囲を制限するよりは background buffer を2枚持っておいて、
  % | 古い方から新しい方へ転送してしまう方が良い気がする。
  %
  % 現在の表示内容を保持するデータ構造として以下の物を考える。
  % (1) 各行について id/version 及び内容を保持する。
  % (2) 更にその行に被る行の id と offset のリストを保持する。
  % 次にどの行を再描画する必要があるかについて調べる。
  % (1) そして、更新の際には id/version の異なる行を invalidate する。
  % (2) 更に invalidate された行を参照している行や、
  %   参照している行との offset が変化した行も invalidate する。
  %   (再帰的な適用はしなくて良い。被っている他の行の内容が変化する事によって、
  %   更に新しく自身が他の行に被る内容について変化がある訳ではないので)
  % (3) 全ての行についてその行が被る範囲を調べて、
  %   被る範囲の中にある行について自身がその行の被りリストに登録されているか、
  %   そして offset が一致しているかについて調べる。もし登録されていないか、
  %   offset に変化があればその行は invalidate しなければならない。

  →invalidate のアルゴリズムについては #D0178 で再実装した。

  描画を実際に行う。
  (1) BufferA に invalidate された行を書き込んでいく。
    その行に被る事が分かっている invalidate されていない行についても
    前景を書き込んでいく必要がある事に注意する。書き込む必要がある前景は
    その行をはみ出ているものだけであることは注意する。
  (2) BufferB から BufferA に invalidate されなかった行の内容を転送する。
    これで一応画面の内容は完成している筈である。
    背景画像との合成を考えると更に合成を実施する必要がある。
  (3) BufferA から BufferB にコピーする。
    その上で BufferA にカーソル等を書き込んで、
    それから BufferA から画面に BitBlt を実行する。

  * 点滅属性などを考えると各行について変更のあった
    アセンダ・ディセンダを求めてそれを処理に使うのは価値がある様に思う。

  * もし背景と前景を独立に描画してその後で合成するのだとしたら
    行内容の差分を考える時に背景と前景に分けて考える価値はある様に思う。
    その為には先ず行内容を背景と前景に分けてしまって良いと思う。
    背景と前景のそれぞれについて差分を取って更新の戦略を考える。
    但し、これは実際にバッファを分けて描画すると決まってから実装しても遅くない。
    今は考えなくても大丈夫である。

* tx11: clip に関しては丁度 XSetClipRectangles という関数がある [#D0176]
  https://tronche.com/gui/x/xlib/GC/convenience-functions/XSetClipRectangles.html
  自分で指定しようと思うと Pixmap を用意して clip 領域を設定しなければならない、
  と思ったがちゃんと便利な関数が用意されていたのである。

  →実際にやってみた所楕円等に関してはちゃんと clip されているが、
  文字列に関しては clip されていない。もしやと思って確認してみると、
  そもそも文字列の描画には gc は用いていない。
  XftDraw という謎のオブジェクトを用いているのであった。
  調べてみると XftDrawSetClip という関数があるそうである。

  使い方について調べてみる。
  https://render.xfree86.narkive.com/MVkn8trX/xftdrawsetclip-questions
  クリアするためには単に XftDrawSetClip(m_draw, 0) とすれば良い。

  http://sweaglesw.org/svn/libxyz/trunk/pango.c を見てみると、
  | Region  clipr = XCreateRegion();
  | XUnionRectWithRegion(&yz_d->cliprect, clipr, clipr);
  | XftDrawSetClip(xdrw, clipr);
  | ...
  | XDestroyRegion(clipr);
  としている。XCreateRegion で調べてみる。
  http://xjman.dsl.gr.jp/man/man3/XCreateRegion.3x.html
  http://xjman.dsl.gr.jp/man/man3/XIntersectRegion.3x.html
  うーん。XUnionRectWithRegion で良いという事なのか。

  更に既存の region を clear する方法について検索したがよく分からない。
  どうも一度破棄してそれからまた作成するのが一番という事が
  マニュアル (Google プレビュー) に書かれていた。
  面倒なので何も考えずそれに従う事にする。
  →実装した。動いている。

* tx11: 反転矩形・楕円の描画に対応する [#D0175]

* 2019-07-25 twin の描画部分を分離できないかという事 [#D0174]

  全く同じ物を X11 に対しても同時に実装するのは面倒だし、
  また機能を追加するのも面倒だしメンテナンスも面倒である。
  従って同じ処理をしている部分は処理を共通化するのが良い。
  そうでなくても再利用可能な形に色々と関数をまとめて置くのは良い事。

  画像の出力先は GDI, X11 だけに留まらない。
  例えば gif または bmp に出力したいという場合も考えられる。
  或いはもっと他の形式も考えられるかもしれない。例えば PostScript 等?

  2019-07-27 取り敢えず簡単に分離はしてみたが
  未だ現状の形式には不満がある。

  * そもそも bitblt だとか background buffer だとかを使えるかどうかで
    効率的な実装が変わるのである。X11 の場合には remote の
    background buffer に対して操作を実行するという事は可能なのだろうか。
    然し、何れにしてもこれは実際に遅いという事が分かってから
    インターフェイスを拡張する等すれば良いのである。

    →取り敢えず X11 では Pixmap を用いて bgbuffer を作れて、
      XCopyArea という bitblt 機能もある事が分かったので、
      Win32 と同様に処理できる。という事で処理を分離して共通化した。

    Background buffer を使わない実装に関しては、
    今後そういう機能が使えない対象が出てきた時に初めて考えれば良い。

  * clip に関しては graphics の側で管理する事になっているが、
    これは renderer の側で clip 範囲も提供するべきである。
    →これは対応済み 2019-08-04

* 2019-07-28 tx11: 領域反転は2回 XCopyArea を実行する? [#D0173]
  https://stackoverflow.com/questions/39969855/invert-the-colors-of-a-region-in-xlib
  Pixmap はリモートに置かれるリソースの様に見える。
  なのでバックバッファも普通に沢山使っても問題ない気がする。

  * ok: 既に現状で何やらちらつきが見えている。
    →バックバッファには対応済みである 2019-08-04

  GC の設定で GXcopyInverted にして XCopyArea すれば良い。
  自分自身にコピーする事は可能なのだろうか。
  上の説明を読むと新しく pixmap を作らなければならない様にも読める。
  分からないので試してみる事にする。
  →試してみた所自分自身に転送すれば別に問題も起こらない様だ。
    これで良いという事にする。もしかすると X server によっては
    問題になるという事もあるかもしれないが気にしない事にする。

* Linux でユーザ毎にフォントを追加するには [#D0172]
  $XDG_CONFIG_HOME/fontconfig/fonts.conf ファイルに記述する。
  https://www.freedesktop.org/software/fontconfig/fontconfig-user.html にユーザごとの設定のテンプレートがある。

  特にフォントを置くディレクトリとして <dir prefix="xdg">fonts</dir> という指定が挙げられている。
  これは実際にはどの場所になるだろうか。検索すると .local/share/fonts に配置される? 様に思われる。
  https://github.com/eosrei/emojione-color-font/issues/14
  というか、上のマニュアルのページの <dir prefix="default"></dir> の所に説明が書かれていた。
  他に "relative" という値もある様である。普通に "home" という値があれば良いのにそういうのはない様だ。
  取り敢えず .local/share/fonts に配置する事にする事にした。

  取り敢えず .local/share/fontconfig/fonts.conf を書いて fc-cache を実行してみると、
  /home/murase/.local/share/fonts: failed to write cache というエラーになってしまう。
  a chmod 777 にしても setenforce 0 にしても駄目だった。
  b http://lukedoomer.blogspot.com/2007/07/failed-to-write-cache.html
    https://lists.opensuse.org/opensuse-bugs/2012-10/msg01318.html
    https://forum.ubuntu.org.cn/viewtopic.php?f=86&t=67385
    によるとタイムスタンプの問題なのか…?
    うーん。2020-01-01 にしても 2010-01-01 にしても駄目だった。
  c 或いは別の人は fontconfig と x11 を全て再インストールしたのだとか。。
    取り敢えず chatoyancy に dnf update をかけるが、
    大して更新はない。フォント関係の更新はない様に見える。
    更新の後に再度実行してみるがエラーメッセージは変わらない。
  d システムのディレクトリだと書き込めるかもしれないと思って、
    /usr/local/share/fonts/murase-fonts にコピーしてみるが、
    これについてもやはり failed to write cache になってしまう。
  e やはり fontconfig を入れ直すという話が出ている。
    https://askubuntu.com/questions/1120116/ubuntu-18-04-fontconfig-update-not-possible-fc-cache-fcdircachecreateuuid
    sudo dnf reinstall fontconfig で入れ直してみる事にする。
    然し結果は変わらない。やはり同じエラーメッセージである。

  既存のディレクトリのキャッシュの形式はどうなっているのか調べようとしたら、ない。
  どうやらキャッシュは別のディレクトリに保存しているという事?
  うーん。sudo fc-cache を実行すると何もエラーが発生しない。
  然し、これだと user murase のデータは読み込まれないのである。

    $ sudo mkdir /usr/local/share/fonts
    $ sudo ln -s ~/etc/fonts /usr/local/fonts/share/murase
    $ sudo fc-cache
    /usr/local/share/fonts/murase: skipping, looped directory detected
    $ sudo rm /usr/local/share/fonts/murase
    $ sudo cp -r fonts /usr/local/share/fonts/murase
    /usr/local/share/fonts/murase: skipping, looped directory detected

  うーん。不思議だ。シンボリックリンクでないのに looped directory になる。

    $ sudo mv /usr/local/share/fonts/murase /usr/share/fonts/
    $ sudo fc-cache -v

  何と成功した。然し、何故か既にキャッシュされているというメッセージになっている。
  これに関してはまとめて置く事にする。
  取り敢えず、MeiryoKe_Console が使える様になったので満足である。

2019-08-03

* 2019-07-28 tx11: サイズ変更のイベント? [#D0171]
  →これは簡単に対応できた。対応漏れがあるかもしれないが、
  それについては後でゆっくり見る事にする。

* tx11: ちらつきがあるのでやはり Pixmap の使い方を調べる [#D0170]
  http://www.yam-web.net/c-programing/x11/index.html
  適当に検索したら正にそういう目的に使うというページが見つかった。

  うーん。これを使って実装するとしても
  twin/tx11 の共通部分を抽出するというのが残っている。

  * done: tx11 は graphics が display とくっついているので駄目。
    display と graphics (描画対象) を分離する。分離した。

  取り敢えず実装してみた。何事もなく動いている気がする。
  カーソルもちゃんと動く様になった。

* tx11: xft_font_manager_t は整理して [#D0169]
  実装を twin と共有できる様にする。

  或いは x11_font_manager_t 的な物も一緒に実装して、
  それとも実装を共有できる様に考えてインターフェイスを決めたほうが良いのかもしれない。
  うーん。其処までする必要は実はないのだという気がする。
  取り敢えず twin の方の実装を整理し直す。

* tx11: X11 の core fonts による実装は後で行う [#D0168]

  - フォント名の一覧はどうにかする。
    これはプログラム的に取得するのは難しいのかもしれない。
    取り敢えず自分の所で使う上では問題ないのでそのままにする。

  * ok: 日本語の表示は未だできていない
    →Cygwin でフォントを入れたらできた。
    それぞれの環境で日本語に対応したフォントを入れる必要があるのだろう。

  * ok :Cygwin ではフォントを追加できるのではないか
    https://superuser.com/questions/801545/how-to-make-the-cygwin-fontconfig-package-inherit-windows-fonts
    このページに依ると

    $ ln -s /cygdrive/c/Windows/Fonts /usr/share/fonts/win-fonts
    $ fc-cache

    等と実行すれば良いそうだ。試しに実装してみたら動いた。

  * ok: フォントが使えない時の為に
    ? ,monospace を取り敢えず付加しておけば大丈夫なのだろうか
    →試してみた所それで良い様である。
    と思ったがこうするとフォントが変化してしまう。
    monospace の方が優先されてしまう?
    取り敢えず自分の所で動けば良いので monospace は入れないで置く。

  * ok: うーん。Windows のフォントを利用している時は
    フォントの大きさは大きすぎるという事はない様だ。
    オプションとしてフォントのサイズを微妙に調節する機能があった方が良いのかもしれない。
    然し、やはり大きすぎる様な気がするので、小さめにする事にした。
    大きくすると ascend/descend の計算も再度修正しなければならず面倒である。

  * ok: 以下は全て対応した

    > * tx11: TrueColor でない時の対策が必要
    > * tx11: 現在は ascii しか表示できない
    > * tx11: X11 で ExtTextOut 的な関数はあるのだろうか
    >   取り敢えず1文字ずつ描画するしかない。遅そうだけれども。
    >   →取り敢えず1文字ずつ描画する事にした。これで一応動かなくはない。

2019-08-01

* やはり文字列の描画位置が気になる [#D0167]

  どうも指定した座標位置をベースラインとして描画している気がする。
  ディセンダとアセンダを XftFont から取得する方法を調べていると、
  XftLockFace というので FT_Face を得てから取得している気がする。
  https://github.com/blueyed/PKGBUILD-rxvt-unicode-wide/blob/master/line-spacing-fix.patch
  https://uwabami.github.io/cc-env/Terminal.html

  # でそのページを見ていたら何か見た名前 (Youhei SASAKI) である…。
  # 昨日自分の前にトークしていた人だった…。
  # GCC や Linux の開発に携わっていると言っていた人である。
  # トークの前に端末を開いて tmux で画面分割していた人である。
  # 木星の渦の柱の計算をしていた人である。
  # 何時もは気付かないだけで実はこういう事って本当はいつもあるのかもしれない。
  # というか XftLockFace で検索するとこの人のトーク画像が出てくる…。

  然し使われているコードを良く見てみると普通に XftFont の方に
  ascent/descent というデータメンバがある様である。
  それを使ってみる事にする。調べてみるとそれぞれ値は 13 と 4 である。
  というより単位が分からない…。うーん。比で決める事にしようか…。

2019-07-28

* X11 で KeyPress を捕まえるには? [#D0166]

  * keycode の処理をどうするかについて。
    その辺に書いてある通りに XKeycodeToKeysym を使ったら
    deprecated であるとの警告が出た。

    検索すると https://codeday.me/jp/qa/20190410/599503.html
    #include <X11/XKBlib.h> の XkbKeycodeToKeysym を使えるとあるが、
    然し廃止された理由などがあるだろうことを考えると、
    本当にこれで良いのかというのはよく分からない。

    XkbKeycodeToKeysym の説明。特に deprecated だとかの説明はない。
    https://www.x.org/archive/X11R7.5/doc/man/man3/XkbKeycodeToKeysym.3.html


    https://www.cl.cam.ac.uk/~mgk25/ucs/keysymdef.h

  * state の処理をどうするのかについて。
    試してみた所以下の様になっている様子だ。
    因みに ScrollLock や CapsLock に関しては反応がなかった。

    ShiftMask   ... Shift
    ControlMask ... Control
    Mod1Mask    ... Alt
    Mod2Mask    ... NumLock

    よく考えてみたら左右の Control を区別したいので、
    state では駄目である。X には現在そのキーが押されているか
    どうかを確かめる関数はあるのだろうか。

    https://stackoverflow.com/questions/3649874/how-to-get-keyboard-state-in-linux
    を観察してみた所、実は Windows と同様の関数が存在する様である。

    此処に載っているのは動かない例?
    https://ubuntuforums.org/showthread.php?t=1149710

    此処には XkbGetIndicatorState という関数が載っている。でもこれは mask と同じ様な気がする。
    https://stackoverflow.com/questions/9009775/using-getkeystatevk-capital-1-in-linux

    うーん。CapsLock, ScrollLock, NumLock に関しては結局 XkbGetIndicatorState が必要の様だ。
    https://www.qtcentre.org/threads/30180-how-to-determine-if-CapsLock-is-on-crossplatform
    https://www.qtcentre.org/threads/44563-Kana-Lock-Detection
    何だかよく分からないが 1, 2, 4 がそれぞれ Caps/Num/Scoll Lock に対応している様だ。
    これらの定数は何処かに定義されていたりするのだろうか…?

    うーん。CapsLock に関しては起動した瞬間に on になっていると
    それ以降ずっと反転してしまう様である。
    最初から off になっている場合には特に問題は発生していない。
    これは Cygwin 固有の問題だろうか。よく分からないが気にしない事にする。
    また、ScrollLock に関しては検出できていない気がする。

  取り敢えずキーボード入力は適当に作れた。
  描画も何か表示される様にはしたが表示は滅茶苦茶である。

* X11 で XEvent を polling する方法が分からない [#D0165]
  →結局 XCheckIfEvent を使った。

  | 以下の元のコードだとブロックしてしまう。
  |
  |   | XNextEvent(display, &event);
  |   | process_event(event);
  |
  | 検索すると X11 のソケットを見張るという話をしているが、
  | これは内部でバッファリング等をしていたりすると駄目なのではないか。
  | https://stackoverflow.com/questions/8592292/how-to-quit-the-blocking-of-xlibs-xnextevent
  |
  | * XCheckMaskEvent?
  |   XCheckMaskEvent というのがある様なのでこれを使ってみたら、
  |   そもそもウィンドウを閉じる事ができなくなってしまった。
  |
  |     | while (::XCheckMaskEvent(display, ~(long) 0, &event)) {
  |     |   processed = true;
  |     |   process_event(event);
  |     | }
  |
  |   検索して見つかった説明を読んでみると…
  |   http://www.polarhome.com/service/man/?qf=XCheckMaskEvent&tf=2&of=HP-UX&sf=
  |
  |   > XCheckMaskEvent -- XLIB Reference Manual R5
  |   >
  |   > Name
  |   >   XCheckMaskEvent -- remove the next event that matches mask; don't wait.
  |   >
  |   > Synopsis
  |   >   Bool XCheckMaskEvent(display, event_mask, event_return)
  |   >     Display *display;
  |   >     long event_mask;
  |   >     XEvent *event_return;
  |   >
  |   > Arguments
  |   >   display     Specifies a connection to an X server; returned from XOpenDisplay().
  |   >   event_mask  Specifies the event types to be returned. See list under XSelectInput().
  |   >   event_return
  |   >               Returns a copy of the matched event's XEvent structure.
  |   >
  |   > Returns
  |   >   True if a matching event is found, else False.
  |   >
  |   > Description
  |   >   XCheckMaskEvent() removes the next event in the queue that matches the passed mask.
  |   >   The event is copied into an XEvent supplied by the caller and XCheckMaskEvent()
  |   >   returns True. Other events earlier in the queue are not discarded. If no such event has been
  |   >   queued, XCheckMaskEvent() flushes the request buffer and immediately returns False,
  |   >   without waiting.
  |   >
  |   >   XCheckMaskEvent() cannot return ClientMessage, MappingNotify,
  |   >   SelectionClear, SelectionNotify, or SelectionRequest events because these
  |   >   event types are by definition unmaskable.
  |   >
  |   >   For more information, see Volume One, Chapter 8, Events.
  |   >
  |   > See Also
  |   >   XQLength(), XAllowEvents(), XCheckIfEvent(), XCheckTypedEvent(), XCheckTypedWindowEvent(),
  |   >   XCheckWindowEvent(), XEventsQueued(), XGetInputFocus(), XGetMotionEvents(), XIfEvent(), XMask-
  |   >   Event(), XNextEvent(), XPeekEvent(), XPeekIfEvent(), XPending(), XPutBackEvent(), XSelectInput(),
  |   >   XSendEvent(), XSetInputFocus(), XSynchronize(), XWindowEvent().
  |
  |   XCheckMaskEvent() cannot return ClientMessage, MappingNotify,
  |   SelectionClear, SelectionNotify, or SelectionRequest events because these
  |   event types are by definition unmaskable. と書かれている。
  |
  | * XCheckIfEvent?
  |
  |   うーん。更に XLIB Reference Manual R5 を Google Preview で見ると
  |   XCheckIfEvent というのがある様だ。これは ClientMessage 等を受け取れるのだろうか。
  |   試してみる事にする。
  |
  |     | while (::XCheckIfEvent(display, &event, &event_filter, NULL)) {
  |     |   processed = true;
  |     |   process_event(event);
  |     |   if (!display) goto exit:
  |     | }
  |
  |   結局これで動いている様な気がするのでこれで良いという事にする。
  |   display をチェックしているのは、tx11_window_t では display = NULL
  |   を設定する事でディスプレイを閉じた事の合図にしている為。

2019-07-27

* scroll back と selection 色々考えなければならない [#D0164]

  * done: scroll buffer 内の選択も考慮してコピーを行う
    選択範囲の更新の際に scroll_buffer も毎回全てチェックするので遅いかもしれないが、
    まあ仕方がないだろう。物凄く巨大な scroll_buffer を考えない限りは大丈夫だろう。

  * done: 現在は term 自体に scroll_amount を保持しているが、
    これは view に依るのではないか。
    複数の view があれば複数の scroll_amount が可能の筈。
    という事を考えればまた一層挟んでも良いのではないかという気がする。

  * done: うーん。実は manager に expose するインターフェイスだけを集めた
    view 的な何かを定義した方が良いのかもしれない。
    これは上の項目で考察した人によって見ている箇所が違うという
    振る舞いにも通じる。

    →これは取り敢えず term_view_t として実装を分離した。
    現状では terminal_application に紐づけているが、
    将来的には独立させて複数の view を持たせられる様にする。

  ? 選択範囲の状態は画面 (view) 毎に持つべきなのではないか?

    | ここで問題なのは人によってそれぞれ選択したいという事があるのではないか、
    | という事である。同じ画面を複数の場所で見ていて、
    | それぞれで選択できた方が振る舞いとしては自然の筈である。
    |
    | その為には選択の情報と実際の表示内容の情報を別々に記録する必要がある。
    | 或いは、選択の情報は開始点と終了点だけを記録して、
    | 描画を実施する際に毎回開始点と終了点から範囲を計算するのだろうか。
    | それは重い。
    |
    | 一方で ECMA-48 が定めている selection はどの様に取り扱うべきか。
    | これはどの画面で見ても同様に選択されている状態になるべきなのではないか。
    |
    | a 例えば、ECMA-48 で定めている selection とユーザの選択は別物として扱う。
    |   これはそれぞれ操作するのに別の操作方法を用意する必要があるという事であり、
    |   そしてそれは使いにくいという気がする。
    | b 或いは、ECMA-48 で定めている selection は全画面にその場で適用して、
    |   それらの selection の設定・解除と画面上での選択は同様に扱うという事。
    | c 現状のように選択状態は全て共有するという事にする。
    |
    | うーん。実装が面倒なので取り敢えず c のままで良い気がする。
    | これが自然か不自然なのかは結局よく分からない。
    | 然し、何れにしても選択した文字列が端末の内容が幾らか変化しても保持されるのは
    | とても分かりやすい振る舞いの様に思われるし (他の端末はそうは行かない)、
    | もしこれを独立したデータ構造で実現しようとすると、
    | 端末の状態変化を追跡しながら更新しなければならずそれは不可能に等しい。
    | それならば端末の状態に選択状態を含めてしまって、
    | それで一緒に選択状態を更新させてしまうというのは自然な実装である。
    | 寧ろ他の端末よりも良い実装になっているのではないだろうか。

    [結論]

    ECMA-48 の定める選択範囲や、端末自体が選択範囲の情報を使って動作する事
    などを考えると選択範囲は唯一であった方が自然である。
    つまり、選択範囲の状態は現状の様に端末状態の中に含ませてしまって良い。
    またこれにより端末変化に対する選択範囲の追跡などが可能になっている。

* view の導入に関して [#D0163]

  | 導入しようと考えたがよく分からなくなった。
  | そもそも view は何処に配置するべきなのか。
  | terminal_application の中なのか、
  | term_t の中なのか、それとも renderer の中なのか。
  | 思うに view をどの範囲で共有してどの範囲で独立に取り扱うのかという事に依存する。
  | そして terminal_application とは何なのかという事についても改めて考え直す必要がある。
  | 現状だとそもそも term_t と terminal_application を分けて置く必要性が分からない。
  |
  | 更にスクロール機能というのは manager が管理するべき事なのか、
  | それとも terminal_application が管理するべき事なのかという事。
  | 描画についても manager のレベルで対応するべき事なのか、
  | それとも terminal_application のレベルで対応するべき事なのか、
  | というのが謎である。
  |
  | 結局描画だとかそういう事を考え始めると board+term は一緒になっていた方が、
  | (少なくとも現在の段階の実装では) 便利である。
  | terminal_application に関しても、実はもうくっついて居た方が便利なのではないか。
  | とも思ったが、まあ view の分離はしておく事にしようと思う。
  |
  | 問題は現状では terminal_application は固有の m_term を保持しているが、
  | 一方で、複数の画面で m_term を共有する時にどの様な構造が望ましいのか、という事。
  | terminal_application は manager の中の terminal の状態であると考えれば、
  | うーん? そもそもどの様な概念が必要であるかに関して列挙する必要がある。
  |
  | (1) term_t ... これが screen における buffer の役割である。
  | (2) terminal_application
  |   ... これは実は application というよりは pane なのではないか。
  |       とも思ったが良く分からない。
  | (3) panel ... これが実際に表示する画面なのではあるまいか。
  |
  | この様に考えると更にもう一つの階層を用意するという事だろうか。
  | うーん。然し、全ての terminal_application でスクロールバックや
  | 画面の一分表示という機能を使う訳ではないのである。
  | 否、少なくとも画面の一部分表示という機能に関しては pane の都合上必要である。
  | 問題はスクロールバッファを保持するのかどうかや、
  | スクロールバッファまでスクロールバックの対象とするのかどうか、という事である。
  |
  | 取り敢えず暫定的でも良いから結論を考える必要がある。
  |
  | * 画面の一部分表示の機能は提供する
  |
  | * スクロールバッファまでスクロールバックの対象とする機能
  |   a これを既定で使える様に実装して設定で使えなくするか、
  |   b 或いは既定ではそれを想定せずに実装して、
  |     使いたい時には自前で行を差し替える等して対応するか。
  |   これはどう考えても a の方が良いという気がする。
  |
  | * terminal_application は様々なキー入力を受け取って、
  |   それに応じて様々な動作をする。
  |   描画は term_t に対して実行するという様に動作する。
  |
  |   スクロールバッファについては意識しない。
  |   と思ったが上下左右のコマンドを受け取って
  |   スクロールを実施したりするのは manager の方なのか、
  |   それとも terminal_application なのかという問題が残る。
  |
  |   結局何が問題なのかというとスクロール機能というのは、
  |   各仮想端末の枠に備わっている機能なのか、
  |   それともそれを表示している manager の側の機能なのか、
  |   という事である。
  |
  |   うーん。もし terminal_application が端末に対応するのだとしたら、
  |   実はスクロールだとかそういう機能というのは manager 側に
  |   一任するべきなのではないかという気がする。
  |   或いは manager 側で pane に対応するとしたら、
  |   その pane 毎に管理するべき物なのである。
  |   というか実は term_view_t というのは pane に対応する物と考えるべき?
  |
  | 取り敢えず m_view は manager の側で管理する事にした。
  |
  | 結局一つの問題は何かというと term の機能が複雑すぎて、
  | それをちゃんと描画する為にはやはり term 自身の状態が必要という事にある。
  | そうでなければ term の為に描画を拡張する度に、
  | その拡張部分について各描画エンジンに対して個別に owner draw を定義しなければならない。
  | 不毛である。その様に考えれば各描画エンジンは初めからフルに term に対して描画を行うしか無い。
  |
  | 或いは描画に影響を与えるであろう機能を全て board の側に移行するという手もある。
  | しかし、少なくともモードの類は全て移動しなければならないし、
  | それに関連してごっそりと色々な物を移動しなければならないのではないか。

  * 先ず board と term はくっつけるかどうか? これについては保留
  * view は描画に必要な情報のインターフェイスとして取り敢えず実装する。
    スクロールの機能はおまけでつける。
  * 混乱の元なので取り敢えずは term_t のレベルから application のレベルに移行する。
    更に manager のレベルに移行するのは後で良い。

* tx11: 終了時のエラーメッセージ [#D0162]
  ウィンドウを [x] ボタンで閉じると変なエラーメッセージが出て良くない。

    XIO:  fatal IO error 11 (Resource temporarily unavailable) on X server ":10.0"
      after 12 requests (12 known processed) with 0 events remaining.

  調べてみると正にそれを解決するのだという記事が見つかる。
  https://qiita.com/SUZUKI_Masaya/items/e73791e20d78be640729
  その通りに書いてみたら解決した様な気がするが実際よく分かっていない。

2019-07-25

* ttty: スクロールバック対応 [#D0161]

  よく考えたら ttty は色々と対応が不足している。
  そもそも入力をデコードしていない気がする。

  * terminfo を使う事に関して → これは独立項目で取り扱う事とした

    | 現在は適当に実装しているが本来は terminfo 等を参照して
    | 動作を決定するべきである。然し ncurses はライセンスがある。
    | その事を思うと自前で terminfo のデータベースを解読する等の事が必要になるだろうか。
    | →ncurses のライセンスについて調べてみた所どうも MIT ライクなライセンスだそうだ。
    |   また、terminfo のバイナリ形式は標準化されていないので
    |   読み取れたり読み取れなかったりするそうだ。
    |   結局新しく何か変なものを作るよりは全て ncurses に任せて置くのが無難か。
    |
    | 大体の terminal は殆ど同じだろうと思って調べて見たがどうもぜんぜん違う様だ…。
    | うーん。世の中には変な端末がある物である。例えば khome について調べた所、47種類あった。
    | そもそも CSI シーケンスの形をしていない物など色々ある。
    |
    |   572 ^[[H      12 M-^@G    2 ^[^E
    |   324 ^^        10 ^[[f     2 ^K
    |   148 ^[[1~     10 ^[[2~    2 ^AN^M
    |   106 ^[H       10 ^[$A     2 ^A?^M
    |    73 ^[h        8 M-^?M-   2 M-^[26~
    |    71 ^[OH       6 M-^[1~   1 ^[{
    |    68 ^^PF       5 ^[p^M    1 ^[[G
    |    59 ^A         5 ^[[Y     1 ^[[44~
    |    55 ^H         5 ^[^R     1 ^[@
    |    37 ^[[26~     4 ^[c      1 ^[#G
    |    32 ^[[7~      2 ~^R      1 ^[^[E
    |    28 ^[[214z    2 ^]       1 ^Z
    |    27 M-^[H      2 ^[[OH    1 ^W
    |    25 ^[?        2 ^[R^M    1 M-^[44~
    |    21 ^[E        2 ^[G      1 M-^[ A
    |    14 ^Y         2 ^[!S
    |
    | この惨状を見たらまあ ncurses に依存しても良いかなという気分になる。
    | というよりそもそも sequence decoder で対応できる雰囲気ではない。
    | trie でも構築してそれを使って読み取る枠組みも一緒に使う必要があるのでは。
    |
    | 何れにしても、大体の端末で動くようにするという目的で、
    | ncurses が使えない時の為の自前のコードも書いておく事にする。
    | 取り敢えずは最初は面倒なのでそれで行く事にする。

  * 入力のデコーダを実装する
    取り敢えず入力のデコーダを適当に実装した。
    現在は ESC によるメタ修飾と SS3 によるキー等には対応していない。

    と思ったが ESC によるメタ修飾を認識しないというのは致命的である。
    修正する事にする。と思ったがどうやったら良いのかが分からない。
    ESC を取り敢えず置いておいて後でくっつけるという事ができたろうか。
    或いはよく分からない ESC を通過させるという機能はあっただろうか。
    というか ESC # 等がエスケープシーケンスとして解釈されてしまうのではないか、
    という事などを考えていくと input_decoder は sequence_decoder とは別に実装するべきなのでは。
    逆に良く分からないのは iso2022 に従っている時には M-# はどの様に送信するべきなのだろうか。

    というより良く考えたら M-\ だとか M-] や M-^ や M-_ だって制御列として取り扱われてしまう。
    うーん。input_decoder は sequence_decoder とは完全に別であるべきなのである。
    然し乍ら、M-[ は特別に "CSI として使われるので入力できない" というのが認められている気がする。
    % そういう意味でいうと M-] も "OSC として使われるので入力できない" になっていて良い気がするし、
    % その延長で考えると M-^ や M-_ も怪しい物である…。うーん。
    % 改めて調べてみるとアプリケーションに対して "OSC" が使われる事はない様である。
    % 取り敢えずはそういった制御列は処理しないという形で良い気がする。

    結局 input_decoder を再実装する事にして再実装した。

  * 改めて考えてみたら unicode にデコードしていない気がする…。

* twin: スクロールバックの描画 [#D0160]

  term を弄って行を取得する部分を書き換える?
  もしくは描画する側で適当に選んで取り出すのが良いか?
  スクロール状態をどの様に表現するか?
  スクロールバッファ内の位置を保持するのか、
  或いは、特定の行の位置を保持するのか。
  例えばスクロールバックしている間に回転したらどうするのか等。
  或いはスクロールしている間は端末の更新を止める等。

  twin の描画部分を見ると直接 board を参照している。
  これを term 経由になる様に変更したいのである。
  →取り敢えず manager 及び twin は term 経由でデータを参照する様に変更した。
  また manager で scroll_amount を設定できるようにしたい。

  取り敢えず動くようにする事が第一である。
  うーん。色々設計について考えてしまう。
  例えばスクロールしない terminal_application の場合もあるのではないか、等。
  更に、terminal_application が複数ある場合にはどうするのか、等。
  然し、そもそも形ができあがっていない段階から考えても無限に時間がかかるだけである。
  取り敢えず動く事を念頭に実装してそれでテストして、
  その後で必要になったら実装する。整理する、という具合にしなければならない。

  twin に実装してみたら意外とちゃんと動いている。

  x fixed: と思って選択しようとしたらクラッシュした。
    というか初期状態でクリックしようとしただけでクラッシュする。
    何かと思ったら無限再帰呼び出しになっていた。修正した。

  x ok: 選択が全くできなくなっている。
    スクロールしていない状態でも駄目。
    と思ったら、これはデバグの為にコードをコメントアウトしていただけだった。x

  x fixed: カーソルの位置が変である。
    これの事は考えていなかった。対応する。対応した。

  * fixed: DL で削除した行が transfer されるのは変な気がする。
    然し、他の実装ではどうなっていただろうか。
    というか、SU で移動した行は transfer されて良い。
    DL で移動した行を transfer するのは変、という気がする。
    ECMA-48 の意図的に。
    →やはり DL/IL では transfer しない様に変更する事にした。

* スクロールバックに対応したいという気がする [#D0159]

  先ず始めにバッファを用意しなければならない。
  これは term のレベルで実装するべきか、
  或いは board のレベルで実装するべきか。
  altscreen だとか或いはページだとかの概念を考えると、
  board のレベルではなくて term のレベルで実装したい気がする。

  | 然し、改めて考えてみると board のレベルで対応しても良いのではないだろうか…?
  | そもそも altscreen だって board の機能なのか term の機能なのかというと微妙である。
  |
  | ? というか board とは何か。
  |   今改めて観察してみると board は幅と高さと行の集合の様である。
  |   それに加えて presentation direction と行IDの管理が含まれている。
  |
  | ? presentation direction が board に所属しているのは何故かというと。
  |
  |   | a 表示する際に必要だから。つまり board だけで何らかの表示状態を表したかった。
  |   |   然し、現状では term の中の様々な状態も一緒に参照しなければまともに表示できない。
  |   |   そういう意味で既に分離に失敗しているのである。
  |   | b 然し一方で抑、行毎に direction という物が存在している。
  |   |   従って、board 自体の direction を
  |   |   行の direction の既定値として保持するのは自然である様な気もする。
  |   |   そして実際に確認してみるとその様な実装になっている。
  |   |
  |   | つまり結論としては行毎に方向を保持していて、
  |   | その設定の一つとして "全体の方向を既定値として用いる" という物があるので、
  |   | その為に board に既定値を保持しておく必要があるのだという事。
  |
  |   →行毎に方向を保持している。盤も既定値として方向を保持するのが自然
  |
  | ? 行IDの管理は board で行うべきなのかそれとも term で行うべきなのか。
  |
  |   今調べてみると結局 m_line_count を使用しているのは board の中だけである。
  |   altscreen の時にだけ m_line_count をコピーする様になっている。
  |
  |   然し、今気づいたのだが altscreen に m_line_count をコピーするのは良いが、
  |   その逆は実行しなくても良いのだろうか…と思ったが、
  |   考えてみたら altscreen の側で行を追加したりする事はないので関係ない?
  |   というか抑、コピーする必要性はあったのだろうか…。
  |   と思ったが、恐らく altscreen と本体の buffer を swap する時の対策なのだろうという気がする。
  |   →確認してみた所確かにそういう事だった。
  |
  |   然し、この様な実装は不自然といえば不自然である。
  |   抑、cur だとか m_line_count を使っていないのに記録している。これが変だ。
  |   width/height, lines, presentation_direction だけ保持していれば良いのではないのか。
  |   というかそもそも width/height だって必要なのか怪しい所である。
  |
  |   結局 std::vector<line_t> と presentation_direction だけ保持すれば良い気がする。
  |   ページの場合にはどうなのだろうか。うーん。ページも考えると微妙な気がしてきた。
  |
  | うーん。同時に色々の事を考えすぎている気がする。
  | 問題は altscreen, page, scrollback のそれぞれの形式を共通にするか、
  | 或いは独立にするのかという事と、更にそれぞれに現れる m_line_count を共通にするか
  | それとも独立にするのかという事。そして、もし共通にするのだとしたら、
  | 新しい行の挿入などは誰が実行するのかという事。
  |
  | 取り敢えず scrollback だけ対応する事にしたい。
  | 問題は行の削除を誰が実施するのかという事。
  | board の中で実施するのか、或いは外から実施するのか。
  | 現在の実装では board の中で実施する事になっている。
  | もし消えてなくなる行の内容を別の場所にコピーするのだとしたら、
  | その書き込み先を引数に指定する必要があるのではないだろうか。
  |
  | うーん。やはり何処にスクロールバックの情報を記録するのかという問題は残る。
  | スクロールバックしている間の表示を行う時は
  | 描画ルーチンに対してそのスクロールバックした行を渡さなければならない。
  | board と term を分ける事の利点は描画をするのに term 依存である必要はない、
  | という判断だった様に思われるが現状として tstate に描画が色々依存するので、
  | 実際には board だけでは描画できないという事。
  | またスクロールバック等に際しても board を変化させれば良いと考えていたが、
  | それは非効率的である様にも思われる。と考えたが、考えて見るにスクロールバック
  | している状況というのはそんなにないので一時的に board の状態を弄っても良い筈?
  | 然し、スクロールバックした状態でデータを受信した時などの事を考えると、
  | やはり実際の現在の board と表示の為に使う board を二つ管理しなければならなくなる。
  | 等という事を色々考えるとやはり term のレベルでスクロールバックを提供するのが適当ではないか。
  |
  | 諸悪の根源は board と term を分けている事である様な気がしてきた。
  | そもそも board を独立して使うアプリケーションが存在するかもしれない、
  | という様に考えたが実際にそういうアプリケーションを作る事があるのかは疑問である。
  | 或いは ncurses の中は簡単な window としてそういう物があるのかもしれないが、
  | その上で term を実装するというのはやはり無理がある様に思われる?

  色々考えた結果として board と term は将来的に統合する事にする。
  tstate に関しても統合の方向を考える様にしたい。
  或いは少なくとも大幅に整理してもっと小さな単位でメンバにする様にしたい。
  そして実際の動作は全て term 及びフリー関数で制御する様にするのである。

  現状は何が問題になっているのかというと
  機能の分離がちゃんとできていないという事。
  様々なメンバを跨ぐ処理になってしまっているのだという事である。
  フリー関数で制御する代わりにこれらのデータメンバのクラスを通して
  ある程度の機能を実装してしまうという可能性も考えられる?

  何れにしても全体的な設計について考える為には、取り敢えず、
  スクロールバックとページ機能を実装してみるというのが手である気がする。
  現段階では全て term 側で実装する事にする。
  特に tstate の上でスクロールバックなどを実装する事にしたい。
  或いは tstate ではなくて term の上で直接実装するか。。
  抑、tstate はモードだとか振る舞いに関する簡単なフラグを保持する物にするつもりだった。
  大きなデータを保持する予定はなかったのである。それが今や altscreen 等まで格納している。

  然し、制御機能を追加する度にメンバを増やすというのも不毛な感じはする。
  もっと動的にデータを追加・削除する仕組みにしても良いのかもしれない。
  ブラウザのDOM要素等は既にその様な実装になっているのだろうという気がする。
  文字列を識別子としてメンバを辞書に格納するという事なのである。
  速度的な観点でいうとその様にすると遅くなってしまう懸念があるので余りしたくはないが。。

  [何も考えずに term 上にスクロールバック機能を実装する]

  取り敢えず term 上に消滅した行を移動する事にした。
  実装した。然しそれを閲覧する機能はつけていない。
  これは別項目で議論する。

2019-07-24

* ttty.exe が常にデータを出力し続けている気がする [#D0158]

  確認するとカーソルの表示・非表示の状態を変更する
  コードは必ず毎フレーム出力される。
  然し、これに関しては描画がそもそも為されないのであれば必要ない筈である。
  然し、現状のコードでは描画が実際にされるかされないかは分からない。

  a 一つの方法は実際に描画が必要と分かった時にカーソルの
    表示・非表示を切り替えるという事。
    然し、実際に描画が行われるかどうかに関しては、
    呼び出した先の関数の中で処理していたりして面倒である。

    かと言って描画する関数自体にチェックを入れるとしても、
    描画を実際に行う時に毎回チェックする様にするのは非効率的である。

  b 或いは最初に描画が起こる可能性についてチェックして、
    もし描画が起こらないと判定できるのであればその場で関数を抜けてしまえば良い。
    考えてみればチェックはそんなに難しくなさそうだ。

  取り敢えず b の方針で行く事にする。実装した。

2019-06-02

* 2019-05-15 カーソルの移動などがあったら multiple click は解除するべき [#D0157]
  他のボタンによる移動なども検出するべき。
  というより他のボタンを途中で押した場合にもクリアするべき。
  →これは #D0156 で一緒に対応した

* 2019-05-15 manager: mouse の判定をもっとちゃんとする [#D0156]

  * down/up の整合性に関しては呼び出し元で管理する事にしたので
    manager の側では気にしない事にする。

  * 考えている内に何だかわからなくなった。
    望ましい動作は一体なんだろう。特に複数のボタンを同時に押した時。
    例えば mouse1_down mouse3_down mouse3_up mouse1_up の時の動作は何か。
    うーん。Poderosa の振る舞いを見ると mouse1_up で click が発生する。
    一方で mouse1_down mouse3_down mouse1_up mouse3_up の時には
    代わりに mouse3_up による rclick が発生する。
    つまり、up の時に他のマウスボタンが押された状態になっていなければ
    対応する click/rclick が発生するという事だろうか。
    然し、現状の Poderosa の振る舞いに倣わなくても良いのである。
    ユーザにとってもっと自然なふるまいはあるだろうか。
    途中で他のボタンを押した場合には click/rclick は発生するべきではないのではないか。

    a 例えば直前の down に対応する up だったら click になるという設定だとどうだろう。
      これだと 1down 3down 3up 1up の時に 3up で rclick が発生してしまって自然ではない。
    b 或いは直前の down に対応する up でありかつその間に他のマウスボタンによる
      イベントが発生していなかくて、かつ他のボタンが押されていない状態だったらどうだろう。
    c Poderosa (もしくは Windows?) の様に up した瞬間に単独だったらOKという実装?
      これは実は分かりにくい気がする。

    b で実装するとしたらどの様にすれば良いか。
    実は現在のマウス状態を記録して置かなければならない。
    うーん。改めて考えてみると c の振る舞いの方が分かりやすい気がする。

  * 後思ったのだがこういうマウスの down/up/drag から
    click/double click などを再構築するというのは普通に
    他の application でも使いたくなる物の筈である。
    という事を考えるとクラスとして独立させた方が良い様に思う。
    その場合には onclick だとか ondblclick だとかのイベントを登録できる様にする必要がある。
    インターフェイスとして実装するのと各メンバ関数で実装してデリゲートにするのとどちらが楽だろうか。
    デリゲートにすると親ポインタを関数ごとに渡さなければならず非効率的な気がする。
    一方でユーザーインターフェイス周りの仕様なのだから非効率でも問題ない気もする。

    どちらの場合でも初期化の時に this を渡したり event に代入したりするのを何処かに書かなければならない。
    という事を考えると初期化が必要という点に関して悩む必要はない。
    それは外部に独立させる場合には必ず支払わなければならない代償である。

    デリゲートで登録する様にするのはインターフェイスを実装するクラスとして、
    std::function を並べた物を用意すれば adapter になるので、
    インターフェイスで登録できる様にする方がより一般的な実装になっている。
    逆にデリゲートで登録するのをインターフェイスで実装できるようにするのは
    効率が悪くなるだけでまるで意味がないので考えなくて良い。

    従って、インターフェイス経由でイベントを通知する様にする事にする。

  * 後、up と down の間で修飾キーが変化した場合にはどうするのだろうか。
    この場合については途中で操作を少し修正しようとしたのだと解釈する事にして、
    そのイベント (click, dblclick) が起こった瞬間の修飾を使うという事にするので良い。

  * "現在アクティブなボタン" というのは multiple click 及び、
    drag 及び click で同じ物になるだろうか。或いは排他的な物になるだろうか。
    或いは、両方保持して置かなければならないといった事になったりするだろうか。

    問題は drag による selection が他のボタン状態の変化によって妨げられるかどうかである。
    例えば左ドラッグをしている途中で右マウスボタンを押下したらどうなるか。
    これは drag をキャンセルするのが自然である。

    * drag ... 複数のマウスボタンが押されている時はドラッグと解釈しない。
      他のボタンが押された時には動作はキャンセルされる。
    * click ... 他のボタンが押されている時には発生しない。
      これを検出する為には現在のマウスの状態を内部で追跡する必要がある。
    * multiple click ... これは click を引き金として起こす。
      前回の button を記録しておく必要がある。

    逆に言えば click 及び drag に関しては "現在アクティブなボタン"
    というのを覚えておかなくても良いのではないだろうか。
    現在アクティブなボタンを覚えていたとしても他のボタンが押されていないかどうか
    というのを判定する必要がなくなる訳ではない。

    と思ったが、drag に於いて左ドラッグで始めた物を終わらせずに
    途中で右ドラッグに変更した場合にはどの様に動作するべきだろうか。
    うーん。ドラッグとして扱われるべきではない気がする。

    ドラッグのボタンに関しては一番始めに押下したボタンを記録しておいて、
    もし途中で他のボタンが押されたらそれを無効化するという様にするのが良い。

  * 取り敢えず実装した。後は動作テストを行えば良い。

    x fixed: mouse_move してから選択しても multiple click が有効のままである。
      mouse_move で色々と無効化する様に修正した。

    x fixed: 試してみると選択によるクリップボードへのコピーが実行されていない。
      また装飾キーが存在していると選択がされない。
      これは現在の選択キーの検索の際に key を直接比較しているのがいけなかった。
      key の中でもマウスのボタンのフラグに大して検査を実行する様に修正した。

2019-05-15

* manager: a-0 で文字の大きさを元に戻す [#D0155]
  キーの配置を変更する事にした。動いている。OK
  a-+, a-- で拡大縮小ができる様にする。

  取り敢えず現在の所は a として Menu キー (VK_APPS) を割り当ててはいるが、
  正直な所押しにくい。自分で各装飾キーの意味を設定できる様にして、
  自分専用の設定として右 Alt を a に割り当てたい気もする。
  或いは prefix キーを登録できる様にする。
  色々試すと CapsLock や 無変換・変換・カタカナキー等は IME が反応してしまうので、
  勝手に装飾キーとして使ってしまうとかそういう用途には向かない。

* manager: 文字の大きさ拡大縮小の仕方が変な気がする [#D0154]

  やはり何か変だ。考え直さなければならない。
  現在の式は ceil(xpixel0 pow(1.05, zoom_level) + zoom_level) になっているが、
  これだと + zoom_level の部分で比率が変わってしまう。
  比率を保持する様に修正しなければならない。

  その為には y 方向だけに上の式を適用して、
  x 方向に関しては比率で計算するという具合にしたい。
  ではその場合に x 方向が limit を満たす様にする為には
  どの様に zoom_level を制限すれば良いという事になるだろうか。

  xpixel = ceil(ypixel * (xpixel0 / ypixel0)) という式で計算される。
  xpixel_min <= xpixel <= xpixel_max が満たされる様な ypixel は何かという事。

  xpixel = (ypixel * xpixel0 + ypixel0 - 1) / ypixel0
  - xpixel >= xpixel_min
    →ypixel * xpixel0 + ypixel0 - 1 >= xpixel_min * ypixel0
  - xpixel <= xpixel_max
    →ypixel * xpixel0 + ypixel0 - 1 >= xpixel_min * ypixel0 + ypixel0-1
  よって、 xpixel_min*ypixel0 - (ypixel0-1) <= ypixel * xpixel0 <= xpixel_min*ypixel0.
  次に A <= B*C という条件を A/C <= B 的な形に変形したいとする。
  うーん。(A+C-1)/C <= B ならばOK
  従って (xpixel_min*ypixel0 - (ypixel0-1) + (xpixel0-1))/xpixel0 <= ypixel
  また A*B <= C という条件を A <= C/B 的な形に変形したいとする。これはそのままでOK
  つまり、ypixel <= xpixel_min*ypixel0/xpixel0 という事になる。

  何だか分かりにくい式である。。。
  整理すると A*B <= C <=> A <= C/B,
    A <= B*C <=> (A+(C-1))/C <= B,
    A/C <= B <=> A-(C-1) <= B*C という事になる。
  うーん。恐らく整理しても綺麗な形にはならないのだろうという気がする。

* C-wheel による文字の大きさの変更に対応する [#D0153]

  wheel_up/down が送られてきていない気がする
  調べてみるとちゃんと WM_MOUSEWHEEL は発生している。
  と思ったら Ctrl を押している時のみというフィルタを自分で書いていたのだった。
  ちゃんと送られてきている。また、タッチパッドで wheel up/down が逆になっている気がしたが、
  本当のマウスで実行してみるとそういう事はなかった。つまりタッチパッドは、
  スクロールを反転させる為に勝手に向きを逆にしているという事なのだろう。

  さて。zoom down/zoou up を実装する為には何が必要か。
  先ず、列数・行数の調整が必要である。更にフォントの初期化も必要になる。
  フォントの大きさに関しては何か式で表現したい所である。
  後、最大のフォントの大きさと最小のフォントの大きさについても。
  最小の列数・行数と最大の列数・行数についても意識する必要がある。

  列数・行数に関しては既に WM_SIZE で実装している筈である。
  最初にフォントの大きさを決める所から始まる。
  うーん。問題は manager の方から GUI の方にリサイズの要求を提出するという事である。

  だらだら実装していたらできてしまったが構造として綺麗かどうかは微妙。
  また問題が出てきた時に構造は整理する事にする。

2019-05-10

* manager: 結局ダブルクリックで単語選択については実装されていない [#D0152]
  単語の範囲は取り敢えず簡単に実装する。
  - (2click) ASCII記号類とそれ以外で考える。
  - (3click) 空白とそれ以外
  - (4click) 行選択

  実装したのはいいけれども画面に表示されない。不思議だ。
  m_dirty は設置されている。ちゃんと該当箇所は呼ばれている。
  自分で明示的に set_selection を呼び出しても反映されない。
  あー。分かった。ループを回す時の y1 の代わりに y を用いていた。
  つまり、折角選択範囲を設定しても他の行に適用するはずの
  clear_selection を自身に改めて適用していたので
  何処にも選択範囲がなくなっていたのである。

  それでも未だ選択範囲が微妙に変だ。修正する。

2019-05-09

* session: ダブルクリックで選択できる様にする [#D0151]
  トリプルクリックで行を選択。
  これは時間を自分で計る必要がある。

  他の端末は選択範囲をどの様に決定しているのだろうか。
  Unicode のテーブルを使っているのだろうか。
  Unicode の表を持ってくる必要がある。面倒である。

  何れにしても記号かそうでないかで判定する。
  また表示部ではなくて当然論理的な順序を保持しているデータ部で
  連続する範囲を選択するのが自然である。

  * 2019-05-08 そもそもダブルクリックやクリックはどの様なタイミングで発生するべきか。

    % Win の UI を見ると mousedown の時点で両者とも発火している気がする。
    % でも実際にそうだったろうか。気になるので調べてみる。
    % と思ったら検出できなくなっている。。mouse_event で goto defproc にしてみても駄目。
    % dyna2018 で試してみてもやはり駄目である。何か変化した事はあっただろうか。
    % mouse event に対してすべて DefWindowProc に流す様にしても
    % やはりクリックやダブルクリックが発生しなくなっている。
    % 不思議だ。改めてメッセージを見るとやはり WM_LBUTTONDBLCLK というのが存在している様子。
    % もしかすると前から送らてきていないという事だったろうか。よくわからない。
    % それにこれだと結局通常の click については検出できないという事になる。自分で判定する必要がある。

    調べてみると window style に CS_DBLCLKS を指定しないとこのメッセージは発生しないそうだ。
    http://gurigumi.s349.xrea.com/programming/visualcpp/sdk_mouse2.html
    つまり以前から発火はしていなかったという事になる。また、目的のタイミングについては
    上記のサイトに既に書かれていたので改めて試さなくても良い気がしてきた。

    うーん。mouse down が double click に置き換えられるという事だろうか。
    もしそうだとすると、素直に WM_LBUTTONDBLCLK を使って実装すると
    mouse down した瞬間に double click の動作が発動するという事だろうか。
    他の実装がどの様になっているのかについて確認したい。
    mintty については2回目の mouse down で発動している。
    その様に考えるとやはり double click triple click に関しては mouse down で
    発動させてしまうという事にする。

  だらだらと書いていたらダブルクリックやらクリックやら右クリックのコードが完成していた。
  何か考え忘れている物があるような気がしてならないがまあ気にしない事にする。

  * 後、twin の側でちゃんと down drag up が consistent になる様に補正を行う様にしたい。
    現在のマウスの状態を記録しておいてそれに反する動作をした時には、
    release を呼び出すか down を呼び出すか或いは無視する。

  取り敢えず実際に動かして試してみる事にする。

  * 右クリックが効かないと思っていたら、
    よく考えたら右クリックは mouse3 と定義したのだった。修正した。
    取り敢えず問題なく動いている様な気がする。

    manager の側からは Windows のクリップボードは見えない、
    というか依存するわけには行かない。
    という事なのでイベントを定義する必要がある。
    ここで疑問なのは各イベントに対して関数オブジェクトを設置するのが
    良いのか或いは一括で様々な関数を提供するクラスを作成してしまうのが良いのか。
    うーん。Windows プログラミングで一つずつ関数を設定する方法が主流だったのは、
    どの様な種類のイベントが存在するのかという集合が予め決まっている訳ではなかった為。
    つまり、Window の中に様々なコントロールを設定して、
    そしてそれぞれのコントロールに対して少数の操作を定義するという事。

    今回はそういうパターンではない。設定の対象はそんなに多くなくて、
    しかし定義しなければならない操作は沢山ある。そういう理由で、
    一つのクラスに仮想関数を沢山設定する必要があるのである。

  次に色々と実装しなければならない。

  * done: 先ず右クリックで貼り付けができる様にする。
    貼り付けに関しては先ず初めに term_t にその機能を追加する。
    temrinal_application にその機能を追加する。
    取り敢えず clipboard_paste 関数を呼び出す様にした。
    clipboard_paste 関数は後で実装する。

  * done: コピーをどの様に実施するか。
    現在の端末画面から選択されているセルの内容を抜き出す。
    同時に適切な空白の padding をする必要がある気がする。

    % 先ず初めに SSA による選択も含めて選択の一番左の列を決定する?
    % というより一番始めに SSA が存在する行を取得するのが先?
    % 一番始めの行だけは初めから選択する事を許可する?

    矩形選択の場合とそれ以外の場合で適切に処理する必要がある。
    或いは一番始めの行の最初の文字を起点として、
    矩形選択の場合にはそれより前にある空白を
    無視するという実装でも良いのかもしれない。

    或いは各行で最初に ssa が設定されているセルが行頭にあると考える?
    guarded の事を考えなければそれが自然である様にも思われる。
    然し、実際には全角文字があって半角ぶんだけ選択セルの開始位置がずれていることもある。
    guarded なセルによってずれていることもある。

    矩形選択の場合とそれ以外の場合で処理を分ける事を考える。

    * 通常の範囲選択の場合には基本的には列は保持する様に空白を補填する。
      但し、始点または終点に一致する時に限り空白類は削除する。
      行ごとに抜き出す事を考えるとその一致する可能性のある位置を
      行に渡さなければならない。というか始点と終点の内でより前方にある物だけ考えれば良い。
      むしろ両方チェックするのではなくてその様にするべきである。

    * 矩形選択の場合には選択範囲の中で一番左にある列を取得して、
      その位置からの offset で切り出す様にする?

      矩形選択をした時に全ての行で全角の真ん中にあって、
      一番左のセルの位置がマウスで指定した物とずれている場合にはどうする?
      これは見た目を優先するべきである。ユーザはその様に指定したつもりなのだから。
      その様に考えると、やはり一番左にある列で考えるべきなのだろうという気がする。

      では全ての行で guarded になっていた場合はどうなのだろうか。

    * その行に選択されているセルが存在しないがマウスではちゃんと
      範囲を指定したという場合にはどうするのか。そのときは空行にする必要がある。
      つまり終点の行までは少なくとも空行であったとしても切り出す。

    選択状態にない時にどの様に振る舞うべきかも気になる。
    その時には普通に SSA 属性のついている行を選択するべきである。

    というか明示的な選択を行った時に存在する他の SSA を取り込んでも良いのかというのは疑問である。
    囲んだ瞬間にコピーする場合には取り込まない方が良い気がするが、
    一方で囲んだ後で出力された SSA などがある場合には C-c 等でコピーできてしかるべき気もする。
    前者の場合に関しては選択を開始した瞬間に他の選択は全て解除しているし、
    よく考えたら選択を更新する際にも全て解除しているので、そもそも他の SSA は存在しない。

    うーん。取り敢えず line_t 側で実装するべき事は何かというと。
    指定した x データ位置よりも後に存在するセルに関してコピーを実施するという事。

    * done: 先ず line_t に selected cells を抽出する関数を定義するという事。
      うーん。途中で trunc や gatm 等について考えて実装しなければならないのではないかと思ったが、
      それらは選択する瞬間に選択フラグを設定する為に使うのであって、
      一旦選択が終わってしまったら単に選択フラグを参照すれば良いだけである。
      従って、選択フラグを見るだけで良いのである。

      DWL 等におけるスペースの取扱はどうなるのだろう…。
      選択されていない範囲は幅に応じたスペースの数になる。
      選択されている領域に関しては実際に其処にある文字という事になる。
      その時に幅も考慮して空白を挿入するべきなのかどうかという話。
      うーん。矩形選択などの場合を考えると取り敢えず空白を挿入する事にする。

      取り敢えず実装した気がする。

    * done: 今は選択範囲に対する実装を行っている。
      取り敢えず実装した。動かしてみて内容を確認した。次に進む。

    * ok: 因みに終点と始点をそれぞれ計算する時には先にデータ位置に
      変換してから前後を決めなければならない事に注意する
      確認したところ、これは selection_update では正しく実装されていた。

  * done: clipboard_paste で使う為に terminal_events を twin.cpp 側で実装する。

* クリップボードからのペーストはここ。 [#D0150]
  http://nienie.com/~masapico/api_sample_clip01_c.html

  RLogin は実は OSC(52) seq でクリップボードの内容を取得・設定できるそうだ。
  これはかなり危ない機能なのではないだろうか。。

2019-05-08

* twin: 端末のリサイズができなくなっている [#D0149]
  サイズ変更がちゃんと伝播していない…。
  前まではちゃんと伝わっていたはずである。
  最近 reset_size のコードを変更したのでそれが原因だろうか。。

  取り敢えず調べる。調べると pty.cpp の set_winsize に到達していない。

  * 後気づいた事はウィンドウをリサイズしている途中に
    どんどんサイズ変更のメッセージが送られてくるという事。
    ウィンドウのリサイズを完了してからで良いのではないか。
    現在の実装だと例えば emacs を表示していた場合、
    物凄い勢いでウィンドウサイズの変更が送られてくる事になる。

    と思ったが、よく考えたらまあセル単位で変更があった時にだけ
    送るのだからそれ程には酷い事にはならないという気もする。

  とここまで来て端末まで変更の通知が行っていないのは、
  セル範囲で変更があったかどうかの判定するタイミングを間違えているのではないかという事。
  調べたら違った。というか見てわかった。

  terminal_application を確認すると
  reset_size(w, h) と reset_size(w, h, xpx, ypx) が独立に実装されている。
  両方上書きする様にしなければならないのである。
  片方を使ってもう片方を実装するという様になっていなければならなかった。
  以前はその様な実装になっていたが width/height だけ変更する時に効率が良い様に書き換えたのだった。
  しかし、実際にリサイズが重い処理であるのであれば、それはリサイズを実装している側で、
  以前と比べて変更があったかどうかを自動的に判定するべきなのではないかという気がする。
  確認すると board_t::reset_size はチェックを行っている。
  pty_connection::set_winsize ではチェックを行っていない。
  これはチェックを行う様に変更する。

* マウスが点滅する。WM_MOUSEMOVE で SetCursor すれば良いのではなかったか [#D0148]
  SetCursor のページを確認すると Windows クラスで cursor を NULL にしておかないと駄目と書かれている。
  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setcursor
  確かに自分の設定している Window クラスを確認すると LoadCursor で ARROW を指定していた…。
  実はここに IBEAM を指定しておけばわざわざ自分で SetCursor をする必要はなかったという事なのではないか。
  →実際のところそうだった。修正した。そのままでちゃんとI字カーソルになってくれている。

2019-05-07

* term: read_buffer_size を大きくしても 256 までしか上がらない可能性? [#D0147]
  少しテストで走らせている時に確認してみたらそんな雰囲気であった。
  read_from_fd 関数の中で出力してみたところやはりそうであった。
  65536 を request しているのに 256 しか読み取っていない。
  これは Cygwin の制限なのだろうか。或いは一般にそうなのだろうか。

  状況に応じて修正する必要があるかもしれない。
  もし linux でも常に上限が 256 なのだとしたら、
  何度か繰り返し呼び出しを試して一気に変換しても良いのではないか。
  →chatoyancy の上で確かめてみたところ 4095 が上限の様である。
    4096 で request したら 4095 だけ書き込まれた。
    64k で request しても 4095 だった。
    システムによって nonblock で書き込まれる量が異なるという事なのだろう。

  或いはその場でループを回したらもっと沢山取れたりはしない、
  という可能性も残っている。

  うーん。気になるので繰り返し呼び出す事にした。
  時間を計測してみると 64kb 読み取るのにかかる時間は 2645ns であり、
  更に 64kb を term_t, sequence_printer 等で処理するのにかかる時間は
  28ms 程度であった。まあ、ビジー状態であれば 28ms ぐらいの遅延があっても
  良いだろう。しかし、これは今使っている性能の良いパソコンの話であるから、
  実際にはもう少しバッファサイズを小さくしても良いのではないかという気がする。
  16kb まで縮める事にした。

* 行内に保持できるセル数に上限を設けるということ [#D0146]

  現状の実装では一つの行に marker を何個でも挿入する事ができる。
  然し、この実装だと攻撃として marker だけを大量に送りつける、
  という物が実現してしまう。なので上限を設けるべきである。
  これは cluster extension についても同様である。
  a 一つの制限のかけ方は行内の合計のセル数に上限を設ける方法。
    この方法だと制限に引っかかった時に有限幅の文字が保持できなくなる。
    或いは合計のセル数が或る値よりも多くなったら有限幅のセルしか挿入できなくする。
  b もう一つの制限のかけ方は行内のゼロ幅のセル数に上限を設ける。
    この方法だと現在の行内のゼロ幅のセル数を覚えて置かなければならない。
  c 或いは、一つの境界辺りのゼロ幅のセル数に上限を設ける。
    これは微妙である。或る境界に集積して marker を設置したいという状況は考えられる気がする。
  更に上限に達した時にどの様に振る舞うべきかも考えなければならない。
  これは上野それぞれの方法に応じて考えれば良い。

  制限をどの様に設定するのかについても考えなければならない。
  例えば現在の端末幅に応じて設定するのか、
  或いは十分に大きな値に設定しておくのか。
  というか、よく考えたら現在の端末幅であっても制限をかけなければ駄目だ。
  mintty の様にいくらでも zoom out できる様な端末の存在を考えると、
  横幅に制限をかけるとしても 500 とかではなくて 2000 とか
  4000 ぐらいあった方が良いのかもしれない。

  contradef 辺りに limit を定義しておくのが良いのではないか。
  名前空間はどうするか contra に直接書くのだろうか。
  或いは contra::limit とかそういう物にするか。

  % 語呂の良いものを考えたくなる気もする。limit 的なラテン語はあるのだろうか。
  % terminus というのがある。然し逆に変換すると border になった。うーん。
  % restriction は restrictiones praestituere になった。うーん。
  % 余り変な事は考えずに contra::limit にするか、
  % 或いは物理の用語か何かから取ってくるか。
  %
  % contra から始まる英単語を列挙しておくのも良いのかもしれない。
  % 検索しようと思ったが検索できない。Web 上の辞書で検索すると熟語も一緒に
  % 引っかかってしまって、実際のところ熟語が 6000 ぐらいあって
  % その中に埋もれてしまっている。駄目だ。まあ、後で考える。
  %
  % - contradict (使用済み)
  % - contract (意味的には微妙)
  % - contrabass (調べると実はメモリとかI/Oとかのバスは bus だそうだ)
  % - contribution (でも活用は語呂が合わないので使えない)
  % - controversial
  % - contrast (コマンド名にするには長い)
  % - contravariant, contravariance

  余り色々の名前空間に散逸はさせたくない。一方で contra に直接入れるのも違う気がする。
  contra::limit なのか contra::limits なのか。<limit> <limits.h> 等の前例を見ると、
  どちらでも良い気がする。limit を limitation の短縮と思えば limit でも大丈夫の気がする。

  取り敢えず insert_marker は maximal_cells_per_line に対応した。
  insert_graph は勝手に改行して別の行に行くし、
  そもそも有限の幅の文字しか挿入しないので、
  1つの行にどんどん累積していくという事はない筈。

* 2019-04-29 twin: コンソールが一瞬表示されてしまう問題をどうにかする [#D0145]
  ref #D0205

  % FreeConsole は効果がなかった。
  % ShowWindow(GetConsoleWindow(), SW_HIDE); は一瞬表示されてしまう。
  % そもそもアプリケーションの種類というかそういうのを指定できないのだろうか。

* 2019-04-29 [自然解消] twin: ウィンドウの背景色の設定 [#D0144]

  % ::SetClassLong(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(0,0,0)));
  % 等の様にして設定する事ができる様である。ちらつきを抑える為には、
  % 一番大きな面積を占めている色にこれを設定しておくのが良い気がする。
  % 取り敢えず WM_CREATE 辺りに置いておく事にする。
  % →というか、自分で RegisterWindowClass しているので、
  %   その時のパラメータに指定すれば改めて指定しなくてもよかった。

  →これはダブルバッファリングにした為に余り意味を為さなくなった。忘れる事にする。

* refactor: pty_connection へのパラメータの受け渡しが無駄な気がする [#D0143]
  やはり pty_connection に関しても初期化用のクラスを作成するか、
  或いは pty_connection と terminal_session をくっつけるかする。

  pty_connection はそれ単体として使えそうなクラスになっているので、
  やはりくっつけるのは止める事にしたい。
  或いは、terminal_session_parameter クラスをそのまま渡す様にするか。
  →すべて terminal_session_parameter で渡す様にしたら綺麗になった気がする。

* ttty が起動しなくなっている [#D0142]
  impl1 は起動する。impl2 が起動しない。
  これは move した後のオブジェクトに触っていたのが原因だった。修正した。

* ansi: 現在 UTF-8 に合わない文字はどの様に解釈されていたのだったか [#D0141]
  勝手に無視するのではなく U+FFFD に置き換えるのが適切と考えられる。
  https://www.jpcert.or.jp/java-rules/ids11-j.html にも書かれている。
  と思ったが、既に NUL や DEL は規格に従って無視している。
  うーん。まあ、検査を行う前にそういう文字コードの処理はちゃんとしているべきなのである。
  現在のコードをチェックした所、無視していた。
  実は無視しているから高速に動作しているという可能性?

  後、非正規の UTF-8 についてもちゃんと棄却する事にする。
  全て U+FFFD に置き換える事にした。と思ったら速度が低下した。

  うーん。更に挿入に関しても一文字ずつ書き込むのではなくて、
  行内に入る限りは一気に挿入する様にした。
  しかし、微妙に高速化したものの 10% ぐらいしか変化しなかった。
  という事は、文字の挿入ではなくて行の挿入に時間がかかっているのだろうか。。

  - ok: 或いは、ちゃんとまとめて挿入する機能が働いていない?
    確認した所ちゃんと働いている様に見える。
  - 然し、改行の挿入をやめてみてもやはり速度は変化しない。
    という事は、実は c2w に時間がかかっているという事なのだろうか。
  - 文字幅の計算を (u < 0xA0 ? 1 : 2) といういい加減な物に変更したら
    だいぶ改善した。つまり文字幅計算が悪い…。
    それでも未だ多少の時間がかかっているが、
    これは文字を処理する事自体の重さであろう。
    それに文字幅を不当に大きく評価しているので、
    改行などの処理も却って大きくなっている面もある。
    後で高速化について考察する時には文字幅の関数を改善するべき。

    或いは別のテスト方法として error_char を '?' にしてしまうという事。
    そうすれば c2w の最初のテストで引っかかる筈である。
    と思ったがリモートだとテストできない。

2019-05-06

* twin: カーソルを変更したい [#D0140]
  変更するようにした。WM_MOUSEMOVE の度に呼び出すのがセオリーの様だ。

* twin: 環境変数を設定する様にする [#D0139]
  何故か HOME が適用されないと思ったら chdir する必要があった。

2019-05-05

* twin: mouse move の頻度 [#D0138]
  よく考えたら、今全ての mouse move イベントを報告している。
  前回から変化があった時にだけ通知すれば良いのではないだろうか。
  但し、px, py を使いたい事もあるので端末で送る時にだけ前回からの x, y の変化を見る事にする。

* ansi: やはり何だか振る舞いが変である [#D0137]
  emacs で編集しているとカーソルの位置がずれる。
  これは或いは VT だとか FF だとかの振る舞いの違いに起因するのだろうか。
  しかし、emacs が VT やら FF やらを使っているとは考えにくい。

  Emacs の出力するシーケンスを確認したら LF BS BS 等として移動している。
  つまり、LF を下に移動するシーケンスと考えている様である。
  一方で contra の既定の振る舞いは何だったか。
  確認すると mode_lnm で変化する様になっている。
  また lnm は既定で true になっていた。既定で false に変更する事にした。

  念の為に mintty と RLogin で確認するとやはり既定で false だった。
  序に DECRQM にも対応した。

* twin: 選択範囲に対応したのは良い物の [#D0136]
  実は選択は見た目で行うのではなくてデータ部で行うべきなのではないか。
  つまり、双方向対応で反転文字列等がある場合には、
  反転を考慮に入れた上で選択範囲を決定しなければならないのではないだろうか。
  だとすると現在の様な実装では難しい。データ部で属性を付加してしまうのが速いのではないか。
  そうすれば line.version を加算するだけでちゃんと表示も更新される。

  また、末尾の空白を選択しないだとか GRCM 等に従って
  選択できない物を判定するだとか、そういう複雑な判定をする場合にも、
  現状の様な位置文字ずつその場で判定する方法だと難しいのではないか。
  それよりは全体に対して選択を計算してしまう方が計算としては楽の筈である。

  所で選択に関連して SSA, ESA はどの様に処理するのが望ましいか。
  例えば、選択されている状態にして、その状態でコピー等の操作をすると
  コピーされるとか、そういう風に使う事ができるのではないだろうか。うーん。

  そういう風に考えると実は SSA のフラグで
  選択を管理してしまっても良いのかもしれない。

  決めた。。選択範囲は SSA, ESA のフラグを使って実装する事にする。
  * done: 先ず初めに現在の反転コードは削除する。

  * done: うーん。取り敢えず行内で指定範囲を選択するコードを書くことにした。
    然し、効率だとかを考えて色々工夫してみたが、よく考えたら実際にはもっと複雑である。
    うーん。実装し直す事にする。

    GATM, truncate_nul, trancate_sp, dcsm 等のオプションがある。
    更に、よく考えたら全角文字の場合には範囲内に
    完全に収まっている場合以外には選択しない。

    結局以下に書いた効率の良さそうなコードは全く使えない
    という事が分かったので、ここに残して供養とする。

    | static bool mono_set_selection_simple(std::vector<cell_t>& cells, curpos_t x1, curpos_t x2) {
    |   curpos_t const iN = m_cells.size();
    |   curpos_t const i2 = std::min<curpos_t>(x2, iN);
    |   curpos_t const i1 = std::min<curpos_t>(x1, i2);
    |   curpos_t i = 0;
    |   xflags_t dirty = 0;
    |   while (i < i1) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= a;
    |     a &= ~attribute_t::ssa_selected;
    |   }
    |   while (i < i2) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= ~a;
    |     a |= attribute_t::ssa_selected;
    |   }
    |   while (i < iN) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= a;
    |     a &= ~attribute_t::ssa_selected;
    |   }
    |   return dirty & attribute_t::ssa_selected;
    | }
    | static bool prop_set_selection_simple(std::vector<cell_t>& cells, curpos_t x1, curpos_t x2) {
    |   std::size_t const iN = m_cells.size();
    |   std::size_t i = 0;
    |   curpos_t x = 0;
    |   xflags_t dirty = 0;
    |   while (i < iN && x < x1) {
    |     auto& cell = m_cells[i++];
    |     dirty |= cell.attribute.xflags;
    |     cell.atrribute.xflags &= ~attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   while (i < iN && x < x2) {
    |     auto& cell = m_cells[i++];
    |     dirty |= ~cell.attribute.xflags;
    |     cell.atrribute.xflags |= attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   while (i < iN) {
    |     auto& cell = m_cells[i++];
    |     dirty |= cell.attribute.xflags;
    |     cell.atrribute.xflags &= ~attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   return dirty & attribute_t::ssa_selected;
    | }
    |
    | // GATM や末尾空白を考慮に入れなくて良い場合は効率的な実装を使う
    | if (!trunc && gatm) {
    |   if (!m_prop_enabled) {
    |     if (mono_set_selection_simple(m_cells, x1, x2)) m_version++;
    |   } else {
    |     if (prop_set_selection_simple(m_cells, x1, x2)) m_version++;
    |   }
    |   return;
    | }

    まあ、何だかわからないが行の更新に関しては完成した気がする。
    但し表示部における選択には対応していない。
    というか表示部における選択というのはまともに実装できる物なのだろうか。
    うーん。対応するデータ部における範囲は細切れになる。
    そして方向文字列などの形状を保つ為には色々なマーカを追加しなければならない。
    選択しているだけなのに変なマーカを挿入すると色々と破壊されてしまう。
    従って選択している時には唯表示のためだけに ssa_selected を設定して、
    実際にデータを切り出す時にはマーカなどを指定して見た目を保つ様にしなければならない。

    というかその事情はデータ部でも同じなのではないか。とも思ったが、
    普通に考えたら選択してコピーというのはデータを保って欲しい
    (見た目ではなくて) ので、そのままで良いのである。
    何れにしても表示部における選択は需要がない様な気がするので取り敢えずの所は実装しない事にする。
    念の為インターフェイスとして引数に dcsm を取るようにはするが、エラーを出力して終了する。

  * 更に表示部での座標から。

  取り敢えず全て実装した。選択領域についてはOKである。

* twin: 何だか色合いが自分のなれている物よりも濃い [#D0135]
  RLogin とは同じ位の色合いだが、うーん。

  Poderosa のソースを見ると i==0?0:i*40+55 と書いてある。
  うーん。現在の実装では 51*i でやっているが切り替える事にする。
  6x6x6 color cube の式は色々だ。

* twin: 無限ループになった [#D0134]
  今度は分かりやすい無限ループである。関数の場所を見ると。
  input_key 関数の中で起こっている。これは今編集したところだ。直した。

* ansi: mouse events の encoding に対応する [#D0133]
  これは ?1000, etc に一緒に対応する必要がある。

* [勘違い] twin: と思ったら今度はまた DECDHL で下線が引かれる様になってしまった。 [#D0132]
  何故だろう。何か変な所を触ったろうか…。
  直近の変更の装飾を描画する時に零幅の文字をスキップする様にしたのが悪いのか。
  戻してみたが関係なかった。と思ったら demo.sh の方がいけなかった。
  下線を引くシーケンスを書きかけてそのまま放置していたのだった。

* ansi: 気付いたのだが ERM が RLogin と逆だ [#D0131]
  ECMA-48 を確認した所逆だった…。修正した。

* 2019-05-03 twin: 選択・貼り付け [#D0130]
  これはマウスを実装してからにしたい。
  Windows の仕組みではなくて端末の仕組みを使って選択・貼付けを実装したい物である。

  | うーん。色々考えた結果、やはり選択は term_t の側で実装する事にする。
  | mouse down/up が全て通知されているのであれば term_t の側で実装できて然るべきなのである。
  | と思ったが本当にそれで良いのだろうか。実は間に何か挟むべきなのではないだろうか。
  |
  | terminal multiplexer としての機能も考えると term_t ではなくて、
  | 更にその上の枠組で実装するべきなのではなかろうか。
  | うーん。今、term_t に input_key という機能を取り付けてしまった。
  | うーん。然し、これは本当に適切だったのだろうか。
  |
  | もう少し落ち着いて考えてみる。
  | ユーザが何か入力する。入力内容は取り敢えず符号化されずに
  | アプリケーションに到達する。アプリケーションはそのまま処理しても良い。
  | 一方で、端末の向こうのアプリケーションに伝達したければ、
  | 端末に入れる事になる。そして端末は符号化して送信する。
  | 端末の行き先では受信したバイトを復号してまたキー入力にして、
  | そしてそのアプリケーションで利用する。端末の符号化と復号は透過的でなければならない。
  |
  | うーん。結局単純化されたインターフェイスを定義して、
  | それに従って端末はアプリケーションの振りをする。
  | という様に振る舞う必要があるのではないだろうか。
  |
  | 単純化されたインターフェイスとは何か。現状では以下の通り。
  | (1) キー入力・マウス入力を受け付ける。
  | (2) 現在の画面の状態を提供する。
  |   画面の状態を実際に描画するのは twin_window_t 側に任せる。
  |
  | では通常のアプリケーションはどうなのだろう。
  | 先ず (1) については共通で良い。一方で (2) に該当する物はない。
  | 強いて言えば標準出力として色々な文字列を画面に出力するという事になる。
  | 結局、端末を介して (2) を獲得するという様に考えるべきなのかもしれない。
  |
  | うーん。つまり、アプリケーションの種類に応じて形態が色々という事。
  |
  | * 通常のコマンドは標準入力を受け取って標準出力に出力するだけ。
  |   これは一種のこういうインターフェイスと見ることができる。
  |
  |   interface input_and_output {
  |     void write(data);
  |     event output(data);
  |   };
  |
  | * 一方でテキストエディタ等は上記の interface の様であるが、
  |   実際には内部でより複雑な事をしている。
  |
  |   interface interactive_application {
  |     void input(key);
  |     event draw(canvas);
  |   }
  |
  |   実際に実装される時には input_and_output を実装するアダプタが
  |   これを操作する事になる。adapter は標準入力を受け取ってそれを
  |   キーの列に翻訳して application に渡す。そして application が
  |   何か画面状態を更新したら adapter はそれを update するシーケンスを
  |   生成して標準出力に書き出す。
  |
  |   丁度これと同じ事をするのが GUI でもある。
  |   ユーザの入力からキーの列を生成して input とする。
  |   画面の状態を更新したらそれを実際に描画する。
  |
  | * 或いは、キー入力を受け取ってまた画面状態を提供するが、
  |   実際には input_and_output を介して実際のアプリケーションと通信をする、
  |   というものも存在する。
  |
  |   実のところ term_t の位置付けは何処にあるのだろうか。
  |   term_t というのは単なる画面状態なのか、
  |   或いは単独の application の振りをする物なのか。
  |
  |   また terminal_session は一体何なのか。
  |   現在の実装だと term_t の初期化を行うためのクラスにしかなっていない。
  |
  |
  |   うーん。現在の実装だと term_t の様々な物に依存して
  |   実際の画面表示が変化する。つまり、term_t 自体が状態でもある。
  |   あらゆるアプリケーションは term_t をインターフェイスとして通信するという事?
  |   従って terminal multiplexer を実装するとすると、
  |   新しい term_t を作ってその中で term_t を動かすという事になるのではないか。
  |   そうしなければ、twin や ttty は更に複数の term_t を切り替えるという操作を
  |   実装しなければならなくなるのではないか。
  |
  | 何だか色々と形のない事を考えてきたが、まあ実際に実装して、
  | その時の雰囲気で自然に決めて行けば良い様なきもする。
  | 今回の場合には term_t で実装するのではなくてその前に何か噛ませたいという事である。

  term_t はやはり状態に徹したい。具体的なアプリケーションというよりは、
  "標準入出力しか持たないアプリケーションに薄いインターフェイスを提供する"
  のが目的である。勝手に入力を解釈して文字列の選択等を行うというのは変である。

  | では何故 twin の側で提供しないのかというと、同じ仕組みを ttty にも
  | 実装したいからである。もっと言うと Win 以外の GL だとか Qt だとか、
  | 別の枠組みの上で端末を実装する時にも同様に必要になる機能である。
  | なので、共通化したい。twin は単にキー入力を受け取ってその共通の枠組に渡すという事と、
  | その共通の枠組にユーザーインターフェイスとして画面描画を与えるという、
  | そういう薄い物にしたいのだという事なのであった。
  |
  | そう考えると何か共通の "端末アプリケーション" という物を作って、
  | それの上で選択等を実装するべきなのではないだろうか。
  | そしてその "端末アプリケーション" はユーザの入力を処理して、色々の事をする。
  | 各子供端末に対して入力をそのまま伝達することもあれば、
  | 端末の処理をとは異なる (選択やコピーなどの) 操作を提供する事もある。
  |
  | 現在の構造だと terminal_session がそれに近い様な気もするが、
  | これは何だか微妙である。実のところ、これは単に接続を開始するだけのクラスである。
  |
  | 結局アプリケーションから見た "仮想端末" が term_t であって、
  | ユーザから見た "端末エミュレータ" というアプリケーションが twin/ttty であって、
  | そしてそのエミュレータアプリケーションの共通構造というか、
  | 本体部分を今から twin から切り出そうという事を考えている訳なのである。
  |
  | んー。"端末アプリケーション" は子供の端末を複数持つ。
  | 実はその子供というのは端末でなくて別のアプリケーションでも良いし、
  | と思ったが任意のアプリケーションという事にすると描画ルーチンの共通化ができないので、
  | やはり書込先のデータは term_t という事になるのではないかと思う。
  |
  | 所で Window 分割等をした時に twin はどの様に対応するべきなんだろうか。
  | 現在の実装では分割の事は考えていなくて全体に描画する気でいる。
  | ウィンドウ分割には対応する気はなくてやりたければ中で起動した
  | terminal multiplexer に任せようと思っていたからである。
  | しかし、今になって考えてみれば terminal multiplexer と機能やインターフェイスを
  | 統一するのだとすれば、twin 自体にも画面分割が在るのが自然である。
  |
  | 以下の様な構造になっていると考える事にする。GNU screen と同じである。
  |
  | screen _>_ session ___ terminal
  |                     \_ terminal
  |                     \_ terminal
  |
  | % 結局、session が実際の端末のアプリケーションであって、
  | % screen が描画を担当しているに過ぎない。
  | % また勝手に接続したり抜けたりする事ができる。
  | %
  | % * screen が ttty や twin に対応する。
  | % * session が今から作ろうとしている機能である。
  | % * terminal は pty_session 及び terminal である。
  |
  | 思考が堂々巡りになっていて良くない。
  | twin から別プロセスの session に attach するとしてどうやって
  | データをやり取りするのだろうか。直接 session の中の term_t に
  | アクセスできればそれが一番良いがそういう訳にはいかない。
  | そういう枠組みを整えるのはとても難しい。
  | というか C++ のコンパイラレベルのサポートが必要になる気がする。
  | だとすると結局その "接続" というのはエンコードされた物になるのではないか。
  |
  | 結局 screen _> session の接続は任意にできる物ではないという事になる。
  | というか ttty の時にのみ適用できる概念である。
  | 然し、一方で twin でも複数の端末を開ける機能は是非に欲しい。
  | 従って、実際に上記の様な構造にするかはともかくとして、
  | session 部分の機能は必要なのである。

  次の様な構造にする。screen (ttty や twin に相当) が
  session (共通部分) を描画したり入力を渡したりする。
  session は terminal を複数開いたりタブ管理したり画面分割の操作を
  提供したりする。

  | うーん。screen/session は GNU Screen 用語であって、
  | しかも改めて考えるとやはり役割が異なるので名前を変更する。
  |
  | GDI/Win32 -- multiplex_t -- term_t
  |
  | 真ん中の名前はどうしようか。multiplexer とか、terminal とか、
  | lexer, user, session, controller, うーん。
  | 然し、本当に ttty と twin で同じ機能を提供するのだろうか。。。
  | タブ管理や画面分割までは未だ良いが、タブの選択だとか
  | そういうインターフェイスまで考えると実は一つの term_t の上で
  | 実現してしまった方が良いのではないか。その時には結局、
  | ttty を内部で呼び出す事になる。でもそれだと常に二重に term_t
  | を起動しているという状態になりそれはそれで変な気がする。
  | うーん。実は session 本体が動作するための term_t というのを
  | 別に用意しても良いという事なのかもしれない。
  |
  | 名前は contra... というのに合う名前にしても良い。
  | window_manager_t 等という名前でも良いし、
  | tab_manager_t でも良いし terminal_manager_t という名前でも良い。
  | うーん。タスクマネージャだとかウィンドウマネージャだとか、
  | そういう用語がある事を考えれば terminal_manager で良い気がしてきた。

  結局、以下の様な構造にする。

  terminal_interface (twin, ttty, etc.)
   \_ terminal_manager
       \_ terminal_application (term_t + pty_connection, etc)
       \_ terminal_application
       \_ terminal_application

  取り敢えず名前は暫定的に上記の物としてコードを整理する。

  (1) done: #D0126 先ずは board_t を term_t のメンバに昇格する。
  (2) done: #D0129 terminal_manager クラスをもう準備してしまおうか。
  (3) さて。マウス操作は terminal_manager の上で実装すれば良い。

    先ず選択操作に関して。
    選択範囲はどの様に表現されるだろうか。
    これは terminal_manager の提供する始点と終点を用いて
    twin_window_t 側で描画する事にすれば良い。
    カーソルを描画する前に描画する。

    描画はともかくとして選択の開始点及び終点を記録する様にする。
    描画にも対応した。

* twin: terminal_manager 導入 [#D0129]

  そして terminal_manager 自身も terminal_application とするか?
  と思ったが自身が独立した term_t を持つ訳ではないので、
  これに関してはまた考え直す事にする。

  うーん。然し、これは実装するべき事なのだろうか。
  うーん。或いは terminal_session のまま機能を拡張して、
  その内に修正するべきなのではないだろうか。。

  うーん。term_t から input_key 等のデコード部分を
  奪おうと考えているが本当にそれで良いのだろうか。
  やはり端末の機能としては共通する所があるのだから、
  そのままでも良いのではないだろうか…とも考えたが、
  書込先がないのに input_key が存在していても仕方がない。
  では、何処がそれを担当するのだろうか。例えば
  terminal_session では openpt による書込先に限定している。
  然し、これがまた別の書込先である可能性もある。
  その場合にも全く同じに実装するのは変である。

  という事を考えていくと実は input_key を
  decode する専用のクラスがあっても良い気がしてきた。
  そのクラスは書込先デバイスを保持して、term_t からの要求に従って書込を行う。
  まあ、こういった枠組みに関しては term_t を使って動作する別の
  プログラムが現れてからで良いという気もする。

  何れにしても、取り敢えずの実装としては
  terminal_session の上で選択機能を実装する事にするのである。

* twin/draw: 回転した文字の位置の補正はフォントの大きさに依存するのでは [#D0128]

  * と思ったら起動しなくなっていた。修正した。

  * と思ったら SLH の動きが変である。
    これは分かった。SLL は実行すると現在行と、それ以降の行の
    line limit を設定するのであって、既存の行の line limit は保たれるのだ。
    という事を考えると、実は現在の振る舞いが元々意図した振る舞いである。

    "それ以降の行" というのが何かにも依るが…。
    それ以降に新しく追加した行という意味?
    これについては別項目として残しておく事にする。

    取り敢えず SLH ではなくて DECSLRM を使って実装する。

  * うーん。やっぱり回転中心の計算が誤っている気がする。
    修正する。うーん。何だか計算方法がよく分からなくなって来た。

    そもそも横幅を計算するのに progress を用いているが…。
    progress を回転中心の計算に使って良いのかは謎である。
    というのも文字の大きさによる補正を行う為に
    次の文字のシフト量を progress に加算してしまっているからである。
    と思ったが、回転文字の場合にはそういう変な小細工はしていない気がする。
    と思ったが駄目だ。そのシフトを打ち消す様に自身の progress を弄っている。

    つまり progress は自身の幅を計算する為には使えないという事。
    total_progress 的な変数を用意して其処に論理的な progress 量を指定するべきでは。

  * そもそも displacement の計算が怪しい。
    dx += dx2 にして、その後で DECDWL に対して dx*=2 だけしている。
    本当にそんな計算で良いのだろうか。

    dx1 を全体の shift で dx2 をサイズ依存の shift である事を考えると、
    その文字の移動量は dx1 + dx2 * w である。これは DECDWL に対しても同じ筈である。
    さて、DECDWL の時には w が倍化する一方で、dx1 はそのままである。
    なので、dx1 がイタリック補正由来であるならば dx1 の方を倍加しなければならない。

  * 更に italic 補正のある時の回転中心は微妙である。
    イタリック補正によるずれは全体に作用するが回転中心を変える物ではない。
    うーん。取り敢えず今は回転が在る場合にはイタリック補正は起こらない事になっているので、
    まあ、気にしない事にはする (回転量0の時だけ位置がずれるのは変な気もするが気にしない)。

    或いは、そうなのであればやはり単純に progress の中心を回転中心としてしまうのが良いのかもしれない。

  結局今やっている事は、progress の中心を回転中心にしたいが、
  全体の shift の分だけは横にずらしたいという事である。
  結局回転中心は (xR - xL) + (dx - dxW) という事になる。

  うーん。まとめると displacement には色々種類があって、

    dx = dxT + dxI + w * dxW
      dxT は全体の並進, dxI はイタリック補正,
      dxW は文字サイズ変更によるずれの補正

  となっているが回転中心は xR - xL + dxT で計算したいという事。
  現在の実装では元々 dxT = 0 なので気にしなくて良い。
  もし将来的に dxT が有限になるのだとしたら、
  それを get_displacement で取得できる様にする必要がある。

* ansi: less の使っている altscreen で残像が残る [#D0127]
  画面をクリアし忘れている?
  使っているのは 1049 の筈である。
  自分で試してみた所クリアできていない…。後で修正する。
  →これは不便なのでチェックしてみたらとても簡単なミスだった。修正した。

* refactor: board_t は term_t のメンバとして保持してしまう? [#D0126]
  そうすると一つの board_t に対して複数の term_t がある、
  というような状況にできなくなってしまうが、然し一方で、
  その様な変な事をする動機はあっただろうか。
  現在 cur は board_t 側に1つしかないので、
  複数の term_t が操作しようとしても混線するだけである。
  結局一つの term_t に対して複数の操作する人がいるという、
  それだけの事になるのではないだろうか。

  cur は term_t に持たせる事にする。或いは、その上で、
  一つの board に対して複数の term_t が存在するという事にはならないか。
  うーん。何だかよく分からなくなって来た。
  結局、一つの board に対して term が複数あるという具体的な状況が
  思いつかないので、実際に board は term に持たせて良い気がする。

2019-05-04

* twin: マウスイベントを捕まえる事にする [#D0125]
  面倒なので以前 Poderosa に実装した時の物を参考にする。
  うーん。余り参考にならない感じだ。
  というか他の端末がどの様に動作するのかを先ず初めに調べなければならない。

  その為には受信バイトを調べるプログラムを書かなければならない。
  或いは ble.sh の受信部分から調べるか。
  ble.sh の受信したキーを全て /dev/pts/12 に書き込む様にした。

  emacs がどの様なマウスモードを有効にするか調べる。
  1000, 1002, 1006 を呼び出している。調べる。
  うーん。1002 は smMouseMotionCell なのでマウスの位置の追跡である。
  取り敢えず 1000 と 1006 を出せば良い気がする。RLogin で調べる。

  ESC [ < 0 ; 7 5 ; 3 8 M ... mousedown
  ESC [ < 0 ; 7 5 ; 3 8 m ... mouseup
  0 ... 左クリック, 16 ... Ctrl+左, etc. は gh にまとめてあった。

  - RLogin は中クリックには対応していない様子だ。
  - RLogin はマウススクロールに対しては up up up up up を送信してくる。
    スクロールの時の down/up がどうなっているかは気になっていたが。
    xterm で試してみると M (つまり押下) としてスクロールが送られてくる。
    CSI < m は送られてこない様子である。

  - 何と…xterm では中クリックが 1 で右クリックが 2 である。
    RLogin では右クリックが 1 である。うーん。
    mintty は xterm に従っている。

  1002
    うーん。32 はマウスの移動の意味を持つ様である。
    RLogin はドラッグしている時にのみマウスの移動を通知してくる。
    左ドラッグは 32 で右ドラッグは 33 である。

    xterm で見ると 32 は左ドラッグで 34 は右ドラッグだ。
    中クリックによるドラッグには対応していない。
    左と右を同時に押している時には 32 である。

  1003
    1002 はドラッグしている時にだけマウス移動を通知してきたが、
    1003 はそれ以外の時にも移動を通知してくる。
    35 である。

    xterm の振る舞いを見ると 1000,1002,1003 は排他的であり、
    一番最後に指定された物が有効になる。また1000,1002,1003
    の何れを使って解除しても全て解除される。

  1001
    xterm これを使ったら操作ができなくなってしまった。
    xterm 自体が固まっている訳ではない。
    他の端末から bash を kill したらログアウトされたのが画面で確認できた。
    うーん。キーボード入力を無効化してしまう何かなのだろうか。。
    これは良く分からないので今後は使わない様にしよう。。

    RLogin で試したらどういう物か分かった気がする。
    1000 がマウスクリックの為の物であれば、
    1001 はマウスによる選択を許す為の物だったのだろうという気がする。

  大体わかった様な気がする。現状で必要なのはどの様なタイミングで
  どの様な情報を検知しておけば良いかだったので、具体的なシーケンスの形式
  についてはどの時にどのイベントを通知するかしないかは考えなくても良い。
  基本的にはマウスボタンの押下・解放と、マウスの移動・スクロールなどである。
  実は focusin focusout も 1004 で送られるが、これはマウスと独立。

  DEC Locator 等と言っているのは
  DECSLE DECLRP DECELR DECRQLP DECEFR である。
  何れにしても pixel 単位と升目単位で現在位置が分かれば良いのである。

  取り敢えずマウスイベントを捕まえる。
  Poderosa は .NET Framework に依拠しているので参考にならない。

  うーん。マウスイベントをどの様に定義したら良いのか。
  様々な組み合わせを考えると無限にある様な気がするが…。

  先ず mouse1..5 で 5 種類ある。
  それぞれについて 押下・解放(選択)・移動 が定義される。
  また wheel について up/down がある。
  ボタンを押していない状態での移動 move もある。
  うーん。実はそれだけ? だとすれば全部定義してしまえば良い気がする。

  取り敢えず term_t の側では空実装にしておく事にする。
  今は枠組みを整えるのが先である。
  序に focus と blur にも対応する事にした。OK

* twin: HOME を設定する [#D0124]
  以下に home directory の取得の方法は書いてある。
  https://stackoverflow.com/questions/2910377/get-home-directory-in-linux
  まあ、実装した。OK

* twin: 一瞬表示されるコンソールを目立たなくする為にショートカットを弄る案 [#D0123]

  ショートカットの設定を弄るとウィンドウサイズや
  位置や透明度を指定できるので、できるだけ目立たない様に
  0,0 の位置でできるだけ小さく 30% の透明度にしている。
  しかし、それでも一瞬表示されるし、透明度を高めても
  タスクバーには確実に一瞬表示されるし微妙である。

  | ショートカットの設定をバイナリで勝手に弄ることはできるのだろうか。
  | 其処に wShowWindow 等があったりはしないだろうか。
  | 検索したら以下の場所にショートカットのバイナリフォーマットが書かれている。
  | https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/16cb4ca1-9339-4d0c-a68d-bf1d6cc0f943
  | プロパティで設定できたのは ConsoleDataBlock という部分であろう。
  | うーん。そういう設定は見つからない。次の ConsoleFEDataBlock という所も違う。
  | 見ていて気付いたのは不透明度に関する設定は載っていないという事。undocumented なのか。
  |
  | 設定を書き換えて binary dump してみる事にする。
  |
  | $ 透明度を30%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity30.od
  | $ 透明度を31%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity31.od
  | $ diff -bwu twin.lnk.opacity30.od twin.lnk.opacity31.od                                                                contra.git master (e5191cf) /src
  | --- twin.lnk.opacity30.od^I2019-05-04 11:40:35.427901900 +0900
  | +++ twin.lnk.opacity31.od^I2019-05-04 11:40:39.821501300 +0900
  | @@ -59,7 +59,7 @@
  |  0001640 63 f6 08 f9 16 34 45 95 19 80 e1 cc 4b 27 a6 c3
  |  0001660 ff 97 c0 00 6d e9 11 9d b4 70 8b cd 54 4c 9f cc
  |  0001700 00 00 00 02 00 00 a0 07 00 f5 00 01 00 29 23 01
  | -0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[00]
  | +0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[08]
  |  0001740 00 10 00 36 00 00 00 90 01 00 00 2d ff 33 ff 20
  |  0001760 00 b4 30 b7 30 c3 30 af 30 00 00 74 00 54 00 54
  |  0002000 00 46 00 6f 00 6e 00 74 00 5f 00 5f 00 00 00 00
  | @@ -77,7 +77,7 @@
  |  0002300 01 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00
  |  0002320 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00
  |  0002340 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00 11
  | -0002360 00 00 00 06 00 00 00 00 02 00 00 00[4d]00 00 00
  | +0002360 00 00 00 06 00 00 00 00 02 00 00 00[50]00 00 00
  |  0002400 11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff 00
  |  0002420 00 00 00 00 00 39 00 00 00 31 53 50 53 b1 16 6d
  |  0002440 44 ad 8d 70 48 a7 48 40 2e a4 3d 78 8c 1d 00 00
  |
  | うーん。二箇所書き換わっている。checksum か? 面倒だ。
  | 更に言うと単純な和ではない。変化量が異なる。
  | 或いはタイムスタンプだったりはしないかとも思ったがそれだともっと書き換わっているはず。
  | でもチェックサムにしては 00 の量が多い 1B しかないチェックサムというのも変だ。
  | また書き戻してみる事にする。
  |
  | $ 透明度を30%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity30.od.2
  | $ diff -bwu twin.lnk.opacity30.od twin.lnk.opacity30.od.2                                                                contra.git master (e5191cf) /src
  | --- twin.lnk.opacity30.od^I2019-05-04 11:40:35.427901900 +0900
  | +++ twin.lnk.opacity30.od.2^I2019-05-04 11:45:02.550927500 +0900
  | @@ -59,7 +59,7 @@
  |  0001640 63 f6 08 f9 16 34 45 95 19 80 e1 cc 4b 27 a6 c3
  |  0001660 ff 97 c0 00 6d e9 11 9d b4 70 8b cd 54 4c 9f cc
  |  0001700 00 00 00 02 00 00 a0 07 00 f5 00 01 00 29 23 01
  | -0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[00]
  | +0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[08]
  |  0001740 00 10 00 36 00 00 00 90 01 00 00 2d ff 33 ff 20
  |  0001760 00 b4 30 b7 30 c3 30 af 30 00 00 74 00 54 00 54
  |  0002000 00 46 00 6f 00 6e 00 74 00 5f 00 5f 00 00 00 00
  |
  | 成る程。前者はどうでも良い値という事なのかもしれない。
  | という事なので、後者について書き換えを実行してみる事にする。
  | 先ず値の解釈について 30% から 31% にしたら 0x4d から 0x50 になった。
  | これは10進数で77から80になった。255*0.3=76.5,
  | 255*0.31=79.05 と一致している気がする。或いは、77/255=0.3019,
  | 80/255=0.3137 と見るべきなのかもしれない。これを 0 に書き換えたらどうなるだろう。
  |
  | バイナリを書き換えるのは面倒だ。と思ったら以下にコマンドでできると書かれている。
  | https://kagasu.hatenablog.com/entry/2016/09/06/083536
  |
  | % $ cp twin.lnk twin0.lnk
  | % $ printf '\x00\x00\x00\x00' | dd of=twin0.lnk bs=1 seek=$((0x236C)) count=4 conv=notrunc
  | %
  | % そうしたら全く表示されなくなった。まあ、これで我慢するしかないのだろう。
  | % 然し、ショートカットを生成しなければならないので、面倒である。
  | % 後、この状態でショートカットを編集するとどうなるのだろう。。
  | %
  | % うーん。何度かやってみると全く表示されないという事はなくて、
  | % 偶に一瞬だけ表示される様である。不透明度0であっても。
  | % 然し、不透明度100の時は必ず一瞬表示されていたので、それよりは良い。
  | % また、不透明度30にしても0にしても余り違いはない気がする。
  | % 実はショートカットを読み出す時に0は30に補正されるのかもしれない。
  | %
  | % dd を実行するとファイルの長さが伸びてしまって駄目だ。
  | % しかし、ショートカットとしては動作している様なので取り敢えず気にしない。
  | % ファイルサイズは実は truncate コマンドで縮められる。
  | %
  | % しかし不透明度のフィールドが一体何処に格納されているのかは気になる。
  | % ConsoleDataBlock の BlockSignature は 0xA0000002 なのだそうだ。
  | % 02 00 00 a0 で検索してみる。#1703 にあった。アライメント等関係ないのか…。
  | % ここから ConsoleDataBlock は #169F から始まると分かる。
  |
  | うーん。何か変だ…あー。od は8進数なのか…。
  | 改めて: 02 00 00 a0 は #3c3 にある。ConsoleDataBlock は #3bf から始まる。
  | 問題のバイトは #4fc にある。offset は 317 である。うーん。
  | ConsoleDataBlock のサイズは 204 の様なので、opacity は別のブロックにある。
  | #48b(=#3bf+204) を見ると 0x000000c7 0xa0000009 がある。次のブロックだ。
  | というか最初の uint32 はブロックのサイズなのか…。
  | 問題のバイトはこのブロックの offset 113 にある。
  | ブロックの種類は PropertyStoreDataBlock だそうである。
  | ショートカットの文書には形式は書かれていない。
  |
  | [MS-PROPSTORE].pdf という文書を見る必要がある。
  | https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-propstore/39ea873f-7af5-44dd-92f9-bc1f293852cc
  |
  | 取り敢えず PropertyStoreDataBlock の中身だけ抜き出す。長さが c7 という事は、#552 まで続くはず。
  | 切り出すと以下の様になっている。
  | 000000 82 00 00 00 31 53 50 53 07 06 57 0c 96 03 de 43
  | 000010 9d 61 e3 21 d7 df 50 26 11 00 00 00 03 00 00 00
  | 000020 00 0b 00 00 00 ff ff 00 00 11 00 00 00 01 00 00
  | 000030 00 00 0b 00 00 00 ff ff 00 00 11 00 00 00 02 00
  | 000040 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00 00 04
  | 000050 00 00 00 00 0b 00 00 00 00 00 00 00 11 00 00 00
  | 000060 06 00 00 00 00 02 00 00 00 4d 00 00 00 11 00 00
  | 000070 00 05 00 00 00 00 0b 00 00 00 ff ff 00 00 00 00
  | 000080 00 00 39 00 00 00 31 53 50 53 b1 16 6d 44 ad 8d
  | 000090 70 48 a7 48 40 2e a4 3d 78 8c 1d 00 00 00 68 00
  | 0000a0 00 00 00 48 00 00 00 11 33 db 8a 80 72 0a 43 bd
  | 0000b0 cb 72 cc bd c4 c5 a0 00 00 00 00 00 00 00 00
  |
  | うーん。何か変だ…。サイズは 82 という事になっている。
  | これだと #4 + #82 = #86 までしかないという事になるが…。
  | まあ、余り気にしない事にする。0x53505331 は一致している。
  | 後、サイズ #82 は自身も含めてのサイズの様に思われる。
  | というのもすぐ次にまた別のデータが始まっているから。
  | そして長さも一致している。
  | 次に来るのは GUID だそうだ。
  |
  | % 96 03 de 43 9d 61 e3 21 d7 df 50 26 11 00 00 00
  | % 更に続きのデータは以下の様になっているが、最早追跡できない。
  | % 03 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00
  | % 00 01 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00
  | % 00 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00 11
  | % 00 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00
  | % 11 00 00 00 06 00 00 00 00 02 00 00 00[4d]00 00
  | % 00 11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff
  | % 00 00 00 00 00 00
  | % GUID の符号化が分からない…。
  | % 9603de43 9d61 e321 d7df 502611000000
  | % 43de0396 619d 21e3 dfd7 000000112650
  | % https://en.wikipedia.org/wiki/Universally_unique_identifier によると…。
  | % Microsoft は最初の3つは little endian で後ろの2つは big endian だそうだ。
  | % 43de0396 619d 21e3 d7df 502611000000 検索しても当たらない…。
  | % 43de0396 619d 21e3 を検索しても 9603de43 9d61 e321 を検索しても当たらない。
  | % Microsoft が内部的に使っていて文書も何もないという事なのだろうか。
  |
  | 然し、うーんやっぱり変な気がする。と思ったら切り出し方が変だった。
  | GUID 07 06 57 0c 96 03 de 43 9d 61 e3 21 d7 df 50 26
  | GUID {0c570607-0396-43de-9d61-e321d7df5026} 検索したら当たった…。23件ある。
  | うーん。しかし他の人も同じ様に LNK ファイルの中身を見てみてこんなのがありましたという感じである。
  | 初めの3フィールドだけ見てもよく分からない。中身の形式について見る。規則性がある。
  |
  |   11 00 00 00 03 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 01 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00
  |   11 00 00 00 06 00 00 00 00 02 00 00 00 4d 00 00 00
  |   11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   00 00 00 00
  |
  | [size(4byte) ID(4byte) ?(1byte) ?(4byte) value(4byte)] x 6 + 0x00000000 に見える。
  | 根拠は得られなかったが、まあ、何か拡張データとして透明度が設定されている様だ。

  まとめると、ショートカットのバイナリフォーマットの形式外で不透明度が記録されている。
  具体的には PropertyStoreDataBlock の中の拡張データとして、
  GUID {0c570607-0396-43de-9d61-e321d7df5026} (undocumented) のデータとして登録されている。
  中のバイナリの構造を見ると ID6 に対して 0x0000004D という値で不透明度 30% を指定している。

  所で不透明度を無理やり書き換えるコマンドは正しくは以下の通り:
  $ printf '\x00\x00\x00\x00' | dd of=twin0.lnk bs=1 seek=$((0x4FC)) count=4 conv=notrunc
  うーん。実際に試してみると、これを実行すると寧ろ不透明になる様だ。
  つまり、変な値を書き込むと強制的に不透明であると解釈され直す。

  うーん。ショートカットを弄るという滅茶苦茶な方法はまあ、
  面白いアイディアではあるかもしれないが現実的ではない。
  これはやめる。

* twin: エクスプローラから起動できない原因を調べる [#D0122]
  調べてみると一応イベントループの中に入って何回かは回転している様である。

  うーん。sess.is_alive に失敗している。
  プロセスが生きているかどうかのチェックで死んでいるという事だろうか。
  うーん。戻り値を取得すると 65496 という巨大な値になっている。???
  もしかして bash の起動に失敗している? 環境変数で PATH を設定していないのが悪い。
  実際に bash.exe をその辺にコピーして試してみると起動しない。
  色々の DLL を参照している様子である。

  mintty の場合にはどういう事になるのだろうと思って試してみると、
  mintty 自体は起動するが、ちゃんと bash の起動が失敗した事を検出している様である。
  cygcheck ./mintty.exe としてみると cygwin-1.dll のみに依存している様だ。

  cygcheck ./twin.exe とすると似た様な物だ。
  但し、cyggcc だとか cygstdc++ だとかも参照している。
  うーん。-static-libgcc -static-libstdc++ を指定したら
  まあ cygwin-1 だけに依存する様になった。
  配布する時にはそちらの方が良いだろう。
  必ずしも Cygwin ユーザが cyggcc, cygstdc++ を持っているとは限らないので。
  まあ、それでもバイナリが大きくなってしまうので取り敢えずは入れなくて良い。

  - 因みに Cygwin で入っている mintty 603kb は strip されている様である。
    twin は現時点で strip して 429kb なので、
    変な機能を実装している事とC++で書いている事を考慮に入れれば
    可也健闘していると言えるのではないだろうか。

  - 話が脱線している。問題は如何にして PATH を設定するのかという事である。
    というか、Poderosa でも同様の事をしていた様な気がする。調べる。
    うーん。Poderosa では特に何もしていない様な気がする…。
    作業ディレクトリはユーザの home に設定してしまっている。
    cygterm の中で何かいい具合にやっているのだろうか。
    うーん。cygterm の中でも PATH を設定している形跡はない。うーん。何だかわからない。
    自身の環境変数に登録してしまっている可能性についても考えたが、そんな雰囲気もない。
    まあ、Poderosa の事は忘れる事にする。

  - 結局の所、自前で PATH に値を追加してしまえば良いのである。
    しかも、恐らく Cygwin PATH に /bin と /usr/bin 辺りを追加してしまえば、
    後は勝手に cygwin-1.dll が Windows PATH に適切な場所を設定してくれる。
    その前に現在の PATH を出力してみる事にする。出力してみたら、
    確かに /cygdrive/c/... ばかりで /usr/bin 等が指定されていない。

    因みに mintty がどんな環境変数を設定するのか確かめてみると
    /usr/local/bin 及び /usr/bin を足している。
    Poderosa で起動してみると /usr/local/bin:/usr/bin:/usr/bin が追加されている。
    誰が追加しているのか分からないが取り敢えず twin でも /usr/local/bin:/usr/bin
    を追加してみる事にする。うーん駄目だ。

  - execl の次にエラーメッセージを出力する様にしたら出た。
    つまり、execl に失敗しているという事である。
    うーん。errno を確認すると No such file or directory となっている。
    これは mintty と同じエラーメッセージである。
    うーん。そもそも cygwin-1.dll をコピーして起動してみるという起動の仕方自体が駄目の気がしてきた。

    twin.exe を /bin/ にコピーして起動してみるとちゃんと起動した。
    更にショートカットを作って起動できる様にしてみる。

  - うーん。やはりコンソールが表示されてしまう。
    ショートカットの右クリックから確認すると mintty.exe の時とは異なるタブが表示されている。
    Windows コンソールの設定を行う項目達である。という事を考えれば、
    やはりコンパイル時に何らかのサブシステムの指定などが抜けているのだろう。

    うーん。やっぱりこれの気がする…。
    https://docs.microsoft.com/ja-jp/cpp/build/reference/subsystem-specify-subsystem?view=vs-2019
    WinMain ではなくて main を使っているのがいけないのかと考えて、
    猫でも分かるの WinMain のプログラムをコンパイルして同様に起動してみたが、
    やはりコンソールが表示される。つまり、普通にやっているだけでは
    常にコンソールをターゲットとしたバイナリになってしまうという事。

    実は PE ヘッダにサブシステムが書かれていたりはしないだろうか。
    http://home.a00.itscom.net/hatada/mcc/doc/pe.html
    によると確かに PE ヘッダの中に書かれている。
    所で PE ヘッダの情報を書き換えるプログラムがなかっただろうか。
    fork failed の問題を解決する時に使った様な…。

    うーん。絶対合ったはずだが検索してもその解決方法のページ自体見つからないし、
    自分の wiki にメモとして書いた様な気もしたが該当しそうなページが分からない。

    あ。分かった。peflags だ。(compgen -c -- '' | grep pe して見つかったが、
    普通に pe で始まるコマンドを探せば見つかったのだった。) peflags の --help で見る。
    然し、peflags コマンドでは subsystem は変更できない様だ。
    となると、勝手に PE header をバイナリエディタか何かで書き換えるしかないのか。

    結局プログラムで読み取って書き換える事にした。
    調べてみると確かに mintty は subsystem が 2 になっている。
    猫でもわかるのサンプルプログラムに適用してみたところ
    確かにコンソールは表示されなくなった。

  - 一方で、twin に対して実行してみたところ起動はする様になったし、
    裏で bash が動いてはいる様な気がするが、何にも応答がない。
    入力した文字列のエコーバックは行われる様である。
    C-d で終了する。また touch hellowww.txt としたら、/usr/bin/hellowww.txt ができた。
    つまり /usr/bin/ の上で何かが動いているという事になる。もしかすると
    コマンドプロンプトが動いているのだろうか、、と思ったがそれだと C-d で終了する理由が分からない。
    もう少し動かしてみる事にする。

    dir > hello.txt として見たら CMD のそれではなくて ls の結果が出力される。
    うーん。bash が -i なしで実行されているという事だろうか?
    ログインシェルとして実行する必要があるのでは。

    cd してそれから echo $HOME > aaa.txt したら ~/aaa.txt にファイルが出来た。
    やはり bash が動いているがログインシェルになっていないという事である。
    うーん。中で bash -l として起動しても何も起こらない。
    echo $- の結果は hBs である。set -i してみたが変化はない。

    * done: bash -l で起動するのを試みる
      →うーん。やっはり変化はない。そもそも端末に繋がっていないという事なのだろう。
    * done: subsystem version を確認する。
      →これに関しては mintty も 4.0 だったので違いはない。関係ないだろう。
    * done: AllocConsole を試してみる事にする。
      AllocConsole しても現在の現象は変化しない…。
      これは最早 mintty の起動シーケンスを見に行くしかないのだろうか。

    逆に subsystem を書き換えずに FreeConsole を実行したらどうなるのだろうか。
    これは直ぐに終了してしまう。これはこれで何か理由があるのだろうが、
    まあ、この方向性については後で考える事にする。

    * done: tty が割り当てられていないのかという事を確かめる。
      /dev/pty24 がちゃんと割り当てられている…。不思議だ。

    https://docs.microsoft.com/en-us/windows/console/console-functions
    コンソールの割当などを上記のページで確認するのも良いかもしれない。

    * reject: CreatePseudoConsole というのがある様なのでそれで適当に作って、
      その後に AttachConsole できないかと思ったが両方の説明を読むと
      そういう事ができるような物ではないようである。

    * reject: うーん Poderosa から起動する時はどうなっているのかと思ったら、
      ProcessStartInfo で CreateNoWindow を指定して起動している。
      つまり内部では cygterm.exe の Console 的な物が存在しているという事か。。
      CreateProcess の説明を見ると STARTUPINFO 構造体に色々指定できるようで、
      恐らく http://chokuto.ifdef.jp/urawaza/struct/STARTUPINFO.html を見た限り、
      CreateNoWindow は SW_HIDE を wShowWindow に指定するという事の気がする。

      実は PE header を見たら CreateNoWindow に相当する何かがあったりしないだろうか。
      ない様だ。どうもそういう雰囲気ではない。
      何れにしても STARTUPINFO を指定するのは起動する側のプロセスだから、
      こちらからはどうしようもない。

    * 現在は起動した瞬間に
      ::ShowWindow(GetConsoleWindow(), SW_HIDE);
      としているが、暫くはこれで我慢するしか無いという事なのか。

    * unknown: mintty がどうしているのかについて確認するしかないのか
      src/winmain.c に main 関数があった。特に何か変な事をしている様子もない。
      というかよく考えたら twin の症状は bash がちゃんと起動してくれない事だった。
      という事を考えたら実は起動時の処理を見るのではなくてシェルを起動する所の
      処理を見なければならないのではないか…。うーん。色々と違うので参考にするのはやめる。

      そもそも mintty は WSL や MSYS にも対応している様である。

    * reject: 或いは GetConsoleWindow() を乗っ取って
      自分のウィンドウにしてしまうという事も可能だったりするのだろうか。
      と思ったが別のメッセージループが回っている筈なので、
      自分でループを回したい場合には都合が悪い。

      と思ったが勝手に WndProc の中でメッセージループを回しても良い気がしてきた。
      終了する時には PostQuitMessage だけして自分ではメッセージを処理せずに抜ける。

      しかし勝手に乗っ取るにしても親の設定したメニュー項目はどうするのかだとか、
      色々問題があるのは確かである。うーん。それにもしそうしたとしても、
      一瞬、親の設定した状態でウィンドウが表示されるのには変わりない。
      何の解決にもなっていない。これなら SW_HIDE する方がましである。

2019-05-03

* というか、mwg/except.h を添付する方が良い気がする [#D0121]
  →これは実際に mwg/except.h をコピーしてきてそれを使う様にしたら簡単にできた。
  問題は発生していないのでOK

* twin/draw: 文字の blinking [#D0120]
  xterm は文字の blinking は速いのも短いのも同じ速さ。
  RLogin は速さを変えている。一方が他方の2倍の速さ。
  mintty は速さを変えている。点滅の速さは独立の様である。
  Poderosa 4.3.5b は当然対応していない。

  xterm と mintty はフォーカスを失っている間は点滅しない。
  RLogin はフォーカスを失っている間も点滅している。
  対応した。動いている。

* twin/draw: proportional を指定した時は ExtTextOut ではなくて [#D0119]
  TextOut を使う様に変更して良いのではないだろうか。
  これで完全に対応できたとは言い難いがまあ無難な描画方法だろう。
  しかし、その時には空白類はスキップできない事になる。

  実装してみた。Times New Roman で試してみたが何か変だ。
  単語内部はまあ良いとしても、単語と単語の間の空白の大きさが気になる。
  →proportional の時には空白も可視文字として取り扱う事にした。
    一気に長い文字列を proportional で描画すると配置がずれるが、
    まあ、今後変な align のタブなどにも対応する事を思えば、
    これぐらいなら良いというかこの様に振る舞うべきである。
    (カーソルの位置と実際の表示の位置がずれてしまう事は
    この様な場合には最早気にしない。表示の為だけの機能と思う事にする)

* twin/draw: WM_PAINT の時は裏のバッファを表に転送するだけで良いのではないか [#D0118]
  その様に変更した。

* twin/draw: 点滅 [#D0117]
  カーソルの点滅は取り敢えず実装する。

  点滅に関しては WM_TIMER でも発生させれば良いだろう。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win47.html

  どうも Poderosa や RLogin の振る舞いを見ていると、
  点滅に関しては入力のタイミングでリセットされている様である。

  xterm でも同様のようである。
  うーん。文字を出力したりカーソルを移動したりする度にリセットされている。。
  一方で内容に変更が伴わない場合にはリセットはされていない。
  内容の変更は line の id/version で追跡するとして、
  カーソルの位置・形状は自前で記録して比較を行う事にする。
  文字の blinking のタイミングとは独立の様である。

  取り敢えず SetTimer する事にする。
  と思ったが、内容に変更があったら SetTimer するという事なので、
  内容に変更がなかった場合には更新しない。
  内容に変更があったかどうかを確認しなければならない。
  つまり一番最初に内容に変更があった時にだけ再描画する様に修正する必要がある。

  * done: 先ず初めに WM_PAINT では再描画ではなくて、
    既に描画してある内容を転送する様に実装する。
    但し、最後に描画してからサイズが変更になったりしていると、
    失敗してしまうので再描画が必要になる。

    うーん。どういう時に更新が必要になるのだろうか。

    (1) 内容の部分更新が必要な場合
      - 行などが更新された

    (2) 内容の完全な更新が必要な場合
      - パレットが変更された
      - 背景色が変更された
      - フォントが変更された
      - その他描画に関する設定が変更された

    うーん。変更に伴う描画内容の更新は全て twin の自発的な
    再描画に任せるとすれば WM_PAINT の時には無駄な更新は一切行わなくて良い。
    完全に転送するだけで良いのである。但し、画面のサイズが変更になっていたりすると、
    その時には完全な再描画が必要になってしまう。

    うーん。画面のサイズが変更になった時にだけ
    現実的に問題になってしまうので再描画を実施する事にした。OK

  * done: 次に…。前回と比べて状態に変更がない時にのみ更新を行う事にする。
    取り敢えず変更があった時にのみ表示を更新する様にした。
    ちゃんと動いているのかどうかについては分からない。

    本当はカーソルの描画と本体の描画を分離して
    より効率的にしたいがそれは後で実装する。

    で何をしたかったのかが分からなくなった。
    カーソルの変更があったら timer をリセットするという事だった。
    しかし、render_window を呼び出した時点でいつも timer をリセットすれば
    良かったのではないか? と思わないでもない。
    現状だと画面に動きがなくても何か受信していたら timer がリセットされる、
    という様な状況からそういう時には timer がリセットされないという様に変わっただけである。

    まあ、理想的にはそうなのであるが、実は現状の実装では余り
    気にしなくても良かったのではないかという気もする。
    何れにしても準備はできたので次に進むことにする。

  * done: うーん。描画内容に変化があったら点滅をリセットする、
    という事にしようと考えたが点滅自体によって描画内容に変化が起こるので、
    単純に考えたらこれでは駄目である…。

    % うーん。どういう変化があったのかという事を tracer の側で記録して、
    % それにアクセスできる様にするのが良い気がする。
    % うーん。実際にはもっと処理の需要に応じた判定方法がある気がする。
    % 始めに全て判定してどうのこうのではなくて、
    % 処理を一回通してその結果としてこうでしたね、という形になっていて欲しい。
    %
    % 後、カーソルが見えない設定になっている時には timer を設定しなくて良い。
    % 現状の問題点は何かというと再描画するかどうかが
    % カーソルに変更があったかどうかに依存しているという事。
    %
    % 更に文字の点滅による再描画についてもカーソルはリセットしない。
    %
    % 結局再描画するかどうかの判定と、
    % カーソルをリセットするかどうかの判定は違うという事。
    % そして、実はカーソルをリセットする必要がある時には、
    % カーソルをリセットしてから再描画しないと駄目。
    % カーソルの点滅状態を点灯にしなければならないから。うーん。

    少し真面目に実装したら整理がついた。
    実装もせずに変に枠組みだけで整理しようとすると、
    実際にどう実装されるかの実態がわからないから変な事になるのである。
    また大幅に書き換えた。まあ動く様になった気がする。
    タイマーのリセットもちゃんと正しい条件になっている気がする。

  * done: 次に WM_TIMER で処理を行う。
    実行してみると点滅しない。変だ。調べると、
    ちゃんと描画を要求する部分では点滅している事になっている。
    つまり、カーソルを描画したりしなかったり。
    しかし、カーソルを描画しなかった時に何も起こらない…。

    あー。分かった。何も描画しなかったからこそ、
    前回の内容がそのまま表示されているという事なのである。。
    うーん。前回表示状態だったら消して、という事をしなければならない。
    というか、前回のカーソル位置も覚えておいて状態を復元しなければならないのでは。

    うーん。駄目だ。それを修正しても点滅してくれない…。
    座標計算を間違えているだろうか。。と思ったら簡単なミスだった。
    直した。点滅している。まあ、満足である。

  * done: カーソルに点滅の on/off の設定がある事を忘れていた…。
    設定した。また、タイマーは点滅していない時やカーソルを
    表示していない時には off にする事にした。

* twin: 日本語フォント名が認識されていない [#D0116]
  「ＭＳ 明朝」などとしても失敗する様である。
  然し、その他のフォントの英語名が分からない。検索しても出てこない。
  ようやく以下のページが見つかった。
  https://oshiete.goo.ne.jp/qa/9530867.html "HGMaruGothicMPRO" だそうだ。
  更にこれを使って検索すると色々出てきた。
  http://www.htbasic.jp/tip/p021/
  | MS明朝               "MS Mincho"
  | MSゴシック           "MS Gothic"
  | HGゴシックE          "Hgsgothice"
  | HGゴシックM          "HGGothicM"
  | HG丸ゴシックMPRO     "HGMaruGothicMPRO"
  | HG教科書体           "HGKyokashotai"
  | HG行書体             "HGGyoshotai"
  | HG楷書体PRO          "HGSeikaishotaiPRO"
  | HG創英角ゴシUB       "HGSoeiKakugothicUB"
  | HG創英角ポップ体     "HGSoeiKakupoptai"
  | HG明朝B              "HGMinchoB"
  | HG明朝E              "HGMinchoE"
  | ＤＦPOPクリップW7    "DFPOPClip-W7"
  | ＤＦPOPコンW7        "DFPOPCorn-W7"
  | ＤＦブラッシュＲＤW7 "DFBrushRD-W7"
  | ＤＦフリー流線W3DF   "DFFreeRyuSen-W3"
  | ＤＦ華康ゴシック体W3 "DFGothicP-W3"
  | ＤＦ華康明朝体W3     "DFMinchoP-W3"
  | ＤＦ華康ゴシック体W3 "DFKanTeiRyu-XB"
  | ＤＦＰ極太丸ゴシック "DFMaruGothic-UB"
  | ＤＦ極太明朝体       "DFMincho-UB"
  | ＤＦＰ太丸ゴシック体 "DFMaruGothic-SB"
  | ＤＦ中丸ゴシック体   "DFMaruGothic-Md"
  | ＤＦＰ中楷書体       "DFKaiSho-Md"
  | ＤＦ唐風隷書体W5     "DFTFLeiSho-W5"
  | ＤＦＰ特太ゴシック体 "DFGothic-EB"
  | ＤＦ風雲体W7         "DFFuun-W7"
  | ＤＦ平成明朝体W7     "DFHSMincho-W7"
  | ＤＦ麗雅宋           "DFLeiGaSo-W9"
  | OMEJDICライト標準    "OMEJDIC"
  | メイリオ             "メイリオ"

* ansi: 二重打ち消し線がないのは意外である [#D0115]
  機能を追加するとしたら波下線なども欲しいし
  更に下線の色も変更できる様にしたいなど色々ある。
  しかし、そういうのは extended flags だとか、
  或いはオブジェクトとして定義できる様にするだとか、
  そういうのが良い。

  一方で実は RLogin は SGR(64) で圏点の代わりに二重打ち消し線を表示している。
  というか SGR(60-63,66-69) で 8 bit も使っているのは変である。
  同時に複数設定するのは変だという事を考慮に入れれば
  (65 でクリアできる事からもこれらはそれぞれ独立に選択できるのではなくて、
  何れか一つのみを選択できるようにするというのが自然である) 4bit で済む。
  そもそも何故この様なスイッチにしたのかというと RLogin に対して透過的にする為である。

  RLogin は SGR(60-63) に対してそれぞれ右縦線・右二重縦線・左縦線・左二重縦線としている。
  これは…うーん。拡張機能として提供する事にして、ANSI SGR(60-63,66-69) は選択式に変更する。

  * done: 取り敢えず先ずは 60-63,66-69 の定義を変更する事にする。
    60-64,66-69 を exclusive に固定し、4bit で表現する事にした。
    (今は 10 種類の値があるので実は未だ余裕がある。
    圏点の種類にでも実は対応できるかもしれない。)

  * done: RLogin の左右の線・二重線に対応した。4bit 使う。
    SGR(8460-8465) で対応した。

* twin/draw: 取り敢えずテキスト修飾を描画する事にする [#D0114]

  気付いてしまったのだが decdhl の属性があると
  あらゆる物について通常の描画と横2倍・上半分・下半分の
  4種類の描画を用意する必要が出てくる。面倒な事である。

  何れにしても描画だけはする。
  これは文字とは違って離れた物を同時に描画する必要はないので、
  背景色と同様に一様に実装してしまう事にする。
  ascii_nul な升目に関してはスキップする。

  打ち消し線や下線などに関しては連続する升目について
  同時に描画した方が都合が良いので、背景色と似たように実装する。
  色々考えると draw_background を改造するのが良いのではないか。

  * fixed: うーん。実際にやってみると何故か下線と一緒に打ち消し線が表示される。
    自分で printf で出力してみると再現しない。不思議だ。
    また、ble.sh の問題かとも思ったが同様に SGR(9) で打ち消し線を表示する
    xterm などで再現していないのは変だ。つまり、やはり contra のバグである。

    うーん。分かった事。これは下線と連動して出ている訳ではない。
    なにか別の属性と連動して現れている。うーん。特定の前景色に連動している気がする。
    あれ。。前景色のビットはどうなっているのだったか。。
    うーん。別に重複が在る様には見えない。調べてみると SGR を設定した後の
    aflags の値には別に変な所はない。とすれば読み出すところで変な事が起こっている?

    あー。分かった。auto xflags = attr.aflags としてしまっている所があった。修正した。

  * done: 取り敢えず試験的な実装が動く様になったのでその他の装飾についても
    追加して行く事にする。取り敢えず overline である。
    →下線に関しては全て対応した。結局、上か真ん中か下しかなかったのだった。

  * 次は各文字に対する装飾である。丸と四角と傍点が存在する。

    % 傍点に関しては…。実は文字を描く時に対応するべきだったのかも知れない。
    % 何故ならば ExtTextOut で一括で書いた方が良かったから。
    % というかフォントに依存する筈である。
    % 然し、文字として描くのはそれはそれで変な気もする。
    % 第一、位置の調整をどの様にしたら良いのか。
    % 所で Unicode に傍点ってあるのだろうか。ちゃんとある様であるが大きさが使いにくい。
    %
    % というより wikipedia によると横書きでは黒丸という事なので、
    % 取り敢えずの所は気にしないで手で黒円を描画する事にする。
    % https://ja.wikipedia.org/wiki/%E5%9C%8F%E7%82%B9
    %
    % 本当はフォントに応じてそのフォントの圏点を使いたい所だが、
    % そもそも字形が定義されていなかったり、大きさの制御が難しかったり、
    % 位置の制御が難しかったりしそうなので取り敢えずは使わない事にする。

    傍点は黒丸で自前描画する。

    円の描画は以下に書かれている。取り敢えず実装する。
    http://www.kumei.ne.jp/c_lang/sdk/sdk_25.htm

    実装した。

* vttest(2): decsc で属性が復元されていないという事に気付いた [#D0113]
  カーソル位置が範囲内になる様に修正した時に、
  属性を適用するコードが実行されなくなってしまっていた。修正した。

* twin/draw: 日本語変換している間はカーソルは表示しない [#D0112]

2019-05-02

* twin/draw: フォントについても実装してしまう事にする [#D0111]

  先ず初めにどの様な属性がフォントに影響を与えるかについて調べる。

  bold/faint 3pat,
    太字・通常・細字
  italic/fraktur 2pat,
    通常の直立体か斜体か。fraktur はフォント自体を
    切り替えるので寧ろフォントとして扱う。
  pld/plu/frame/circle 3pat,
    通常の大きさ・小さめ・より小さめの3段階
  sco 8
    8種類の角度
  sgr(10-19)
    これは10種類+frakturの11種類
  decdwl など 3pat
    3種類

  うーん。合計で 3x2x3x8x11x3 = 4752 の可能性がある。。
  全てについてフォントを生成していたらメモリを物凄く食ってしまう。
  やはりキャッシュしておくのは一部だけにするべきの気がする。

  取り敢えず覚えておく物に関しては
  (1) 10-19+1 の 11 pattern
  (2) bold/faint, italic の 6 pattern

  回転と倍幅の文字などはその場で生成する。
  過去に使ったN個までは記録しておく。
  plu/pld/frame/circle に関しては小さめだけで十分(2pat)と判断する。
  実は faint については通常の太さと変わらないのではないか。
  特に現状の GDI の機能だと細字にしても何か描画結果に違いが出るとは思われない。
  faint なフォントについては永久記録ではなくて一時記録にして良い気がする。

  因みに circled, framed は RLogin では二重囲み線、一重囲み線として実装されている。
  また、文字毎に囲んでいるのではなくて連続する同じ属性の範囲で囲んでいる。

  余り変な機能は今は考えずに実装した方が良いのかもしれない。

  * fixed: 回転を実装してみた物はいいものの何だか変だ。
    ごろんごろん転がる石の様な動きをする。
    もっと細かい角度で回転させてみてみる。
    普通に回転しているように見えるが回転の原点がずれている気がする。

    詳しくキャプチャして画像に線を引いたりしてみると。
    回転の原点はちゃんとあってそれに従って回転はしている。
    つまり、回転+変なシフトではなくてちゃんと回転である。
    回転の原点の位置も問題ない様に見える。
    しかし 90 度に比例しない角度の時だけ、
    回転前の画像が y 方向に幾らかずれている気がする。
    文字の大きさ自体が変わっている等の事はないようだ

    文字の大きさ自体も変化させてみようか。
    実際に文字の大きさを変えて試してみた所、やはりひくひくしている。
    うーん。つまり、ずれの量は絶対量で決まっているのではなくて、
    文字の大きさに対する相対量で決まっている。何れにしてもずれの方向は
    y 方向だけの様に見えるので適当に値を決めて試してひくひくしない様にする。

    うーん。文字をうんと大きくして試してみた。
    ypixel = 104 の時には先ず文字の大きさは変化していない。
    x 方向に 1px 進んでいる。y 方向に 32px 進んでいる。
    もう少し小さい文字の時にも x は 1px 進んでいた。
    ypixel = 52 の時には x 方向に 1px 進んで、
    y 方向には 15px 進んでいた。
    ypixel = 26 の時には x 方向に 1px 進んで
    y 方向に 9px (8.5--10px) 進んでいた。
    うーん。y 方向の進み方は a ypixel + b の線形関係かとも思ったが、どうだろう。

    a 104 + b = 32
    a 52 + b = 15
    a 26 + b = 9

    係数を整理する。4a+b=32, 2a+b=15, a+b=9
    最小二乗残渣は R = 21a^2 + 3b^2 + 14ab -334a -112b + 1330
    最小を与える a, b は? 42a+14b-334=0, 6b+14a-112=0
    よって 14a=112-6b を代入すれば 0=3(112-6b)+14b-334=2-4b -> b = 1/2
    更に a = (112-3)/14 = 109/14.
    書き換え前の係数で考えれば
    f(ypixel) = 109/14/26 ypixel + 1/2 = 109/364 ypixel + 1/2 という事になる。
    実際に入れてみると f(104) = 31.64, f(52) = 16.07, f(26) = 8.28 である。
    また、109/364=0.29945 である。

    うーん。b=1 に固定してみるとどうなるだろうか。
    4a=31, 2a=14, a=8 残差は R=21a^2-320a+const 最小値を与えるのは a = 160/21
    f(ypixel) = 1+(160/21/26)ypixel = 1+(160/546)ypixel
    →f(26)=8.61, f(52)=16.23, f(104)=31.48 という具合になる。
    因みに 160/546=0.293 である。まあ f(ypixel)=

    この様に考えてみると。std::round(0.3ypixel) 辺りが妥当なのかも。
    0.3ypixel について 26,52,104 に対してそれぞれ 31.2,15.6,7.8 である。

  * done: decdhl bottom に関する表示位置の補正。

  * decdhl の描画範囲制限に関して
    描画範囲の制限は以下に載っている関数でできる様だ。
    https://stackoverflow.com/questions/358611/how-to-set-g

    よく考えたら decdhl, decdwl をテストする方法が存在しない…。
    対応する事にする。取り敢えず対応した。SGR(0) でクリアできないのは都合が悪いので、
    SGR(0) でクリアする事にする。というか、今までは DECDHL, DECDWL 等を
    実現する為の枠組みと考えていたが、これは新しい SGR の属性と考えた方が良いかも知れない。

    或いは、SGR(0) でクリアはできるがその他の操作では SGR 属性としては扱われない、
    という感じの取り扱いにしても良いかもしれない。現実的にはそれで良い気がする。
    さて、ちゃんと動くことを改めて確かめる。OK 位置に関しては大丈夫。

    これから Clip について試してみる事にする。
    以下のページの方が詳しく書かれている。
    http://wisdom.sakura.ne.jp/system/winapi/win32/win134.html
    以下に Region 関連の関数の一覧がある。
    https://docs.microsoft.com/en-us/windows/desktop/gdi/region-functions

* ansi: SLH, SLL をクリアできないのは不便すぎる [#D0110]
  と思って実装を確認してみたらちゃんと無引数で呼び出せばクリアされる様になっていた。

* twin: S8C1T, DECCKM の時に送信されるシーケンスが変だ [#D0109]

  再現させる。S8C1T ... ESC SP G で DECCKM は SM(?1) である。
  実際にやってみると再現した。然し、送信されているのは M-^O で一文字であった。
  つまり、ble.sh は M-^O に対応していないというだけの事。
  或いは普通に考えれば S8C1T に対応しているアプリケーションは少ない。

  後、S8C1T の状態で bash にログインすると minencoded char 0x9B というのが出る。
  つまり、utf8 encode を介さずに CSI が送信されているという事。
  これについても修正する必要がある。
  うーん。これは丁度枠組みとして重複している部分である。

  * 先ず初めに terminal_session の送信部分を term の方に移動する。
    もしかすると同じ仕組みを他にも使いたくなる事もあるかもしれないが、
    それはその時に共通部分を括りだせば良い。今は未だ切り出す必要はない。

  * done: term_t における関数名をどうするか。
    枠組みを統合するにしても関数名が悩ましい。

    % term_t は2つの物の間に位置するので通信をするにしても
    % 入力・出力が2つずつあって関数名がややこしい事になる。
    % 整理しておいた方が良いかもしれない。
    %
    % 基本的にはアプリケーションとの通信がメインであると思えば、
    % input と言えばアプリケーションに対する送信である。
    % 一方で、端末の状態に対する操作と考えれば端末に対する書込は
    % write という事になる。read というのは何だろう?
    % うーん。本当に4種類の物があるだろうか。
    %
    % ユーザと端末とアプリケーションがいて、
    % ユーザからの入力は端末で符号化されてアプリケーションに送信される。
    % アプリケーションからの出力は端末で可視化されてユーザに見える様になる。
    % そう考えれば実は余り複雑ではない。
    % 4種類あるのは passive かどうかという事の違いの気がする。
    %
    % 通常はアプリケーションからのデータは間欠的にやってくる。
    % データが届いたら処理をするという形でデータの送信元が主導権を持っている。
    % term はそういう意味で常に受け身なのである。term 自体が手動して読み取るという事はない気がする。
    % 逆にユーザからの入力はどうだろうか。実はこれについても送信元が主導権を握っている。
    % 時々 term 自体が何かを送信したりはするがこれも送信をする側が主導権を持っている。
    % そういう意味でいえば passive かどうかという区別もないのである。
    %
    % うーん。結局全て term に対する入力という形で処理されているので、
    % 2つを区別するのに関数名が困るという事である。
    % アプリケーションから来て端末を制御するのに使われる関数は write である。
    % これはこれで良い気がする。端末を canvas か何かの様に考えた命名である。
    % しかしだからと言ってユーザからの入力は read ではない。
    % もしアプリケーションが読み取り元でそちらが主導権を持っていれば read で良かったがこれは違う。
    % ではユーザからの入力は何かというと input なのだろうか?
    % うーん。やっぱり変な気がする。send だろうか。respond は取り敢えずそうしてみたが変である。
    % input の方がましである。うーん。やっぱり現在の設計というか構造が変なのである。
    % term が一体何なのかが意味不明である。

    うーん。まあ input としておけば、それが端末画面に対する書込ではないと分かるので、
    input ということで良い気がする。もしより良い案が見つかればその時に置換すれば良いだけである。

  * fixed: term_t::respond と terminal_session::put_flush は統合した。
    その過程で misencoded char の問題も修正した。

  * 後は ble.sh の側で対応すれば良いだけである。
    CSI に対して何かユーザーのキーバインドを割り当てるという事もないだろうし、
    やはり CSI 等に対してもキーバインドを追加して良い気がする。
    というか現に ble.sh の枠組みでは CSI シーケンスとして読み取っている物に関しては、
    ちゃんと CSI を解釈する仕組みになっている。
    個別に登録している物だけ対応していないというのも変である。
    取り敢えず対応した。動くか試してみる事にする。
    →ちゃんと動く事を確認した。OK

* twin: いつの間にかに日本語入力が起動したりしなくなったりしている… [#D0108]
  と思って色々試していたら実はメッセージループで hWnd に限っていたのがいけなかった。
  他の hWnd を対象として IME_COMPOSITION 等が送られてくる様なのである…。
  更に変換の途中で部分確定した時の座標を再設定しなければならない。

  Poderosa の実装を確認するとデータを受信する度に調整を再実施している。
  うーん。実は IME_COMPOSITION だけでも十分な気もする。試してみる。
  試してみたら駄目だった。うーん。やっぱりデータを受信した直後に実行しないと駄目だ。

* twin/draw: 次に背景色に対応しなければならない [#D0107]

  背景色の塗りつぶしはそんなに時間がかかる訳でもなさそうだし、
  それに離れている四角を塗りつぶすためには別々に塗りつぶさなければならないので、
  結局別々に API を呼び出さなければならない。従って連続する部分だけ塗りつぶせば問題ない。
  対応した。色々とバグも潰した。動いている。

* 取り敢えず文字色に対応したい [#D0106]

  その前に背景色を全て描画してから前景を描画する様に変更したい。
  これは行をはみ出ている文字などを描画することがあるからである。
  行をはみ出ている文字は他の行の背景色で塗りつぶされて欲しくない。

  取り敢えず文字の背景色が書かれない様にする。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win21.html
  int SetBkMode(HDC hdc , int iBkMode); を使えば良いそうだ。
  設定した。ちゃんと動作している事を確認した。

  | うーん。そもそも半透明とかアルファとかに対応しているのだろうか…。
  | だんだん怪しくなってきた。まあ、何れにしても可能な範囲で対応して、
  | もし難しければその時には自前で実装するという事にすれば良い。
  | 結局速度が問題になるのでできるだけ単純で高速な方法を使って、
  | それが難しいときにだけ自前で実装した方法を使う事にすれば良い。
  |
  | もし半透明に対応していなかったとしても色々やりようはあるのである。
  | BitBlt っぽい AlphaBend という関数も在る。
  | この関数でどれだけの事ができるのかという事も含めて、
  | 色々試してみないと分からない。

  とにかく前景色だけでも描く様に変更する。
  前景に関しては先に枠線だとかを描いて、
  その後で文字を書き、それから打ち消し線を描く、という順番が良い。
  しかし、そうだとしても先に文字を描く部分を完成させるのである。

  因みにフォントを大量に生成したくはないので、
  下線だとか打ち消し線だとかは自前で描画する事にする。

  * ok: いい加減に grapheme cluster が ExtTextOut で
    どの様に表示されるか調べなければならない。
    surrogate pair についても同様である。

    | うーん。新しいプログラムを作って其処で試す事にするか。。
    | 試してみた所、TextOut は全然駄目である。
    | 次に ExtTextOut は文字幅を自分で指定できる分だけ
    | 表示位置の乱れはなくなっている。
    |
    | 色々試した結果を整理すると、先ず初めに
    | ExtTextOut に指定する進み幅は加算された結果が使われる。
    | つまり、Grapheme cluster の中で幅をどう配分しても、
    | 最終的に表示される結果には何の影響もない。
    | そういう意味で現在の実装のまま
    | 最初の文字に幅を持たせて計算しても問題はない。
    |
    | 何故か知らないが ExtTextOut の結果によると、
    | 結合文字の類は次の文字に対する相対座標で表示されている。
    | ちゃんと進み幅の計算では前の文字とセットで考えられているのに不思議である。
    | うーん。これは Windows がおかしいんだ。もしくはフォントがおかしい。
    | 気にしない事にする。真面目に考え始めたら自分でフォントのレンダリングコードを書く羽目になる。
    |
    | 或いは、freetype を使うか。
    | % 然し freetype は GPLv2 である。LGPL ですらない。
    | と思ったら FreeType License という物とのデュアルライセンスである。
    | そして FreeType License の方は比較的自由な感じである。
    | なので気になったら FreeType を調べてみるのが良い。
    | ただ Grapheme cluster だとかに対応しているのかなどは不明瞭である。

    [まとめ]

    - TextOut ではなく ExtTextOut を使うべき。
    - ExtTextOut で cluster に与える進み幅は総和だけが意味を持つ。
    - ExtTextOut の表示は微妙。乗り換えるなら freetype である。

  * うーん。どうも調べると COLORREF は透明には対応していない様子。
    結局自分で合成する事になるのだろうか…。
    或いは Brush を頑張れば何とかなったりするのだろうか。
    Brush を探すと memory bitmap を使って brush を定義できるそうだ。
    しかしそれだと完全な透明か完全な空白しか定義できない。。

    うーん。以下のページを見ると矢張り諦めた方が良い感じがする。
    或いは GDI+ に移るか。GDI+ は遅いという話だが…。
    https://stackoverflow.com/questions/9443070/gdi-object-hbrush-translucent

    調べると転送が遅いのだという。実は自分で作った HBITMAP の上で
    HDC を生成してそれに対して Gdiplus::Graphics g(hdc) を生成すれば速いという話も。。
    http://miyano.s53.xrea.com/cgi-bin/sb/log/eid77.html

    うーん。その他の処理はどうにでもなるが文字描画のアルファに関しては
    自前で描くのは困難である。やはり Gdiplus::Graphics を起動するしかないのだろうか。。
    まあ、これに関しては後々考える事にする。

2019-05-01

* ansi: DECSCUSR で 0 を指定した時のカーソル形状は、 [#D0105]
  1 と同じ "ブロック・点滅" であるが、これは別に VT に従う必要はないのではないか。
  つまり 0 を指定した時にはユーザの指定したカーソルの形状を用いるというので良い気がする。
  なので、0 の値を取ることも許容する。ブロックは 100 という事にした。
  点滅するかどうかもで指定するのかは…取り敢えず点滅という事にする。

  或いはユーザー設定に従う? resource_cursorBlink が XOR
  になっているので実はこれを変更する事によって既定値を変更できるのではないか。
  と思ったが何か微妙な気がする。振る舞いが反転するというのは分かりやすいのだろうか…。
  まあ、分かりにくいかもしれないがこれで設定はできるので良いという事にする。

  取り敢えず適当に実装した。twin の側でも実装した。

* twin: カーソルの位置が分からないのはいい加減に分かりづらい [#D0104]

  カーソルを表示する。表示するのである。
  さて反転するのにはどうしたら良いのだったか。
  反転する為の関数が存在した様な気がするが。
  検索しても分からないので Poderosa の自分の編集した部分を探す。
  なるほど。PatBlt という関数が存在する様だ。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win103.html

  取り敢えず自分の好きな形のカーソルを表示できる様にする。
  うーん。本当は点滅が欲しい所であるが、
  点滅をする為にはタイマーなどで制御をしなければならない。
  それと現在の実装では background buffer に直接 cursor を描いているが、
  これは double buffering の部分更新と相性が悪い。
  まあ BitBlt は高速なので余り気にしなくても良いのかもしれないが。

  後々考える事にする。

* twin: 所で FillRect という関数があるという事が判明した [#D0103]
  http://wisdom.sakura.ne.jp/system/winapi/win32/win103.html

  Rectangle なる関数で縁の処理が難しいなどと言っていたが
  初めからこの FillRect という関数を用いていれば良かったのではないか。
  試しにこの FillRect で縁が変にならない事を確認する事にする。
  →ちゃんと動作している。初めからその様にすれば良かったのだ。

  更に、RECT を走査する関数として SetRect, SetRectEmpty, OffsetRect などなど、
  色々な関数があるという事が分かった。

* twin: サイズ変更に対応したら以下のエラーが出た [#D0102]

  mwg_assertion_failure! b.cur.x() < b.m_width || (b.cur.x() == b.m_width && b.cur.xenl())
    @ ansi/term.cpp:2006:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)

  うーん。何処かで何か間違えている…。少なくともサイズを変更した時には b.cur.x() < b.m_width
  になる様に調整をしている筈である。という事は別の箇所でカーソルを移動した時に何か間違えているという事になる。
  カーソル移動は今は全て関数になっているのでその時にどういうスタック呼び出しになっているのかを
  出力すれば良い。しかし、面倒である。簡単なそういう枠組みを揃えるのも良いのかもしれないが…。
  例えば mwg/except.h で好きなフレームでそういうのを設定できる様にするなど…。

  * fixed: 各シーケンスの直後に検査する様にして回してみたら意外とすぐに引っかかった。CSI S である。
    調べると原因が分かった。to_presentation_position してから to_data_position してそれを set_x している。
    然し、始めに右端に居た時には単に xenl を消してしまう事になる。
    他の箇所で実行しているのと同じ様に set_x_keeping_xenl を呼び出す事にした。
    と思ったがこの set_x_keeping_xenl というのは何だろう。
    これは実は右端から sll に移動した時でも同様に xenl が入りっぱなしになるのではないか。
    そしてそれは望む動作ではないのではないかという気がする。
    set_x_keeping_xenl を呼び出している箇所を全て確認してみる事にする。
    うーん。全て update_x に変えてしまって良い気がしてきた。直した。

  * fixed: 回している内に次のエラーが発生した。CSI G である。思い切り範囲を超えている。
    mwg_assertion_failure! b.cur.is_sane(b.m_width), "cur: {x=98, xenl=0, width=80} after CSI G"
      @ ansi/term.cpp:2036:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)
    調べると do_cha である。これは丁度 set_x を観察していた時に hpa で修正したのと同じ問題だった。
    これは直ぐに直した。

  * ???: 次のは C0/C1 で発生している…。何か物凄い値になっている。
    mwg_assertion_failure! board().cur.is_sane(board().m_width), "cur: {x=19, xenl=-2147292284, width=6867512} after C0/C1 4096"
      @ ansi/term.cpp:2069:void contra::ansi::term_t::process_control_character(char32_t)
    というか本当に実際の値なのだろうか。board() が変な値を返してはいまいか。
    というか 4096 というのは何だろう…。コードを見たら mwg_assert に渡す引数を間違えている。
    実際のところ受信した文字が x として表示されている。つまり 19 = 0x13 = DC3 である。変だ。
    ascii_dc3 に対しては何も実行していない筈なのである。

  * done: 更に vpa や hvp や cup 等についても DECOM でない時の振る舞いを修正した。

  * 次に出たのは以下の物である。なるほど。確かに記録した位置を復元する時に問題が発生するのは道理である。修正した。
    mwg_assertion_failure! b.cur.is_sane(b.m_width), "cur: {x=18, xenl=0, width=16} after CSI u"
      @ ansi/term.cpp:2046:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)

  今の所は新しいクラッシュは発生していない。

* twin: サイズを大きくできるようにしたら [#D0101]
  今度は描画に矢鱈と時間がかかる様になってしまった。
  空白やら何やらも描画しているのが悪いのである。
  空白については描画しない様にする事にした。
  (但し、下線などについては描画する必要があるし、
  反転部分についても特別に描画する必要がある事には注意する)。

  空白や null の描画に関してはスキップする様に修正してみた。
  改善した様な気がする。実際に時間を計測してみるとやはり速くなっている。
  一方で、BitBlt は時間はかからないのだろうか…と思ったが、
  BitBlt は全画面を対象にしているのにも関わらず高速である。
  殆ど 0ms (resolution は 15ms しかないのでなんとも言えないが 20 行から
  30 行に1回 15ms と表示されるぐらいなので少なくとも 1ms より短い) である。
  一方で、全画面に対して文字を描画していると 300ms といった時間がかかっている。

  更新のある部分だけにしたり、移動した行は BitBlt したりすればもっと改善するだろう。
  一方で、結合文字などではみ出た物がある場合にはどうしたら良いのかは微妙である。
  そういった物は実は行毎に別の bmp に保存しておいて、それから BitBlt すると良いのだろうか…。
  文字を回転する場合なども同様である…。後、現在は背景色の上に文字を書いているが、
  背景色を指定せずに元からあった内容の上に合成する様にするとまた時間がかかるのではないだろうか。

* twin: サイズ変更に対応する [#D0100]

  サイズ変更にも対応した。動いている気がする。
  サイズ変更に関しては board の大きさの変更と
  仮想端末への通知の二種類が必要になる。

  また board の変更において保存していた altscreen とのずれがどうなるか気になる。
  と思って確認してみたらちゃんと考慮に入れていた。大丈夫。
  また lmargin, rmargin は一緒に更新しなくても大丈夫なのだろうか。
  と思って確認してみたがこれも大丈夫そうである。

  取り敢えず動いている様な気がするので大丈夫という事にする。
  所で、adjust window size と adjust terminal size のどちらが先に受信されるのだろうか。。
  確認する必要がある気がする。→一応確認してみた所先に window size が調整される様である。

* twin: サイズの調整を行う [#D0099]

  先ずは一番最初に起動時の高さを調整しなければならない。
  以下にキャプション部分の既定の高さを取得する方法が書かれている。
  https://stackoverflow.com/questions/28524463/how-to-get-the-default-caption-bar-height-of-a-window-in-windows
  取り敢えず SM_CYBORDER SM_CXBORDER が枠の幅で (3D の時はちゃんとそれに応じて CYEDGE 等と同じ値になる)、
  SM_CYCAPTION と SM_CYFRAME と SM_CXPADDEDBORDER を使っているそうだ。
  しかし 他に SM_CYSIZEFRAME とか SM_CXSIZEFRAME がある。
  うーん。それぞれ何なのか分からない。取り敢えず出力して試してみるのが良さそうである。

  →そもそも現在の _WINVER では SM_CXPADDEDBORDER は対応されていなかった。

  取り敢えず
    windowWidth = clientWidth + 2 * SM_CXBORDER
    windowHeight = clientHeight + 2 * SM_CYBORDER + SM_CYCAPTION
  で計算して初期化してみたところ、
    clientSize=(560, 390) expected
    SM_CXBORDER=1
    SM_CXEDGE=2
    SM_CXSIZEFRAME=8
    SM_CXFIXEDFRAME=3
    clientSize=(546, 376)
  となった。CXBORDER と CXEDGE は異なる値になっている…。
  うーん。取り敢えず…上記リンクに従って SM_CXSIZEFRAME (SM_CXFRAME に等価) を使う事にする。

  | // チェックに使ったコード
  | mwg_printd("clientSize=(%d, %d) expected", clientWidth, clientHeight);
  | mwg_printd("SM_CXBORDER=%d", GetSystemMetrics(SM_CXBORDER));
  | mwg_printd("SM_CXEDGE=%d", GetSystemMetrics(SM_CXEDGE));
  | mwg_printd("SM_CXSIZEFRAME=%d", GetSystemMetrics(SM_CXSIZEFRAME));
  | mwg_printd("SM_CXFIXEDFRAME=%d", GetSystemMetrics(SM_CXFIXEDFRAME));
  | //mwg_printd("SM_CXPADDEDBORDER=%d", GetSystemMetrics(SM_CXPADDEDBORDER));

  と思って調べていたら実は AdjustWindowRectEx という関数が存在して、
  http://kitano.plala.jp/~kitano/winfaq/11/11-1.htm
  それを使えば client size が正しくなる様に補正する事ができる様だ。

* twin: 今は物凄く適当な描画しか行っていないのでちらつきが激しい [#D0098]

  ちゃんと描画するにはダブルバッファリングにするというのと、
  更新を変更のあった行だけに絞るという事。
  実のところダブルバッファリングにするだけで十分なのかもしれない。
  全体を描画するのにそんなに時間はかかっていない様な気がするから。
  また、端末の画面を変更しているアニメーションを表示する訳でもない。

  調べると自分で Compatible bitmap を使って明示的にダブルバッファリングしている例。
  https://qiita.com/kero_dgu/items/981706aaa7fb64daab11

  然し、Windows に元から備わっているダブルバッファリングがちゃんと動くならば、
  それを使うのが良い。と言っても前に試した時には色々調べた挙げ句結局、
  上記の方法と同様に compatible bitmap を作った様な気もする。
  取り敢えず試すだけ試してみる事にする。

  http://home.a00.itscom.net/hatada/windows/tips/doublebuffering01.html
  うーん。ここの説明を読むとやはり適当に Windows の機能を利用しただけでは
  ちらつきは完全には防止できない様に書かれている…。
  実際に WS_EX_COMPOSITED を試してみた。やはりちらつきを抑える事はできない。
  前よりはましになったかもしれない、というぐらいの事である。やめる。

  InvalidateRect(hWnd, NULL, FALSE) とすると WM_PAINT が全体に対して送られてくる。
  これを使っても再描画する事ができるのでそれを使ってみた。
  WS_EX_COMPOSITED で前よりはちらつきが少なくなった気がするが、
  それでもやはりちらつきが微妙に起こっているので double buffering にしてみる事にする。
  | @@ -382,9 +384,10 @@ namespace twin {
  |            if (msec > 20) break;
  |          }
  |          if (processed) {
  | -          HDC hdc = GetDC(hWnd);
  | -          render_window(hdc);
  | -          ReleaseDC(hWnd, hdc);
  | +          // HDC hdc = GetDC(hWnd);
  | +          // render_window(hdc);
  | +          // ReleaseDC(hWnd, hdc);
  | +          InvalidateRect(hWnd, NULL, FALSE);
  |          }
  |
  |          while (::PeekMessage(&msg, hWnd, 0, 0, PM_NOREMOVE)) {

  結局やはり double buffering を自前で実装してみる事にした。
  それでもちらつく様だったら仕方がない。取り敢えず試すだけ試してみる。
  http://home.a00.itscom.net/hatada/windows/tips/doublebuffering01.html
  を参考にして hdc を生成してみるが、カレントスクリーンに互換、というので大丈夫なのか?
  というか以前 Poderosa に同様の実装をした気がする。確かめてみる。
  Poderosa で自分が書いた時にはカレントスクリーンに互換、としたのではなくて、
  受け取った hdc に互換の hdc を作っていた。取り敢えず自分の実装の方に従う事にする。
  そちらの方がより安全であろう。

  うーん。変だ。実装してみた物は良いがそれでもちらつきが発生する何故だろうか。
  誰かが勝手に内容をクリアしている? → WS_EX_COMPOSITION を外したらできた。
  つまり、自前で double buffering している時には WS_EX_COMPOSITION は外す必要があった。
  これで完全にちらつきがなくなった気がする。

2019-04-30

* [OK] cat /dev/random を実行すると何故か行内容が clear されなくなる問題 [#D0097]
  不思議である。普通に実行していれば clear されなくなるという事はないのに、
  /dev/random を実行すると一瞬だけ実行したのであっても、
  何故か行内容が消えなくなってしまうのである。

  不思議な事である。clear しているのに clear されないという事が果たしてあるのだろうか。
  或いはもしかして SPA が混ざって来ている? うーん。その可能性もある。
  試しに printf '\e[6l' で ERM を外してみたら直った。つまりそういうことだった。
  更に printf '\e[6h' としてその上で '\eW' (EPA) として見たらそれでも直った。

  また色々試すと今度は行の位置などがおかしくなった。
  これについては以前も似たような事があった。VEM だろう。
  '\e[7l' として見たら直った。つまり、ちゃんと色々のモードが動いているという事である。

* 色々と構造を整理したい [#D0096]

  取り敢えず impl2 及び impl3 は共通部分を括りだして
  ttty という枠組みに纏めたいという気がする。
  後、tty_observer というのは何だか分かりにくい。

  * done: tty_observer も ttty の枠組みに統合してしまうのが良いという気がする。
    一方で ttty の rendering を実行する部分と session を管理する部分は独立でも良いのかもしれない。
    その場合には print_screen は rendering を実行する部分に任せるのが良いのではないか。
    少なくとも SGR の apply をする仕組みは括りだして置く必要がある様な気がする。

    contra::dict::tty_writer と contra::ttty::buffer に分ける事にした。

  * done: dict が ansi を参照しているが本来は逆であるべきである。
    attribute_t 等については dict に移動しても良いのではないか。
    →早速その様に書き換えた。

  * done: うーん。impl.hpp にある fd に関する操作は実は device として
    一つのクラスにしてしまうのが良いのではないのか。
    →まとめた。twin.cpp はこれを使って動く様になった。

    impl2.cpp と impl3.cpp についても更新する。
    というか impl3.cpp に至っては早速 terminal_session を使っても良いのではないか?
    とも思ったが multicast_device になっているのを忘れていた…。
    取り敢えず一番初めの段階として pty_session を使う様にする。

  * 取り敢えず impl2 及び impl3 の共通部分は括りだして
    ttty/screen.hpp とした。しかし括り方が変な気がする。
    現状では do_loop に渡す引数で動作の切り替えを行っているが、
    これは本来別の方法で実装するべきなのではないか。

    というか、そもそもクラスとしてくっつけたのは良かったのか。
    impl2 と impl3 は完全に異なる動作の仕方をする物であるから、
    実は別々のクラスにした方が良かったのではないかと思わないでもない。

    まあ、その辺りの整理に関しては追々考える事にする。

* twin: C-RET を押したらハングした [#D0095]
  何かあるのだろうか…。再現性が在る事は確認した。
  コードを確認してみると、確かにこれだと無限ループになる。修正した。
  序に、未だ対応していないキーの送信にも対応した。

* twin: 実際に端末に接続して動かしてみる事にする [#D0094]
  また何だかつまらない事で止まっている気がする。
  次にするべき事はもう早速端末に接続する事なのではないだろうか。

  さて。termios が必要である。今までは既存の termios をそのまま使っていたが、
  今度はゼロから作らなければならない。どの様にするのが正しいのだろうか。
  以下のページに依ると既定値は /usr/include/termios.h にあると書かれている。
  http://tldp.org/HOWTO/Serial-Programming-HOWTO/x115.html
  /usr/include/sys/termios.h の中に定義が書かれているが何が既定値かは分からない。
  以下の様なマクロが定義されてはいたが、これが他の環境でも使えるのかは分からない。

  #define TTYDEF_IFLAG    (BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
  #define TTYDEF_OFLAG    (OPOST | ONLCR)
  #define TTYDEF_LFLAG    (ICANON | ISIG | IEXTEN | ECHO | ECHOE | ECHOKE | ECHOCTL)
  #define TTYDEF_CFLAG    (CREAD | CS8 | HUPCL)
  #define TTYDEF_SPEED    (B9600)

  https://stackoverflow.com/questions/16782715/termios-default-for-standard-terminal-session
  を参照してみると、openpty に対して NULL を指定すれば既定の sane な termios になるそうだ。
  取り敢えず何も設定せずに開いてみる事にする。

  後、ループを合成しなければならない…。GetMessage を非同期に実行する方法はどうするのか。
  複数スレッドで実行する方法、SetTimer/KillTimer を瞬間的に実行して無理やり GetMessage を止める方法、
  MsgWaitForMultipleObjects を使ってチェックする方法が載っている。
  https://stackoverflow.com/questions/10866311/getmessage-with-a-timeout
  以下のページには PeekMessage に空の引数を指定する事でメッセージがあるかどうかチェックしている。これが良さそう。
  http://www.sm.rim.or.jp/~shishido/mainloop.html
  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-peekmessagea

  うーん。PeekMessage 及び GetMessage に hWnd を指定して呼び出してみた所、
  どうやら WM_DESTROY または WM_QUIT が来ない。WM_QUIT は hWnd なしで来る様だ。
  もしくは WM_DESTROY を受信した時点で、状態を変更しなければならないという事か。
  調べたら WM_DESTROY は受け取れるが WM_QUIT は受け取れない。
  従って GetMessage が失敗する事が永遠にない、という状態だった。
  WM_DESTROY を受け取った時点で hWnd = NULL として、
  hWnd が有効の間だけループを回すように修正した。直った。

  うーん。取り敢えず起動はしている。Bash も動いている気がする。
  しかし何も表示されない…。次に何も受信されない。
  先ず表示されなかった理由は何かというと、BeginPaint 等をして render していると、
  invalidate の領域だけにしか描画されないという事。
  GetDC で得た物を使えば全体が描画される。

  次に、何だか反応がないように思われたのは文字が送信されていない?
  更に出力バッファをクリアし忘れていたのでどんどん大量に入力される様になっていた。

* twin: IME に関しては難題であると思ったが、実は猫でも分かるに載っていた [#D0093]
  http://www.kumei.ne.jp/c_lang/sdk3/sdk_278.htm

  結局何だかよく分からないので Poderosa の実装を観察する。
  どうやら WM_IME_STARTCOMPOSITION で ImmSetCompositionWindow を呼び出すだけで良い雰囲気である。
  実際にやってみると思うように動かない。変な位置に表示される。
  と思ったら Poderosa では基底の WndProc を呼び出していた。
  DefWindowProc を呼び出せば良いのだった。動く様になった。
  実はこれで完了なのではないだろうか。

  所で背景色・前景色は指定できるのだろうか。。
  もしかするとコントロールの背景色・前景色を使っているのかもしれないと思って変更してみた。
  https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q10139369610
  ::SetClassLong( hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush( RGB(0,0,0) ) );
  然し、やはりIMEの候補表示に使われる前景色・背景色とは関係がない様だった。

  或いは、変換中の文字列を自前で描画するという様にするしかないのだろうか。
  しかし、それはさすがに面倒である。というか本当に可能なのかもよく分からない。
  mintty は対応していないようであるし Poderosa も対応していない気がする。
  従って、これに関してはわざわざ自前で描画する必要もない。このままで良い。

  実は、ImmSetCompositionWindow を指定するだけで動く様になってしまった気がする。簡単だった。

2019-04-29

* twin: キー入力を受信する方法について調べる [#D0092]
  結局の所これは Poderosa を参考にするのが良い。
  Poderosa を自分で弄った時に色々と苦労した所である。
  同様に処理を行えば良いのではないかという気がする。

  取り敢えず VS で Poderosa を開く事にする。というか重い。
  取り敢えず問題の物が書かれているファイルは分かった。
  TerminalControl.cs で色々処理している。

  mwgSendChar, mwgSendKey, mwgSendAltKey, ProcessCmdKey 辺りから。
  更に、遡ると、ProcessDialogKey, OnMouseWheel である。
  うーん。何か変な物を override していた様な気もするが…。
  他に OnKeyPress もある。OnKeyPress のコメントに IME で確定すると
  「WM_IME_CHAR、WM_ENDCOMPOSITION、WM_CHARの順でメッセージが送られてくる。」
  と書かれている。うーん。IME を有効にするにはどうすれば良いのだったか。
  他に OnMouseDown, OnMouseUp, OnResize 等。

  OnLostFocus で ClearIMEComposition という関数を呼び出している。
  うーん。IME 関係の処理は WndProc 内部で実行している。
  WM_IME_COMPOSITION, WM_IME_START_COMPOSITION,
  WM_IME_ENDCOMPOSITION を見ている。

  取り敢えずメッセージを出力する事にする。

  うーん。WM_KEYDOWN を調べると。修飾キーが取れない様だ??
  https://stackoverflow.com/questions/33051983/how-to-get-modifier-key-eventaltctrlshift
  結局毎回 GetKeyState で自分で状態を確認するしかない様子である。

  仮想キーコードから文字に翻訳するには MapVirtualKey(wParam, MAPVK_VK_TO_CHAR) という関数を用いるそうだ。
  或いは、一旦 VSC にしてからその後で ToAscii で文字に変換する。
  https://stackoverflow.com/questions/318777/c-sharp-how-to-translate-virtual-keycode-to-char
  https://msdn.microsoft.com/ja-jp/windows/ms646306(v=vs.80)
  https://stackoverflow.com/questions/3864153/on-windows-how-do-we-convert-a-virtual-key-code-to-the-shifted-character

  * うーん。dead-keys はどの様に取り扱うべきなのか。
    ToAscii ではなくて ToUnicode に変換した方が良さそう。
    https://stackoverflow.com/questions/42667205/maximum-number-of-characters-output-from-win32-tounicode-toascii
    然し、一度に複数の文字に decode される事もあるそうで、どうしたら良いのか分からない。
    というか、そもそも dead-char を入力する時に dead-char が完成するまでのキーボード入力はどうなっているのかだとか色々謎。
    もし、dead-char が完成するまでのキーイベントも全て拾っているのだとしたら、
    dead-char を解釈してしまってはいけない気がする。それに kbstate に変な物を指定しているが、
    この時にちゃんと dead-char を decode できるのかも謎である。という訳で dead-char に関しては今の所対応しない事にする。
    単に無視する事にする。

  * 様々のキーの組み合わせに対してどの様に動作するべきかについて整理して置く必要がある。

    a 先ずアルファベットのキーに関しては:
      (1) 修飾キーがある場合には小文字に変換して修飾を付加する。
      (2) 修飾キーがない場合には capslock の状態を考慮に入れて変換する。
    b それ以外の文字キー・記号キーに関しては
      (1) Shift を考慮に入れて文字に変換し、Shift 以外の修飾を付加する。
    c カーソルキー・関数キーの類はそのまま修飾を付加して処理する。

  IME に関しては別項目で考えることにする。

* twin: 取り敢えず GUI を作り始めてみるという事 [#D0091]

  段々出来てきて些末な事をやり始めている。
  次にしなければならないのは何かというと。
  GUI を作ることではないだろうか。
  その後に attach detach の機能を実装するのである。

  GUI は何で作るのが良いだろうか。
  取り敢えずよく知っている Windows で作るのが良い気がする。
  然し、よく考えてみたら Windows でスクラッチで GUI を書いたことは無いような気もする。

  まあ http://www.kumei.ne.jp/c_lang/index_sdk.html の辺りを参考にすれば良いきもする。

  * done: 然し、Windows で作るのだとすれば取り敢えず Cygwin 上でコンパイルできるようにしなければならない。
    と思ったらコンパイルが通らない。libmwg を最新に更新してコンパイルし直して、
    それから contra の Makefile に追記する。-std=c++17 でなくて -std=gnu++17 にしないと fileno がなかった。

    更に posix_openpt や grantpt の類が見つからないというエラーメッセージが出る。
    然し、それは変である。cygterm でも使っている筈だし、それに検索すると Cygwin 1.7 で既に
    posix_openpt が実装されたと書かれている。ヘッダを検索すると stdlib.h と fcntl.h である。
    然し、両者を include しても見つからない。
    検索すると /usr/include/cygwin/stdlib.h に定義が見つかった。
    そして /usr/include/stdlib.h から cygwin/stdlib.h は include している筈だ。変だ。
    明示的に include <cygwin/stdlib.h> しても駄目だ。中を除くと __XSI_VISIBLE >= 600 でなければ見えないそうだ。
    % そもそも __XSI_VISIBLE が定義されていない様だ。grantpt は __XSI_VISIBLE が定義されているだけで存在する筈。
    うーん。勝手に定義してしまって良い物なのだろうか…。

    cygterm を確認してみると…何と全く posix_openpt だとか openpt の類を使わずに実装されている…。
    これは参考にならない。もしくは今後これを参考に書き直したりする必要があるかもしれない。

    うーん。調べてみると <sys/features.h> に __XSI_VISIBLE 0 が定義されている…。
    更にその中を除くとコメントに _XOPEN_SOURCE >= 600 と書かれている。
    うーん。つまり #define _XOPEN_SOURCE 600 とか 700 とかしておけば良いという事だろうか。
    うーん。取り敢えず通る様になった。

  * done: 取り敢えず簡単なサンプルをコンパイルする。
    と思ったら文字化けする。UNICODE にする。
    と思ったらリンクできない。調べてみると wWinMain には対応していない疑惑。
    少なくとも MinGW は対応していない。MinGW が fork してから
    cygwin が更新指定しなければ今も使えないという事になる。
    https://cat-in-136.github.io/2012/04/unicodemingw32twinmainwwinmain.html

  * [保留] ダブルクリックで開くとコンソールが表示されてしまう。
    wWinMain が使えない弊害だろうか。消す方法はあるのだろうか。
    以下のページに依ると FreeConsole(); を呼び出せとか、ShowWindow(GetConsoleWindow(), SW_HIDE); を呼び出せとか書かれている。
    https://forum.openframeworks.cc/t/switching-from-console-application-to-gui-application-loses-custom-icon/15279
    https://social.msdn.microsoft.com/Forums/vstudio/en-US/16b5aff3-2aff-4434-a3d7-bc5048f66572/how-to-make-a-console-apps-window-invisible?forum=csharpgeneral
    FreeConsole() は試してみたが何も起きない。ShowMessage に関しては一瞬だけ画面が表示される格好悪い。
    本来は表示されない方法がある筈なのである。

    或いは UNICODE でない方法で実装するべきなのだろうか。
    と思って WinMain から起動する様にしてみた所関係なかった。
    やはりコンソールが表示されてしまうのであった。UNICODE に戻す事にした。

    取り敢えずこれは後で処理する事にする。

* vttest(2) の origin mode test が駄目 [#D0090]
  一番下に表示されると言っている行が一番上に表示されている。
  動作を調べる事にする。

  \e[23;24r\r\n の直後に "この行は一番下" と出力し始めている。
  これが意味する所は、 DECSTBM で原点に移動するという事である。

2019-04-28

* bug: vttest で抜けてから ls すると背景色が適用されていない領域ができる [#D0089]
  どうも前回と内容が同じ時に起こるスキップの様である。
  然し、IL や DL で消滅した行に関しては old_content は clear() されている筈である。
  trace_line_scroll の中で不整合が起こっているという事だろうか。

  動作をもう少し詳しく見てみることにしてみた。
  問題が起こっている時には DL で 23 行消して IL で 0 行挿入している。
  (そもそも削除しっぱなしで良いのか、同じ行数だけ挿入する必要はないのか
  という話もあるがまあ後で考える事にする。)

  一方で、screen_buffer の方でどれだけ clear しているのか、
  というのを観察してみると 1 行しかクリアしていない。
  うーん。これは実際に移動した1行についてだけクリアしているという事。
  その他の行についてもクリアしないといけないのである。
  修正した。ちゃんと動く様になった。

  * done: 画面が一番下にない限りは削除するだけでなくて
    同じ行数だけ挿入しなければならないのではないか?
    これもその様に修正した。

    取り敢えず一番下にいるかどうかを is_terminal_bottom という変数を参照して決める事にした。
    現在は is_terminal_bottom は定数だが、今後実際に使う場合にはその時の状況に応じて
    設定する変数とする。

* 変だ xenl の時に \b をすると2文字戻ると思っていたが、 [#D0088]
  xterm の上で試してみると1文字しか戻っていない様に見える。
  何かそういう設定が存在するという事なのだろうか。

  RLogin で試すとちゃんと2文字戻る。
  xterm は何か特別な条件で戻ったり戻らなかったりするのだろう。
  よく分からないのでこれはそのままで良いという事にする。

  * ok: xterm の行末での全角文字を潰す時の振る舞いについて:
    % 後、xterm は行末で あ\e7\e8\ba 等とすると
    % "あ" の左半分だけを表示できる。
    % つまり、全角文字の途中で半角文字を踏み潰しても OK になる。
    % 例えば "え\ba" 等としても全角文字が消去される。
    % 行末以外で "え\e7\e8\ba" としても全角文字は消去される。
    % 行末で "あ\ba" とすると全角文字は消去されない。
    xterm は行末で "あ\ba" とすると全角文字の左半分だけが残る。
    これはバグだろう。この振る舞いに関しては再現しなくて良い。

* うーん。実行していて気づいたのだが、実は DECSLRM が設定されている時に [#D0087]
  右境界の右側にいる時に文字を出力すると改行せずにそのまま出力される。
  更に、同じ位置に居ても実は xenl として其処に留まっているのかどうかが
  ちゃんと記録されている様である…。つまり…。
  カーソル移動を大幅に修正しなければならない。

  更にカーソル移動によって実際のところカーソルが動かなかった場合、
  というのも存在すると思われるがその場合には xenl 状態をクリアするべきなのか、
  クリアしなくても良いのか…。

  これは大きな変更になりそうなので独立した項目で処理する事にする。

  [実装]

  * done: 先ず初めに cur に xenl を記録できる様にする。
    振る舞いを見るに実は xenl が設定されている時には、
    本当は最後の文字ににカーソルがあるけれども、
    色々の制御機能において行末にある振りをしているという事の気がする。

    然し、insert_graph だとかの実装の都合を考えると、
    やはり行末の位置にカーソルを置いて置いた方が便利な気がする。
    一方で行移動などが起こった時に行の最後の位置に
    移動するという振る舞いをどの様に再現するか。

    振る舞いに関して SU,SD 等は xenl を保持する。
    CUU,CUD,VPB,VPR や VPA 等は xenl を保持しない。
    DECSC, DECRC は xenl を保持する。
    VT,FF の類は xenl を保持しない。

    取り敢えず実装した。今の所は問題なく動いている気がする。

  * do_sm_decawm は範囲外にいる時に範囲内に強制して良いのか?
    xterm の振る舞いを調べてみると、xenl が
    設定されている時に 1 文字戻しているだけの様に見える。
    取り敢えず b.cur.adjust_xenl() だけ呼び出す事にした。

  * done: insert_graph の調整
    うーん。取り敢えず範囲外にいたら範囲を広げて考える様に修正した。
    また SIMD の時には xenl は考えない事にした。
    直ぐに次の行に移動する事にする。

  * done: do_bs の調整

    うーん。xterm の振る舞いがよく分からない。
    vttest を実行している時には BS の前に xenl で後退している様に見える。
    然し、手動で行末に行って其処で \b を出力しても 1 文字しか戻らない。
    一方で RLogin は手動で行末に行って其処で \b を出力すると2文字戻る。
    また DECSLRM の右境界に行っても \b でちゃんと2文字戻る。
    よくわからないので、取り敢えずは RLogin の振る舞いを真似る事にする。
    xterm については何か発動条件の様な物が存在するのだろう。

    SIMD の時の振る舞いがどうなるべきかはよく分からないが、
    取り敢えずそれっぽい振る舞いで実装する事にした。

* 2019-04-23 DECSLRM の時の動作テスト: SU,SD,LF,IL,DL のそれぞれについて [#D0086]

  どうやってテストを作るのが良いのだろうか。
  実はシェルスクリプトでも作った方が良いのかもしれない。

  DECSLRM を実行したらコアダンプしてしまった。
  エラーメッセージは出力されていない。
  compose_segments の line_segment_transfer の時のバグだった。修正した。
  取り敢えず do_vertical_scroll は動いている様だ。
  SU,SD,SL,SR は do_vertical_scroll を使って実装されている。
  IL,DL も do_vertical_scroll で実装されている。
  LF も do_generic_ff -> do_vertical_scroll という具合に実装されている。
  その様に考えれば現状で do_vertical_scroll が動いていたのでまあ大丈夫だろう。

  但し、m_prop_enabled = true の時については誰もテストしていない。。
  取り敢えず m_prop_enabled = true の場合でも動いてはいるようである。

* vttest が decmode 3 4 5 8 40 45 を要求している [#D0085]
  2019-04-28 残っているのは ?45 だけである。
  ?45 は何だったかというと、"行頭BSによる上行右端移動" と書かれている。
  xtBSBackLine という名前を与えて実装する事にした。

* [自然解消] ansi: clear screen で DECSTBM の原点に移動する? [#D0084]
  そもそも clear screen はどの様なシーケンスで実施されているのだったか。
  $ TERM=xterm infocmp | grep 2J を見ると \e[H\e[2J の様である。
  つまり原点に移動している。しかし、原点と言っても \e[H である。
  つまり DECOM の影響を受けて移動先の位置は変わるのだと思われる。

  clear screen という機能はそもそもない。terminfo のシーケンスで自動的に原点に移動する。
  DECOM にも対応しているので、恐らく他の端末で実行した時と同じ振る舞いになっている筈。

* DECALN の実装 [#D0083]
  これで恐らく vttest 1 はちゃんと通る様になった筈。

* DECLRMM の説明を読むと [#D0082]
  DECLRMM が有効の時にしか DECSLRM は margin を設定できないとなっている。
  つまりいつでも DECSLRM が設定できるが DECLRMM がないと効果が発揮されない、
  という事ではなくて DECLRMM が有効でないと margin を設定できないだけで、
  既存の margin は有効であるという解釈なのだろうか。

  xterm で試す。
  - % xterm で DECLRMM 及び DECSLRM を設定して試そうとしているが発動しない。
    % もしかして、未だ実装されていないとかそういうことだったりするのだろうか。
    % 或いは、無効になっているとか。。
    → -ti 340 で起動すると無効になる様だ…。
  - 改めて xterm-344 で起動してみると…。
    ?69l した瞬間に margin の設定をクリアする様である。
    うーん。面倒なので、xterm の振る舞いには追随しない事にする。

  RLogin で試してみる。
  - % やはり ?69 は現在設定されている margin が有効か
    % 無効かだけを制御していて、DECSLRM が margin を設定できるかどうかとは
    % 関係ない動作をしている様に見える。
  - ?69 を設定して margin を設定して、
    ?69 を解除して設定しても margin は有効であった。
    ここから分かる事は ?69 を解除しても margin がその場でクリアされる訳ではないという事。
  - ?69 を設定して margin 10;25 を設定し、
    ?69 を解除して margin 10;50 を設定し、
    ?69 を設定すると、どうやら 10;25 になっている様子だ。
    つまり、?69 が設定されている時にのみ DECSLRM は margin の設定を変更する。

  これについては端末によって振る舞いが異なるので
  取り敢えず contra では RLogin の振る舞いにする。

* vttest: test 2 を実行してから test 1 を実行すると着色が反転する [#D0081]
  調べてみると test 2 は反転状態で最後に DECSC (ESC 7) を実行している。
  そして test 1 は何故か最初に DECRC (ESC 8) を呼び出している。
  然し、xterm や RLogin は影響を受けていない。
  何か途中で実行している物が影響を与えて DECSC された内容をクリアしているのかとも思ったが、
  調べてみてもよく分からない。ESC 0 と ESC B は試してみたがクリアしてはいない。
  CSI J 及び CSI 2 J も当然関係なかった。CSI ? 3 l も関係なかった。

  不思議だ…。実際に impl3 が見ているシーケンスを出力するスクリプトを書いてみた。
  そのスクリプトを xterm に食わせてみたら反転するのが再現する。
  という事は xterm が見ている内容と impl3 が見ている内容が異なるという事。

  infocmp を確認しても \eB や \e0 が含まれる様な項目は見当たらない。
  うーん。DA2 で 67;0 という変な物を返しているのが悪いのかと思って、
  それを 61 や 67 に変えてみても症状は変わらない。

  a うーん。という事は受信する時点で何かを間違えている可能性?
    何らかのシーケンスが消滅しているという可能性はあるのだろうか。

    うーん。やはり変だ。やはり受信する時点で何か内容が変化している気がする。
    例えば E で囲むというのが実行されていない…。E で囲むというのは何に依って引き起こされるかというと。
    ESC#8 によって引き起こされる…。あれ、もしかして ESC#8 が ESC 8 に翻訳されている?
    何と、そうだった。手で \e#8 を出力すると \e8 が記録されている。
    これが意味する所は escape sequence の中間バイトが記録されていないという事。

  b screen でもやはり \e7\e8\e8 で反転状態になってしまう。
    detach して attach してもやはり反転状態はそのままなのでそうなのだろう。
    一方で、screen から vttest を実行した時には、
    一瞬だけ反転する様子が見えるがその後に通常の表示に戻るのが見える。うーん。

  原因は a だった。遡っていくと、そもそも # が受信されていない疑惑…。
  分かった。sequence で ESC を受け取った瞬間には has pending ESC の状態になって、
  その次に文字を受け取った時に初めて ESC # のペアでエスケープシーケンスを開始する。
  それなのに ESC だけしかシーケンスに記録されないというバグだった。

* vttest (2): 三行の****が現れる筈の所4行現れている [#D0080]
  出力されているシーケンスを確認すると **** を2行分ずつ出力しているが、
  decawm SM(?7) が入っている時と入っていない時で試している。
  もしかして decawm というのは xenl 等の機能ではなくて、
  新しい文字が来てもずっと其処に留まるという動作の物なのだろうか。。

  うーん。振る舞いを色々と調べると現在の実装は微妙だ。
  xenl と decawm の両方を参照して処理を分ける必要がある。

* bce というのが erase の時に使われる着色を制御している気がする [#D0079]
  対応した。mode_bce を見て erase に使う属性を変更する。

  と思って色々と動かしていたらどうも bce というのは背景色だけを適用するのであって、
  その他の属性は適用しない様に思われる。例えば反転を適用すると前景色と
  背景色を入れ替える事になるが xterm 及び RLogin の振る舞いを見ると、
  背景色がそのまま表示されている。

* 行内容の更新は先頭一致部分と末端一致部分だけ活かす様にする [#D0078]
  #D0077 の様な方法を考えるととても複雑になって、
  色々と新しいデータ構造をメモリ確保しなければならなくなって微妙な気がするので、
  取り敢えず先頭一致部分と末端一致部分だけを使って処理する事にする。

  (それでも末端一致部分は DCH 等すると一致しなくなってしまうので、
  結局先頭一致部分しか一致させない場合になってしまう事も多いが、
  これに関しては取り敢えずは気にしない事にする。)

* [棄却] 動的計画で最短の出力で行内容を更新する方法? [#D0077]
  現在の実装では行の追跡は行っているが、行の更新は全て再描画している。

  これは結構考察が必要な気がする。
  基本的には diff のアルゴリズムと同様で、
  しかし、スキップなどがあったりした時のコストが異なる。
  diff の場合にはスキップのコストが一定だったので何とかなったが、
  今回の場合にはそう簡単ではない。何しろ二次元の表であるマス目に来たとしても、
  其処に来るまでの経路で描画属性が異なるはずで、それも考慮に入れないと
  実際にどれだけの出力が行われるかはわからないからである。

  よく考えてみたら proportional の場合にはもっと複雑になる。
  →余りに複雑になるし本当にそれで効率的になるのか分からないので取り敢えず棄却する。

2019-04-27

* vttest: DECCOLM 後のカーソル位置 [#D0076]
  うーん。未だ表示位置が変である。調べると DECCOLM を unset している。
  この瞬間にカーソルを原点に移動するべきという事か。
  然し、やはり駄目である。と思って再度実行したら動く様になった。

* vttest で気づいたのだが BS は行末にいる時に一文字戻ってから作用する。 [#D0075]
  これを修正したら何だか良い感じになったが…。

* vttest で全然駄目だと思ったらどうやら DECOM を使っている様だ。 [#D0074]
  RLogin を確認すると DECOM で変化するのは
  HPA HPR VPA VPR HVP CHA CUP なのだそうだ。
  然し、HPR, VPR がどう影響を受けるのかというのは謎である。
  →RLogin で試してみた所 HPR, VPR は DECOM が有効の時に
    範囲内に confine される様になる様だ。

  * do_cux の lrmargin の制限はちゃんと行方向の反転を意識しているのだろうか…。
  * 更に、RLogin では RS,GS 等の移動も影響を受けるのだろうか。試すと影響は受けない様だ…。

* mode ?4,?5,?8 [#D0073]

  4 はスクロールに関する話。これに対応すると滅茶苦茶遅いので対応したくない。
  というか現在の機構だと対応が困難である。一行変更する度に画面更新をかけるのだろうか。

  5 は背景色の設定だが…。よく考えてみれば現在の実装だと、
  背景色は外側の端末の設定をそのまま使う前提である。
  そういう意味において内部で背景色を設定できる様にしても良いのではないかという気がする。
  うーん。然し、背景色を設定したとして…面倒だ…。

  8 はキーボードを実際に持っている端末でないと意味がない。
  これに関しては外側の端末に伝達しなければならない。

  取り敢えず背景色が設定されている時の output について実装する事にする。
  幾つかの実装方法を考える事ができる。

  a sgrcap の方で設定を弄って既定の前景色・背景色を設定する時に
    前景色・背景色を設定する様に書き換える様にする。
    この方法の問題点は設定を term の中で書き換えるのが難しいという事である。
    また、やはり出力先の端末の性質と中の端末の設定は独立にしたい。

  b もう一つの方法は attribute_t を描画時に渡す時にそれを修正して渡すという事。
    前景色・背景色の設定は何処に保持するのが良いだろうか。
    tty_state の中に保持するか、或いは、sgrcap の中に保持するか。
    うーん。実際に term に対して背景色を問い合わせたりするという事があるという事も考慮に入れると、
    やはり term の中に現在の前景色・背景色について設定できるようにするのが良い気がする。

  c 或いは board_t の中で既に背景色や前景色を設定した状態で記録する。
    これは微妙な気がする。やはり独立にしたいという気がする。

  apply_attr する時に既定の前景色・背景色があればそれを上書きする事にする。

  * reject: screen_buffer に格納する前に既定の前景色・背景色を適用してしまう?
    うーん。差分を取って行を更新している事などを考えると、
    背景色の変更に関してはキャッシュに記録した方が良い気がする。
    後、背景色の変更があった時には全体を更新しなければならない。
    うーん。逆に全体を更新しなければならないのであればキャッシュをクリアすれば良い訳で。
    という事を考えると、やはり既定色についてはその場で設定するというので良い気がする。

  * done: とにかく。先ずは既定の前景色・背景色を attribute に適用するコードについて考える。
    結局最後まで実装した。動いている。まあ、これで良いだろう。

  * done: 次に mode ?5 で既定の前景色・背景色を弄る様にする。
    改めて説明などを読むと、これは明るいか暗いかというよりは反転しているかどうか、
    という話の様なので実は既定の前景色・背景色の設定の話ではない気がしてきた…。
    うーん。これは結局、反転として処理する事にした。

  x fixed: 反転として実装したら妙な感じになった。
    自分で指定して着色している物まで反転していて良いのか。
    その様に考えると実はやはり前景色・背景色の既定色の
    入れ替えとして考えるべきなのではないか。

    xterm で試してみると実際に既定色のみの入れ替えになっていた。
    また、DECSCNM の説明に反して明暗は固定ではなくて、
    その端末の既定の背景色・前景色に依存して変わる。

    →その様にして実装する事にした。
    前景色・背景色が設定されていない時には分からないのでそのまま。

* BUG: ansi: 何故か知らないが空白が入力される様になってしまった… [#D0072]

  うーん。ble.sh 側の問題ではない筈。というのも、他の端末では症状が出ていないので。
  respond() を消すと問題がなくなる。という事は DA2 のシーケンスを構築しているところが悪い。
  うーん。見てもよく分からない。或いは DA2 のシーケンスの中身によって何か変な事が
  ble.sh 側で起こっている可能性もなくはない。
  うーん。respond() だけ呼び出しても変な物が出力されている。
  respond() を2回呼び出しても1回しかスペースは入力されない。

  もしかして初めから変な物が入っている可能性がある?
  と思って初期化の所を見てみた所、サイズを指定するつもりで 32 が指定されていた。
  これがサイズではなくて要素の初期化であると見なされて空白が挿入されていたのである。
  更に、よく考えてみれば初期化の時に指定するのはサイズではなくて、
  capacity の方である筈なのでここで指定しても仕方がない。
  コンストラクタの中で reserve を呼び出す事にした。

* ansi: 端末サイズ変更関連に対応する [#D0071]

  * done: 端末のサイズを変更した時に行内容を truncate する。
    そうしないと全角文字などが化けて出たり座標計算がおかしくなったりする。

  さて、vttest でどの様に動作するのが正しいのか確かめる為に実行してみると、
  そもそも screen では何やら変な動作をする。
  Poderosa に下って実行してみようとしたら Poderosa が固まってしまった。
  結局まともに動作する端末は余りないという事なのだろうか。

* というより DSR に応答する様にしなければならない [#D0070]
  現在は何も応答していない。というか、そもそも制御機能の登録もしていなかった。
  不思議だ ble.sh が DSR(6) を発してはいなかったか。。
  或いは ambiguous width を emacs にしているから飛んできていないだけか。

  何れにしても vttest を実行する上で DA1 だか DA2 には応答したい。
  応答する為には応答の書き込み先を用意しなければならない。

  * done: 適当に DA1 には応答する様にした。
    然し、今度は vttest が DECRQSS を要求している。
    うーん。実装していない。

  * done: DA2 についてはうーん。取り敢えず適当に CSI > 6 7 ; 0 c を返す事にする (67 は 'C')。
    中で ble.sh が DA2 を要求しているので ble.sh が受信した内容を確認する。

      $ echo $_ble_term_DA2R
      67;0

    OK. ちゃんと返答できている。

  * done: というか返答に使う CSI は S7C1T 等の設定に応じて切り替えるべきでは。
    更に "\x1b[...c" 等ではなくて ascii code で出力するべきである。

  * done: vttest を実行してみると DECRQSS を送ってくる。
    DECRPSS を返信する様にした。

* bug: vttest を実行しようとしたら表示が滅茶苦茶に乱れる、と思ったら tab を使うとなる様だ [#D0069]
  tab は全て nul か sp に変換しているつもりだったのにそのまま挿入されているという事になる。
  うーん。調べる。やっぱりカーソル移動しか実行していない気がする。
  或いはカーソル移動するともう駄目なのだろうか。
  →そうだった。カーソル移動だけで座標計算が駄目になる。
  と思ったら pus_spaces の中身を展開した時に変数を書き換えていたのが駄目だった。

* というか sequence で ^@ や ^? を読み飛ばしているつもりだったが読み飛ばせていない。 [#D0068]
  うーん。不思議だ確認してみると ascii_nul または del は無視している筈…。
  そもそも graphic character としても挿入されない。全く処理されない筈なのである。

  * fixed: うーん。そもそもエラーメッセージに ^@ という文字が含まれているのがおかしい。
    と思って確認したらちゃんと変換するのを忘れている。直した。NUL と表示される様になった。
  * fixed: うーん。もしかすると中途半端に終了してしまったシーケンスを処理しようとしている?
    調べてみるとそうだった。process_invalid_sequence を呼び出す前に set_final で
    問題の文字を設定してしまう事にした。

    そして実際にシーケンスの途中に改行だとかタブだとかを混ぜて来ている…。
    この時にどう振る舞うべきなのか…。改めて ECMA-48 を確認してみたが何も書かれていない。
    screen はちゃんと対処して vttest を通っている。という事は何か期待される動作があるという事。
    a もしかするとその改行だとかタブだとかを改めて制御機能として処理するという事なのだろうか。
      現在の contra の実装では単に捨ててしまっている。
      と思って改めて処理する様にしてみたが全然駄目だった。
    b 或いは単に途中に C0 が含まれていても無視する様になっている??
      試しに無視する様にしてみたら駄目だった。
    c 或いは途中に現れた C0 は独立に処理してしまう?
      その様にしたら通る様になった。

    vttest は CR HT VT に対してしかこの振る舞いを要求していない。
    他の制御文字に関してはどうなっているだろうか。
    RLogin で試すと (1) FF も埋め込める。(2) 流石に他のエスケープシーケンスは埋め込めない。
    (3) 制御シーケンスの中に ESC が来た時、その ESC は次のエスケープシーケンスの先頭として使われる。
    つまり、ESC も一緒に廃棄されるという訳ではない。(4) LF も埋め込める。(5) 8bit NEL は埋め込めない。
    恐らく UTF-8 デコード前にもう駄目になっているのではないかという気がする。(6) 実は C1 は全て認識している。
    FS, GS, RS, US による移動も認識している。

2019-04-23

* cat memo.txt すると右端にごみが残ってしまう [#D0067]
  これは何だろう。描画ルーチンで m_width + 1 だけ ECH すると消える。

  | 何処かで一文字消滅しているのだろうか。或いは screen が文字幅を勘違いしている?
  | というか、impl3 の方で文字幅を勘違いしているのかもしれない…。
  | と思ったが、screen で観察する限りはちゃんと最後のごみは 80 桁目に収まっている。
  | と思ったら screen を detach/attach すると消える。
  | という事はこれは contra 側の問題でもなく screen 側の問題でもなく、
  | Poderosa の問題という事になるだろうか。
  | 直接 Poderosa から ./impl3 を実行しても問題は発生しなかった。
  | という事はこれは screen が Poderosa に出力する時に起こる何らかの不整合だろう。

  結論: screen の Poderosa に対する描画が何か変である。contra ./impl3 は関係ない。

* 行の追跡と再描画の省略 [#D0066]
  次に実装するべきは何だろうか。

  恐らく行毎に変更があったかなかったかを検出する事と、
  行事体の移動を追跡する事である。
  その為には前回の行の内容 (というかその瞬間に端末に表示されているであろう内容) と、
  行番号と version 番号などなどである。
  行番号と version が一致していれば更新の必要はない。
  一致していなければ行内容を照らし合わせて変更のあった部分以降について更新を行う。

  行番号の追跡に関しては全画面の時には実施するが、
  他の内容も表示されている時には DECCRA もしくは DECSLRM がないと難しい。
  逆に DECCRA 及び DECSLRM が使えるのであればそれを使ってスクロールする様にしても良い。

  * done: 取り敢えず各行に固有の id が割り振られる様にする。
    set_id をする場所は何処だろうか。board_t の中で新しい行を入れている所で割り当てる。

    ? 後 term.cpp で clear_content を呼び出している箇所はどうだろうか。
      clear_content を呼び出しているのは EL(2) 及び ED である。
      これらに関してはまあ新しい行と認めなくても良い気がする。
      全削除をしている事によって追跡の必要はなくなるという事の気がするけれども、
      然し、概念としては実際には削除していない。結局どちらでも良い気がするが…。
      id を描画の目的だけで用いるのだとしたら新しい id を割り当ててしまって良い気がする。
      一方で id を別の目的で将来使用したくなる可能性まで考えると
      新しい id は割り当てない方が良い気がする。
    →結論: EL(2) 及び ED では新しい id は割り当てない事にする。

  * done: id 及び version が変化した行だけを再描画する。
    これは直ぐに実装する事ができた。そんなに大変な事はなかった。

  * done: id を用いた行の追跡を実行する。
    これは scroll が有効な場合とそうでない場合があるので on/off できる様にする。

    というか、これは先ず始めに差分のアルゴリズムで最長の一致を求める必要があるのではないか?
    と思ったが、よく考えてみると端末のシーケンスには行を挿入したり削除したりするコマンドはあるけれども、
    行の順序が交換される様な操作は存在しない。従って、最長の一致は共通の id を持つ行を特定するだけで良い筈。
    もし順序が交換される様な場合もあるとしても、さしあたっては簡単なアルゴリズムで十分であろう。

    取り敢えず決めなくてはならないのは共通部分をどの様に決定するのかという事である。
    これは実は前の表示内容の各行がどれだけ移動したかという情報で良いのではないか。

    行の移動の最適な方法は何だろうか。
    先ず始めに各位置で削除と挿入をそれぞれどれだけ行うかを決定する。
    挿入を実行した時に内容がはみ出てしまうと問題に鳴るので削除は先に実行する。
    その後で挿入を実行すれば良い。

    では screen_buffer の方の更新はどの様に行うのか。
    screen_buffer は配列なので削除と挿入を毎回行っていると効率が悪い。
    実際には各範囲毎に移動量が決まるはずで、それに従って移動を実施すれば良い。
    若い番号に移動する場合には何も考えなくて良い。
    大きな番号に移動する時にはふみつぶさない様に保留する。
    最初に踏み潰されない要素が見つかった時にその要素から順に移動すれば良い。
    その様に考えると移動量ではなくて移動先で管理した方が良い様な気もしないでもない。

    うーん。結局、削除・挿入・screen_buffer の更新は独立に実施するのが良さそう。
    実装した。本当にこんな実装で大丈夫なのか確認はしていないが、まあ取り敢えず動いているには動いている。

* 2019-04-21 DECSLRM が設定されている時 SU, SR, 及び暗黙移動による rotate で内容を切り貼りする [#D0065]
  内容を切り貼りする為にはある行の内容を切り出して、
  別の行に貼り付けるという事をしなければならない。

  更に mono の場合と prop の場合が混在していた時にどうするかについて考えなければならない。
  表示部での切り貼りとデータ部での切り貼りの二種類の可能性についても考える必要があるだろうか。
  ECMA-48 によると SU, SD, SL, SR は表示部におけるスクロールであった。
  従って、表示部に於いて複雑な切り貼りを実行する必要があるのではないだろうか。
  うーん。DCSM を感知する様にしても良いのではないかという気がする。
  表示部で切り貼りされたらアプリケーション側では現在の状態の追跡が困難になるのではないか。

  然し、将来的な対応だとか実装の自然さなどを考えるとデータ部における切り貼りも一応対応したいと思う。
  後、この様な機能を使う頻度を考えると多少効率の悪い実装になっても構わないという気がする。

  compose_segments に渡す line_segment_t に親の行を指定する事ができるようにすれば良い気がしてきた。
  後でまた観察する。一方で mono_compose_segments についてはどうだろうか。
  これもそんなに悩まずに実装する事ができそうだが、一方で、
  呼び出し元で処理すればより効率的な実装ができそうな気もしないでもない。

  * done: 取り敢えず、SU,SD,IL,DL 迄は対応した。

  x fixed: うーん。試しに動かしてみたらスクロールが動かなくなっている…。
    そして動かなくなったのは一つ前のコミットの様である。
    diff を見てみたが何が行けないのかすぐには分からない。
    取り敢えず insert_graph を確認してみる。

    何と折返しが起こっていない、と思ったがよく見るとそもそも
    画面の右端に達していないので折返しが起こっていないというだけだった。
    という事は do_nel が怪しい。特に do_generic_ff が怪しい。

    * fixed: 調べるとそもそもスクロールする所まで進んでいない…。
      というか spl の値が何故か 80 になっている。直した。

    と思ったら直っていない。動作を調べていくと一応 rotate(1) までは呼び出されている。
    うーん。不思議である。ちゃんと呼び出されている。

    うーん。確かに rotate をする時としない時で振る舞いは異なるが変である。
    後、initialize_cells の効果も変である。別に負の shift が起こっている訳でもない。

    うーん。IL DL の方の問題の気がしてきた…。でも変だ。コメントアウトしても何も変わらない。
    IL と DL を即座に抜ける様に修正しても画面の内容が消えたりスクロールしない問題はそのまま。
    やはり rotate が変なんだろうか…。rotate を全くしない様に変更すると、
    出力した内容の1行目だけが表示される様になる。
    最終行だけが表示されると期待するのに何故1行目だけなのだろう…。
    或いは、別の行に何か表示しているのだろうか…。

    1. うーん。先ず prompt で enter を押しても rotate が起こっていない様子である。
      bash --norc で起動するとちゃんと rotate が起こっている。
      これが意味する所は IND もしくは IL, DL による行挿入が動作していないという事。
      また、bash --norc で起動したとしても次々に行内容が消滅する。

      うーん。もしかして書き込み位置がおかしくなっている?

    * fixed: 今気づいたが spl の値が変だ。1 多い。これは修正した。
      然し、振る舞いが微妙に変化しただけで依然として何かが変だ。
      因みに implcit_spl を呼び出している所はこの箇所だけである。

    未だ治らないと思ったらテストの為にコメントアウトしたコードを修正したら直った。OK

  * 次に暗黙的移動で起こる shift_lines についても DECSLRM の影響を受ける様に修正する。
    もう他には shift_lines を呼び出している箇所はない。

2019-04-21

* ICH と DCH についても DECSLRM に対応した [#D0064]
  ECH については RLogin も xterm も DECSLRM の影響を受けていないので保留する。

* SLH,SLL と DECSLRM は同一視しても良いのだろうか [#D0063]
  例えば、ECMA-48 を参照すると SLH, SLL が SU や SD の範囲に影響を与えるとは書かれていない。
  然し、DECSLRM は SU や SD の範囲に影響を与えるという前提の様である。
  少なくとも Tw 上の議論ではその様な前提で行われている様に見える。
  うーん。やはり ECMA-48 を見ても SLH, SLL でスクロール範囲が制限されるとは読めない。

  しかし暗黙移動に対する影響は両者とも同じ様に見える。
  どの様に実装するのが良いだろうか。
  例えば暗黙移動に関する関数に関しては両方を参照する様にして、
  スクロールに関する機能からは DECSLRM だけを参照する様にするなど。
  また、SLH, SLL は subsequent lines という話なのだから、
  行毎に情報を保持する事にする。
  DECSLRM は全体で一つの値を保持するという事にする。

  その様に実装を修正する事にする。

  * done: というか DECSLRM を実装する事にする。
    実装は殆ど DECSTBM と同様で大丈夫。
    調べて分かった事は DECLRMM モードにも依存するという事。

  * fixed: xterm の振る舞いを観察すると変な引数を与えて
    DECSTBM が効かない時には原点に移動する動作も行わない様である。
    今までの実装だと変な引数を与えた時でも原点に移動していたので修正した。

  * done: DECLRMM 用意した。

  * done: 範囲を取得する関数。関数名を考える必要がある。

    うーん。現状で slh sll で取得するのは line_home, line_limit としているが、
    似たような関数名だとどれがどれか分からなくなってしまうので、
    それぞれが何を取得するのか分かりやすい方が良いのではないだろうか。
    例えば slh, sll で設定するのは暗黙的移動による範囲であると考えて良い。
    一方で decslrm で設定するのは暗黙的移動による範囲に加えて、
    スクロールの範囲やカーソル移動の範囲も制限する。

    うーん。slh, sll による設定は implicit_{left,right}_boundary と言った感じである。
    一方で decslrm は完全に範囲を制限している。scroll_left, scroll_right なのか、
    という感じである。うーん。違う。スクロールに関しては decslrm の設定だけ参照する。
    CUF, CUB に関しても decslrm の設定だけ参照する。
    implicit_left と implicit_right に関しては両方の設定を参照する。

    実装した。DECLRMM を参照しつつ決定する。

  * done: implicit_home,limit は引数に line_t const& を受け取る様にしたい。

  * done: board_t::line_home,limit は廃したい。

  * done: RLogin では CUF CUB が影響を受ける。HPB, HPR は影響を受けないのだろうか。
    これについては後で調べる事にする。→調べてみた所 HPB, HPR は影響を受けない様だ。
    従って、取り敢えず CUF, CUB だけ修正する事にする。

  * done: FF の類は SPH, SPL と DECSTBM の両方を参照する様に変更する。

* bug: less で上にスクロールした時に何も表示されなくなる [#D0062]
  何故だろうと思って出力されているシーケンスを観察すると、
  表示されている文字列と表示されていない文字列の出力の間に RI が呼び出されている。
  つまり、RI を呼び出した瞬間に画面がクリアされているという事だろうか…。

* bug: emacs 上で括弧の対応の強調が起動されると描画位置がずれる [#D0061]
  出力されているシーケンスを観察すると何と CR HT HT BS という列で移動を行っている…。
  一体どういう移動方法だ…。ESC [ 1 5 ` か ESC [ 1 5 G で良いのでは?
  と思ったが、確かに 1 byte 少なくて済む…。terminfo か何かの移動テクニックなのだろうか。。

  それと同時に CR HT HT BS に対して現在の実装はどの様に反応するだろうか。

  x fixed: というか、現在の実装では HT に対して 0 埋めを実行しているが、
    実は HT は移動だけしか行わない?→どうやらそのようである。
    現在の実装では 0 で埋めているので修正が必要になる。修正した。

  x fixed: しかしこの修正だけだと未だ振る舞いが変である…。
    →うーん。分かった tab で進む位置の計算を間違えていた。
    現在の位置が丁度タブの位置になっている時に移動しない様になっていた。

  o 実は右端に行った時の振る舞いが変なのでは…。
    と思ったが、改めて見た所、ちゃんと std::min で抑えてあるので大丈夫。
    本来はこれについても line_limit か何かで制限するべきではある。

  何れにしてもずれは発生しなくなったのでよしとする。

2019-04-20

* ansi: rotate を DECSTBM に対応する [#D0060]
  今の実装だと改行などで範囲の外に出てしまう。

  x fixed: さて、対応したつもりだがそれでも何故か文字列を入力して行って
    改行を実行すると範囲の外に出てしまう。
    と思ったが改行で一番下にいるかどうかの
    判定を修正していない気がする。→修正した。

  x fixed: 動かなくなった…と思ったが、
    これは rotate の呼び出し方を反転していたのが問題だった。修正した。

* altscreen が動いていない気がする… [#D0059]
  調べるとどうも set_mode(true) しか受信されていない様である。
  と思ったら get_mode(mode_altscreen) に対応していなくて
  常に false が返る様になっていた。つまり、false に設定しようとしても、
  常に既に false になっているから特別の処置は不要であると判定されていたという事。
  修正した。altscreen は無事に動作する様になった。

* impl3: 取り敢えず端末画面の内容を出力する様にしてみた [#D0058]

  先ずは簡単で良いので画面内容を出力し続ける様にする。

  * fixed: TIOCSWINSIZE の問題
    % できたと思ったが内容がおかしい。どうも出力がおかしいのではなくて
    % 実際に端末画面の内容がおかしいようである。調べてみると、
    % LINES, COLUMNS の内容がおかしい。
    % slavefd に対して TIOCSWINSIZE を実行しても反映されない。
    % masterfd に対して TIOCSWINSIZE を実行しても反映されない。
    % ループの中で何度も masterfd に対して TIOCSWINSIZE を実行すると反映される様だ。
    % しかし、それだといかにも非効率的というか変な事がおきないか心配である。
    % 更に、不自然である。ちゃんと正しい方法が存在する筈である。
    % 思うに bash が起動した瞬間からちゃんと winsize を設定していないといけないのでは。
    % と思って create_session の内部で一番始めに設定する winsize の時点で
    % ちゃんと目的の幅・高さに設定する様にしたら解決した。
    →仮想端末を開いた時の初めの TIOCSWINSIZE の時点で最終的な値を設定する必要があった。

  * fixed: mode_vem の既定値が true になっていた問題
    bash だと内容が正しいが ble.sh だと内容がおかしい。
    これは IL, DL の実装が変だからの様な気がしてきた。
    画面内容が少しずつずれていくからである。
    というか IL, DL を実行するにしても上にずれていくのは変である。
    bash で問題になっていないのだから改行などによって起こる
    スクロールが問題になっている訳ではない様に思う。
    と思ったら mode_vem の既定値が true になっていた。修正した。

  * fixed: 日本語を正しく出力できていない。
    然し、どうも print_screen では正しく出力できている様だ。
    つまり、端末内容は問題がないが出力に問題があるという事だろうか。
    或いはバイト値で格納されている?
    うーん。そちらの様な気がしてきた。
    つまり、入力時に UTF-8 ではない変な解釈になっている。

    tty_player_device を見ると term_t::write を呼び出している。
    調べると term_t::printt はちゃんと encoding に対応しているが、
    term_t::write は encoding に対応していない様である。

  * done: 後、着色もちゃんと反映する様にしたいのである。

    取り敢えず先ずは着色を反映される様にする。
    と思ったが現在の実装だと並び替えなどを実施した際に、
    属性を取得する事ができない。属性も取得する様に拡張するのは面倒である。

    a 或いは、line の側で並び替えを実行した時のセルの配列を取得する関数を用意するか。
      処理に時間がかかる様になってしまうのではないかと思ったが、
      よく考えてみると現在の暫定実装について考えると、
      文字列の入れ子を何度も走査するので一括で取得した方が明らかに速い筈である。

    b メモリが無駄になるなどの事を思うならばセルに対するポインタの配列でも良いかもしれない。
      と思ったが、現状でセルは 16B でポインタは 8B なので対して節約になっていない。
      寧ろポインタ経由でアクセスする為に遅くなってしまうのではないか。
      その様に考えるとポインタの配列にするぐらいならば直接セルの配列にする。

    文字列の情報を用いて反転を実施する事にする。
    所で update_strings で得られる文字列で記録しているのは、
    文字列の座標範囲であって、cell のインデックスではない。
    という事はこれを使って実装する事はできない。
    update_strings でインデックス情報も取得する様にするか、
    或いは一からループを書き直してその場で反転を実施する様にするか。

    取り敢えず今の所は他の箇所でインデックス情報を参照するかどうかも分からないので、
    表示に於ける並びを取得する関数で新しくループを記述する事にする。
    然し面倒なのは cluster 等は元の順番を保持する様に反転しなければならないという事。
    cluster の部分だけ予め反転させて置いて、最終的に正しい向きになるように調整しなければならない。

    取り敢えず適当に実装を初めて見る事にする。

    取り敢えず実装は完了した。実は文字列がある場合にはテストはしていないのだけれども、
    それについては追々テストを追加して行く事にする。

  * [自然解消] うーん。並び替えも含めてどの様に処理するか考え直す必要があるかもしれない。
    取り敢えずの所は get_cells_in_presentation で実装する事にした。

  * 保留: うーん。emacs みたいに描画中にカーソルを
    一時的に隠すというのは有効かもしれない。

    所でちらつくのは単に fflush が足りていないだけではないかと思ったが、
    実際に試してみると、ある程度は現在の位置にカーソルが表示される様にはなるが、
    やはり fflush しても余りちらつきは変わらない。

    \x1b[?25l で隠す様にしてみたが対して変わらない様だ…。
    というか \x1b[?25l 等を実行してしまうと現在の端末の状態に応じたカーソルを破壊してしまうので、
    もし使うとしても現在のカーソル状態をちゃんと管理する様にしてからでなければならない。
    何れにしても余り効果が無いようなのでこれについては今の所は off にしておく。

  * done: 次は更新があった時にだけ画面内容を出力する様に書き換えたい。
    後、変更があったかどうかについては version を参照する様にしたい。
    また、行に id を割り当てて追跡する様にしたい。
    然し、これらの実装は恐らく複雑になるので別項目で処理したい。

* 2019-04-14 RLogin では FS/GS/RS/US に対して ADM-3 互換と称してカーソル移動を割り当てている [#D0057]
  一方で xterm, mintty ではその様な機能は存在しない様である。
  FS-US は単に何もしない機能という事になっているからこれに対応しても良いかもしれない。
  しかし、この様なシーケンスを用いたプログラムが書かれる事があるのだろうか、
  という事を考えるとやはり対応しても仕方がないのではないかという気もする。
  まあ、RLogin に倣って対応するというので良い気がする。

* ansi: bug: 画面内容が全く保存されていない。何処かでクリアされている? [#D0056]
  改行が効いていないのかもしれないと思ったが今までのテストでちゃんと動いていた筈である。
  実際に何か別のコマンドを呼び出してみるとちゃんと複数行になっている。
  という事は何らかのシーケンスが画面をクリアしていると考えるのが自然である。

  どうやら調べてみると IL で全てが消滅している様である。
  shift_cells の引数が負の時に移動方向が反転してしまっているバグがあった。修正した。

* DECSTBM と IL DL 等の関係を調べる [#D0055]

  DECSTBM の影響範囲に関しては RLogin のエスケープシーケンスのページが詳しい。
  http://nanno.dip.jp/softlib/man/rlogin/ctrlcode.html#SGR
  CUU CUD CNL CPL IL DL SU SD
  後 MC, DECMC というのも DECSTBM, DECPEX の影響を受ける。

  取り敢えず勘で実装してしまった。RLogin で振る舞いを確認した方が良さそう。
  先ず初めに DECSTBM に変な引数を与えた時にどの様に振る舞うかに関して。

  - %%先ず初めに DECSTBM の第二引数は最終行ではなくて、最終行の次の行である。%%
    →どうやらこれは勘違いの気がする。単に ble.sh のステータス行を数え忘れていただけだった。
  - fixed: 巨大な値を指定すると最終行までと見なされる。
  - fixed: 範囲が潰れる様な指定の仕方をするとスクロール範囲に対する変更は実行されない。
  - fixed: 引数 0 もしくは空欄は既定値を意味する。開始の既定値は画面の一番上で、
    終端の既定値は画面の一番下である。

  更に、IL 及び DL がどう振る舞うかについて。まあ、これは確認してなくても良いだろう。
  また、同時に SU SD SL SR についても実装をしておきたい。
  それから CUU, CUD 等も影響を受けるそうだ…。

  * done: DECSTBM の振る舞いについて確認して gh に記述した。
  * done: SU, SD, SL, SR の振る舞いについても確認を行った。
  * done: SU, SD, SL, SR の実装。
  * done: CUU, CUD, CUF, CUB, CPL, CNL の修正。

* ansi: DECSTBM の対応 [#D0054]
  emacs を起動してみると凄い勢いで
  DECSTBM (set scrolling region) を実行している。
  つまり DECSTBM に対応した方が良いのでは。という事。

2019-04-17

* ansi: Alternate Screen Buffer には対応しないと行けない [#D0053]

  仕様について確認を行う。

  ?47 と ?1047 でバッファは共有の様である。
  ?1047 は ?47 を設定して更に代替画面をクリアするという事の様だ。
  また、?1047 の値と ?47 の値は DECRQM で確認すると連動している。
  ?1049 も連動している様子である。双方向に変更が伝わる。

  実は alternate screen buffer は VT の機能ではない様だ。なんで名前はついていない。
  誰が一番始めに実装したのだろうか。xterm には xterm と書かれている。

  関連して ?1048 の設定・解除は実は \e7 \e8 と等価になっている。
  現在の状態は記録されていない。
  取り敢えず表面上だけでも実装する事にした。

  うーん。後は altscreen の board を用意するだけで良い気がする。
  或いは board ではなくて lines だけでも良いのかもしれない?
  presentation_direction だとかも保存されるのだろうか…。
  然し、SPD 等で変換する場合なども考えると、
  altscreen の SPD と本体の SPD は独立が良い気がする。

* ansi: やはりモードの登録方法を考える必要がある気がする… [#D0052]
  一覧表から自動生成する事にしようか。

  * 一覧表を作るところから始める事にする。
    何が必要だろうか。

    1. 名称
    2. type = flags, accessor
    3. flags 内のインデックスは自動生成すれば良い
    4. mode_type = ansi, dec, contra, etc.
    5. mode_param = 番号
    6. 既定値

    $1--$4 に上記の 2. 1. 4.5. 6. を入れて一覧表を作った。

  * さてどの様に実装しようか。
    実用性を考えると実は今と同じで良いのではないか?

    と思ったが ansi1 だとか dec2004 だとかの情報は
    mode_spec に埋め込まなくても良い。どうせ辞書から引かないと行けない。
    そして辞書から引くのだとしたら辞書に登録する時に必要になるだけで、
    別に mode_spec に埋め込んでおくのは冗長である。
    今までその様にしていたのは表を作るのが面倒だったからである。

    そうすると flags か accessor かという情報と
    それぞれに対応した index だけ記録しておけば問題ないという事になる。

    a 先ず値に関して。
      accessor_flags = 0x10000 として
      後は flags, accessor それぞれに対して順に 0...n まで生成すれば良い。
    b 規定値の設定部分も生成する。
    c 辞書に登録する部分も生成する。

    実装した。動いている。異常もない。

2019-04-15

* emacs が SM(34) と SM(?25) を送ってくる [#D0051]
  SM(?25) は DECTCEM である。カーソルの表示・非表示である。
  他にもカーソル関係はある。SM(?12) はカーソルの点滅を制御する。

  * 次に SM(34) について。

    | 調べてもそういったものは無いようだ。
    |
    | もしかして terminfo から拾っているだろうかと思って
    | 調べてみると TERM=screen-256color であって、screen のマニュアルには
    | "normal cursor visibility" と書かれている。infocmp を見ると、
    | cnorm=\E[34h\E[?25h と書かれている。cnorm はカーソルを表示するという奴である。
    | うーん。よく見てみると cvvis=\E[34l になっている。cvvis は very visible
    | つまりカーソルをよく見える様にする、という事である。
    | という事はやはりカーソル形状をブロックにするという物と思って良さそう。
    |
    | all-escapes.txt によると 34 33 は WYSTCURM, WYULCURM という名前の様である。
    | それぞれ "カーソルの形は下線" と "カーソルは点滅しない" である。
    | 調べているとカーソルの形状・点滅・表示に関しては錯綜している。
    | まあ現時点では contra は GUI を持たないので適当に空実装という事にしておく。

    まとめると
    Mode 32, 33, ?12, ?13, ?14 は Wyse 及び xterm でカーソルの点滅のon/offに使われている。
    Mode 34 は Wyse 及び screen でカーソルの形状の変更に使われている。

  * mode についての getter/setter?

    | 後、これらに関しては重複する設定の様な気がするので、連動させる為に
    | getter, setter を設定できる様にしたい。
    | また、後で observer から設定変更を検出する為にも getter, setter の仕組みは
    | 何れにしても必要になるのではないかという気がする。
    | と思ったが、getter, setter と onchange は違う気もする。
    |
    | board に追加しようとして思ったのは、端末の状態は board に含まれていない。
    | つまり tty_observer は実は term に対しても observe を実行する必要がある。
    | まあ、それはそういう構造でも良いという気がする。
    | getter というよりも setter だけが必要?
    | と思ったけれども実際に記録されない様なフラグや他のフィールドから算出される様な
    | フラグに関しては getter も特別な物に差し替えるのが良い。
    | そして、それは term.cpp の側で処理するというよりも、
    | tty_state の側で処理する方が適切である様に思われる。

    →取り敢えずのところはその場に switch で書き込む事にした。
    もっとちゃんとした感じの実装にするのは増えてきてからという事にする。

  * 他にカーソル関係で形状と点滅を同時に制御する制御機能があった筈。
    これとの相互作用は一体どうなっているだろうか。
    うーん。& で良い様な気がする。つまり、片方が点滅を抑制していれば点滅は抑制される。
    と思ったが…うーん。片方が点滅を指定していれば点滅するという考え方も存在する。
    因みに既定値は点滅である。という事を思えば点滅が既定であって、
    どちらか一方で点滅を抑制する指定があったら点滅しないという設定で良い気がする。

    | xterm の動きを観察する。うーん。よく分からない。
    | 分かった事は menu の Blinking Cursor は反転として働いているという事である。
    | というか DECRQM を実行してしまえば良いのでは。。
    | 実際に実行してみると ?13 は認識していない。?14 も認識していない。
    | うーん。xterm の説明書に書かれているのは手元の xterm の振る舞いと違うという事なのか。
    | 最新の xterm で追加された機能なのかもしれない。
    | とにかく menu 項目の設定 (説明書によると ?13 らしい) は反転させる効果という事。
    | 更に DECSCUSR の値を変えても ?12 の値は常に 2 (RM) のままである。
    | 本当に ?12 はカーソルなのだろうか…。更に、SM(?12) にしても RM(?12) にしても
    | DECRQM(?12) の結果は変化しない。これが意味する所は…。
    | 実は一度でも DECSCUSR を使うと ?12 は inactive になるのだろうか。
    | RIS SM(?12) DECRQM(?12) を試してみたがそれでも状況は変化しない。
    |
    | うーん。つまり実は xterm は対応していないという事?
    | Cygwin の xterm の version は 330 と書かれている。
    | 最新版の xterm (344) をダウンロードしてコンパイルして実行してみた所、
    | ?13 も ?14 もちゃんと有効になっている。?12 も設定に応じて変化する。
    | これで改めて設定を確認してみる事にするのである。
    | ?12 は SM/RM で変化する。?13 は RM のままで SM/RM では変化しない。
    | ?14 は permanently set という状態を返す様である。
    |
    | % DECSCUSR は説明と比べると反転した状態になっている。
    | % そして、メニューが表示されていないので分からないが、
    | % メニューに於いて Enable Blinking Cursor の
    |
    | DECSCUSR は ?12 と連動するという所まで確認できた。
    | メニューとどう連動するかは良く分からない。
    |
    | man xterm に詳しく書かれていた。cursorBlinkXOR が設定されていない時は、
    | どちらか一方でも blink になっていれば blink する様である。つまり or。
    | うーん。メニューを設定する方法は不明だが、
    | % うーん。-bc で起動すると反転していない。+bc で起動すると反転している。
    | % DECSCUSR の仕様の方を勘違いしているだろうか…。
    | 勘違いだった。ちゃんと期待した通りの動作になっている。
    |
    | 因みに #330 はどれだけ古いのかと思ったが、
    | 調べると 2017/06/20 なので特に古くもない。

    まとめると。
    1. xterm が ?12 ?13 ?14 に真面目に対応したのは割合最近の話である。
    2. ?12 の設定は DECSCUSR による設定と連動している。
    3. ?13 の設定は cursorBlink resource の値を反映する。
      SM/RM では変更する事ができない。
      因みに cursorBlink resource は false true always never の4種の値を本当は取る。
    4. ?14 は常に set という事になっている。
      set の時は片方だけ set (blinking) の時に、blink する。
      reset の時は一方でも set ならば blink する。

2019-04-14

* BDSM の実装。これは DCSM の有効・無効の判定部分に影響を与える [#D0050]

* 2019-04-13 選択範囲や属性化領域はどの様に処理するのが良いのだろうか [#D0049]

  | ? 例えば選択範囲は入れ子にすることができるのだろうか。
  |   他の領域と overlap がある場合にはどの様に取り扱うべきか。
  |   領域は或いは他方が一方を必ず包含する様になっているのだろうか。
  |
  |   うーん。用途を考えると入れ子にしても仕方がない気がする。
  |   なので on/off で解釈してしまっても良い気がする。
  |   因みに属性化領域の説明には選択領域で終了するなどは書かれていないので、
  |   互いに overlap する事が可能である様な気がする。
  |
  |   つまり、属性化領域・保護領域・選択領域は互いに overlap 可能の様に思われる。
  |
  | ? 属性化領域も入れ子にすることができるのだろうか。
  |   と思ったが DAQ の解説によると次の DAQ が現れたらもう其処で終わるとの事。
  |   なので入れ子はないと解釈して良い。
  |
  | ? 他の実装はどうやっているのだろうか。
  |   例えば DECSCA の様に描画属性に紛れ込ませていたりはしないか。
  |
  |   例えば VT510 は対応しているのだろうか。調べてみると SSA-ESA も SPA-EPA も DAQ も対応していない。
  |
  |   RLogin を見ると文字消去ガード開始・終了、としていて SPA-EPA と同じ取り扱いという事になっている。
  |   具体的にはどういう実装になっているだろうか…。ERM も機能として実装している様だから試してみる。
  |   printf '\e[41mabcdefghijklmnopqrs\ra\eVBC\e[20Cx\t\td\eWefg\e[m\e[2K\n'
  |
  |   - どうも試してみると SPA-EPA はやはり描画属性の如くに処理されている気がする。
  |     というのも物理的に SPA と EPA の間の文字列が保護される訳ではなくて、
  |     時間的に SPA と EPA の間に入力された文字が保護されている様子だからである。
  |   - 更に EPA をした後に上書きした部分に関しては削除されない様子である。
  |   - また HT による移動では1文字目だけに属性が適用されて、
  |     それ以降のスキップには属性は設定されていない。
  |
  |   printf '\e[41mA\eVBC\eW\e[10P\e[m\e[2K\n'
  |   これだと行末に描画属性が適用される事になるが、
  |   実は其処には保護は適用されていない。うーん。
  |   つまり、描画属性とは別に管理されているという事になるのか。
  |   実は文字を書き込む時に設定されるという事だろうか。
  |   だとすると ht で一文字だけ適用されるとも理解できるかもしれない。
  |   或いはできないかもしれない。
  |
  |   xterm も実は対応している様子だ。xterm の場合には HT では属性は保存されない。
  |   HT でスキップした範囲は保護の対象ではない。EL や DCH 等で挿入された空白は保護の対象ではない。
  |   などなど。
  |
  |   これらの事を考慮に入れて "領域" はどの様に定義されるだろうか。
  |   - 例えば HT でスキップした場合に同じ "領域" と見做して良いのだろうか。
  |     それとも別の領域と思うべきなのか。或いは、保護を実行する時に何回目の保護領域なのか
  |     というのを覚えておくとかそういう手もあるかもしれない。然し、実装が面倒だし、
  |     振る舞いとしても分かりやすい物であるとは言えない。
  |   - 或いは保護領域の範囲と実際に保護される文字は別でも良いのかもしれない。
  |     例えば SPA を実行した位置と EPA を実行した位置を覚えておいて、
  |     その間を保護領域であると解釈する等。
  |
  | ? また、表示部での範囲を指定するのだろうか。
  |   それともデータ部での範囲を指定するのだろうか。
  |
  |   DAQ の内部で文字列を使用した時の動作は未定義という事になっていた。
  |   これを考えるに DAQ は属性として処理してしまって良い気がする。
  |   更に、未定義というのはデータ部で範囲を抽出しても良いし、
  |   表示部でデータを抽出しても良いという意味に取れるのではないだろうか。

  contra の実装では以下の様にする。SPA, SSA, DAQ は何れも描画属性の一部として記録する事にする。
  これらの属性がカーソルに設定されている間に入力された文字についてだけ属性を適用する事にする。

  領域はどの様に定義するのかは微妙である…HT によるスキップには現在属性は設定していない。
  他の実装でもそうなっている気がする。但し、RLogin に関しては1文字目だけに属性を設定している。
  うーん。取り敢えず NUL は跳ばす事にして同じ属性になっている範囲を領域という事にする?

  * protected guarded などについて意味を確認しておく。
    protected は削除されないし変更されないという事。
    guarded はデータストリームとして転送されない・補助装置との間で転送されないという事。

  * ERM に同時に対応したい気がするが面倒である…。
    全て消去するのならばともかくとして protected だけ残して消す。
    mono の場合には簡単である prop の場合にも簡単である。
    問題は prop&presentation の場合である。

    というか ERM が影響を受けるのはどれだったか…EA, ECH, ED, EF, EL である。
    うーん。shift_cells のフラグとして erm を追加するのは良しとして、
    どの様に対応するべきだろうか…。

    現在の実装は compose_segments に依っているが、
    実はこれは表示位置から計算されたデータ位置を使って抽出を行っていて、
    各セルのインデックスで抽出を行っている訳ではない。
    つまり、marker によって protected, unprotected が混ざっているかもしれないが、
    そういった物は全く関係なく全て切り出す様になっている。
    erase なので unprotected な marker は削除したい。
    或いは、単に protected なセルだけ残して他を全て削除するという処理方法でも良いのだろうか。
    うーん。取り敢えずそういう方針で実装する事を考えてみる事にする。
    それによって見た目が変な事になっても知らない、という事で。

    取り敢えず少しずつ実装する事にした。
    mono, prop&data については実装した。

    prop&presentation については compose_segments で実装されている。
    考慮に入れなければならない事が色々ある。

    - done: というか、そもそも protected な文字が含まれている行というのは
      余りない。みんなそんな機能は使っていない筈である。
      という事を考えると、実は、事前に protected があるかどうかだけ
      チェックして、含まれていなければ普通の処理方法で良いという事。

      含まれている場合には多少重い処理になっても気にしないという事にする。

    - done: 先ず初めに境界上に protected な全角文字が存在する時、
      現在の compose_segments の実装だとうまくできない。
      これは compose_segments の呼び出し元で範囲を調整する様にしたら良いだろうか。

      % 但し、どちらの方向に調整するのか等も含めてよく分からない…。
      % 然し、境界上に全角文字が存在する場合、
      % 必ずそれは表示範囲の端にある筈だから、
      % どちらの方向にずらしたら良いのかは自明なのでは。
      % つまり、範囲を広げる方向にずらせば良いのである。
      % 従ってこれは気にしなくても大丈夫。

      やはり全角文字がある場合にはどちらの方向に調整したら良いのかわからない…。
      特に全角文字の幅が 3 以上あって、境界の右側と左側で幅が異なる場合に。
      幅が同じ場合には適当に幅を拡張すれば良いだけなのである。

      然し、異なる場合には先ず初めに現在の文字の方向性を取得して、
      それに基づいて修正する量を決定する必要がある。
      或いは、二種類試してより良い方向を選べば良いのだろうか。
      二種類の xL, xR を pL, pR に変換して試すというのをやってみたが、
      よく考えると xL, xR でも文字列マーカの左右で結果が異なる筈である。
      なので xL, xR -> pL, pR の方向の変換は信用できない。
      一方で、pA, pB -> xA, xB の方向の変換は多分大丈夫である。
      うーん。本当だろうか。依然として曖昧さが残る気がするが、
      まあ、"その位置の右にある有限幅の文字の位置" になっていた筈で、
      その場合にはちゃんと変換される筈なのである。

      取り敢えず実装した。

    - done: 次に考えなければならないのは…。
      零幅文字を含むのか含まないのかという事である。
      うーん。境界上の零幅文字については元々削除しない方針なので、
      残す必要はない、というか残してはならない。
      その他の零幅文字については残すべきである。
      では何処が端の境界に対応していたのか、という情報は得られるだろうか。
      現在の実装だと難しい。

      これも無理矢理に実装した。本当に動作するのだろうか…。

  x fixed: うーん。テストケースを作っていたらアルゴリズムに不備が判明した。
    やっぱり真面目に反転しているかどうかを判断しなければならないという事なのか。

    * done: うーん。向きまで考えるのは面倒だけれども、convert_position を境界の左側について
      計算する関数があれば向きも自然に分かるのでは? という様に思われる。
      その様な関数を作るのは簡単だろうか。思うに、range.begin 及び range.end を +epsilon
      したアルゴリズムを作れば良いのではないかという気がする。
      そうすれば現在の位置が相対的に境界よりも左側にいるという事になる。
      と思って convert_position の実装を観察してみるが…うーん。
      +epsilon しても動作に変化はない。というか寧ろ -epsilon しないと動作が変化しない。変だ。
      というより反転部分の処理の方が効いている? end-1 - (x-begin) としている。
      これは文字の位置を意識した処理になっている。境界について処理をしているのだとしたら、
      end - (x-begin) とするべきなのである。
      文字の位置を意識した時は xL+0.5 = end - (xL+0.5-begin) より
      自然に xL = end-1 - (xL-begin) が導ける。

      では、文字の右端と左端の変換で違いはどうなるだろうか。
      うーん。+epsilon 作戦で実装してみたが全然駄目だった。真面目に考える事にする。
      と思ったが、単に +epsilon した時に条件式がどう変化するかを逆に考えていた。
      a < b → a < b + epsilon ⇔ a <= b という事だった

      と思ったが、それでも駄目だった…。"境界の左側" にあるのは元々の状態の時であって、
      一回反転が起こった時には "境界の右側" になっている…。
      実装した。従来の convert_position の実装に組み込んだ。

      然し、よく考えてみたら逆方向の変換の事を考えていなかった…。
      うーん。やっぱり分からない。反転回数によって結果が変わるのである…。
      というか現在文字の位置の変換は問題なく行えているのだから、
      それと反転回数を元に結果を修正すれば良いだけでは?
      というわけでその様に実装し直したら簡単に動作する様になった。

    convert_positions を拡張したのでそれを使って計算する事にする。
    と思ったがどうやって計算したら良いのかよく分からなくなった。

    取り敢えず boundary の位置がどうなるかを判定すれば良い筈である。
    その時に境界の右隣の位置を追跡するべきか、或いは左隣の位置を追跡するべきか。
    実は、これはどちらでも良い。全角文字が跨っている時には、
    どちらで計算しても同じ筈である。全角文字の途中で文字列が切れている事はないので。
    また、丁度境界の上に乗っていた時にはちゃんと _prob_glb で一致している位置が返ってくる筈で
    その時には何も処置しなくて良いという事が直ちに分かるのでやはり問題ない。
    その様に修正した。うーん。取り敢えず動いているから良いという事にする。

2019-04-13

* 2019-04-12 ansi: 行末ECH後のカーソルの位置は? [#D0048]

  (これは調べたやはり端末によって色々である。contra-gh に追記した。)

  以下に於いて B が行末に表示されれば最後の文字に移動している。
  B が行頭に移動していれば ECH,DCH,ICH に於いて行末に留まる。
  printf '\e[100CA\e[@B\n'
  printf '\e[100CA\e[PB\n'
  printf '\e[100CA\e[XB\n'

  RLogin で試すと最後の文字に移動する。xterm でも同様である。
  Poderosa と screen は行末に留まる。mintty は行末に留まる。

* 2019-04-11 どうも to_presentation_position の仕様を前と変えてしまった [#D0047]
  presentation position は文字進路の方向にするべきだった。
  今は左から右という事になっている…。

  各実装でちゃんと結果がどうなるか確認する必要がある。
  - convert_position
    これは既に修正した。と思ったが、to_data_position 側を修正していない。
  - curpos_t line_t::_prop_to_presentation_position(curpos_t x, curpos_t width, bool line_r2l) const;
  - void line_t::calculate_data_ranges_from_presentation_range(slice_ranges_t& ret, curpos_t x1, curpos_t x2, curpos_t width, bool line_r2l) const;
  - というか line_r2l が関わってくる関数は全てこれが問題になる気がする。

  取り敢えず機械的に書き換えてみたが本当に大丈夫なのかは不明である。
  一通りテストを書いておく必要がある気がする。
  特に data における ECH, ICH, DCH は確認しておきたい。

  実際にテストを少しずつ追加していたらバグが出た。
  DCSM(PRESENTATION) に於いて正しく抽出できていない?
  と思ったが、調べてみると ECH の後の様子は問題ない。
  SDS(1) がちゃんと動作していない様である。

2019-04-12

* ansi: EL について DCSM(PRESENTATION) でも !m_prop_enabled の時は簡単に実装 [#D0046]
  というか ECH ICH DCH に関しても実装が term.cpp と line.cpp に分散しているが、
  基本部分だけを line.cpp に移動して、
  細かい動作については term.cpp で指定する様にできないだろうか。

  a 例えば、insert delete 等の操作を仮想的に行う事によって
    compose_segements の引数を構築する等…。
    つまり {{0, 10, insert_fill}, {10, 20, delete}} 等の引数を渡す。
    これをデータ部で実行するか或いは表示部で実行するかは line 側に任せる、など。

    うーん。ICH の実装を見て思ったが delete して insert したり、
    insert して delete したりするのは無駄である。
    データを移動してそれから消去すれば良いだけの筈なのである。
    insert, delete を分けるという事は2回も移動を行っているという事になる。

    そう言った移動を体系的に操作として記述する事は可能だろうか。
    そしてそれに基づいて !m_prop_enabled の場合、
    data && m_prop_enabled の場合、表示部 && m_prop_enabled の場合に分けて
    適切に効果的な処理方法を算出する事が可能だろうか。

    例えば !m_prop_enabled の場合を考えてみると、
    1. move {a..a+delta} to {0..delta}
    2. erase {delta..a+delta}
    の様に記述する事ができる。表示部 && m_prop_enabled の場合に対応する為には、
    先ず初めに、[0..width] という状態があって、(1) の操作によって
    [a..a+delta][delta..a+delta][a+delta..width] という領域に分かれる。
    更に (2) の操作によって真ん中の区間が消去されるという具合になる。
    こう言った区間の演算はどの様にして実行するのが良いのだろうか。
    場合分けして真面目に実装するのだろうか。
    しかし、どの程度複雑なケースまで考慮に入れるのかというのも気になる。

  b 「実は重複がない・順序が保たれる」という条件の下では、
    現在の compose_segments の形式の方が便利なのではないだろうか。
    各範囲について移動が必要かどうかも含めて判定する事ができる気がする。
    然し、動かす順番に気をつけないと何処かの範囲が移動している内に
    別の範囲が塗りつぶされるという事故が起こる可能性もある。
    というか本当にどの範囲も一回だけの移動で移動できる様になるだろうか。。

    少なくともどの範囲も最終的な移動量は確定している。
    その時に他の範囲を踏み潰す様な事があれば移動を延期しなければならない。
    例えばある範囲の移動について考えることにする。
    その範囲が左に動くとする。その時に左側にある範囲を踏み潰す様であれば、
    その左側にある範囲は先に動かさなければならない。その範囲は必ず左側に動く筈である。
    という事を繰り返し考えていけば必ずすぐに移動できる範囲に達する筈である。

    つまり、最初の範囲から順番に見て行って、
    右側に動かす場合には踏み潰される範囲がないかを確認して、
    一番最初に踏み潰されない範囲があればそれを移動する事にすれば良い。

  試しに実装してみる事にしようか。。
  取り敢えず compose_segments をどの様な場合でも動く様に修正した。

  * 実装してみて思った事はこの様な複雑な処理をするぐらいであれば、
    普通に移動を2回するぐらいの方が速い気がするという事である。
    更に _prop で同様の物を実装する為には余計に複雑な処理になってしまう。
    とにかく潰した全角文字を変換した後のスペースを何処かに記録する必要がある。
    そしてそれを記録していると余計にメモリの確保・解放の回数が増える。

    しかくよく考えてみたら今回実装を統一したのは
    効率をよくする為ではなくて今後の実装をすっきりした物にする為である。
    あらゆる制御機能を実装する度に同じコードを何度も書くのは不毛である。
    従って、統一的で一般的なインターフェイスを用意して、
    今後はそれを使って処理を行う様にしようというのが目的だった。

    insert/delete をくっつけて要素の移動を少なくする事ができる
    という話は副次的な利点であったのである。
    なので、この実装によって速度が遅くなったとしても、
    まあ実装する意味がなかったという事にはならない。

  * もっと効率の良い実装の方法はないだろうか。
    現状だと全角文字を潰した事によって発生する空白を
    どの様に記録したらよいかが分からない。
    これを記録する為には新しいメモリ領域を準備する必要がある気がするが、
    それで新しいメモリ領域を準備するぐらいであれば、
    実は既存の compose_segments と同様に処理するのと大差ない。

    或いは、実装を一般的にしすぎという事なのかもしれない。
    例えば segments の数は最大でも 2 か 3 という具合に
    制限して実装しても良いのかもしれない。
    左右の不変部分と、真ん中の消去・削除・移動部分という具合に。

    ECH の場合には真ん中を削除して代わりに何かを挿入する。
    DCH の場合には左端を固定して、真ん中を左に移動するという操作である。
    ICH は実は DCH と逆の動作になっている。
    SR や SL も似た様な実装になっている。
    EA 等については実は ECH を使って実装できてしまう。
    なので余り気にしなくても良いのである。

    然し、SEE を考慮して DCH 等をするとまた具合が異なる気がする。
    左右の不変部分があって、それとは別に内部に移動する文字列がある。
    この場合最大四箇所で全角文字の処理をしなければならない。

    うーん。これは結局何を意味しているのだろうか。
    実は一般的なインターフェイスは、もっと簡単にできるのではないか。

    beg, end, xL, xR, fillL, fillR で指定する事ができるという事だろうか。
    つまり最終的に [0..beg] [fillL] [xL..xR] [fillR] [end..width]
    という形になる様な編集である。
    或いはもっと簡単にする事はできないだろうか。
    beg, end, xL, xR, shift でも大丈夫の気がする。
    それどころか beg, end, m, bool LR で行ける気がする。
    LR=0 の時 [0..beg][m..end][fill][end..width] になる。
    LR=1 の時 [0..beg][fill][beg..m][end..width] になる。
    或いは beg, end, shift で大丈夫の気がしてきた。
    ECH は [beg..end] 以上に shift が起こる場合と捉える事ができる。

    所で見た目は同じかもしれないが DCH ICH ECH で
    境界上の零幅文字の処理の仕方が異なるのではないかという気がする。
    これは引数で制御する様にすれば良いのだろうか。
    うーん。それが良い気がする。

  * 何やら振る舞いがおかしいと思ったら
    to_presentation_position が負の値を出している。
    convert_position の実装を眺める。何だかよく分からない。
    どうしてこのコードで to_presentation_position が計算できるのだろう…。

    q = 0 に初期化して、
    x を含む反転範囲があると、q = end - 1 - (q - beg)
    を実施する、という具合にしている。
    そして最後に p = x - q という様にしている。
    うーん。p = x - q についての漸化式に書き換えたら分かるだろうか。

      p = x - q = x - (end - 1 - (x-p -beg))
        = x - ((end-1)+p-(x-beg))
        = 2x - p -(end-1+beg)

    何だか分かりそうで分からない。
    結局反転によってどれだけずれるかを積算していると考えたら良いのだろうか。

      xold - beg == end-1 - xnew という事を思えば
      xnew = end-1 - (xold-beg) という式を得る。
      xnew+xold = end-1 - beg と言っても良い。

    結局分からないけれども最後の反転の条件がおかしいことだけは確かな気がする。
    従って最後の反転の条件を書き換えた。一応直った気がする。
    しかし、今度は CUF が変な気がする。to_presentation_position は、
    lr になる様に修正を行う物である。一方で CUF は rl の時は、
    方向が反転している物と思って移動を行っている。

  まだテストが通っていないが presentation position の定義に誤りがあったので
  改めて全体的に手を入れる必要が出てきた。従って、一旦ここで commit する事にする。

2019-04-11

* ansi: ICH ECH DCH で挿入される空白の属性 [#D0045]

  どうも ICH ECH DCH で新しく現れる空白領域には現在の属性が適用されるらしい。
  例えば DCH した時に行末に補填される空白にもちゃんと現在の背景色が適用される。
  これは RLogin 及び xterm, mintty で確認した。
  Poderosa でもそうなっているが多少バグがある。
  screen の場合には属性は解除される。
  大勢に倣って現在の属性を適用する様に変更する事にした。

  * done: また全角文字を踏み潰す場合には
    其処に適用する属性は元の文字の属性という事にする。
    - write_cells を確認する
      _mono_generic_replace_cells に関しては元から属性は全て設定されているのでOK。
      _prop_generic_replace_cells に関しても lfill, rfill でちゃんと属性を読んでいる。
    - _prop_reverse は特に踏み潰す様な操作はしていない。
    - copose_segments を確認する。これは其処にある文字の属性を使う様に修正した。

  * done: HT についても現在の属性を適用する?
    と思ったが、これはどの端末でも現在の属性は適用されていなかった。
    contra では寧ろ現在の属性を適用していたので、適用しない様に変更した。

  * done: ICH ECH DCH で挿入される空白について。
    これは外部から属性を指定する必要がある。
    伴って ech や ich や dch についても属性を指定する。
    面倒な事になっているが仕方がない…。
    また、dch に関しては右端をクリアしていたが、
    右端に属性を適用する為にちゃんと余白を fill する様に変更する必要があった。

    compose_segments を使わない時の実装についても同様に
    fill_attr を指定して dch に関しては余白を明示的に insert する必要があった。

  * done: EL と ED に関しても修正する。
    何と EJ や ED で埋められる領域についても現在の属性が適用される様である…。
    clear_content 等と言っている場合ではない…。

  * 実は IL (CSI L) や DL (CSI M) によって挿入される行についても?
    少なくとも RLogin は現在の属性を使っている。xterm, mintty もである。
    Poderosa と screen は違う。空の行を生成する様である。

    というか IND や RI についてはどうなのだろう…。
    やはり属性が適用されている。と思ったら実は LF ですらそうである。
    つまり、新しい行があれば必ず全体に色が適用されるという事である。
    それならその様に実装すれば良いのである。

    これで IND も RI も LF も IL や DL も全部属性が適用される様になったはず。

* DECSCA ... これは描画属性に含めてしまって良い気がする [#D0044]
  DECSC,DECRC で一緒に復元されるとの事なのでそういう実装なのだろう。

* ansi: DECSC, DECRC に対応する [#D0043]

  DECAWM DECOM の状態と属性とカーソル位置を保存する。

* ansi: DECSET, DECRST に対応したい [#D0042]
  SM, RM と同時に対応した。
  然し、結局認識していないモードが受信された時にメッセージを表示しておきたいので、、
  煩い認識できない〇〇のメッセージが表示されるのは変わらない。
  というか、覚えておいて二回目以降は表示されない様にするというのも手かもしれない。
  とも思ったが、そういうのは出力した後に処理するべきである。
  どの様なシーケンスがどのくらいの頻度で呼び出されているかが気になる事もあるかもしれない。

* ansi: ESC k や OSC(0) によるタイトル設定に対応した [#D0041]
  プロンプトからこれが出力されて画面に表示されるのがうるさいので。

2019-04-10

* ansi: VEM for DL IL →DL IL の対応と同時に対応した [#D0040]

* ansi: SLH for ICH DL IL → これは対応した。mode_home_il というモードを作った [#D0039]

* [完了] 2019-04-05 ansi: 新しい端末の定義として ansi_term というのを作る事にした。 [#D0038]

  取り敢えず動く物から作る事にする。

* [完了] 2019-04-05 行のデータ構造の変更の可能性 [#D0037]

  | Unicode 対応等を考えると現在の形式は色々微妙である。
  | 先ず結合文字などが入ってくると特別にメモリ領域を作らなければならない。
  | (但し、これは特別なオブジェクトを保持する時には
  | やはり特別にメモリ領域を作らなければならないので同じ事かもしれない。
  | 然し、そういったオブジェクトは数が限られている一方で、
  | 結合文字などは余りにも簡単に出力する事ができてしまう。)
  | Grapheme cluster も考えて実装するとなると、
  | もう少し柔軟なデータ構造の方が望ましいのではないかと思われる。
  |
  | 結局どのような事を考えているかというと、
  | 行は幅などを考えずに文字の列で表現し、
  | その中に bidi を制御する文字なども含めるという事にする。
  | 座標からデータ内部の位置への変換をスムーズにする為に、
  | B木で各節に合計を保持する?
  | 或いは、行内の文字数がそんなにないと思えば直列に文字を保持しても良い気がする。
  |
  | Proportional なフォントなどを使う場合も考慮に入れて文字の幅は自由にする。
  | 全角2半角1でも良いし、或いはもっと細かい単位でも良いという事にする。
  | 元々の端末の考え方だと全て1だが、今や全角文字のためにその取り扱いは崩れている。
  | 従って、最早2だろうが何だろうが全部真面目に処理するしかないのである。

  行は単にデータ位置とは独立に文字の列として保持する。

    Unicode の bidi や SRS, SDS 等の文字列や、属性化領域・フィールド
    等の情報を保持する為には任意のゼロ幅の文字も保持できなければならない。

  Q. データ位置は行内の文字の番号なのか、仮想的な座標なのか。

    | というかそもそもECMA-48におけるデータ位置とは何だったのかが分からなくなってきた。
    | データ位置には埋め込まれたマーカーはカウントされるのだろうか。
    | 今までカウントされないと考えていたが本当だろうか。
    |
    | 文字が受信された時の事を考えると、受信した文字は次の"マーカー"を上書きするのではなくて、
    | 次の"文字位置"を上書きするのである。という事を考えるとデータ位置というのは
    | bidi の並び替えを実行する前の座標と考えるのが自然である。

    A. データ部における仮想的な座標であるべき。

    何故ならば (1) 文字を受信した時その "座標位置" にある文字を上書きするのであって、
    行内のN番目の文字を置き換えるという訳ではない。(2) データ位置は全角文字の途中にも
    移動する事ができる。

  Q. grapheme cluster で保持するか文字で保持するか

    | そうすると再度文字の表現方法から再考が必要になるのではあるまいか。
    | 今、行を Unicode 文字列で表現する事にしたので、
    | 実は grapheme cluster をそのまま複数の文字として行内に埋め込む事ができる。
    | 或いは今までどおりに特殊文字として毎回登録して使うという様にもできる。
    | どちらの方が良いのだろうか。
    |
    | UAX#9 等を考えると、並び替えの時に面倒なので grapheme cluster の単位で保持したい気もする。
    | 一方でメモリの確保・開放などの効率を考えると grapheme cluster は展開して埋め込みたい気もする。
    | そうすると並び替えなどの操作が色々面倒になってしまう。
    |
    | うーん。考えて見るに通常の使用方法における速度を保証する為には、
    | 内部に grapheme cluster だとか marker だとか R 文字だとか変な物が含まれていない、
    | というフラグを用意しておいて、そのフラグが立っている時は高速な処理にして、
    | そのフラグが立っていない時には低速な処理に切り替えるという手がある。
    |
    | 高速な処理にしている時には wide_extension を有効にしておいて、
    | 低速な処理にしている時には wide_extension を無視するという具合にする?
    | 実は wide_extension は結合文字や grapheme cluster の二番目以降の文字を格納するのに使えるのでは。

    wide_extension 文字を復活させる。
    grapheme cluster は wide_extension と同様の取り扱いにする。
    更に grapheme cluster, marker, R/AL 文字の有無で処理を切り替える。
    これらがない時にはデータ位置と文字インデックスは一致する。

* [消滅] 2016-10-31 bidi: ICH, DCH, ECH に際してどの様に設置されている文字列を更新するかが問題になる。 [#D0036]

  % つまり、文字列の更新とはマーカの位置をどの様に更新するのか、
  % 或いは削除するのかという問題に帰着する。
  %
  % | 先ずは方向付き文字列しかない場合について考える (つまり TATE などの設置されていない場合)。
  % | ICH に関してマーカに隣接していない場合には単純にそれより後ろにあるマーカを移動すれば良い。
  % | また、DCH に関しても削除領域がマーカに隣接していない場合にはやはり後ろにあるマーカを移動すれば良い。
  % | しかしマーカに隣接している場合の取扱は微妙である。
  % |
  % | 先ず ICH に関しては比較的簡単に処理できそうな気がする。
  % | 挿入位置に丁度マーカが設定されている場合にはどの様に処理するべきか。
  % | 挿入位置のマーカは動かさなくて良い。
  % | では現在位置とその左側の位置に挿入を行おうとしている場合にはどうすれば良いか。
  % | (これは HEM で逆向きに設定されている場合のことを言っている)。
  % | どの様な場合にこの HEM を使うのかよくわからないが例えば SIMD と一緒に使うのだろうか。
  % | だとすると HEM が設定されている場合には現在位置に存在しているマーカも一緒に動かす必要がある。
  % | # しかしこの動作で丁度よい気がする。マーカが現在位置以前にあるものと現在位置より右にあるもの
  % | # の二つに分類されて、HEM に応じて片方のグループがまとめて動くという形になっている?
  % | # →ちょっとこの考え方は説得力に欠ける。
  % | 一方で、ICH において反対側で消去される部分のマーカをどうするのかという問題が残る。
  % |
  % | ECH, DCH, ICHシフトによって失われる領域のマーカの取り扱いに関しては、
  % | insert character 時の文字が置かれる場所の掃除を行う時の手法をそのまま使うのが自然に思われる。
  % | なので、insert character 時の処理がどの様になっているのかを改めて確認し、
  % | どれだけ再利用できるか、どれだけ書き直さなければならないかについて考える。
  % | 望ましいのは insert character で用いているコードを拡張して、
  % | 引数などのオプションに依って動作を切り替えて様々な消去の場合に対応できる様にする事である。
  % | (insert character の実装では任意の文字幅に対応できる様になっていた筈なので、
  % | 自然に拡張できれば嬉しいが…。)
  % |
  % | insert character 時の消去についてまとめる。
  % | 実装は board.cpp の board_line::update_markers_on_overwrite にある。
  % | 既に結構複雑な処理になっている様である。
  % | 先ず引数は curpos_t beg, end 文字の左端と右端を指定する。
  % | つまり、消去する領域の右端と左端と考えて良いだろう。
  % | そして beg <= p < end にあるマーカについてのループを考える。
  % | a bidi string の場合には
  % |   内部に存在するマーカは simd に従ってマーカを右端か左端に移動する。
  % |   その移動によって文字列が潰れる場合には始端・終端マーカを一緒に除去する。
  % |   更に、終端マーカの場合には直前に開始マーカまたはフィールド開始がある場合に除去する。
  % | b aligned string の場合には
  % |   基本的に削除を実行する。但し、simd に応じて左端または右端に存在するマーカは削除しない。
  % |   これは自然なデータの流れによって aligned string が開始して初めの文字が挿入される時に
  % |   直前に設置した aligned string マーカが削除されないという条件と同じであり、
  % |   それが自然な動作に丁度なっている。
  % |   更に、直後の aligned string marker が aligned string 終端の場合にはそれも一緒に削除する。
  % |
  % | 問題はこの動作は ECH や DCH ICH においても自然なのかどうかという事である。
  % | 実は余り自然ではないのではないかという予感がしている。
  % | 様々なケースを想定して考える必要があるだろう。
  % |
  % | 先ずは ECH について考える事にする。
  % | a bidi string 開始が ECH 消去領域の内部に存在する場合の動作は何か。
  % |   もし対応する終端がやはり ECH 内部にあるのだとしたら
  % |   その終端と一緒に削除するのが自然である。
  % |   また、もし対応する終端が ECH 外部にまで及んでいるのだとしたら、
  % |   その bidi string 開始は ECH 消去領域の終端に移動するべきである。
  % |   さて、その時 SIMD が逆になっている場合に ECH 消去領域の開始に移動するという事はありえるか?
  % |   →その動作は変な気がする。
  % |
  % |   ではそもそも何故文字挿入時にはその様な動作になっていたのだろうか。
  % |   例えば全角文字を挿入する時には [直前][現在] という様になっている升目を上書きする。
  % |   内部に存在している bidi string 開始マーカは左端に移動するのが自然と思われるというのも、
  % |   文字を挿入する前のカーソルの位置は確かに現在位置より前にあるのだからその時点で文字を挿入すれば、
  % |   その文字に押し出されて左端に移動するというのは自然だからである。一方で SIMD が設定されていない時には、
  % |   [現在][直後] というセルの並びになっているのだから、文字の挿入に依って現在位置から後方に向かって
  % |   マーカが押し出されるのだという風に解釈する事ができる。
  % |
  % |   さて、ECH を実行する際にも似たような解釈をする事は可能だろうか。
  % |   ECH で後方に向かって削除をする時には単純にマーカを終端に設置すれば良い。
  % |   では、現在位置から前方に向かって削除をする時にマーカを前方に移動するのは自然だろうか。
  % |   - 例えば、それが直後にそこに SIMD を用いて文字を書き込んでいくという事を想定しているとする。
  % |     うーん。もし現在位置が文字列の内部に存在していて現在位置の文脈を以て領域を拡大しようと
  % |     考えるのだとしたら ECH によって左側にマーカがずれるというのは自然である。
  % |     しかし ECH で消去をしようとしているのに bidi string の領域が増えるというのも変である。
  % |     また、ECH というのはやはり文字を挿入するという訳ではないのだから bidi string は長くならなくて良い気がする。
  % |     →やはり ECH で現在の階層の領域が拡大されるというのは無理がある様な気がする。
  % |   - そもそも update_markers_on_overwite では "文字を挿入した後" のマーカの位置を想定して設計された物である。
  % |     従って、削除した瞬間のマーカの配置を表す物ではない。つまり、"削除してから挿入する" という様な形にはなっていないのである。
  % |     つまり、マーカの移動は文字の挿入に固有のものであって、領域の確保によって起こる物ではない。
  % |     その様に考えるのだとしたら、別に ECH によってマーカを移動させたりしなくても良いような気もする。
  % |     しかしやはり ECH というからには其処に設置されている諸々のマーカが除去されてほしくもある。
  % |     →うーん。やはり ECH された領域の中ではマーカは存在してほしくない。
  % |   - しかし完全に階層構造を消去領域の中で解いて除去してしまうというのも変である。
  % |     というのも ICH や DCH を用いる場合には、現在のカーソルの位置に於ける階層構造の上で削除や挿入を行うのが自然であり、
  % |     それと整合性を取る為には ECH も同じように現在位置における階層で消去を行いたいからである。
  % |   - そうすると消去領域の内部に一部でも含んでいる階層については、消去領域の端まで移動を行い、
  % |     消去領域を完全に含む階層に関しては何も変更しないというふうにするのが現実的である。
  % |     しかし、その様な動作を実際に行った時にそれは自然な動作になるのかというのも考えておく必要がある。
  % |     例えば abc[defg]hijk という風になっていて現在位置が f にあるとする。
  % |     前方に向かって 1-3 文字消去する時には abc[   g]hijk という様になる。
  % |     更に前方に向かって 4 文字消去すると ab    [g]hijk という形になる。
  % |     また、初めに 3 文字消してそれから 4 文字目を消去すると ab [  g]hijk という形になる。
  % |     この様な不連続性は実際に行った時に気にならないだろうか。
  % |
  % |   | というかそもそも DCSM が表示部になっている時には一体どのように処理したら良いのか謎である。
  % |   | 一つ一番簡単な実装方法は一文字ずつ消去した時とまとめて消去した時の結果が同じになる様に設計して、
  % |   | それから消去対象の位置について一つずつ消去を実施していくという物である。
  % |   | 一文字ずつ消去しても動作が変わらない様にするというと、消去位置で完全に階層構造を解除するという物が考えられる。
  % |   | - その様な実装だと ICH をどの様に処理するのかが疑問として残る。ICH でも完全に階層構造を解除するのか、
  % |   |   或いは ICH に関してはその時の階層構造を尊重して挿入を行うのか。
  % |   |   特に DCSM で表示部になっている場合にはどの様に考えるのが良いのだろう。
  % |   |   特に ICH に伴うシフトをどの様に行うのかというのも問題である。
  % |   |   もし完全に階層構造を解除するのだとしたら、(1) 先ずは見た目に従って文字列を完全に分割する
  % |   |   (2) その後でシフトを実行するという様にできる。注意するべきは (1) でも字の並び替えが必要になるという事である。
  % |   |   ただ (1) さえ実装してしまえば後は簡単である。
  % |   |
  % |   |   また DCH について考えてみると…もし階層構造を完全に解除してからシフトなどを行うという事にしていると、
  % |   |   ある階層構造の中の或る文字を削除した時に、その文字があった箇所の前後で bidi string が分かたれてしまい、
  % |   |   見えない "切れ目" ができてしまう事になる。
  % |   |   その後の文字の書き込みなどで正しく bidi が処理されなくなるという問題が生じる。
  % |   |   そもそも DCH 等の非自明な操作を行ったときでも bidi が保たれる様に要求するべきかという話もあるが、
  % |   |   できるならば自然でありなおかつ予想可能な振る舞いをするのが良いように思う。
  % |   |
  % |   | - うーん。思うに DCSM で表示部だったとしても文字列の範囲をどの様に縮めるか、
  % |   |   もしくは拡大するか、文字列を削除するかといった様な論理はデータ部の時と同じである。
  % |   |   違うのはデータの表現方法との間に複雑な変換が必要になってしまうという事のみである。
  % |   |   従って、余りデータの変換方法などについては考えない様にして、
  % |   |   先に見た目での文字列の処理方法を与えるほうがよい。
  % |   |   編集が実際にデータ部にたいしてどの様になされるかの変換については後で考える事にすれば良い。
  % |   |
  % |   | さて DCSM に対して作用する事も考え合わせれば update_markers_on_overwrite は恐らく使えそうにない。
  % |   | この既存関数とは別に新しく考えるのが良いような気がする。
  % |
  % |   [結論]
  % |
  % |   - DCSM(PRESENTATION) に関しては先に見た目での文字列の消去・短縮を決定してから、
  % |     それを実現する様にデータ部に対して加工を行うという様に考える。
  % |     恐らく複雑な文字のシフトを伴う変換が起こるがそれについては後で考える。
  % |   - update_markers_on_overwrite については忘れる。
  % |
  % | うーん。やはり ECH においては其処にある bidi string は全て除去するのが自然な気がする。
  % | 一方で DCH は現在の階層において削除を実行する。
  % | ICH は現在の階層において挿入を実行する。端から出ていった物に関しては ECH と同様に消去を行う。
  % | それを元にして再度ルールを決め直すのが良い気がする。
  % |
  % | 次に問題になるのは aligned string のマーカの移動に関してである。
  % | ECH に於いては消去範囲の中に aligned string マーカが存在する場合に削除を行う。
  % | 隣接している場合には削除は行わなくて良い。
  % | 問題は DCH や ICH を行う際に移動範囲に ECH が含まれていたとしてそれを一緒に移動するかどうかである。
  % | 一緒に移動しないと文字だけがずれるので変な事になる。
  % | 一方で一緒に移動すると全て解除するというのも変な気がする。
  % | 或いは、aligned string の内部にある文字列は移動しないという風にする可能性もあるかもしれないと思ったが、
  % | やはりそれは ICH してから何かを上書きするという様な使い方などを考えるに、文字列を動かさないのは駄目である。
  % | 結局、一緒に移動せざるを得ないという風に考えるのが良いだろう。
  % | では、中に設置してある tab stop についてはどうするか。一緒に動かすかそのままかという選択肢がある。
  % | MULTI の場合には DCH でずれる様になっていると全体で共通のタブという状態が崩れてしまう。
  % | その事を考えればずれないという実装にするのが自然である様に思う。
  % | つまり、後になってまた HT 等で移動を行った時は DCH をする前の位置にまた上書きをするという形になる。
  %
  % [結論]
  %
  % - ECH は階層構造も全て消去する。内部の aligned string marker は削除する。
  % - ICH, DCH は現在の階層構造において実行する。DCH において内部の aligned string marker は削除する。
  %   ICH においてシフトで押し出される内容はその階層で削除する。つまり、DCH で削除する。
  %   (実は ICH と DCH は全く同じ実装で行けるのではないかという気がする。)
  % - 何れにしても隣接する aligned string marker はそのままである。
  % - SIMD の影響は受けない。代わりに HEM の影響を受けても良い。
  % - DCSM(PRESENTATION) の場合には表示部における消去・挿入・削除をデータ部にどの様に反映させるかについて考える必要がある。
  %   単純に表示部の範囲をデータ部の範囲に写像して消去を行うと駄目である。階層構造がばらばらになってしまう。
  %   上の階層にある文字列から順に適用していって分割統治で行くような感じに実装したい。これは後で考える。
  %
  % ----------
  %
  % 次に考えなくてはならないのは DCSM(PRESENTATION) の時にどの様に表示部での編集をデータ部での編集に変換するかである。
  % それを考える為には先ずどの様に問題を分割して、そして個々の場合についてどの様に場合分けをするかが重要になる。
  %
  % 取り敢えずは aligned string については考えない事にする…というか、aligned string に関しては
  % データ部と表示部での差異については考えないという実装だったはずだ。
  % つまり、aligned string に関しては特別の変換は必要ないという事になる。
  % また方向付き文字列の内部に aligned string が含まれているという事も設計上無いはずだから、
  % 結局 aligned string の削除についてはデータ部と表示部での差はないという事になる。
  %
  % 問題は方向付き文字列が存在する時の処理についてである。先ず初めに ECH について考える。
  % ECH の領域と方向付き文字列がどの様な関係になるのかというのには幾つかのパターンが考えられる。
  % 1 先ずは ECH の領域が方向付き文字列に完全に含まれている場合である。
  %   今 ECH の領域が eb <= x < ee として方向付き文字列が sb <= x < se であるとする。
  %   sb <= eb && ee <= se の時 ECH 領域が方向付き文字列に含まれていると判断する。
  %   この場合には方向付き文字列内部の座標で ECH を実行する様にすれば良い。
  % 2 次の場合は ECH の領域が方向付き文字列を完全に含んでいる場合である。
  %   これは eb <= sb && se <= ee という条件で表される。
  %   この場合には単純に方向付き文字列諸共削除してしまえば良いだけの話である。
  %   1 かつ 2 の場合には 2 の取り扱いで良いだろう。
  % 3 次のパターンは eb < sb && ee < se という様な場合である。
  %   この場合には消去領域は二つに分割される。
  %   先ずは eb <= x < sb に当たる部分に関しては現在の階層で消去を行う。
  %   そして sb <= x < ee に当たる部分に関しては更にその方向付き文字列の内部で消去を行う。
  % 4 逆に sb < eb && se < ee という場合もあるが、これは 3 と同様に処理すれば良い。
  % 結局以上のことを文字列の入れ子階層に従って実行すれば良いという事である。
  % ここで注意しなければならないのは 3, 4 において ECH は階層構造を消去するという事である。
  %
  % ----------
  %
  % | この時方向付き文字列の中身をシフトしなければならない。
  % | どのタイミングでシフトを行うか・どの様にしてシフトを行うかについてはまた考える必要がある。
  % | というか 1 の場合にも分かたれた２つの部分それぞれについてシフトを実行しなければならない気がする。
  % | 更にどんどん文字列が入れ子になっている場合には単純なシフトでは済まないだろう。
  % | 一体どの様に処理すれば良いだろうか…。一つの方法は一旦表示部に内容を転写して、
  % | 消去を行った後で再びデータ部に転写する方法である。この方法は簡単で安全であるが、余りスマートでない様にも思う。
  % | もしもっと簡単に位置関係・シフトなどを表す表式があればそれを採用したい。それについて考える。
  % |
  % | 一回数式にしてみようとも考えたが複雑になりそうである。
  % | 数式を見ても簡単な形に単純化することができるとは思われない。
  % | 一旦簡単な場合で考えてそれから入れ子がある場合を考えていくという様にしたい。
  % | 入れ子のない一番単純な場合で反転領域の内部を消去する場合は、
  % | 右の端に残ったデータと左の端に残ったデータを交換しなくてはならない。
  % | つまりシフトもしくは swap の様な物が必要になる。
  % |
  % | とここで思ったのだが入れ子が複雑になっている場合はシフトもしくは swap の組み合わせで対処できるようには思われない。
  % | というのも、原理上入れ子を組み合わせる事によって任意の置換を表現する事ができるはずで、
  % | 表示部での単純なシフトでさえデータ部では複雑な置換になりうるからである。
  % | 置換は循環の組み合わせで書くことが出来るが独立な swap で組み合わせて書くことはできない。
  % | つまり、何れにしても原理上は swap やシフトを複数回実行しなければならない訳である。
  % | なので、シフトを複数回ではなくて一回で実行するという事に拘る事はできないし、しなくても良い。
  % | 結局、シフトの組み合わせで実装するという事を受け入れて良い気がする。
  % |
  % | 入れ子の構造がある場合の問題は、交換する領域 (右端のデータと左端のデータ) の境界が
  % | 更に内側の文字列の内部にあるという場合である。しかし、これに関しては
  % | 内側にある文字列から順番に交換・消去を実行していけば良い。
  % | 先に内側から交換すれば、外側の文字列で交換を実行する時には
  % | 丁度内側の文字列の境界が交換領域の境界に一致する様になっている。
  %
  % [まとめ]
  %
  % DCSM(PRESENTATION) の時は ECH は見た目が変わらないようにデータ部で文字の並び替えを実行しなければならない。
  % 特に反転文字列内部で消去部分の右側にある部分と左側にある部分の内容を交換する必要がある。
  % 表示部・データ部の変換および文字の並び替えに関しては、内容交換を階層ごとに実行する事によって行う。
  % 入れ子階層の一番深いものから順に消去・分割・内容交換を実行していけば良い。
  %
  % ----------
  %
  % 次に考慮しなければならないのは文字列を切断した時にどのようにマーカを更新するのかという事である。
  % 交換に際してマーカも一緒に交換しなければならない。そのまま愚直にその様にするのが良さそうである。
  % "交換を全て実行した後の位置" というのを計算するのは面倒そうである。
  % (或いはオフセットを計算できるだろうか?)
  %
  % - うーん。というか文字列を分割する時の表現はどの様にするのが良いか。
  %   マーカにするべきかそれとも文字列の配列にするべきか。
  %   マーカで交換をそのまま実施するのは困難を極める。というのも、
  %   マーカが必ず開始と終端のペアになっているとは限らないからだ。
  %   という訳でマーカで移動を行うとしても正規化などの操作が必要になるだろう。
  %   更に正規化したとしても一つの文字列が "開始" と "終端" という複数の (離れた) 要素からなるため、
  %   移動・交換などの処理が面倒である。但し、"文字列" の配列であったとしても
  %   入れ子になっている子孫も一緒に移動しなければならない事を考えると大した違いはないかもしれない。
  %   何れにしても正規化という手順を踏む必要性がある事を考えれば、
  %   マーカでの処理は諦めて普通に "文字列" で並び替えを実行して、
  %   その後でそれをマーカに逆変換する方が自然である。
  %
  % ----------
  %
  % 2018-02-19 暫く時間を置いたので現状でどこまで実装したのかが何だか良くわからない状態になっている。
  %
  % ToDo: 後シフトの際に中途半端に全角文字の半分だけシフトするという事がない様にする。
  %   消去される領域が中途半端に被っている場合にはその全角文字全体を削除する必要がある。
  %   また、そもそもマーカが全角文字の中途半端な位置に挿入されない様に設計しておく事も必要である。
  %   (ただ、それでも何かの拍子にマーカが全角文字の途中に置かれる事も考えられなくはないので、
  %   その様な中途半端な事が起こっても大丈夫な様に設計したい。)
  %
  % ToDo: ICH, DCH についても場合分けを考える必要がある。
  %
  % 2019-04-04 ECH について時間を費やし過ぎである。
  % うーん。紙に書くなどして簡単に実装することはできないのか。
  % そもそもどの様に方向付き文字列を表現していたかを確認する必要がある。
  %
  % board_line に std::vector<line_marker> m_markers; というメンバがある。
  % line_marker は curpos_t position と nested_string_type stype というメンバを持つ。
  % nested_string_type には方向付き文字列、反転文字列、
  % 横位置合わせ文字列 (string_aligned) の三種類がある。
  % というか string_aligned とは何だったか…。
  % 確認すると TATE TALE TAC TCC 等である。
  % これらは次の string_aligned が現れると其処で範囲が終わると見なされる。
  %
  % * update_markers_on_overwrite の実装を見ると、
  %   1. aligned string は次の aligned marker が現れる迄の範囲を表す。
  %   2. aligned string の終わりは方向付き・逆転文字列の終わりを表す。
  %     これは workaround というよりも実際にそういう表現を正当な物として許す。
  %
  %   というより update_markers_on_overwrite の実装が変な気がする。
  %   これに対応するテストという物は存在するのだろうか…。
  %   うーん。明らかにテストは実装されていない。
  %   勝手に実装し直す事にする。
  %
  % うーん。そもそも現在の表現方法自体がおかしい気がするが…。
  % まあ、これで実装を続けるとするとどうなるだろうか…。
  % とも思ったが、やはり微妙である。
  % ICH だとか DCH だとか色々実装しなければならない物は沢山ある。
  % その時にも毎回この様に複雑な事を考える必要があるのだろうか。
  % もっとすっきりした表現で簡単に実装する事はできないのだろうか。
  %
  % 例えば ECH を実装する際には、文字列の開始位置・終了位置を
  % 削除範囲の両端に寄せれば良いのでは。
  % その上で空の文字列を削除する様にする。
  % TATE 等で設置した aligned 文字列は単に削除する事にする。
  % と思ったが、途中で方向付き文字列の内部で消去が起こった時は微妙。
  % 方向付き文字列の内部のままという事にしておくと、
  % 後から其処に何かを記入した時に意図しない表示になってしまう。
  % 従って、現在の実装では方向付き文字列を分断して、
  % 其処には文字列が現れない様にするという様に実装している。
  % うーん。結局昔の考察の通りに ECH は階層構造も全て削除するという仕様にする。
  %
  % DCSM(PRESENTATION)の時の動作については。
  % というか DCSM(PRESENTATION) はどの様に実装しているのだったか。
  % 恐らくカーソル位置はデータ部での位置になっている。
  % それを表示部での位置に変換して更に其処から右にN文字進んだ場所までを削除領域とする。
  % それをデータ部での消去に変換する必要がある。
  %
  % 最終的な結果は完全に階層構造を取り除いた状態というのは DCSM(DATA) の時と同じ。
  % うーん。競技プログラミング勢だとあっという間に実装してしまうのだろうか…。
  % 取り敢えず、データ構造は考えない事にして、構造とアルゴリズムについて考える事にする。
  %
  % (1) 表示部における範囲を決定する。
  % (2) トップレベルの反転文字列から再帰的に処理を行う。
  %
  % うーん。どうも滅茶苦茶構造が汚い。全く駄目だ。実装し直したい。
  % そもそも marker で文字列を表現しようとしたのは何故だったか。
  % 1. 実際の文字の配列と別個に管理したかった。
  % 2. 受信するのは開始マーカと終了マーカである。
  % という事だった。従って、marker で管理するのが自然であるとの考えであった。
  % 然し、marker による表現は実際の構造を反映しているとは言い難いので、
  % 具体的な操作を実装しようとすると対応するマーカを探し出すという事を
  % 毎回実行しなければならない。従って、色々と面倒な事になってしまう。
  %
  % 実は文字列に関しては真面目に木構造で保持した方が良いのではないだろうか。
  % うーん。

  これはデータ形式を変更して実装し直した。

* ansi: SPD の実装 [#D0035]

  見た目を変えずに charpath が反転する為には
  データ部での反転を実行しなければならない。
  然し、strings などがあると複雑になってしまう。
  どの様に処理するのが正しいのか。

  因みに strings は終端していない場合は強制的に終端しても良い物だろうか。
  例えば反転文字列を書き込んでいる途中で SPD による反転が実施されたとする。
  この時反転文字列の続きを記入できる様にするべきだろうか。
  考えてみるにそうではない気がする。やはり反転が起こったらその時点で固定化する。
  つまり、strings は終端を明示的に挿入する様にするという事なのである。

  さて、どの様に実装したら良いだろうか。
  update_strings は実行する必要がある気がする。

  a 例えば以下の様に実装する。
    先ず update_strings で得られた結果を反転する。
    然し単純に逆転させれば良い訳ではない。
    開始点について昇順に元々並んでいるが、
    これは終端点について昇順であるとは限らない。
    そして、それに基づいてマーカーを挿入しながら
    文字を順番に登録していく。
    中に含まれていた文字列のマーカーは全て無視する。

    と思ったが色々問題がある。
    零幅文字と文字列開始・終端の順序が保たれない。
    それに update_strings を end について
    ソートし直さなければならないのは面倒。

  b 例えば、始めに文字列終端を設置していく。
    完全に設置して対応が取れている状態になって、
    その時に始めて反転を実施し始める。
    反転する時には予め update_strings で得られた
    情報を元に開始マーカーと終了マーカーを入れ替える。

    或いは update_strings のルーチンを改造して、
    その時にもう開始マーカーと終了マーカを入れ替えるべきだろうか。

  取り敢えず b で実装できた気がする。

* ansi: カーソル移動について。 [#D0034]
  これは色々調整が必要かと思っていたが
  実は表面的に書き換えたら簡単に動く様になってしまった。

* ansi: SGR 等。 [#D0033]

  取り敢えず鬼門だった ICH, DCH, ECH の類を実装できたので、
  SGR 等の機能について移植していく事にする。

  うーん。これらの属性は拡張フラグを使って実装されている。
  面倒なので attribute_t に沢山関数を生やして実装する事にする。
  後で拡張したくなっても大丈夫な様にする為に。

* ansi: ICH, DCH も同様に実装するべき? [#D0032]

  どの様に実装するべきだろうか。
  ICH に関しては現在の位置に文字を挿入する。

  SIMD の影響は受けない様である。HEM の影響を受ける。
  DCSM の影響も受ける。

* ansi: ECH 取り敢えず実装した。まあこんな物だろうか…。 [#D0031]

2019-04-08

* ansi: ECH (DCSM(PRESENTATION)) [#D0030]

  さて、問題の ECH である。これの実装をどの様に考えるか。
  思うに Unicode Bidi を考え始めると訳が分からなくなるし、
  もっと言うと Unicode Bidi を考慮に入れて端末にシーケンスを
  送ってくる様なアプリケーションが存在するとは思われない。
  強いて言えばユーザが画面を見た目で操作する為にその様な物を送るぐらいか。

  さて、今となっては NUL が segment separator の役割をしているので、
  DCSM(DATA) の時には単に ECH は NUL を書き込むだけで良い。
  NUL を書き込んだ場所より後の反転の効果は解除されるが、
  まあ、データ部は marker も含めた文字列の集合なのだと思えば、
  その様な振る舞いは自然なのである。

  DCSM(PRESENTATION) の時にはどの様に取り扱うのが良いのだろうか…。
  表示部に於ける各点に対応するマス目を消していけば良いのだろうか。
  然し、そうすると変な事になる気がする。更に境界上に乗っている
  marker をどの様に取り扱うのかが謎である。
  というか PRESENTATION というからには、やはり見た目を保持したい気もする。
  Unicode bidi を対応しないという決断をした今、実はその様な実装は可能の気がする。

  文字列 m_strings_cache の情報は使う前提である。
  結局、前半部分までの文字列と、後半部分までの文字列を生成して、
  それを接続するという事にすれば良いのではないだろうか…。

  前半部分までの文字列は内容を変更しない様に構築しようとするとどうなるか?

  * ゼロ幅の文字の取り扱い

    | 取り敢えずゼロ幅の文字をどの様に取り扱うのか決めておく必要がある?
    | ゼロ幅の文字も一緒に反転して表示する前提にした方が良いだろうか。
    |
    | 例えばデータ部で ...[A|B|C|D]... となっていて
    | 表示部で ...[D|C|B|A]... となっている時に、B 以降を削除するとする。
    | 得られる結果は表示部で ...[D|C|] という事で良いのだろうか。
    | というか ECH はできるだけゼロ幅を残す様に実装すると考えれば、
    | 実はあんまり考えなくてもゼロ幅文字をいつも残す様にしておけば良い気がする。

    →ゼロ幅の文字はできるだけ拾う様にする。

  うーん。取り敢えず…。前半部分の範囲を取得するコードを書く事にする。

  | 早速何がどうなっているのか分からなくなった…。
  | 結局何をしたいのだったか。
  | 持っているデータは何かというとデータ部で見た時の入れ子の構造である。
  |
  | 外から中に見て行った時に、反転を起こす。
  | 更に範囲で見ているので範囲が分断されたり色々する。
  | 分断された範囲をそれぞれどの様に取り扱うのか。
  |
  | 例えば [] で切り取り範囲を () で反転範囲を示すと、
  | 以下の様な場合には [>>>(<<<)>>>] 三分割される。
  |
  | 或いは [>>>(<<<]<<<) という様な場合には、
  | () に要求するのは後半の3文字である。
  | うーん。実は要求はデータ位置で行っておけば良いのではないか?
  | 何だかよく分からなくなってきた。データ位置というか、
  | その反転範囲に取ってのデータ位置というべきである?

  a うーん。ちゃんと木を作ってから処理すればできる気がするが、
    今のデータ構造の儘で単純に深さ優先で並列に処理する事は可能なのだろうか。
    そのノードの中に入る時に座標を変換して、そして出る時にまた変換を戻す。
    そんな風にして処理していけるのだろうか…。
    行ける筈だが何だか面倒な感じしかしない。
    先ず、ノードに入る・出るというのを検出しなければならない。

  b うーん。特にノードを出たというのを判定するのが難しいのではないか。
    と思ったが、それは parent を記録しておいて、それが減ったら抜けたと思えば良いのか?

    前回処理した i と現在の parent を比べる。現在のノードが前回処理したノードの
    子供ならば i - 1 == range.parent になる。現在のノードが前回の兄弟ならば、
    strings[i - 1].parent == range.parent になる。前回のノードが抜けたのであれば、
    strings[i - 1].parent > range.parent になる。
    そんな感じに先ずは抜けたとか入ったとかを検出できる様にしたい。

  取り敢えず b によって入ったり抜けたりするのは試験的に実装した。

  | この段階でどの様に実装したら良いのだろうか。
  | 少しずつ考える事にする。今見ているのは常にデータ部での範囲である。
  | 基本的には文字を削除するのと等価なのでデータ部での順序は保たれる。
  | 問題は切り取る範囲をどの様に動的に管理するのかという事である。
  | 実は簡単な気がしてきた…。
  |
  | と思ったがそうでもない。途中で範囲が二つに別れたりする…。
  |
  |   表示部   ----[--**]**--
  |   データ部 ----[**--]**--
  |
  | うーん。push する度に結局何処か別の場所に範囲を記録しなければならないのだろうか。
  | 更に入れ子が増えていくとどんどん分裂していく事になる。これに対処するのは難しい。
  | 結局スタックか何かを用意して処理していくしかないのだという気がする。
  | そして、現在の範囲は現在のノードの中でのみ有効と考える。
  | →残っている断片をスタックに記録して処理する事にした。実装できた。
  |   動作テストもしてみた。ちゃんと動いている。

  スタックに分断した断片を記録する事にして、範囲取得は実装してテストした。

  * ネスト状態の復元について

    うーん。然し、本当にこんな実装で良いのだろうか…?
    というか文字列の始まりと終わりについて記録しなくて良かったのだろうか?
    またネスト状態の追跡をしたいという要望もあるのである。
    もしネスト状態の追跡をしたとして、範囲で拾った物の前にネスト状態の復元を置いたとする。
    しかし、範囲で拾った物に既にネスト状態の更新が含まれていたらどうするのか?
    うーん。含まれていたり含まれていなかったりの気がする。
    という事を考えてみると実はネスト状態の復元に必要な点もリストに含めておく必要がある?

    本当だろうか。境界上の marker は全て拾う様になっているので、
    境界に至る直前のネスト状態を復元すれば良いという事になるのではないか。
    然し…境界上の marker を全て拾うというのはそれはそれで厄介である。
    重複して前後して拾ったりはしないのか? と思ったがデータ部の上でちゃんと
    順番に列挙する様になっているので境界が重複しているという事はない筈である。

  うーん。と思ったけれどやはり微妙な気がしてきた。
  必ずしも先頭ではないのである。少し動かしてみる。
  必要なのは丁度先頭に来た部分に対して状態を復元する事である。

  因みに削除直前の部分に関しては特に処理は必要ない。
  というのも NUL を置いた時点で其処で文字列が強制的に終了するからである。

  * 因みに NUL にした所に文字を書き込んで行くと、
    文字列が延長されて混ざり合ってしまう。
    この様な振る舞いをよしとするかどうかは微妙である。

    a まあ、再び同じ内容を書き込んだら復元できるという様に考えたらこれでも良い気がする。

      x と思ったが、表示部でそうなる様に文字を書き込むというのは困難がある。
        実際に書き込みが行われるのはデータ部であって、
        データ部に於けるデータの並び方に関しては既に並び替えられてしまっているので、
        再び復元する事は不可能である。

    b 或いは、何らかの文章を途中に書き込むのが目的と思えば、
      勝手に混ざり合ってしまうのは都合が悪いという考え方もある。

    その様に考えると実は、ちゃんと終端して置いた方が良い気がする。
    →終端する様に実装した。

  * テストが不十分な気がする。
    もっとちゃんとテストするにはどうしたら良いか。
    テストコードを書いた。幾らか試した。動いている気がする。

  * find_innermost_string についてもテストして置きたい。
    →テストを書いた。ちゃんと動いている。完璧な気がする。OK

* ansi: to_data_position [#D0029]

  これの実装はどうしたら良いのか…。

  [>>>>[<<<<x<<<<]>>>>]

  持っているのは presentation_position なので、
  反転範囲が終わるまで見ないと分からない気がする…。
  うーん。一旦、完全な string のリストを作ってしまう事にするか…。
  そして外側から順に中に入っていくという作戦。
  これが元々の contra の実装である。

  もっと簡単にする事は果たして可能なのだろうか。
  うーん。一旦、対応する終端までジャンプすれば可能なのだろうか。
  とも思ったが、其処から更に後退していく等の処理を考えると、
  やはり一旦完全な string のリストを作ってしまう方が楽の気がする。
  これは既存の実装を参考にするのである。

  実装した。動いている。

* ansi: to_presentation_position [#D0028]

  nested_state を追跡する事で計算できるだろうか。
  要するに目的のデータ点 x を含む nest について
  深さを以下の様に書いた時 (x を含まない nest は書かない)、

  [>>>>[<<<<x<<<<]>>>>]

  x より前にある >>> と x より後にある <<<< の数を集計すれば良い。
  また、都合上 x と同じ位置にあるマーカーは x の直前にあると見做す。
  先ずは x が現れるまでループを回す事を考える。
  その間に nest を開いたり閉じたりする事になる。
  x に出会った時にどの状態になっているかを調べる。

  nest を記録する時に何を記録するべきだろうか。
  始まりの位置? それから方向?
  stack の中にある逆方向の文字列の数も調べておくべき。
  途中で中断できる様にしたいので。

  contra::ansi における文字列の入れ子の解釈

  1. SDS(1) SDS(2) SRS(1) によって文字列を開始する
  2. SDS(0) によって対応する SDS に当たるまで全部閉じる。
    SRS(0) によって対応する SRS に当たるまで全部閉じる。
    対応する物がない場合には無視する。
    例えば SDS(1) aa SRS(1) bb SDS(0) cc SRS(0) は [aa[bb]]cc と解釈される。
  3. NUL に当たった時は全部閉じる。
    (但し、NUL は HT 等によってフィールドを移動した時に設置される。)

  取り敢えず実装した。幾つかテストケースを試してみて動いているからよしとする。

* ansi (line_t::proportional_glb): [#D0027]
  もっとまともなデータの保持の仕方はないだろうか…。

  a 例えば std::multiset で良いのではないか
    % …と一瞬思ったが、ICH や DCH をする度に位置を全て書き換えなければならず非効率的である。
    % と思ったが、実は ICH/DCH の頻度は低いし全て位置を書き換える方法の方が効率的なのでは。。

    x 然し、その場合には monospace の時とデータ構造を切り替える必要がある。
      o 何れにしても工夫をするのであればデータ構造を切り替える必要があるのは確実である。

  b 或いは最後に触った位置を記録しておけば良いのかもしれない。
    どうせ前から後ろに向かって書き込んでいく場合が殆どなのだから、
    実は最後に触った位置を記録しておけば問題は起こらない。

  →取り敢えず b の様にして最後の位置を記録する様にした。
    SIMD で逆方向に進んでいる時は毎回全て計算する事になるが、
    まあ気にしない事にする。

* ansi: wcwidth に相当する物を自分で実装する [#D0026]
  これは ble.sh にテーブルがあった筈なのでこれを流用する。
  →これは enc.c2w に実装した。contra::encoding::c2w である。
  取り敢えず現在の端末の c2w_width_emacs でテストを続ける事にする。

  monospace 側も non-monospace 側も正しく動作している様に見える。

2019-04-05

* [棄却] bidi: 文字列の構造はマーカではなくてちゃんとした構造に変更する [#D0025]
  そもそも文字列はそんなに頻繁には使われないので複雑な構造でも大丈夫の筈。
  但し、文字の記入などのあらゆる操作に対して文字列がある場合には色々と考察が必要になる。

  取り敢えず試験実装として現在の実装と並列にする事にする。
  試験実装の構造には prefix として xxx をつける事にする。
  リスト構造にしようか、或いは vector にしようか。
  そんなに要素が増えないと思えばリスト構造である。
  メモリを節約しようと思うとリスト構造になるだろうか。
  然し、最悪の使用方法の場合を考えると vector の方が効率も良い。
  実装は断然 vector の方が楽である。

  うーん。属性化領域だとか色々考え出すと余りにも複雑である。


2016-10-19

* [2016-10-14] "文字列" データ構造再考 [#D0024]

  | -- 方向付き文字列の表現について --
  |
  | タブなどの仕様について調べた結果、"文字列" の記録方法に変更を加えた方が良いような気がする。
  | タブの仕組みの内に TATE, TALE, TAC, TCC という物があって、これは
  | ある HT と次の HT または CR, NEL の間を一つの単位として
  | 表示する時の配置を指定する物である。
  |
  | SRS, SDS の文字列の内部で HT や VT を行った時の動作が未定義になっているのはそういう事だろう。
  | また、他にも文字列のある場所にカーソルを移動して其処に文字を挿入すると、
  | 文字列の内部に文字が挿入される形になるという仕様についても合理的な実現方法を考えなければならない。
  | 思うに、SRS, SDS は "data stream の中に文字列の開始を意味するマークを挿入する" という意味なのだから、
  | その通りにデータ部の中身を一つの stream と思って其処にマークを挿入するという風に処理するという手があるのではないか。
  | しかし、それをそのままやるとデータ形式を全く変えなければならないし、また、データの位置と表示位置との対応が崩れるので、
  | 様々の処理の効率も悪くなる。そもそも文字列だとか特殊な配置を持つタブだとかを使う機会は殆どないのだから、
  | その様な機能のために overhead を追加したくない。そう考えれば、文字列のマークなどのデータは別に管理したい。
  | 結局、現在は文字列のデータとして開始点と終了点のペアを管理しているが、
  | それを直接更新する事によって状態の変化を追跡するのではなくて、
  | 単にマーカの位置と種類を保持する様なデータ構造を追加するというので良いような気がする。
  | もし座標の対応関係などを取得したくなったら、それらのマーカの情報を用いて計算を行うか、
  | 或いはその都度開始点と終了点のペアのリストの構造を構築してそれを元にして計算を行う様にすれば良い。
  |
  | -- タブ揃えなどの配置の実現方法 --
  |
  | もう一つ考えて置かなければならないのは変なタブ配置が設定されている時の表示の方法である。
  | a 一つの手はデータ部では文字の重なりなどは全く気にしないという事である。
  |   データ部の内容を元にして描画する時に全て処理するという風に考える。
  |   しかし、問題は普通の端末ではそもそもそういう変な揃えタブに対応していないという事である。
  |   受信側の端末では表示がそれっぽくならなくても仕方がないという風に捉えるのであれば、
  |   そのままデータ部の内容を転送するようにすれば良い。
  | b しかし、受信側の端末が様々の機能に対応していなくても、
  |   それっぽい表示にするようにしたいというのであれば、色々と考えなければならない。
  | 思うに、データ構造としてはデータ部の中にマーカとして保持するだけで十分である。
  | これらの問題はデータ部の中に保持している時の問題ではなくて、描画する時の問題である。
  | つまりレンダラの都合でそれらの機能に対応したり対応しなかったりという風にして良いのではないか。
  | そして他の端末に内容を転送する場合には
  | a 変な揃えタブの機能は無視して出力するか
  | b 変な揃えタブの機能を STAB, SDS や SRS を埋め込んで出力するか
  | c contra 側で配置を行った後の結果を転送するか
  | という風にして良い気がする。
  |
  | 但し、描画する時に正しくカーソル位置を動かせる様にする為には
  | やはり描画した時にどの位置にどの文字が表示されるのかという情報を計算できる必要がある。
  | うーん…。本当に必要だろうか。特に問題になるのは上下移動を行おうとした時だろうが、
  | 見た目にカーソル位置がずれても別に問題ないのではないだろうか。
  | むしろ複雑なカーソル位置判定を行うとアプリケーションの側で
  | それに応じた動きをするのが難しくなるのではないかという懸念がある。
  | まあ、これはどちらでも良い気がする。
  |
  | いや、しかしレンダリング先が複数ある場合には困る。
  | 或る表示処理系ではある配置をされて、別の表示処理系では別の配置をされて、
  | という風になっていると表示部での移動というのをどの様に取り扱うべきかというのは難しくなる。
  | また、フォントだとか字間だとかそういうのの取り扱いも入ってくるとより難しくなるだろう。
  | その様に考えれば、実際の所表示部での移動というのは内部的なデータ構造から計算できる範囲に留めておいて、
  | 表示する時の様々な配置に関しては追随しないという様な実装が無難である様に思う。
  |
  | 上記の様に "文字列" などの構造は (規格にある通りに) 所詮は始まりと終わりを扱うマーカであり、
  | そのマーカは制御機能に依って明示的に挿入される物で、自動的に範囲を考慮して辻褄が合う様に
  | 生成されたりするものではないのだという立場にたてば実装が大分すっきりする。
  | そもそも、端末の場合文字を受け取る度に端末の状態が更新されるわけで、その様な場合に
  | 途中の中途半端な "文字列" の状態が何であるのかというのを色々定義しようとするのは無理がある。
  | それならば単にデータ部に埋め込まれたマーカであると考えた方が楽であるし、自然な定義になる。

  [現在の結論]

  1 先ず方向付き文字列などのデータはマーカの配列 (1) として表現する
  2 場合に応じて一時的なデータとして文字列の開始点と終端点のペアを保持する配列を
    (1) から生成して使っても良い。
  3 TATE などによるタブ揃えの処理とデータ部を完全に分離する。
    つまり contra::board 上では表示部における細かい配置については関知しない。
    ただ、属性値として保持するだけに留める。
    "表示部に置けるカーソル移動" の制御機能は方向付き文字列による文字位置の入れ替えのみに対応する。
  4 端末を出力先とするレンダリングにおいては、
    タブ揃えなどの配置について関知せずにそのまま出力する物と、
    内部的に配置をしてからそれを出力する物の二種類を考える事ができる。
    特に後者については実装方法について考える必要がある。


  | -- 配置をしてから端末に出力する場合の実装方法 --
  |
  | この実装をする時に注意しなければならないのは、できるだけ出力するデータを少なくしたいという事である。
  | 例えば配置をし直す度に全データを出力するなどという実装にしていると環境によっては遅くて仕方がない。
  | 従って、できるだけ出力先の端末の持っている機能を用いて簡潔な出力になる様にしたい。
  |
  | ところで、実際の仕様では TATE だとか SDS だとかを使う機会は殆どないと思われるので、
  | そういう物が使われない限りは普通に動作して、そういうのが使われる場合に限っては
  | 遅くても仕方がないという考え方でも良い様に思う。
  |
  | さて、次の問題はいざ使われたという時に一体どの様なデータ構造に依って現在の表示状態を表現するのかという事である。
  | 一番簡単な方法は、何のデータ構造も使わず、行を更新する必要が生じる度に完全に一から表示内容を構築するという方法である。
  | そして差分のある部分だけを出力する様にする。もう少しちゃんと考えるのであれば、ウィンドウシステムの様にしてしまうという手もある。
  | つまり、表示する領域毎にオブジェクトを定義し、
  | 各オブジェクトの重なりなどを計算して一番上にあるオブジェクトの内容が表示されているという様に処理する。
  | そして或るオブジェクトの内容に更新があったとすればそのオブジェクトの表示されている領域について再表示を行い、
  | またそのオブジェクトの位置やサイズが変わったとすればそのオブジェクトが新しく占拠する領域、または、
  | そのオブジェクトが退去した領域について再度どのオブジェクトが一番上に来ているのかという事を計算し直す。
  | ここで難しいのは実際のデータ部におけるデータの更新はオブジェクトに対する操作という形になっている訳ではないという事である。
  | ちょっとした操作によってオブジェクトが完全に組み変わったりする。
  | そもそも "或るオブジェクトの位置が変わる" とか "大きさが変わる" とかそういう風な更新ではなかったりする。
  | 面倒なので取り敢えずは非自明な行に関しては行の内容を毎回完全に生成するという形にする事にする。
  | 後で必要性が生じればもっと効率のよい方法を模索する事にすれば良い。

  [現在の結論] (端末を出力先とするレイアウトエンジンについて)

  1 非自明な設定のない行に関しては単純に出力を行う。
  2 非自明な行に関しては毎回行内容を全て構築して出力するという形態をとって良い。
  3 余裕があれば、先ず方向付き文字列の部分についてだけは対応を行う。
  4 更に余裕があればウィンドウシステム的にオブジェクトの入れ子構造を構築・管理して、
    効率の良い更新ができないか模索を行っても良い。

  という訳で現在のデータ構造を変更する事になる。
  現在のデータ構造を変更した時の影響範囲はどれくらいになるだろうか。
  調べた所、外部から使っている箇所は現在はテストコードだけという事がわかった。
  皆 to_data_position/to_presentation_position 経由で情報を使っている。
  この二つの関数さえ修正すれば自由に変更できる状態にある。

  | 取り敢えずデータ構造は確定した。
  | 次に実装するべきは to_data_position/to_presentation_position である。
  | これを実装する時にどの様な戦略が考えられるかについて一度考察したほうが良い。
  | また、その前に文字列の始まりと終わりの対応が取れない場合などに
  | 一体どの様に処理するかなどについても確定しておく必要がある気がする。
  |
  | a 一つの方法は始点と終点の対応を取って配列に格納してからそれを使うという方法である。
  |   これにすれば既存の to_data_position/to_presentation_position を流用できる。
  |
  |   しかし to_data_position/to_presentation_position を呼び出す度に配列を構築するコストがかかる。
  |   これについてはどうにかならないだろうか。
  |   例えば一つの方法は始点と終点のペアの配列をキャッシュする様にしておいて、
  |   前回から変更がなければ前回のデータを使うという風にすれば良い。
  |
  |   x しかし問題は marker の配列に変更がなかったとしても、
  |     行の内容の文字列の側に変更があると文字列の終端位置などに影響が出るという事である。
  |     つまり、前回から変更があったかどうかというのの判断は行内容も含めて実行しなければならない。
  |     これだと駄目である。なので、何とかこれを回避する方法はないだろうか。
  |
  |     例えば、特に行内容で影響を与えているのは "行終端" = "行の内容が存在している一番右端の位置" だけの気がする。
  |     だとすれば、行終端を表す特別な値 -1 などを使ってキャッシュすれば良い気がする。
  |     しかし、本当にデータ部における行内容が影響を与えるのは行終端だけなのだろうか。
  |     例えば行内容で一番初めに文字がある位置というのは影響を与えない。
  |     何故なら文字列の始まりはかならず明示的に指定されるからである。
  |     問題なのは文字列の終端がまだ受信されていない "過渡的な文字列" なのである。
  |     また、当然行内容の文字が入れ替わっても何の影響もないだろう。
  |
  |     但し、文字挿入の際に或る marker を跨ぐような文字が設置されると困る。
  |     でも、その際にはそれによって marker の除去もしくは修正が行われなければならないから、
  |     結局それに依って marker 列に変更が生じるので変更検出については問題ない。
  |     しかし、この文字挿入時の marker 修正については留意しておく必要があるだろう。
  |     marker の位置をずらすのだとしたら後方にずらして、もしその他の marker と衝突するようであれば
  |     それらも広報にずらす様にする必要がある。その際に長さ 0 の文字列が発生すればそれは削除する。
  |     しかし aligned tabulation に関してはずらすというのは変なので削除する。
  |     削除する時には、対になる end marker が既に来ているのだとしたらちゃんとそれも削除しなければならない。
  |     そうしないとその他の文字列を一気に閉じる事になり望まない結果になる様な気がする。
  |
  |     結局そんな理由で行終端だけが文字列範囲の決定に影響を与えると思って良さそうである。
  |
  |   所で、どの様にしてその様な対応関係の配列を生成するのかというのは一つの問題である。
  |   効率的な方法があるかどうかについてはまた後で考える必要がある。
  |   うーん。結局 stack の様な構造を作って処理するしかないのだろうか。
  |   それだと結構コストがあるような気がするが。しかしだからといって
  |   再帰にするとスタックオーバーフローの危険性があるし、うーん。
  |
  | b 或いは、対応関係を配列に入れなくても処理する方法はあるだろうか。
  |   例えば始点が来た時に終点をその場で計算するという方法が考えられる。
  |   この方法を使えば新しくメモリを確保するなどの手間が省けて良い。
  |   しかしこの方法だと始点ごとに入れ子になっている部分について
  |   同じ計算を実行する事になり非効率的な気がする。
  |   結局処理の見通しの良さなどを考えてもこの方法は取りづらい。
  |
  | まあ a で実装するのが現実的な気がするので、それで行く。
  |
  | + SIMD で文字が逆方向に進んでいる時には一体どうするのか?
  |   - SDS 開始と終了を反転させた順序で認識しなければならないのだろうか。
  |     しかし思うにデータ部内の内容自体がデータストリームであって、
  |     SIMD で文字を逆方向に進めるというのはデータ部内の "データストリームに対する編集" の一つだと考えるならば、
  |     文字を挿入する時に逆方向に進んでいたとしても、
  |     最終的に解釈する時にはその時にデータ部に記録されている内容から SIMD に関係なく文字列などの構造を決定するべきである。
  |     従って SIMD がどうだとかそういうのによって marker の解釈を買える必要はない。
  |   - もう一つ考えて置かなければならないのは過渡的な状態についてである。
  |     データ部に逆方向にデータを格納できるとすると、例えば SDS 終端を先に記録して、
  |     その後で SRS 始端を書き込むという事が可能になる。その過渡的状態で何か問題になる事はないだろうか。
  |     先ずそもそも終端のマーカだけでは SDS の場合には、その文字列の方向を決定できない。
  |     なので SDS の場合には終端マーカだけで有効な文字列として解釈するというのは不可能である。
  |     従って、SDS 終端マーカしか存在しない場合にはそれは単に無視するという風に処理するのが無難に思われる。
  |     だとすれば SRS の終端マーカの場合にも同様に処理するしかないだろう。
  |     それに終端マーカだけ存在していた時に、例えばそれを行頭までの文字列と解釈しようとすると
  |     文字列入れ子状態キャッシュ配列の処理もより複雑になる。
  |     といっても "行頭" を表す特別な値 "-2" に対して処理を書くだけのような気もするが。
  |     何れにしても余り凝ったことをしても自然な振る舞いになる様に思われないので、
  |     終端マーカだけしか無い文字列に関しては単に無視するというので良いだろう。
  |
  | + 一つの行に設定できるマーカの個数に上限を設定する必要がある。
  |   もしくは複数のマーカを縮約する方法について取り決めれば論理的に上限の数があるかもしれない。
  |   例えば同じ位置で始まって同じ位置で終わる文字列というのはくっつける事ができるのではないかという事である。
  |   そして入れ子になっていなければならない (閉路がない) という事と、空の文字列はないという事を考えれば、
  |   文字列は最大でも (行の文字数) * 2 - 1 個しか作成できない。
  |   但し、過渡的な状態として開始マーカを大量に仕込むことが出来る。
  |   開始マーカの時点ではそれぞれのマーカの終端が同じになるかどうかについて何も分からないので、
  |   結局終端マーカが来るまでは縮約については保留しなければならない。
  |   だとすると結局縮約をするとしてもマーカの個数に上限を設定しなければならないという事だから、
  |   そもそも縮約などの面倒な事も考えなくて良さそうな気がしてくる。
  |   ただ、マーカの個数の上限は (行の文字数) * 4 以上でないと不都合が生じるケースが
  |   存在するという事は分かった。なのでマーカの個数の上限は十分大きくとっておくことにする。

  [結論] 記録したマーカの処理方法について

  - 文字挿入時の marker の修正。全角文字の挿入に依って marker 位置の上に文字を上書きするとき、
    a その marker が aligned tabulation による物である場合にはそれを削除する。
      もし対応する終端マーカ (通常の tabstop への HT) がある場合にはそれも削除する。
      但し、それよりも前に aligned tabulation marker がある場合には削除しない (フィールド連結になる)。
    b その marker が SRS/SDS 文字列である時には marker の位置を新しく挿入した文字の終端に移動する。
      この時、文字列長が 0 になった場合には (つまり文字列終端が挿入文字の終端にあったときは)、
      その文字列 (同じ位置にあるマーカのペア) は削除する。

  - 終端マーカだけの存在は許す。文字列としては解釈しない。
    これは SIMD(1) による data stream 構築の過渡的状態として考えられる。

  - 一つの行に設定できるマーカの個数に上限を設ける。
    それは、論理的に配置できる文字列の個数が 2 * (行の文字数) であることから、
    4 * (行の文字数) より十分大きな物にする必要がある。
    この制限は tty_player の側でかける事にする。

  という訳で取り敢えず実装するものについて整理する。
  > 1 マーカ配列 → 文字列配列 への変換。
  > 2 to_data_position/to_presentation_position の調整。
  > 3 SDS/SRS によるマーカの挿入。
  > 4 文字挿入時のマーカ修正。
  # 5 HT によるマーカの挿入 (これはタブ実装の後で)
  # 6 一頻り実装が終わった後で様々な動作テストを行うべきである。

  5,6 に関しては別に項目を立てる。

  | [過渡的状態の文字列(非終端文字列)の取り扱い]
  |
  | to_data_position/to_presentation_position で行の終端を意味する
  | nested_string::npos を処理する必要がある。
  | しかし、そのためには行の終端を取得しなければならない。
  | line 構造体自体は行の内容について関知しないから行の終端を取得するためには
  |
  | a line 構造体自体に行の終端を格納するフィールドを用意して、
  |   行内容の変更に応じて line 構造体の行終端位置も更新する様にする。
  |
  |   # この方法を採用すると行内容の編集と一緒に毎回行終端位置を更新しなければならない。
  |   # そのまま愚直な実装で実装するとコストが高いし、
  |   # 或いは更新の方法に応じて賢い方法を考えるとすると複雑になる。
  |   # やはり使いたい時にその場で計算する方が理に適っている様な気がする。
  |
  | b もしくは、to_data_position に引数として予め計算した行終端を渡す様にする。
  |
  |   # この方法を採用すると行終端を毎回必ず計算しなければならず非効率的である。
  |   # 関数オブジェクトでも渡す様にすれば必要になった時にだけ計算する様にできるが、
  |   # 何か設計を誤っている様な気がする。
  |
  | c 或いは board の側に data_position を移して実行する様にした方が良いか。
  |   現状では presentationDirection を引数に受け取っているが、
  |   その様な情報によって計算結果が左右されるという事はやはり
  |   to_data_position/to_presentation_position は論理的にも board の管轄下にあると考えるのが自然である。
  |
  |   と思って確認してみたが、presentationDirection が記録されているのは board ではなくて tty_state の方だった。
  |   だとすると to_data_position/to_presentation_position は tty_player に実装するべきなのだろうか。
  |   しかしそれは変だ。行毎に文字列を管理しているのだから board や line のレベルで to_data_presentation
  |   に対応していないとおかしい。tty_player に実装するとなると、これらの board や line に記憶されているデータは、
  |   tty_player で board を操作している時にしか有効でない外付けの様なデータになる。
  |   だとすれば、これらの文字列のデータは board ではなくて player の方に移すべきなのだろうか。
  |   そもそも board にどれだけの機能をつけて、また、どれだけの機能を player の方に任せるのかというのを考えないと行けない。
  |   確かに双方向サポートなどというのは ANSI ターミナルを実装するときにしか使いそうにない機能である。
  |   その様に考えれば tty_player の側に実装する物の様にも思われる。
  |   しかし、一方で tty_player で管理するべきなのは "画像の出力内容をどのようにするかという設定" だけで、
  |   "実際のどの様な画像が表示されているか" に関しては board に完全に情報を持たせるべきの様にも思われる。
  |   また、各行についての設定・データを tty_player の側で管理するというのはやはり違う気がする。
  |   その様な情報はやはり飽くまで画面に付随している属性に思われる。
  |
  | どうも腑に落ちない。いろいろ考えている内に眠くなってきたので晩ごはんを食べに行く。
  |
  | 歩いていて思ったのだが、そもそも presentationDirection が tty_state の上にあるのがおかしいのだ。
  | これは board 上でどの様にデータが表現されているかという board の情報であって、
  | tty_player の振る舞いを規定するような情報ではない。それが tty_player の上にあるのがいけないのだ。
  | そもそもの方向付き文字列なども board 自体の presentationDirection を与えないと一意に定まらない。
  | さて、presentationDirection を board 上に移動するとなれば話はずっとすっきりする。
  | という訳で presentationDirection の移動を実施する。→移動した。意外と簡単に移動できた。
  |
  | 後は to_data_position/to_presentation_position の実装を board_line から board に移動するだけの筈である。
  | →これも無事にできた。

  | [文字列挿入時のマーカの上書き]
  |
  |
  | 文字列挿入時のマーカの修正方法について改めて考える必要がある気がする。
  | 実装している途中でよくわからなくなったので。
  | できるだけ様々な場合で整合的に動作する様にしたい。
  | つまり微妙な違いで振る舞いがぜんぜん違うというのは良くない気がする。
  |
  | 1 先ず初めにマーカの或る位置に文字を書き込んだ時の動作について。
  |   特に HT を行った時に設定される aligned string について。
  |   実際に実装する前には上書きする場合には消去し、
  |   隣接する場合には消去しないという風に考えていた。
  |   しかし、それだと全角で文字を出力していって丁度マーカを踏み潰す形になった場合には
  |   前のフィールドと次のフィールドが連結されるという様な形になるが、
  |   一方で、半角で出力していった場合や丁度全角文字がフィールドに収まる場合には、
  |   途中で書き込む先のフィールドが変わるという動作になる。
  |   出力位置の微妙な違いでこれらの大きな動作の違いがあるのは何か変だ。
  |
  |   そもそも、次のフィールドに移動する時に HT をするという前提で考えると、
  |   フィールドの末端ギリギリまで文字を出力するわけには行かない。
  |   そうすると、その文字を出力した直後に既に次のフィールドの位置に移動していて、
  |   その場所で次のフィールドに移動しようと思って HT を出力すると更に次のフィールドに移動してしまうからである。
  |   だとすればぎりぎりまで出力した場合には、上書きする時と同様にマーカを削除してしまって良い気がする。
  |   その次の瞬間にカーソルがそこを跨ぐから削除するという風に考えても良い。
  |
  |   改めて書くと、境界 a から境界 b に亘る文字を配置した時、a < m <= b なる位置 m にあるマーカは削除する。
  |   ではこの動作にした時に不明瞭は点は他にないだろうか。
  |   aligned string のマーカには三種類ある。純粋な終了点を表すマーカと、開始点を表すマーカ、
  |   それから開始点を表すマーカはそれより前に開始点を表すマーカがあった場合に終了点をも兼ねる。
  |   - 先ず状況の簡単そうな終了点のマーカを削除する事について考える。
  |     終了点のマーカが其処にあるという事は普通の状況では、
  |     現在出力している場所は前の開始点マーカで指定される文字列の途中という風に思われる。
  |     その時に其処に終了点が現れたらどうするか。
  |     もし、その行に対する出力が初めてであった場合には其処には何も終了点マーカなどはなかった筈で、
  |     過渡的な状態においては終了点が存在しないフィールドという物が許される。
  |     その様に考えればその様な終了点マーカは単純に削除してしまって良いと考える。
  |   - 次に純粋な開始点の場合にはどの様に処理すればよいだろうか。
  |     純粋な開始点を削除するというのは一体どういう事だろうか。
  |     先ずそれより前の部分は algned string ではないという事。
  |     なので、それより前の aligned string の整合性などについては考えなくて良い。
  |     一方で、対応する終了点について気になる。それは削除した方が良いのではないか。
  |     しかし、よく考えてみれば対応する終了点が孤立して残されたとしても何か問題が起こるという訳でもない。
  |     処理の上では単純に無視される。それならば局所的な変更になる様にしておいた方が後々様々な所での動作が自然になるのではあるまいか。
  |     しかし、これは data stream という観点から考えるとどうだろう。終了点マーカというのは HT によって次のフィールドに移った時や、
  |     NEL によってその行を終了したとき等に自動的に設置される。明示的に其処に埋め込むという物ではない。
  |     そう考えると開始点が消滅しているのに終了点だけ其処に残留するというのも変な話である。
  |     例えば、カーソル移動で適当に移動して文字を挿入したりタブを設置したりしようとすると変な事になる。
  |     従って、やはり終了点も対で削除した方が良い様に思われる。
  |   - では開始点と終了点の両方を兼ねているマーカの場合にはどの様に処理すればよいか。
  |     基本的には純粋な終了点と純粋な開始点の両方の処理をすれば良い気がする。
  |     純粋な開始点の様に前方に終了点マーカが存在すればそれと一緒に削除を行う。
  |     後は単純に削除を実施する。
  |
  |   結局動作についてまとめると、それが開始点マーカであるならば、
  |   次のマーカを探してそのマーカが終了点であればその終了点マーカを削除する。
  |   そしてそのマーカを (終了点マーカ・開始点マーカかに限らず) 削除する。
  |   また、マーカの範囲に関しては SIMD でない時には a < m <= b であり、
  |   SIMD である場合には a <= m < b にする。
  |
  |   ※実装前の考えではその点が終了点マーカである場合には、
  |   終了点をずらして今までのフィールドの長さを縮める様にしていた。
  |   しかし、この動作はやはりおかしい気がする。
  |   それだと例えばその行に既に内容が出力されているという事を知らずに、
  |   通常通りに出力を行った時に意図しないフィールド分割になってしまうという事になる。
  |   何も知らずに上書きしていっても副作用が出ない様に設計するのが良いのだ。
  |
  | 2 SDS/SRS で挿入される文字列についてはもう少し慎重になりたい。
  |   不用意に上書きをすると左右が突然反転したりして何か良くわからない事になる。
  |   上書きされる文字の部分は消えてしまうとしても、
  |   残った部分の方向性については保持する様にしたい。
  |
  |   もし、挿入文字がマーカ直前に隣接するという場合には何もしない。
  |   というのもマーカ直前に文字を挿入したとしても
  |   SDS/SRS 文字列の内容はそこに変わらず残るからである。
  |   直前に文字を書いただけで内容が破壊されるというのは変である。
  |   しかしそうするとその次に文字が書き込まれるのは文字列の内部という事になる。
  |   しかし、文字列先頭の位置はデータ部ではマーカの直後になるが、
  |   表示部で見るとその文字列の方向性に従った位置に表示されている。
  |   その様に考えると次の文字が挿入されるのはやはり方向性を考慮して計算された位置であるべきで、
  |   つまり、SDS/SRS 文字列の内部に文字が追加されるという事になる。
  |
  |   ※この動作は先の algned string の時と違う。
  |   aligned string の時には最終的な状態が空の行に出力した時と同じになる様に考えたが、
  |   今回の SDS/SRS 文字列の内部に侵入可能という様な実装では、
  |   既に其処に文字列が存在している状態で行を出力すると変な出力になってしまう。
  |   うーん。これについては後でもう少し考えたほうが良いような気もする。
  |   例えば現在の出力位置にどの様にして移動してきたのかという事や、
  |   マーカがいつ設置されたものなのかという情報を考慮に入れて文字挿入の動作を変化させるなど。
  |   しかし、それはそれで変な気もする。
  |
  |   また、挿入文字がマーカを上書きするという場合にはマーカを後ろにずらす。
  |   SIMD の場合には前にずらす様にするのが良いだろう。
  |   一つの懸念はマーカをずらす時にマーカの順序が変化してしまわないかという事である。
  |   終了マーカは開始マーカの直後になければならずその順序が変わってしまってはならない。
  |   m_markers 配列の中では勿論登録されている順序は変化しないが、
  |   しかし、位置を補正する事によって m_markers の内容がソートされているという条件が破れるのが心配だ。
  |   しかし、SDS/SRS マーカを全て同列に扱っている限りは開始マーカが後ろにずらされる事によって
  |   終了マーカの位置を追い越したとしても終了マーカも同様に後ろにずらされる筈であるから、
  |   問題は起こらない筈である。
  |   所で、ずらす事によって長さ 0 の文字列ができる事があるこれについては残しておいても良いような気もするが、
  |   やはり削除してしまったほうが自然な動作と思われる。従って、これについてチェックして削除を行う。
  |   これは終了マーカを移動した時にチェックを行えば良いであろう。
  |
  |   ? しかし SIMD の時に前方にマーカをずらすとするとちょっと微妙である。
  |     終了マーカが移動した時に文字列が潰れるかどうかの判定はどの様に行えば良いだろう。
  |     と思ったが、終了マーカも前方に移動するのでその時にやはり文字列が潰れているか
  |     どうか見極めて削除を行えば良い気がしてきた。
  |     実のところ開始マーカで判定をしても終了マーカで判定をしても良いけれども、
  |     両方移動した後に判定を実行しなければならない。
  |     そんな訳で順方向にループを回すのであれば終了マーカ移動時に文字列が潰れたかチェックし、
  |     逆方向にループを回すのであれば開始マーカ移動時に文字列が潰れたかチェックを行うという事になるのだろう。
  |     今回は順方向にループを回す実装しか考えてないので SIMD に拘らず終端マーカで空文字列判定を行えば良い。
  |
  |     うーん SIMD の時に前方にずらしたとしてその時に何か別の物を跨いだりして変な事にはならないだろうか。
  |     今のところの実装としては最終的な状態では挿入文字の内部にマーカが残る様な事はない。
  |     従って、SIMD の時に前方にずらしたとして追い越すとしたら元々文字内部または文字の境界にあったマーカだけである。
  |     うーん。SIMD で前方にずれるマーカというのは文字内部のマーカである。それが追い越すとしたら
  |     文字内部のマーカしか無い。文字内部のマーカの内 SDS/SRS マーカは同様に移動するので追い越す事はない。
  |     aligned string マーカに関しては削除されるので、これも追い越すという事はない。
  |     従って、SIMD で前方にずらしたとしても SDS/SRS/alignd string markes の何れも追い越さない筈である。
  |
  |   ? もう一つの問題は終了マーカで削除判定を行うとすると開始マーカと削除マーカの二つを削除する事になり、
  |     マーカに対するループの番号を補正しなければならない。
  |     と思ったが、よく考えてみればこれは aligned string の時も同様である。
  |     削除が発生した場合には次に検索するマーカは前回と同じ i であるべきなので、i-- するか、
  |     i++ しないようにするかの対策が必要である。
  |     同様に文字列が潰れた事の判定に依ってマーカの対を削除するのだとしたら単に i -= 2 などとすれば良い。
  |
  |   ? さて、しかし SDS/SRS 文字列が終端する条件は一つではない。
  |     SDS/SRS による明示的な終端だけではなく、次に aligned string マーカが存在するというパターンも有る。
  |     aligned string マーカの際に直前にある文字列が潰れていないか判定するのは面倒である。
  |     その様に考えると実は開始マーカの移動の際に一緒に終了点マーカの移動先も計算して、
  |     その上で文字列が潰れるかどうかを判定するという手のほうが良いのかもしれない?
  |     しかしそれだと入れ子になっている文字列が潰れた時に削除できない。
  |     終端マーカで削除判定を行う事の利点は、空文字列の終端マーカに到達した時には、
  |     必ず内部に入れ子になった文字列 (すべからく空文字列である) のマーカは既に全部除去されているという事である。
  |     つまり、直前の要素を見れば必ず開始点マーカに対応する物が存在するはずという事である。
  |
  |     もし直前の要素がない場合や、aligned string マーカである場合には
  |     そもそも開始点が存在しないという事になるので、
  |     そのマーカは単に削除すれば良いだろう。
  |
  |     結局、終了点マーカもしくは aligned string マーカが現れた時には空文字列判定を行うという事になる。
  |     SDS/SRS 終了点マーカの場合には移動後に空文字列判定を実施する。
  |     aligned string マーカの場合には先に空文字列判定を行って、その後で aligned string マーカの処理を行う。
  |
  |     →実装している時に気づいたが。
  |     現在の実装では aligned string マーカが現れたらその直前にある SDS/SRS を削除するという方針にしていた。
  |     しかし、この方法だと既にあってシフトの対象となった SDS/SRS だけではなくて、
  |     新しく追加した SDS/SRS マーカまでも削除してしまう事になる。
  |     つまり、alined string マーカの直前で SDS/SRS を設置してもそれが削除されてしまうという事態になる。
  |     本当に処理しなければならないのは何かというと、暗黙上書きによってシフトされた SDS/SRS に関して、
  |     直後に aligned string が存在していた時に空文字列として削除を行うという物である。
  |     元々の懸念は入れ子文字列の場合に正しく削除できないのではないかということだったが、
  |     仕方がないので可能性のあるマーカは全て確認して aligned string が一つでもあったら
  |     空文字列になると判定して削除するという具合にする。

  | [SDS/SRS によるマーカ挿入]
  |
  | 通常時は現在の文字位置の左側に挿入し、SIMD 時は現在の文字位置の右側に挿入する。
  | (そもそもその様にしないと次に全角文字が来た時に潰されてしまう。)
  | 左側に挿入する時は append で右側に挿入する時は prepend にするべきだろう。


* [2016-10-05] TAB 関連の機能 [#D0023]

  | Mode TSM
  | VT VTS
  | TAC TALE TATE TBC TCC TSR
  | STAB (ISO 8613-6) HTJ HT HTS CHT CBT CTC CVT
  |
  | 影響のあるもの: DAQ(7) DCH ICH DL IL RIS
  |
  | RLogin は HTS, DECHTS, VTS, DECVTS を認識するが、
  | 何も設定しない状態で HT を呼び出すと何が起こるのだろうか。
  | 確認する必要がある。
  | 因みに VT に関しては次の行に単に進むだけの様に見える。
  | VTS を設定してる状態で VT を実行するとどうなるだろうか?
  |
  | 1 HTS の設定に関する確認。
  |   $ printf $'\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |   xterm, screen, RLogin, mintty, Poderosa の何れも TSM(MULTIPLE) で、
  |   予め 8 の倍数の位置にタブが設定された状態で始まる。
  |   HTS を呼び出すと予め設定されているタブに加えて新しいタブを設定する。
  |
  |   TSM 対応に関して
  |
  |     $ printf $'\ec\e[5W\e[18h\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |
  |     RLogin のマニュアルを見ると TSM を ISM という名前で対応している。
  |     しかし "マルチ" と "シングル" の名前が間違っている。逆である。
  |     動作自体は逆にはなっておらず正しい。
  |     CTC(5) の仕様が異なるのは気になるが、何れにしても TSM(SINGLE) にすると、
  |     TSM の変更前に全体に共通のタブを色々設定していたとしても、
  |     各行で 8 の倍数にタブが設定された状態になる様だ。
  |     つまり、TSM の変更前のタブは引き継がれない。
  |
  |     xterm のマニュアルには何も書かれていない。実際に試しても対応していない。
  |     mintty, screen, Poderosa も試してみたが対応していない。
  |
  |   CTC in RLogin
  |
  |     RLogin の CTC(5) と CTC(6) の記述が ECMA-48 の記述と異なる。何故か?
  |     ECMA-48 側が変化したのかもしれないと思って確かめたが
  |     2nd edition から 5th edition まで記述は同じである。
  |     vt510 及び xterm にはそもそも CTC が存在しない。
  |     all-escapes.txt の内容は ECMA-48 の内容と全く同じだ。
  |
  | 2 TAC, TALE, TATE の取り扱い方法?
  |
  |   ECMA-48 に含まれるこれらの機能によって設置されたタブは特別な意味を持つ。
  |   タブ位置の前後にある文字列の配置に影響を与えるとある。
  |   しかし、実際のどの様に実装する物なのかよく分からない。
  |   まず例えばデータ部での配置に影響を与える物なのかどうか、
  |   表示部での上下左右の移動に影響を与えるのかといったことである。
  |
  |   恐らくデータ部での配置には影響を与えないつもりなのだろう。
  |   これらは飽くまで実際に表示する時にどう表示するかというのを指定するためにある。
  |   表示部での取り扱いをどの様にするべきかという事を考える前に、
  |   そもそもこれらのタブが具体的にどの様に処理されるかについて考えなければならない。
  |
  |   % 恐らく前後の文字列というのはフィールドと考えて良いだろう。
  |   % "文字列" と言えば方向付きの文字列という物が ECMA-48 の中で定義されているが、
  |   % それだと、それらが丁度タブの前後で分かたれているとは限らないのでよく分からない。
  |
  |   改めて規格の文面を見ると前後の文字列という訳ではなくて、
  |   何らかの text string があってそれが TAC などによるタブで揃えられる時には、
  |   その文字列の先端もしくは後端の位置によって左右位置の調整が行われるものと見える。
  |   また text string というのは恐らく双方向対応で出て来る strings とは別の物であろう。
  |   よくわからない点が色々ある。先ず、"tabstop by TAC で揃えられる text string" という物を
  |   どの様に指定するのかという事である。"これこれここの範囲はタブによって揃える text string ですよ"
  |   という様な感じに明示的にそれを指定する制御機能はないように思う。
  |   しかしだからといって、タブに従って揃えられますという様な表示規則も元々あるという訳ではなさそうだ。
  |   もし何かあるとすればフィールドだが、これについて何か説明が見つかるかもしれないので
  |   また改めて規格の内容をフィールドに関連して観察してみる。ECMA-48/6.7 を見る。
  |   うーん。分からない。とここで STAB の説明を改めて読むとそこに、
  |   以降の文字列を引数に依って指定されるタブ位置とその性質に従って align されると書かれている。
  |   実は TAC, TALE, TATE, TCC はこの制御機能ありきの機能なのではないだろうか。
  |   しかし、この制御機能は ISO 8613-6 に詳細を投げている。そちらも参照する必要があるだろう。
  |   ISO 8613-6 というか T.416 を見ると TAC, TALE, TATE, TCC は存在しない。やはり関係ないのか。
  |   T.416 STAB に関して見てみると、[T.416/9.1.13] のデータ構造 Line layout table を参照している。
  |   このデータ構造を見ると丁度 TAC, TALE, TATE, TCC などに対応する状態を持っている。
  |   というか、このデータ構造をそのまま採用すれば良い気がしてきた…。
  |
  |   更に、HT の説明に、もし次のタブ位置が TATE, TALE, TAC, TCC による物だとしたら、
  |   次に HT または改行が来るまでは文字列の内容はそのタブに関連付けられた文字列とすると書かれている。
  |   しかもそれは表示部で定義される物ではなくてデータ部の data stream 内で記録されるという。
  |
  | 3 RLogin で垂直タブの設定などをいろいろ試してみたがどうもうまく動かない。
  |   いつでも VT や DECSVT などは一行下に移動するという意味になる様に見える。
  |   xterm でやって見ると DECSVT は効果を持たない (対応していない?)。
  |
  |   縦タブを全てクリアしてから縦タブを設置する様にしてみたり色々したがうまくいかなかった。
  |   でもマニュアルにはちゃんと縦タブについて系統的に対応している様に見える。
  |
  |   - 一つの可能性は初期状態として全ての行に縦タブが設定されていて、
  |     更に縦タブをクリアする機能が効いていないという物である。
  |     縦タブをクリアする機能は CTC と TBC, DECAVT しかない。何れも試したが駄目だった。
  |
  |     $ printf '\e[H\e4\e[6W\e[4g\e[91m\e[10HX\eJ\e[20HY\e3\e[Hhello\vworld\e[1Ytest\e[m\n'
  |
  |     \e4 \e[6W \e[4g のどれを使っても縦タブが解除されていないという事になる。
  |
  |   - もう一つの可能性は何処かにモードがあって縦タブによる移動と
  |     単に一行下に移動するのを切り替えられる様になっているという物である。
  |     しかし説明を見ても VT もしくは縦タブに関連したその様なモードはない様に見える。
  |
  |   - 更に可能性として縦タブの設置に失敗しているという可能性がある。
  |     縦タブが存在しない場合は一つしたの行に移動するという実装になっているのかもしれない。
  |     しかし VTS も DECVTS も駄目だった。
  |
  |   - 或いは VT は常にひとつ下の行に移動するだけで、
  |     実際に縦タブするには CVT を使わないと行けない可能性もある。
  |     しかし CVT で試してみてもやはり状況は変わらない。
  |
  |   - 縦タブは1つずつ解除しなければならないのかもしれないと思って以下も試したが駄目だった。
  |
  |     $ printf '\e[H'; for a in {0..20}; do printf '\e[1g\e[3W'$a'\e[B'; done; printf '\eJ\e3\e[Hhello\vworld\e[Ytest\n'
  |
  |   うーん。RLogin は本当に縦タブに対応しているのだろうか。


  [実装方針]

  1 早々に実装方針を決定したい。
    基本的には ISO 8613-6 (というか T.416) にある様なデータ構造で保持したい。
    タブ構造は各行で保持する。但し、全体で共通のタブ構造を管理している場合には、
    共通のタブ構造と一致する限りに於いて実際にタブ配列を複製するのを避ける。
  2 TSM(MULTIPLE) のとき同じページの全ての行に適用する。
    新規行の文字タブ設定は頁毎に保持する。
  3 タブの位置は常に表示部で定義される。
    と思ったがタブと方向付き文字列の実装に関連して考察した結果、
    方向付き文字列の内部でタブは設定しないという風に考え、

2016-10-12

* Poderosa bug [#D0022]

  | Poderosa で RI を試そうとして以下を入力していたら無限ループになって死ぬ。
  |
  | $ printf 'hello\e[H\eMworld\n'
  |
  | ble.sh をロードした状態で上ボタンで履歴を表示してそれからこれを実行するとなる。
  | 具体的にどの様なエスケープシーケンスを受け取って死ぬのかは調べないと分からない。
  | 面倒だ。どの様にすれば確認できるだろう? contra で escape sequence を全て出力する?
  | 新しく escape sequence を全て出力するクラスを作った: sequence_dump
  | 関係のありそうなものだけを抽出する。DECSET(25), SGR, OSC, SI は関係ないだろう。
  |
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   CR LF
  |   unrecognized control sequence: CSI 1 L
  |   l o a d i n g   h i s t o r y . . .
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 1 1 C
  |   CR LF
  |   unrecognized control sequence: CSI 1 M
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 2 9 C
  |   p r i n t f
  |
  |   '
  |   h e l l o \ e [ H \ e M w o r l d \ n
  |   '
  |   unrecognized control sequence: CSI K
  |   CR LF h e l l o
  |   unrecognized control sequence: CSI H
  |   RI w o r l d CR LF
  |   unrecognized escape sequence: ESC 7
  |   [ b l e :   E O F ]
  |   unrecognized escape sequence: ESC 8
  |   unrecognized control sequence: CSI 2 0 7 C
  |       CR
  |   unrecognized control sequence: CSI K
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   [ b l e :   e x i t ]
  |   CR LF e x i t CR LF
  |
  |   くっつけて見る。
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\e[13D\n\e[1M\e[1A\e[5Cprintf\e[K\nhello\e[H\eMworld\n\e7EOF\e8'
  |
  |   ちょっとここまでで Poderosa に食わせてみる。何も起こらない…。もう一回実行してみる。再現した。
  |   何だろう。ただ単に printf 'hello\e[H\eMworld\n' を繰り返すだけでは起こらない様だ。
  |   もう一度やってみる事にする。起こらない。どうやら境界が下の方にできて、その境界の直後で実行するとなる様だ?
  |
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK
  |   printf '\e[H\n\e[1L\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK 再現性あり
  |   printf '\e[H\n\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\n\e[H\eM' OK

  まとめ: 以下の手順で Poderosa が死ぬ。
  (1) Poderosa で新しいウィンドウを開く
  (2) printf '\e[2H\e[L\e[M\n\e[H\eM' と入力して実行する

* escape sequence の処理の段階で NUL や DEL は無視しなければならないのではないか。 [#D0021]
  恐らくシーケンスの途中に NUL や DEL が含まれていても単に無視して取り扱うべき。

2016-10-11

* bidi サポート追記 [#D0020]

  規格を読んでも active data position と active presentation position の関係が分からないと考えていたが、
  ECMA-48/6.3/4 に書かれている。この段落はとても重要な段落である。

  > The graphic image output is constructed in the presentation component from the data stream stored in the
  > data component, and according to the line orientation and line progression of the presentation component.
  > The presentation of characters along a line in the presentation component is dependent on the character
  > path, the character progression and the direction associated with the string.
  >
  > 訳: 記憶部に記録されたデータストリームから、表示部の行送りの方向と行の向きに従って、
  > 表示部に画像出力が構築される。行内の文字の表示は文字進路・文字進行・文字列の方向に依る。

  acative data/presentation position の関係について全てがこの段落に含まれている。
  他の部分の記述や ECMA-TR/53 の記述を組み合わせて解釈したのと整合しているので、
  実装について変更を行う必要はないという事が分かった。つまり現在の実装を変更する必要はない。
  そのことが分かっただけでも大きな成果である。

* 全角文字の取り扱い in ECMA-48 [#D0019]

  ECMA-48/6.3/3 に行は predetermined number of character positions からなると書かれている一方で、
  ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている。
  つまり、全角文字などは複数の character position を専有するという扱いではなくて、character position 自体の
  大きさが大きくなるという解釈なのだろうか。だとすると一行に収める事のできる文字の数は全角・半角に関係なく、
  ただ表示する時に全角文字で構成された行はサイズが大きいという風な扱いということなのだろうか。
  これは実際の端末の実装とは一致しないし、何より変だ。しかし、異なっても良いし固定でも良いと書かれている
  (may be fixed or may be depend)。文字に依って専有する character position が複数でも良いという風に何処かに書かれていれば
  それが実際の実装と一致した物と考える事ができる。でも 6.1.6/2 には implicit movement によって
  the active data position is moved to the following character position と書かれている。the とついているので、
  やはりこれは一つ次の character position に移動するという事である。

  ECMA-48 的には
  - 行に全角文字が含まれていても行に入れる事のできる "文字数" は同じで、
  - 例えば SLH SLL で設定される文字番号は幅ではなく "文字数" でカウントされ、
  - CUF や CUB では半角幅毎ではなくて文字毎に移動するべきなのか…。

  これは実際の端末の実装と乖離しているし、それに実装として不自然である。
  また全角幅の文字は普通に使われる機能なので、今ここで ECMA-48 に厳密な実装にすると色々な問題が実用上生じる。
  どう考えても、実際の端末の実装の方が自然で現実的な実装であるので、ここでは ECMA-48 を無視する。
  これについて Note を残しておく事にする。

2016-10-05

* SPH/SPL [#D0018]

  page_home_position -> page_home, page_limit
  取り敢えず値を設定できる様にする。

* sequence_decoder, sequence: support ESC sequence [#D0017]
* escape sequences の解釈 [#D0016]

2016-10-04

* SCP SPD に対応する。 [#D0015]
* CR ... SCP SPD の向きが逆の場合に対応する。 [#D0014]

* data position と presentation position の変換方法について。 [#D0013]

  SCP による character path の方向は基本的な計算部分に影響を与えない。
  何故ならば character path は presentation position の番号と、
  実際に表示される位置の対応関係を規定する物であって、
  data position と presentation position の間の関係には影響ないからだ。
  但し、directed string の ltor と rtol は、
  character path によって意味が入れ替わるので注意する。

  従って、計算の上で気にしなければならないのは directed_string だけである。
  directed_string によって向きが反転している範囲の中にあれば反転するという事をしなければならない。


  presentation position -> data position の実装は比較的簡単である。
  1 先ず presentation position を x とする。
  2 directed_string のリストから x を含む
    一番大きい directed_string を拾って str とする。
    もし x を含む directed_string がもうなければ処理は終了する。
    ここで x は記憶部で最終的に必ず str の範囲に含まれる事に注意する。
  3 もし str の向きが外側の向きと一致していなければ x の位置を反転させる:
    x = str.end - 1 - (x - str.begin);
  4 以降は str 及び、その中に含まれる directed_string のみを考えれば良い。
    従って、str に含まれる directed_string のリストについて 2 に戻って繰り返す。

  data position -> presentation position については少々厄介である。
  presentation position -> data position の逆の処理をすれば良いかと考えたが、
  外側と較べて反転しているかどうかを知るためには外側から順に辿って
  一旦何処で反転が起こるのかを記録しなければならない。
  もっと賢い方法はないだろうか。
  反転は線形の関数である事を思えば、shift の量だけを記録すれば行ける気がする。
  反転が起こる度に、

    x = -x + (str.end + str.begin - 1)

  という事になる。i 回目での shift 量を

    shift[i] = str[i].end - 1 + str[i].begin

  とすれば、最終的な結果は、

    x[i] = -x[i-1] + shift[i],
    (-1)^i x[i] = (-1)^{i-1} x[i-1] + (-1)^i shift[i],
    (-1)^n x[n] = (-1)^0 x[0] + ∑[i = 1 .. n] (-1)^i shift[i],
    x[n] = (-1)^n x[0] + ∑[i = 1 .. n] (-1)^{n-i} shift[i]

  で求められるという事になる。但し、i の小さな shift の方が、
  より小さな範囲の directed_string に対応している。
  今、番号付けを変更して k = n - i とすれば、
  一番大きな単位の directed_string が k = 0 に対応する様になる。

    x[n] = (-1)^n x[0] + ∑[k = 0 .. n - 1] (-1)^k shift[n-k].

  これで行く。自身がないので様々な例に対してテストを実行して確認する。

    x[n] = (-1)^n (x[0] + ∑[i = 1 .. n] (-1)^i shift[i])

* tty_player (SGR): ANSI font [#D0012]

* bidi サポート [2016-10-02] [#D0011]

  具体的にどの様に実装するべきかについて。
  これは ECMA TR/53 の Appendix にある動作例が参考になる。

  思っていたのと似たような動作を考えている様だが、実際にはもっと複雑である。
  具体的には nested strings という仕組みが問題である。
  行の中に配置を反転して表示するべき領域を埋め込むという構造は想定していた。
  しかしその様な文字列を幾らでも入れ子にする事ができる様なのである。

  問題点が二つある。

  1 先ずその様な入れ子構造を表現するのに適したデータ構造は一体なんであろうか。

    勿論、愚直にそのまま実装すれば実装できない事はないが、
    パフォーマンスなどへの影響が気になる。
    特にこの様な、実際に使う人が本当に存在するのかどうか不明な謎機能のために、
    フラットな配列の構造を諦めて何らかのリストの様な構造にするのは受け入れがたい。
    つまり、基本的には配列の構造にデータを記録しておいて、
    この様な埋め込み文字列の様な物を表現したい場合に特別な取り扱いをするというのが良い。
    その時にできるだけシンプルに最小限のデータサイズで記録する方法があれば良い。
    特に、入れ子構造を表現する為の固定長のデータ表現が存在しうるかという事である。

    例えば各セルにネストレベルを記録したらどうだろうか。
    そうしておけば同じ位置でネストレベルが複数段階変化する場合に対応できる。
    (ab[[cde]fgh]ijk の様な感じの入れ子構造が存在しうる。)
    しかしそれだと各ネストレベルでどの方向性を持っていたかという情報を保持できない。
    或いは完全に別のデータ構造として構造を保持するという手の方が現実的なのかもしれない。

  2 もう一つは後から編集が起こって別の文字を上書きした時に、
    どの様に更新範囲を検出するのかという事である。
    更に関連して編集の順序を記録しないでもちゃんと一意的に座標の対応を取る事ができるのかというのも気になる。
    また SHP や SLL を変更した時に既に出力した内容について
    どのような表示を行うべきかについても考える必要がある。

  うーん。その前にもっと詳しく動作について考えておく必要がある。

  文字列をどの様に記録するかについては 2016-10-04 に議論を残した。
  具体的に文字列の挿入を行う時にどの様に動作するべきかについては後で考える事にして、
  取り敢えずはデータ構造を確定する事にする。

  →データ構造は Memo 2016-10-04 にある通りに、
    方向付き文字列のリストとして表現する事にした。
    後で問題が起こればその時にまた変更すれば良い。


* SLL/SLH と DCSM の関係 [#D0010]

  | DCSM(PRESENTATION) の時 DCSM(DATA) の時で動作が異なる。
  | ここで問題になるのが実際に効くのは、
  | SLL/SLH を設定した時の DCSM なのか、
  | それとも実際に CR などを実行する瞬間の DCSM なのかという事である。
  |
  | もう一つ気になるのは、SLL/SLH を設定した時の DCSM が効くという場合に、
  | それを data component における座標に対応させる事は可能なのかという事である。
  | (つまり単に data component における座標を記憶しておくだけで良いのか、
  | 或いは、SLL/SLH を設定した瞬間の DCSM の状態も
  | 一緒に記録して置かなければならないのかという事である。)
  |
  | これを決定する為には、CR の動作を詳しく調べて、
  | それに整合する様に決めなければならない。
  | 例えば DCSM(PRESENTATION) で CR/LF を実行した時に、
  | LF によってカーソルが丁度下に移動する様にしたい。
  | もしくは DCSM(DATA) の時に CR/LF して、
  | LF によってカーソルが data component 内部で丁度下に移動する様にしたい。
  |
  | CR について調べた。CR 自体の動作が DCSM, SIMD によって、
  | SLL の値を使ったり SLH の値を使ったりという風になっている様だ。
  | そして SLL/SLH が設定された時の DCSM がどうたらという様な記述は全くない。
  |
  | a つまり、SLL/SLH の側では特に DCSM の値によって記録方法を変えたり
  |   という事はしなくて良い様に思う。
  |   それに、その方が自然である。つまり、DCSM や SIMD によらない
  |   一定の範囲が存在して、CR の方がモードによって変化するという事である。
  |   範囲自体が DCSM や SIMD を切り替える度に変化するというのは変である。
  |   一方で DCSM(PRESENTATION) DCSM(DATA) の切り替えによって、
  |   見た目の範囲が変わってしまう。
  |
  | b (他の例) DCSM(PRESENTATION) か DCSM(DATA) かに拘らず表示部での表示位置で
  |   記録するという様な実装も考えられたが、DCSM(DATA) の状態で
  |   SLL/SLH した行で表示部・記憶部で複雑な座標の対応になっている場合、
  |   記憶部での値で指定した列を表示部での座標に変換して記録する事になる。
  |   どの様に動作するかを予期するのが難しく、しかも使い所が分からない。
  |   うーん、訳が分からない。
  |
  | やはり自然なのは a である。
  | ECMA-48 の説明には SLL/SLH の項目で矢鱈説明がされていて、
  | SLL/SLH した瞬間に複雑な処理をしなければならない様に錯覚するが、
  | これらの説明は単に CR や他の制御機能にどう影響を与えるかを説明しているだけと思われる。
  | というか、CR や他の制御機能の説明の所に書かれている動作をそのまま再度説明しているだけで、
  | ECMA-48 SLL/SLH の部分に書かれている説明は冗長である。
  | 丁寧という事なのかもしれないが規格書らしくないし、却って混乱を招いている。
  | ここは単に "CR/IL/DL/NEL で参照される、行内の使用範囲の先頭列を設定する" とか書いておけば良いのだ。

  [結論]

  - SLL/SLH によって記録される情報は単に一つの列番号であり、
    DCSM の状態に応じて変化する様な物ではない。
  - 機能 CR/IL/DL/NEL を実行する際に、
    それぞれの機能が DCSM の値に応じて SLH または SLL の値を参照する。

* 双方向テキストに対応する際の動作について [2016-10-02] [#D0009]

  | ★例えば nested strings の中で行末に達して、折り返し処理をしなければならない場合にはどうすれば良いのか。
  |
  |   例えば [one [two [three] four] five] の各箇所で改行が起こった場合にどの様になるべきだろうか。
  |   但し一番外側の括弧で括られた部分は左から右で、その内側の括弧で右から左になり、更に内側で左から右になっているとする。
  |   折り返しがない場合には、[one [ruof [three] owt] five] という具合に表示される。
  |
  |   1 もう少し単純化する。[one [two] five] の場合はどうだろう。[one [owt] five] と表示される。
  |     これで tw の直後で改行が起こったとする。こうか?
  |
  |       [one [wt
  |       o] five]
  |
  |     或いは、
  |
  |       [one [ow
  |       t] five]
  |
  |     元の言語の文章に於いて改行を考えるとすれば前者の様な気がする。
  |     しかし改行の後に一番左に配置されるというのは元の言語の文章ではないことだし、
  |     また、これはその言語の文章というよりも外側の言語に埋め込まれた物だと思うと、
  |     埋め込まれた部分の内部で内側の言語の改行ルールによる改行が行われるというのも変である。
  |     つまり、改行というのは一番外側のレベルで行われる物なので、
  |     一番外側の言語の規則で行われるべきものなのではないかという気がするのである。
  |     だとすると後者のほうが正しいという事になる。
  |
  |   2 具体的な例で考えてみないと感覚がよくわからない。
  |
  |     日本語は古くは右から左であったが、しかし、
  |     これは、基本的に縦書きで高さが狭い場合には右から左になるという事であって、
  |     本当に右から左なのかというと微妙だし、更にそこで改行を入れることがあるのかというともっと微妙である。
  |     それに普段使っている訳ではないので実際にこれで例を作ってみた所で感覚はよく分からない。
  |
  |     どちらの方が自然だろうか。これは縦書きの日本語の文章に含まれた英文でも同様の事が言えるだろう。
  |     英単語を右に 90 度傾けて印刷する場合には問題は起こらない。英語も日本語も上から下に流れるからだ。
  |     しかし、もし仮に英単語を左に 90 度傾けて印刷する事になった場合にはどうだろう。
  |     英語は下から上に読まなければならない。そしてその途中に改行が入った場合に、
  |     英単語をどの様に並べるべきだろうか。考えて見るにどちらでもありの様な気がする。
  |
  |     取り敢えず、埋め込まれている部分が短い場合には外側の言語のルールで改行し、
  |     内側の言語については一旦行内に全て配置してから見た目で改行を実行するのが自然そうだ。
  |     つまり、1 の例で言えば後者である。
  |     しかし、ある程度の長さの文章(複数行に跨る)が埋め込まれている場合には、
  |     1 の例で言えば前者の様にした方が自然な気がする。
  |     でもやはり総じて後者の方が良いような気がする。
  |
  |   3 ここで TR/53 の例で参考になる物はないか改めて調べてみる事にする。
  |
  |     うーん。途中で改行したりという事はしていない様だ。
  |
  |     % というかそもそもの SRS の動作がよくわからない。
  |     % →と思ったら勘違いだった。data component を見ていた。
  |
  |
  | ★一番初めに各 SRS や SDS の動作について確認しておくべきだ。
  |
  |   SRS 元々確立されている方向性とは逆方向の文字列の開始・終了を定義する。
  |
  |     [ECMA-48] における記述は以下の通りである。
  |
  |     但し、character progression (data component 内の文字の記録順序) は影響を受けない。
  |     つまり、data component の中で見ている限りには SRS はあってもなくても変わらない。
  |     ただ、presentation component における位置との対応を考える為には、
  |     SRS が何処で始まって何処で終わっているのかといった情報を記録する必要があるだろう。
  |
  |     また、"文字列" 中で CVT HT SCP SPD VT によって引き起こされる効果については定義されない。
  |     また are に関係する機能 DAQ, EPA, ESA, SPA, SSA は文字列の中では用いてはならない。
  |
  |   SCP
  |     これは表示の際の方向を指定する。
  |
  |     途中で改行したりした時に一体どういう扱いにするつもりなのかと考えて改めて ECMA-48 を参照してみると、
  |     この制御機能は "現在の行" 及び "それ以降の行 (subsequent lines)" に対して適用される物のようである。
  |
  |     では、既に確立した行に対してはどうなのだろう。例えばカーソルを移動してそこに何か書き込んだ時はどうなるか、
  |     これは TR/53 の動作を見るに、後で SCP してからその行に戻って其処に文字を書き込んだとしてもその行の
  |     characater path は変わらないという様に見える。それでは一旦カーソルを上に戻して、その場所で SCP したら
  |     一体どうなるのだろうか。もし subsequent lines というのが行番号が現在いる行よりも大きい全ての行、
  |     という意味であるのだとすれば既に表示している内容に影響を与えるという事になる。
  |     一方で、もし subsequent lines というのが新しく作成される行なのだとしたら、
  |     既に出力されている行については影響を受けないという事になる。
  |
  |     うーん。説明を読むと、現在の位置に既に書かれている内容をどの様に処理するかについては書かれているが、
  |     subsequent lines の内容をどの様に処理するかについては何も書かれていないので、
  |     新しく生成される行に対してのみこの character path が適用されると考える方が自然だろう。
  |
  |     然し、一方で subsequent lines in presentation component という表現もされれているので、
  |     見た目で現在行よりも下に表示されている全ての行に対して適用するという意味なのかもしれないが、
  |     もしそうだったとすると規格の文章にはミスがあるという事になる。
  |     既に表示されている内容についてどの様に処理するかは active line については記述があるが、
  |     subsequent lines については記述がない。しかし、"subsequent lines にも同様に適用する"
  |     だとかいう感じに簡単に一文付け加えるだけで済むはずなので、この記述がないという事は、
  |     そもそも subsequent lines は空の新しい行であるか、
  |     或いは規格を記述・確認した人たちがうっかりしていて思い至らなくて書き忘れたかのどちらかである。
  |     しかし、規格を記述するにあたって実現不可能な変な記述がないように参照実装ぐらいは行って、
  |     規格に問題がないかというのを確認するのが普通だと思われるし、
  |     特に記述がないという事は subsequent lines というのは新しく生成される行という事で問題ないだろう。
  |     →この解釈については escseq.html に記述する事にした。
  |
  |   TR/53 の二つ目の例を見る限り、文字列の中で新しく文字の挿入を行った場合は、
  |     入れ子のレベルはその部分におけるレベルに埋め込まれる形で文字が挿入される様だ。
  |     つまり、その場所に移動した時点でそこにある入れ子レベルに従う事になる。
  |
  |   結局、一通り ECMA-48, ECMA-TR/53 の内容を gh-pages/escseq.html にまとめた。
  |   結局不明な事は不明なままであるが、何が不明で何が分かっているかが多少すっきりした様に思う。
  |
  |   * 自動的な折り返しに際してどの様に振る舞うかについては記述はない。
  |   * 文字列の中で制御機能を用いて移動を行った場合にどの様に振る舞うかについても記述はない。
  |   * 文字列中での active data position は定義されていない。
  |     しかし TR/53 Annex A で何かしらの方法が与えられている様にも見える。
  |   % * "文字列" の中に後から文字を挿入して追加することができる。
  |   %   これはとても厄介である。
  |
  | ★文字列の入れ子構造は記録部に記録されるのか? そして後で挿入を実行できるのか?
  |
  |   % "文字列" の中に後で内容を追加する事はできるのかできないのか。
  |
  |   TR/53 の Example 2 を見ると、一度出力して確定した "文字列" の入れ子構造の内部に
  |   後から文字を挿入する事によって、入れ子構造を変化させる事ができるという様にも見えた。
  |   しかし、落ち着いて考えてみると実はそうではないのかもしれない。というのも、
  |
  |   1 先ず、規格を参照して見るに strings だとか nested strings の概念があるのは、
  |     data stream だけであって、data component や presentation component に関しては、
  |     string がどうのこうのという記述はない様に思われる。
  |     従って後になって入れ子構造がどうのこうのというのは変なのではないか。
  |
  |   2 また、別に入れ子構造を保持していなかったとしても、
  |     data component と presentation component でそれぞれ独立に文字の挿入を行って、
  |     同時に data position と presentation position の対応関係をセル毎に記録したとする。
  |     その様な動作をしている限りにおいては Example に出ているのと同様の効果が得られるであろう。
  |
  |     しかし何れにしても対応関係をセルごとに記録するとしても、
  |     文字が新しく来る度にその対応関係を大幅に更新しなければならない。
  |     少なくとも文字列が閉じるまでは入れ子構造を保持しておく必要がある。
  |     但し、文字列が閉じた後は内部の並び替えは起こらない物と思って、
  |     入れ構造を記録したデータについては削除しても良い。
  |
  |     然しながら、data/presentation positions の対応表を保持するぐらいであれば、
  |     実のところ元になった入れ子構造を記録しておいても良い気がする。
  |
  |
  |   さて、これを区別するためには TR/53 の Example 2 で挿入する文字列について、
  |   "方向を明示せずに挿入する"、もしくは "SRS 文字列を挿入する" という例があれば良い。
  |   文字列の入れ構造に挿入されるのだとしたら、"方向を明示せずに挿入" した結果、
  |   挿入点の方向に影響されて文字列が表示されることになる。
  |   一方で、単に指定した位置に data/presentation component 上で文字列を挿入するというだけであれば、
  |   "方向を明示せずに挿入" した結果として普通の文字列の向きで文字が表示されることになる。
  |   しかし、残念ながら "方向を明示せずに挿入する" 例も "SRS 文字列を挿入する" 例も載っていない。
  |   説明文には "Character insertion is always performed according to the presentation directions
  |   and the nesting level which are established by the data stream." としか書かれていない。
  |   data stream によって確立した nesting level が何処で記録されるかによって解釈が異なる。
  |   もし data/presentation component の各行・文字の位置で記録されるのだとしたら、
  |   入れ子構造を後から変更できるという事になるし、もし nesting level というのは
  |   実際にデータを受け取って書き込む時に保持するものなのだとしたら、
  |   後から文字列を挿入するのは単に data/presentation component 上の配列を見て挿入するだけという事になる。
  |
  |   と思ったが改めて SRS の説明を見ると "SRS is used to establish in the data component
  |   the beginning and the end of a string of characters as well as the direction of the string."
  |   と書かれている。つまり、SRS は data component 内部に入れ子構造を構築するという事になる。
  |
  |   それに data/presentation component の間の座標の対応を一つずつ覚えておく方法だと、
  |   結局どのように表示されているのかということが人にとって良く分からない物になる気がする。
  |
  |   [結論]
  |
  |   文字列の入れ子構造は記録部に記録する。
  |   そして文字の挿入は入れ子構造の内部で行われる。
  |
  |   但し、方向が異なる場合には新しく入れ子文字列を作って挿入するのが良いだろう。
  |   挿入点の方向について意識しなくても安全に挿入ができる様にするためである。
  |   というのはアラビア語など言語自体が方向性を持っている場合、
  |   明示的に SRS/SDS を指定しなくても反転文字列が設定されうる。
  |   その時に或る任意の場所に新しく文字列を書き込もうとした時に、
  |   挿入位置の方向に従って勝手に文字列が反転されてしまっては困るからである。
  |
  |
  | ★途中で折り返しや改行があった場合の処理方法としてどの様な物が考えられるか。
  |   先ず初めに、明示的な改行があった場合にはそのまま其処で改行してしまって良い。
  |   改行前の文字列の内容は前の行に表示し、改行後の文字列の内容は次の行に表示する。
  |   折り返しによって反転部分に改行が挿入された時の動作は微妙である。
  |
  |   a data [he][llo] presentation [eh/oll] (/ が折り返し改行挿入位置)
  |     (行毎に文字列の構造を管理し、表示内容は行分割してから方向を適用したものにする。)
  |
  |     行に入る部分までを一つの文字列の単位として切り、改行を挿入する。
  |     続きの部分はまた新しい文字列として開始する。
  |     この方法が一番単純であり実装に曖昧さが残らない。
  |     これだと外側の文字列に埋め込まれた部分文字列だという風に思うと不自然な結果になる。
  |
  |   b data [hello] presentation [ol/leh]
  |     (複数の行に跨って構造を管理し、表示内容は方向を適用してから行分割したものにする。)
  |
  |     外側の文字列に埋め込まれた形で行を構築して、その後で行を分断したという感じになる。
  |     しかし right-to-left の人にとって見れば読みにくい文章になるかもしれない。
  |     この方法だと改行に跨った領域に "文字列" が存在するという事を管理しなければならない。
  |     特に、後になって行を挿入したり行を削除したりした時に一体どの様に管理するのか謎である。
  |
  |     例えば文字列を構成するセルを一つずつ全て記録してリストにして保持するとする。
  |     - その時、最終的な結果を別の端末に転送する場合にはどうしたら良いのか。
  |       正しく転送する為には文字列を構成するセルの順序に従って端末内を
  |       色々に飛び回る様なシーケンスを生成する必要が出る。
  |     - ※例え文字列の内部で制御機能を呼び出す事が禁止されていたとしても、
  |       後になって行を追加削除したり文字を追加削除したり出来る様になっている以上は、
  |       "文字列" が連続になっている事は保証できないのではないかという気がする。
  |       或いは、挿入される行や文字は全て "文字列" の内部に追加されるという風に考えるのだろうか。
  |     - 然し、何れにしてもその様な実装は極めて不自然である。
  |       その様な動作を期待してそれに整合する様なプログラムを書くのは難しい。
  |       結局、多少動作が人間にとって不自然に思われても、
  |       曖昧さを含まない単純な規則で動作する様に実装しないと、
  |       アプリケーションプログラムを書くのが難しくなる。
  |       人間的に自然かどうかだとかそういった事に対して柔軟に対処するためには、
  |       そういったものは装置の側で対応するのではなくてアプリケーションプログラムの側で対応するべきである。
  |
  |     従って、この方法にするとしても開始点と終了点だけを保持して、
  |     それ以降に内部に行が挿入されたり削除されたりという事は気にしない様にするという手もある。
  |     つまり、開始点と終了点だけを素直に記録して、
  |     間に文字や行が挿入される場合には開始点と終了点も同じだけずらすという様な具合にしたらどうだろう。
  |     - しかし、色々と問題がある。例えば開始点と終了店の間で SCP をした時に行内容の位置がずらされるが、
  |       その時に、元々の文字列の内容があった領域は分断される事になる。
  |       間に新しく入った空白も反転の対象だと解釈すると表示が滅茶苦茶になり、
  |       SCP がどうのといった機能が効かなくなってしまうのでそれはない。
  |
  |   c data [hello] presentation [eh/oll]
  |     (複数の行に跨って構造を管理し、表示内容は行分割してから方向を適用した物にする。)

  色々に考えた結果、一定の結論を得た。
  この結論は 2016-10-04 の memo にまとめる。

  以上の事から "文字列" を管理するデータを行毎に管理する事にする。
  特に文字列を使用する事はそんなに多くない事から、実装の見通しが立ちやすい様なデータ構造を採用する。
  (開始点, 終了点, 方向) の三組を配列に格納し、未だ閉じていない文字列に関しては終了点に -1 でも代入しておく。
  implicit movement をしている限りは終了点の更新は行わない。


2016-09-27

* ECMA-48/9 の記述についてどうするか。 [#D0008]

  Control sequences や Control strings の中にある文字 (0xA0-0xFE) は、
  0x20-0x7E と同じに解釈しろと書かれている。しかし、これに愚直に従うと、
  Control strings で日本語などの文字列を送ることができなくなる。

  | というか、何故この様な仕様になっているかというと、
  | ECMA-35 (ISO 2022) に従って 7bit から 8bit に変換した時に、
  | GL に何を呼び出しているかに応じて変換後に 0x20-0x7E が 0xA0-0xFE に
  | map されてしまうという問題があるからなのだと思われる。
  | つまり escape sequences の内、CSI sequences や control strings は処理せずに、
  | ISO 2022 の sequences だけを実行してしまうことに問題がある。
  |
  | 例えばUTF-8 前提でやっている場合にはこの問題は起こらない。
  | あるいは ISO 2022 の sequences と CSI sequences
  | を同時に処理する場合にも問題は起こらない。
  | 然し、何処かに変な filter が入っていたりすると問題になる。
  |
  | 普通は端末とプログラムの間に文字コード変換が入ったりする事はない。
  | 問題になるとすればエスケープシーケンスを出力するプログラムの内部の問題である。
  |
  | | % 通常はエスケープシーケンスを出力する部分と、
  | | % 文字コードを変換する部分は分離されて設計されている。
  | | % 特にエスケープシーケンスを含む文字列を生成して、
  | | % それからそれをエンコードすると思われる。
  | | % UTF-8 にエンコードするという場合はどうなるだろう。
  | | % 多分受信側で先に UTF-8 をデコードするという仕組みにしている限りは何も起こらない。
  | | % では、ISO 2022 にする場合はどうなるだろう。
  | | % 先ず、制御文字の表現は決まっているので変な混乱は起こらない。
  | | % 一方で、0x20-0x7E が ISO 2022 を通した結果としてどの様に変換されるかは謎である。
  | | % もしかすると GR に割り当てられた上で 0xA0-0xFE というバイトで送られてくるかもしれない。
  | | % しかし、この場合は先に ISO 2022 から UTF-32 に戻してしまえば、
  | | % 結局元々の数値に戻るのでやはり問題は起こらない。
  | |
  | | つまり「送信側(アプリケーション)はエスケープシーケンスを生成してからそれをエンコードする。
  | | 受信側はUTF-32にデコードしてからエスケープシーケンスを解釈する」
  | | という取り決めにしている限りは途中の文字コードが ISO 2022 であろうと UTF-8 であろうと平気である。
  | |
  | | しかし送信側(アプリケーション)が通常文字列はエンコードしてから出力するが、
  | | エスケープシーケンスは直接書き込んでしまう、などという設計になっていると面倒だ。
  | | 受信側ではエスケープシーケンスと ISO 2022 のシーケンスを同時に処理する必要がある。
  | | その様にしておけば一応問題は起こらないのだろうと思われる。
  | | また UTF-8 だと 8bit C1 と UTF-8 を構成するバイトの区別ができないので死ぬ。
  | | ただ出力するエスケープシーケンスを 7bit C1 文字に徹していれば問題は起こらない。
  | |
  | | - gettext を使って国際化している場合などにはこれに該当すると思われる。
  | |   ただ、gettext で ISO 2022 を出力する際に毎回 GL を元の状態に戻すと思われるので、
  | |   先にデコードを実行してからでも問題は起こらない?
  | |   (そうでないと gettext を通さない英語のメッセージなどが文字化けしてしまう。)
  | |   UTF-8 の場合には 7bit エスケープシーケンスだけ出力する様に設計されていれば、
  | |   先にデコードして問題ない。8bit C1 を使っている場合にはそもそも論理的に
  | |   一意な切り出しが不可能なのでアプリケーションが壊れていることになる。
  | |   なのでそんなアプリケーションの事は気にしなくても良い。
  | |
  | | - gettext などは使わずに自前で文字列をエンコードしながら、
  | |   それでいてエンコード結果にエスケープシーケンスを挿入している場合は、
  | |   やはり問題が起こる。この場合は確かにエスケープシーケンスとデコードを同時にしなければならない。
  | |   しかし、そもそも stateful なエンコード形式を採用していながら、
  | |   そのエンコード結果を切り貼りする様なプログラムは壊れているとしか言いようがない。
  |
  | 以上の考察からまともな実装になっているアプリケーションの出力は、
  | 普通にデコードしてからその後で制御シーケンスの処理を行っても問題は起こらない筈である。
  |
  | もう一つの可能性は伝送路の途中に文字コード変換が挟まっている場合である。
  | この場合でもまともな設計のアプリケーションの出力する制御シーケンスならば、
  | 制御シーケンスは壊されずにちゃんと文字コード変換される筈である。
  | なのでこれも問題ないのではないかという気がする。
  |
  | さて、一方で気になる事もある。この ANSI (ECMA-48) が制定されたきっかけは、
  | 文字コードによってアルファベットなどの実際の数値が異なるので、
  | bit combinatinos (column/row) を用いて規格を記述する、という事である。
  | つまり、文字コードの変換をする前の生のバイト列に対して処理することを考えている。
  |
  | - うーん。プログラムを書く上では 'a' などと書くとそれがどの様にエンコードされるか (execution charset)
  |   が保証できないので危険で、だからこそ 0x61 などの様にして表現するわけだが、
  |   でもよく考えたら U'a' とか書いておけば済む話の様な気もする。
  |
  | これらの整合性については ISO/IEC 10646 に記述があるという事だった様に思うが
  | 一体どのようにしているのか実際に確かめてみる必要がある様に思う。
  |
  | http://kikakurui.com/x0/X0221-2007-01.html
  | [JIS X 0221/D.2.Note3] によると C1 の文字は U+0080 - U+009F を UTF-8 に変換した表現を持つとしている。
  | つまり、エスケープシーケンスを含んだ文字列を char32_t の列で作っておいて、
  | それをまるごとエンコードするという方式になっている。
  | [JIS X 0221/15] UTF-32, UTF-16 の時も同様のようである。

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそうしろと書かれている。
  それ以外の実装は駄目な実装なので気にしなくても良い様に思う。

  | しかし、ECMA-48/9 にある事を考えて、駄目なアプリケーションの為に
  | 途中で GL と GR が入れ替わったりする可能性を考慮に入れて、
  | CSI sequences だけは 0xA0-0xFE を受け入れても良い?
  | と思ったが例えばその後 UTF-8 に変換されたりすると、
  | 最早 iso 2022 でどの様な構成バイトを持っていたかの情報も失われてしまうので、
  | 下手に対応しないのが良い様に思う。
  |
  | うーん。改めて ECMA-48/9 を読んで見る。
  | 結局のところ iso 2022 の state に依らず同じ representation を
  | 制御機能に持たせたいが、その様にすると 7/8 bit 変換でぶれができるという事に見える。
  | そして実は iso 2022 の範囲内で扱っている限りに於いては 7/8 bit 変換のぶれは
  | 必ず GL/GR の入れ替わりしかないということが保証されているのだろう。
  | しかしそこに Unicode が入ってくると混乱が生じる。
  | Unicode から iso 2022 への変換は一意でない。
  | 同じ文字が複数の言語に含まれているかもしれないからだ。
  | だとすると GL/GR の文字化けは一旦 unicode にすると復元不可能という事になる。
  | というか文字化けとかそういうのに限らず、
  | "iso 2022 の state に依らず同じ representation になっている制御シーケンス" を
  | そのまま unicode に変換した時点で単射性が失われるので復元不可能である。

  ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、ECMA-48/9 の内容に対応する必要はない。

2016-09-24

* 取り敢えず 00/08-00/13 は実装しようと思ったが、ECMA-48 にある FF の説明が分からない。 [#D0007]

  screen では FF は単に無視される様だ。一方で ECMA-48/8.3.51 には FF は、
  列はそのままで、presentation component の中の次の form/page の
  page home position がある行に移動するという事になっている。

  然し、form だとか page とか page home position だとかは一体何なのか。
  仕方がないので ECMA-48 の初めの方の説明も見てみる事にする。
  presentation component だとか device (装置) について書かれているのは 6.1 である。

  | [ECMA-48/6.1.1, 6.1.3] presentation/data component とはそれぞれ行の集まりであり、
  | 行は文字を表示する位置の集まりである。
  | [ECMA-48/6.1.5] presentation が実際に表示される座標に関連する物であって、
  | data は内部的な座標に関連する物と考えれば良い。双方向 (bidi) の文字列表示に対応する為にある。
  | [ECMA-48/6.1.2, 6.2.4] presentation/data component はそれぞれカーソル (active position) を持つ。
  | active line/field/area/page はそれぞれカーソルが存在しているそれを指す。
  | [ECMA-48/6.1.5, 6.1.8] 両者のカーソルの位置は連動 (indirect movement) する。
  | [ECMA-48/6.1.6] 文字の挿入によるカーソルの移動は data component に作用する (implicit movement)。
  | [ECMA-48/6.1.7] 制御機能によるカーソルの移動は data copomponent もしくは
  | presentation component に作用する (explicit movement)。
  | 何れのカーソル移動の場合にも存在しない場所に移動しようとしたときの動作は処理系依存である。

  この説明の中で既に field/area/page などと言った定義の不明な語句が出てくる。
  もっと遡って調べる必要があるのか。最初の語句定義に色々載っていることに気付く。
  [4.2.7] Area: 範囲。連続する文字描画位置の集まり (必ずしも1つの行に含まれているとは限らない)
  [4.2.40] Field: ある tabstop から次の tabstop までの area (範囲)。
    但し、次の tabstop はその field には含まない。
  [4.2.56] Page: 連続する行の集合。
  [4.2.57] Page home position: presentation/data component の中でカーソルがそれ以上前へ動かせない位置。

  結局良くわからない。特に page が一体何なのかというのが分からない。
  というか出力のデバイスとして display または printer を想定するという事が書かれていたので、
  printer の場合には page というのはそのまま物理的な紙の事だと思って良いだろうか。
  だとすると、display を考える時には page という物を想定しなくても良いという事だろうか。

  改めて SPH/FF の説明を読んで見る。物理的な page だと思うとこの説明も納得が行く。
  page home position は紙を1枚送った後に何処にヘッドを置くのかという事に対応するのだろう。
  だとすれば display での自然な実装は、clear screen してから
  SPH の設定した位置を含む行に移動するという事だろうか。

  - ところで screen で試してみたが SPH にも対応はしていない様だ。
  - 次に xterm で試してみた所 FF は VT と同じ役割を持つ様に設計されている様だ。
  - mintty は xterm と同じ動作だ。
    沢山の機能を実装している RLogin はどうだろう→RLogin も xterm と同じく VT で実装している。
    SPH 等には対応しているのだろうか→対応していない様だ。
  - 更に RLogin の説明を読むと LF/VT/FF は全て同じ動作をする様だ。
    また LF で CR LF の動作になっている様に見えたのは仮想端末が LF を CR LF に翻訳しているからの様だ。
    基本的には全て VT の動作を行う。そして Mode 20 LNM でその動作を変更する事ができて、CR LF と同じ効果にできる。
  - これについて xterm でも確認を行ってみたが、やはり同様に LNM で VT/FF/LF の全てが影響を受ける様だ。
    また、何れも SPH 及び FF のそれっぽい実装には対応していない様だ。
    様々な端末における動作がよく分からなかったので包括的に調べる事にした。

  | 調査方法
  |
  | $ stty nl; printf '\e[20hhello\nworld\n\e[20lhello\nworld'
  | $ stty nl; printf '\e[20hhello\vworld\n\e[20lhello\vworld'
  | $ stty nl; printf '\e[20hhello\fworld\n\e[20lhello\fworld'
  |
  | - 仮想端末が勝手に \n を \n\r に変換しない様に設定する必要がある。
  | - Mode 20 LNM が設定されているかどうかで振る舞いが変わる。
  | - 更に現在位置が最終行かどうかで振る舞いが変わりうる。
  |   次の行を追加するかどうかで実装にぶれがある様だ。

  結果は gh-pages branch の escseq.html にまとめた。

* これから本格的に端末の機能を実装していこうと考えている。 [#D0006]
  しかし、多少プログラムが長くなってきたので再度構造を考えてからにする。

  window 自体はできるだけ plain な構造体にしたい。
  端末自体は window とは独立に "window を書き換える者" として実装したい。
  また window の描画先は "window の中身を写す者" として実装したい。
  つまり受動的なオブジェクトとして描画先を定義するのではなくて、
  能動的に window の中身を見て描画を行うのである。

  window を書き換える者の名前は何にしようか。案としては
  controller, painter, writer, layouter, application,...
  writer や application は一般的すぎる気がする。
  layouter は何か違う気がする。painter にすると、
  window を実際に描画する者の方は一体何になるのかという問題がある。
  controller も少々一般的というか余りしっくりと来ない。
  window を碁盤か何かと考えれば player と observer がいい。
  或いは window も board か何かに改名するか。
  (しかし、"player" はまた別の意味にも取れるかもしれない。)
  →取り敢えず各クラスの名前を変更する。

  出力に関しては現在は全体を出力する様になっているが、
  これは勿論効率が悪い。dirty section を管理する様にしなければならない。
  しかし一つの window に複数の observer がくっついている場合には、
  全ての observer で同じタイミングに同じ範囲を反映する様にするか、
  もしくは各 observer 側で dirty section を管理しなければならない。
  一つの window の履歴から各 observer の中で dirty section を再現するのは困難である。
  各セルについて version 番号を保持するという手もあるが効率的ではない。
  また、行の移動なども追跡したい。
  という訳で、やはり実際に window を変更するのと同時に dirty section を更新するしか無い。
  従って、実際の実装では (dirty section 情報を書き出すオブジェクト) を用意して、
  observer が自分の中に保持しているそれを、window の内部にあるリストに登録し、
  window は自分の状態が変更される度にそのリストにある dirty section オブジェクトの更新を行う、
  という仕組みにするのが良いのではないかと思う。

  何れにしても、出力部分を後で処理する事にする。
  それよりは先に実装するべきは player の方である。
  受け取ったバイトに応じて制御機能を呼び出すのである。
  また同時に UTF-8 のデコードも行いたい。
  一番初めに実装するべきは何か。UTF-8 のデコーダか。
  何でも良いから早く動くようにしたいという意味では、
  普通にバイトを受け取ってそれを書き出すという風にすれば良い。
  現在の put_char 関数を拡張する形で良いのではないだろうか。
  取り敢えず出力部分に関しては別のファイルに分離するか。

* is_ideogram_exclusive が使われていない -> fixed [#D0005]
* 49 が無駄に出力されている? -> fixed [#D0004]

2016-09-23

* 仮想端末の作り方については確か POSIX にサンプルコードが載っていたはず。 [#D0003]

  [[posix_openpt>http://pubs.opengroup.org/onlinepubs/9699919799//functions/posix_openpt.html#]] これ。

  ポーリングは O_NONBLOCK にするのが楽?
  [[ファイル入出力の基本 (IO モデル) を勉強する - フリーフォーム フリークアウト>http://d.hatena.ne.jp/cou929_la/20121103/1351950688]]

  あと exit とか _exit とか _Exit とか色々あるけれど何だったか。
  [[_Exit>http://pubs.opengroup.org/onlinepubs/9699919799/functions/_exit.html]]
  [[fork - Wikipedia>https://ja.wikipedia.org/wiki/Fork]] たぶん _exit でよい。

  一応何か起動した。
  bash: cannot set terminal process group (2692): Inappropriate ioctl for device
  と出るので子プロセスで setsid() しなければならない。

  さて、次に仮想端末の設定が変だ。どうも親プロセス側の仮想端末の設定がいけない様だ。
  (というか bash 側は bash 側でなんとかしているはずだ。)
  と、色々試行錯誤した後で以下の親切なページを見つけた。

  [[PTY を使ってシェルの入出力を好きなようにする - Hika Hibariya>http://note.hibariya.org/articles/20150628/pty.html]]

  簡単にできた。色々調べたりしながら分かった setsid や dup2 のことも全て書かれていた。
  初めから此処を見ていれば余り悩むこともなかった (然し理解が浅いままだったかもしれない)。
  あと、終了時に念のため子プロセスを kill しておくようだ。
  と思ったらこれらの事は詳細UNIXプログラミングという本に書かれている様だ。

2016-09-20

* バッファのデータ構造 [2016-09-19] [#D0002]

  行の管理

    行の管理はB木が良い様に思われたが、世の中にはスキップリストというデータ構造もある様だ。
    平衡を保つ仕組みは複雑になりがちだがそれから開放されるというのが売りの様である。然し実際の所どうなのだろう。
    Wikipedia によるとやはりリスト構造であるが故に遅いという様なことが書かれている。
    もっと調べると、M分木にすればB木だと logN/logM になるが、
    スキップリストだと M logN/ logM になるとある。考えてみれば確かにそうだ。
    連続添字の配列として使う場合は、赤黒木よりは良いけれど B 木には及ばないという所ではないか。
    しかしながらスキップリストには、アルゴリズムが簡単なお陰で並列処理・非同期処理などで分がある様だ。
    しかし、もし一旦画面の外に出た部分で内容の更新が起こらないのだとすれば、
    わざわざB木にしなくても単なる配列(or linked array)で良い。
    表示領域の高さは精々数百行なので挿入などは大したことない。

  文字の管理

    % 文字の管理はどうするのか悩ましい。
    % 一つの方法は列数と同じ要素数の配列を用意して、
    % その文字が表示される位置に文字を書き込むというものである。
    % しかしそれだと grapheme clusters に対応するのが苦しい。
    % 外字的な取り扱いにして新しい種類の clusters が来る度に登録を行うという手がある。
    % メモリリークを防ぐためには参照カウンタ方式にでもするか。
    % 遅そうではあるが、普通の文字を扱っている分には overhead がないというのは良い。
    % 一方で、proportional な font を許すような terminal を考えるとこの方法は苦しい。
    % (そもそもそんな物があるのか分からないし、あったとしても各文字の幅や
    % kerning などをどの様に取り決めておくのかという大きな問題がある。
    % 取り決めをしておかないと表示が乱れることになる。)
    %
    % 或いは、初めから可変長な文字の存在を受け入れて、
    % 要素が可変長な配列みたいな構造にしてしまうという手もある。
    % メモリ的にはこれが最もコンパクトである。UTF-8 を使うことにすれば
    % 通常のアルファベットを扱っている限りは各文字 1B しか消費しない。
    % 但し文字幅などの補助情報を持たせるとすると結局 2B になるか。
    % この時の問題はその様なデータ構造は前代未聞なので効率良い実装が可能なのかという事である。
    % 特に index を指定した時に対応する cluster を特定するのに必要な補助情報と計算時間である。
    % 補助情報が一切ないと先頭から順に文字を区切って行かなければならず不毛である。
    % 一応 B 木の各節で、下にぶらさがっている cluster の数を保持しておけば大分ましになる。
    % 問題は B 木の葉である。一つの方法は 1 cluster 1 byte の配列 (A) と、
    % 実際の文字の羅列を記録した配列 (B) の両方を保持して、
    % (A) に (B) 内での index を記録する方法である。
    % 然し、この方法だと単一の grapheme cluster の合計サイズに制限がかかってしまう。
    % また、その葉に含まれる全データサイズにも制限がかかる。
    % しかし、B木の容量を要素数ベースではなくデータ量ベースにするという手もある。
    % 更に一つの cluster が複数の葉に跨る事も許すことにすれば良い。
    % しかし効率の面から言ってこの方法は本当に得策なのか。
    % そもそも端末画面の横幅というのは上限がある。
    % 1行の文字数に制限のないエディタを作るのでないかぎりはB木にする必要もない。
    % また、端末での操作は基本的に挿入ではなくて上書きである。
    % なので各配列要素が各列に対応する様な設計の方が自然である。
    % やはりその様な側面から考えてもB木にするのは大げさである。
    %
    % やはり struct { char32_t ch; int32_t flags; } の配列のような構造にするのが無難だろうか。
    % しかし大抵の場合アルファベットの plain な配列だという事を考えるとこの表現はやはり無駄が大きいように感じられる。
    % この構造をベースに考えて、より効率化するという方向で考えられないだろうか。。
    % 例えば普段は char 配列で考える事にして、unicode 文字等の場合には何らかの特別な文字を使う。
    % そして unicode 文字本体の情報は別の所に格納する。
    % しかし何処に格納するのか? 格納位置を直接表現しようと思えば sizeof(void*) のデータが必要であり、
    % これだとそもそも char32_t と同じ大きさになってしまう。
    % だからと言って char の 128-255 の値を index に使おうと考えれば 128 文字しか unicode 文字を扱えない。
    % 或いは、128文字ごとに buffer を切り替えるというのも手なのかもしれない。うーん。
    % 然しそれだと初めから char32_t*128 の領域を確保しておくのと較べて得しているのかどうか怪しい。
    % 何より大量の文字が流れている場合、結局最終的に char32_t*画面の広さ 分だけの領域を確保する事にもなりそうである。
    % その場合には、初めから char32_t で全部領域を確保しておけば良かったという結論になりそうである。
    % 計算してみると、例えば sizeof(char32_t)*210*80 = 67.2 KB である。
    % 全部 char で済んだとしても 1/4 になるだけである。何かどうでも良い気がしてきた。
    % 実際に動いているプロセスを見ると普通に MB 食っている。
    % 16bit マシンならば 64KB もしくは 32KB に収めないといけないのかもしれないが、
    % 実のところその様なマシンで動かそうと思ったらプログラム自体をコンパクトにせねばならずそちらの方が問題だ。

    結局、char32_t ch の単純な配列で管理するのが良さそうだ。
    余計にメモリの確保解放を繰り返さない為には、初めから領域と同じ大きさの配列にしてしまう。

    Grapheme cluster は上限の大きさを決めておかないと攻撃が可能になってしまう。

  属性の管理

    さて次に考えるべきは属性をどの様に管理するのかという事である。
    実際の使用される状況を考えると、以下のことが言える。
    - 多くの場合は属性は設定されない。特に大量のデータを出力する場合。
    - 属性が設定されているとしても各文字ごとに設定されることは少なくて、
      連続する文字は完全に同じ属性を持っている可能性が高い。
    - colorful な実装にするにしても xterm 256color までが普通で、
      24bit color 等を出力する様なプログラムは稀である。
    勿論、これに反する様ないじわるなプログラムも作ることはできるが、
    上記の様な状況に対して効率の良いような実装にしてしまっても問題ないと思う。

    どのようにするのが良いか様々な実装について考えてみる。
    一番単純な方法は文字のデータと一緒に管理するという物である。
    しかし、実際に描画する時には一文字ずつ属性に応じて描画するというのは効率が悪い。
    普通は同じ属性の物をまとめて描画するという様にする筈である。
    実際に描画を行う場合には属性が連続しているかどうかを確認して出力を行うことになるだろう。

    もう一つの方法は Poderosa で使われている方法である。属性オブジェクトへのポインタを各セルに保持しておいて、
    描画する際の同じ属性の連続かどうかの判断はポインタが一致するかどうかで判定するという方法である。
    しかし、これが本当に効率的なのかどうかは怪しい。先ず、単に文字を描画すると言っても、
    複数の段階がある。まず初めに背景画像を描画し背景色があればそれを描画する。その後で文字を描く。
    各ステップで使用される属性が異なるので同じ属性が連続しているかどうかの判定も、
    属性オブジェクトをひとまとめにして行うのではなくて、
    関連のある属性のみに絞って連続しているかどうか判定した方が良さそうな物である。
    また、属性オブジェクトの確保・解放などの操作にもコストがかかる様な気がする。
    基本的な属性に関して言えば十分 32bit におさまるので
    32bit/64bit のポインタで属性オブジェクトを参照する方が余程メモリを食う。
    Poderosa の方法だと拡張性が高いのは良いが効率面で余り良くないだろう。

    あるいは Poderosa の様に属性オブジェクトを作るまでではないが、
    属性に変更があるという意味のフラグを char32_t の内部に置いて
    (unicode はどうせ 10FFFF までなのでフラグを幾つか設置する自由はある)、
    別の箇所に属性データを記録するという風にすることも可能だろう。
    しかし、その場合属性データはどの様に保持するべきだろう。
    属性に変更があったかどうかのフラグだけでは属性データに対する参照にならない。
    一つの方法は配列にして適用対象の文字と同じ位置に属性データを格納する事である。
    しかしこの方法だと初めから文字と一緒に属性データを記録するのとメモリ効率的に変わらない。
    逆にメモリの管理や参照が複雑になるだけで意味がない。
    もう一つの方法はハッシュテーブルや平衡木などを用いて sparse な map にするという物である。
    これならばメモリを節約できる。しかし、そこまでする程の事なのかという疑問が残る。
    特に高が属性を参照するのに一々毎回複雑なデータ構造を辿るというのは非効率的に思われる。

    結局、基本的な属性の範囲であれば文字のデータと一緒に固定長で管理をし、
    特別な種類の属性を含む場合にはそれを示すフラグと拡張属性データの index を埋め込む。
    拡張属性データは別の一つの配列に入れておいて管理すれば良い。
    同じ属性が連続して続く場合を考えれば拡張属性データは複数の文字から参照できる様にして、
    また参照カウントを用いて管理するのが良いだろう。

    基本的には各セル struct { char32_t ch; uint32_t flags; }; を保持する。
    基本的な属性に関しては flags に格納する事にして、
    特殊な属性を含む場合には或るフラグを立てておく事にする。
    そのフラグが立っている場合には、別に持っている拡張属性データ用配列にデータの格納を行う事にする。
    拡張属性データの配列要素は、参照カウントと基本属性と更に拡張属性データへのポインタを持つ。
    char32_t ch に収まらない様な unicode grapheme clusters についても同様に処理を行う。


  他に必要なデータはあるか

    他の実装も確認してみる。

    yaft.h を見ると、先ず気づくのは文字データは一つのオブジェクトとして生成し、
    セルはそこへのポインタを保持する。更にセルは uint8_t fg, bg と、
    enum char_attr attribute と、それから width まで保持する。
    加えて sixel support としてセル内部に bitmap データまで持つ
    (これはセルのサイズが固定だからできる事であろう)。
    yaft の目的上、メモリ使用量の上限が分からない動的なメモリ確保ではなくて、
    使用メモリ量の計算がしやすい固定的な割当になっているという事だろうか。
    また、glyph に関してはビットマップに結びついているので、
    予め用意された文字しか扱えない。当然、grapheme clusters に対応しているとは思われない。

    struct cell_t {
        const struct glyph_t *glyphp;
        struct color_pair_t color_pair;
        enum char_attr attribute;
        enum glyph_width_t width;
        bool has_bitmap;
        uint8_t bitmap[BYTES_PER_PIXEL * CELL_WIDTH * CELL_HEIGHT];
    };

    sixel もしくは端末の特定の領域に設置される挿入オブジェクトを管理できる様にしたい。
    当初は属性データに持たせる事を考えたが、属性データは複数の文字で共有されるという性質があり、
    しかし一方で挿入されるオブジェクトは或る位置セルに紐付けて管理した方が良い気がする。
    あるいは領域に属する全てのセルで共有しても良いが、何れにしても属性と同列の物ではない気がする。
    だとすれば flags とは別に更に拡張可能なオブジェクトを設定するべきか。
    もしくは grapheme clusters の別種として管理するべきか。それが良い気がする。
    例えば sixel オブジェクトと文字を両方保持しなければならないという事はなさそうに思われるし。

    tmux.h を見るとどうやら文字データは UTF-8 で保持している様だ。
    5 bytes で属性・フラグ・色・幅・UTF-8の長さを持つ様だ。
    不思議なのはこの実装も "幅" を保持している事である。
    幅なんていう物は右のセルに続いているかどうかだけ見れば良い気がするのだが。
    文字のデータには 9 bytes 使っている。そんなに使う文字は存在していただろうか。謎である。
    特定の grapheme clusters だけは扱える様にしているのかもしれない。

    #define UTF8_SIZE 9

    struct grid_cell {
            u_char  attr;
            u_char  flags;
            u_char  fg;
            u_char  bg;

            u_char  xstate; /* top 4 bits width, bottom 4 bits size */
            u_char  xdata[UTF8_SIZE];
    } __packed;

    screen については何処に定義があるのだろう?? image.h の struct mchar, mline?
    どうも screen がどういう処理方法になっているのか色々見ても見えてこないが、
    取り敢えずそれっぽいものはこれしかない。
    文字に関しては恐らく image と mbcs に分割して格納されている。
    ASCII の範囲内であれば image で、そうでなければ mbcs に続きが格納されるという事だろうか。
    他に色と属性とフォント(?)がある。./configure --help を見たがフォントが何か分からなかった。
    面倒なのでこれ以上は深追いしない。しかし前から思っていたがやはり screen のソースコードは汚い。

    struct mchar {
             unsigned char image;
             unsigned char attr;
    IFFONT(  unsigned char font; )
    IFCOLOR( unsigned char color; )
    IFCOLORX(unsigned char colorx; )
    IFDWCHAR(unsigned char mbcs; )
    };

    struct mline {
             unsigned char *image;
             unsigned char *attr;
    IFFONT(  unsigned char *font; )
    IFCOLOR( unsigned char *color; )
    IFCOLORX(unsigned char *colorx; )
    };

    mintty は term.h に一連の定義がある。
    mintty の構造は他のプログラムに較べてよく考えられた構造になっている。
    綺麗だ。他のプログラムが俄然ごみの様に思われてくる。詳しく見てみる事にする。
    - 気付く事は、色は初めから true color 前提で書かれている。
      256色前提の場合パレットを変更した時に既に表示した文字の色も変わってしまうので、
      理想的にはパレットの変更に追随させておけば背景黒と背景白の切り替えなどをしても見にくくならない、
      等の利点があると考えられるが実際にはそううまくは行かない。
      複雑な出力や様々な色を表示するプログラムの場合、パレット変更は普通は想定しない。
      パレットが変更されたときのことまで考えて設計するのは困難な為である。
      それを考えると true color 前提で書いた方が本当は良いのかもしれない。
    - もう一つ気になるのは grapheme clusters の取扱である。
      複数の文字が一つのセルに含まれる場合には、
      各文字毎に 文字&属性&cc_next(=リスト用) を保持する様になっていて、
      更に、同じセル内の次の文字 cc_next は相対位置で表現している。
      配列中で未だ使用されていない文字は termline::cc_free を先頭として、リストで管理している。
      よく考えられた設計である。気になるのは combining characters が沢山来て、
      行内の文字数が SHRT_MAX を超えた場合に何が起こるのかという事である。
      ちょっと見た所、何も対策がなされていない気がするがいいのか?
      後、相対位置にする意味があるのかというのも可也謎である。
      というか相対位置にしていると行内の文字を削除して
      切り詰める時に余分な操作が必要になってしまう気がする。
      もう一つは文字を格納する領域を行単位で管理している事である。
      これだと部分スクロールなどをする場合に文字の移動と一緒にリストを再構築しなければならない。
      一方で利点もある。行の生成・削除が簡単だという事である。
    - また sixel に関しては特殊な文字コード 0xFFFC で表現している。
      恐らく文字がこれになっている場合には其処には文字ではなくて画像が入るという事なのだろう。
      これの意味する所は端末の文字サイズ拡大縮小に際して
      埋め込み画像のサイズは一緒に大きくなったり小さくなったりするという事である。
      しかし下手に埋め込み画像をピクセル単位にしてレイアウトが変わったりするよりは、
      出力したときの領域をそのままに画像も一緒に大きくなったり小さくなったりするのが自然である。
      また U+FFFC は OBJECT REPLACEMENT CHARACTER で place holder の役割のある Unicode 文字の様だ。
      画像本体はどの様に管理しているのかと思ったら struct term の中に保持している様だ。
      恐らくこの中に画像の表示位置などの情報も含まれているのだろう。
    - 属性も様々な属性がある。
      bold dim underline italic reverse invisible blink
      doubleunderline overline protected wide/narrow/expand
    - temp_strage_t は temp_storage_t のつづり間違いではないだろうか。

    typedef struct {
      unsigned long long attr;
      uint truefg;
      uint truebg;
    } cattr;

    typedef struct {
      short cc_next;
      wchar chr;
      cattr attr;
    } termchar;


  結論

    エディタとデータ構造を共有する (エディタにも転用可能にする) のであれば、
    巨大なファイルに対して行の挿入などがスムーズにできる様に B 木にする。
    また、proportional なフォントに対応するために列と配列要素を対応させる構造は使えない。
    ファイルへの書き出しが楽になる様にするためには、
    ファイルに書き出すデータをそのまま保持するようなデータ構造の方が良いかもしれない。

    しかし terminal 専用に設計するのであればより簡単な実装になる。
    流れたデータは単に末尾に追加可能な配列に溜めれば良いし、
    行のデータも長さ決め打ちで良い。
    端末の領域と同じサイズの単一のメモリ領域でも allocate すれば良い。
    効率を考えれば terminal 専用に設計して、特殊な機能に関しては例外的な方法で処理するのが断然良い。

* 名称 [2016-09-18] [#D0001]

  [議論]

  名称を決めよう、と思うが良い名前は何だろう。
  変に凝った様な名前は嫌なので短いのが良い。でも他とは被りたくない。
  混同しやすいようなものや検索しにくいものも万一のため避けたい。

  暫定的に tty1 (単に tty の初めての実装ぐらいの意味) としたが、
  これは既に /dev/tty1 と被っていてよくない。それに version 番号をつけにくい。

  端末の名前といえば、*term *tty などが多い。
  この系統にするとしたら一文字入れるのが良い。
  然し未だ使われていないものが良い。
  - xterm は言うまでもない。
  - iTerm は Mac 用の物。
  - aterm はルータの製品名に使われている。
  - atty は isatty を思い出す。isatty は何の略だろう。"is a tty" ということか?
  - stty は仮想端末の設定を行うコマンドである。
  - RTTY とはアマチュア無線×TTYのこと??
  - VTTY というのも既にあるようだ。

  関連して pseudo-terminal を pty としたりする様だが、
  それだと pseudo-typewriter にならないか?
  それに、近くにあるコンソール tty に tele という語句が入って、
  遠くにあるリモートに繋がっている pty で tele が抜けていることになり妙だ。話がそれた。
  何れにしても ty だけを取るというのも手なのである。
  - mty とか vty とか…? 三文字だと流石に既存のコマンドなどと被るだろうか。

  screen 系列で行くと
  - 例えば tmux がある。これは terminal multiplexer の略である。
  - また、byobu というのもある (単なる設定集の様な物だが)。
    これは screen の言い換えだ。

  contra

    ふと昔書きかけたプログラムの事を思い出した。contra という名前だった。
    エスケープシーケンスを翻訳して TERM に応じた出力に変換する為の物である。
    もしくは Windows のコンソールに対して出力を行ったりもできる様にするという目的だった。
    これと合流するのが良い考えである様に思う。
    名称も contra に変更する。

    というのも今回のプログラムの構想としては、

    1 端末の内部状態と描画部分を分離する
    2 描画部分は "他の端末に対する制御シーケンス" だったり、
      あるいは "GUI ウィンドウに対する描画" だったり、
      容易に切り替えられる様にする。
    3 端末の内部状態に対する操作は、
      "プログラムから直接操作" したり、
      "制御シーケンスを解釈して操作" したり
      色々切り替えられる様にする。

    ということであったが、一方で contra は制御シーケンスの解析
    と制御シーケンスの解釈部分を分離して、
    制御シーケンスの適用先をまた別の端末にしたり、
    或いは Windows のコンソールやその他の GUI Window にしたりという事だった。

    これらは容易に統合してより機能を綺麗に整理する事ができる。

    - icontrol_function_processor

      制御シーケンスからデコードされた制御機能の呼び出しを処理する。

      実装として二通り考えられる。内部端末に対する操作を行うもの。
      それから他の端末に対する制御シーケンスを生成するもの。

      - tty_writer: icontrol_function_processor を実装

      - window_writer: icontrol_function_processor を実装

    - tty_reader

      制御シーケンスを解釈して icontrol_function_processor を操作する。

    - iwindow_target

      window の内容を表示・出力するための物。様々な実装が考えられる。

      - tty_target

        m_proc = icontrol_function_processor に対する操作として実装する。
        特に m_proc が tty_writer の場合には端末に対する出力になるし、
        或いは window_writer の場合には window の簡易複製になる。

      - x_target
      - gdi_target
      - console_target

        様々な GUI interface やコンソールに対する描画として実装しうる。

    以上を組み合わせれば様々なプログラムを容易に実装できる。

    - 例えば、tty_reader -> tty_writer を組み合わせれば、
      制御シーケンスの翻訳として動作する。

    - 或いは、tty_reader -> window_writer -> tty_target を組み合わせれば、
      screen の様なことができる筈である。

    - もしくは tty_reader -> window_writer -> x_target とすれば、
      新しい terminal emulator を実装できる。
      特に、様々の target を実装するだけで様々な環境に移植できる。

    さて、ここまで考えたのはプログラム→端末のデータの流れについてであるが、
    逆に端末→プログラムのデータの流れ (主にユーザの入力操作) についても
    同様に綺麗に扱うことができる。

    - キーシーケンスの解釈部: キーシーケンスを操作のイベントの列にする。
    - イベントの列を処理する部分:

      例えば、直接ここにプログラムを実装してしまっても良いだろう。
      或いは、また TERM に応じたキーシーケンスに翻訳しても良い。

  [結論]

  contra にする。更に、元々 contra という名前で書いていたコードと順次統合する。
