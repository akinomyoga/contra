# contra dev note


------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

2019-05-02

* twin/draw: Win API (GDI) で描画する時のメモ。

  * grapheme cluster / surrogate pair に関して (ref #D0106)
    - TextOut ではなく ExtTextOut を使うべき。
    - ExtTextOut で cluster に与える進み幅は総和だけが意味を持つ。
    - ExtTextOut の表示は微妙。乗り換えるなら freetype である。

2018-02-19

* データの表現方法

  行内の文字ではなくて行内の各文字位置(半角)に対して board_cell を保持する。
  board_cell は二つのメンバを持つ。

  - character_t character (32bit)
  - attribute_t attribute (32bit)

  character は character_flags と文字コードのビット和になる。
  character_flags として何も指定されていない時、値は Unicode である。
  character_flags として is_wide_extension が指定されている時、
  その領域は半角よりも大きな幅を持つ文字の余白である。

  is_wide_extension は一定の大きさの文字を格納する時に
  各セルに対応して board_cell がある。


2016-10-11

* 全角文字の取り扱い

  - ECMA-48/6.1.6/2 暗黙的移動 (文字挿入に伴って起こる) によって現在記憶位置は一つ次の文字位置に移動する
  - ECMA-48/6.3/3 行は予め決められた数の文字位置からなる
  - ECMA-48/6.3/5 文字位置の大きさは其処にある文字に依存しても良い

  これらの記述を総合するに、ECMA-48 では全角文字は複数の文字位置を専有するとして実装されるのではなく、
  文字位置自体の幅が大きくなって実装されるという想定の様である。しかし、この仕様は現実の実装と異なる。
  更に、行に含まれる全角文字の数に応じて各行の大きさが異なるという事になるし、
  また、CUU CUD CUB CUF などの制御機能でどの様にカーソルが移動するかを計算するのが困難になる。
  contra では ECMA-48 に従った実装は行わず、現実の端末と同様の方法で全角文字を取り扱う。

2016-10-04

* 方向付き文字列 (SRS/SDS string) の取り扱い

  0 文字列の定義によって記憶部上の文字の配列に影響は出ない様にする。

    # これは双方向に対応していないアプリケーションでアラビア語や
    # 双方向制御を含む Unicode 文字列を取り扱っても問題が生じない様にする為に必要である。
    # それに記憶部ではできるだけデータの受信順序を保ちたい。

  1 記憶部で文字列の開始終了の情報を記録・管理し、
    これらの情報から一意的に表示部での配列を再現できる様にする。

  2 行にまたがる文字列構造は管理しない。
    受信したデータの中に改行が含まれている場合や、折り返し処理によって行が分割される場合、
    一旦文字列を全て閉じて改行してから再び文字列を開いたかの様に動作する。

    # 理由は複数ある。
    #
    # + [明示的な改行との取り扱いの一貫性]
    #   明示的な改行が含まれている場合は改行前の文字列は前の行に、
    #   改行後の文字列は次の行に表示する。
    #   行折り返しによる暗黙的な改行も同様に取り扱うべきである。
    #   そうしないと暗黙的な改行が挿入された後に、
    #   再度その内容を別の装置に転送する時に、
    #   文章の順序が保たれなくなってしまうからである。
    #
    #   ※暗黙的な改行を区別して記録すれば良いという意見もあるかもしれない。
    #     しかし、様々な制御機能を経た後にそれが意味論的に
    #     まだ暗黙的改行として扱ってよいかなどを決める規則は難しい問題である。
    #     それに暗黙的な改行を区別する為のデータ表現も色々考えると難しい。
    #
    # + [行毎にSCPした時の取り扱い]
    #   行毎に SCP で character path を切り替える事ができる。
    #   例えば SRS 文字列が複数の異なる character path を持つ行に跨っていた場合に、
    #   どの様にその文字列の "範囲" を表現するのかや、
    #   それをどの様に整合的に表示するのかなどに曖昧な点が生じる。
    #
    #   例えば、文字列の各行に含まれる部分を切り出して一つの文字列としたのと
    #   同様に表示するという取り扱いにするのが自然だろう。しかし、
    #   その様に取り扱うのであれば、初めから各行毎に文字列を分割して管理したほうが良い。
    #
    # + [SCP による複数行表示との一貫性]
    #   例えば単に複数行のアラビア語を表示するとして、
    #   SCP を使用して出力する場合と、出力文字列全体を SRS で囲む場合を考える。
    #   前者では次の行は前の行の下に表示される。
    #   後者でも次の行は前の行の下に表示された方が動作として一貫している
    #   (それに読みやすさの観点から言ってもその方が良い)。
    #
    # + [行内での完結]
    #   表示する際に文字の並び替えは行内で完結していたほうが取り扱いやすい。
    #   ある所に表示する内容が別の行に含まれるというのは始末が悪い。
    #   それに座標の計算をする際に考慮に入れるべき範囲の長さに上限がなくなるので、
    #   そういう意味でも複数行に亘る文字列というのは都合が悪い。

2016-09-27

* ECMA-48/9 には対応しない。

  [2016-09-27 の考察の結果を抜粋する]

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそういう前提の内容がかかれている (15 および D.4.Note3)。
  それ以外の実装は駄目な実装なので気にしなくても良い。

  もともと ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである (ECMA-48/1)。
  意図的に 10/00 - 15/14 を使って制御シーケンスを記述するための物ではない。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、そもそもの前提が崩れるので、
  ECMA-48/9 の内容に対応する必要はない。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2019-07-27

* twin: 画面外で選択のドラッグを止めるとコピーされない

* view: 実は横方向のスクロールも考えるべきなのではないか。
  然し、これは実際にそういう機能を実装してから対応するべき。

* 処理時間を計測してみたが不思議な事に
  端末処理や描画をしない様にした方が2倍位遅くなる。
  何か返答がないと処理を待つ等の事があっただろうか。不思議な事である。

  或いは idle の待ち時間の問題だろうか…。
  →これだった idle 時の待ち時間を 10ms から 1ms に変えたら改善した。
    然しそれでもやはり端末処理を省略したとしても余り早くならない。
  端末の処理自体は実は 1/5 位しか時間を使っていない様に見える。
  残りは入出力なんだという気がする。

  やはり現在の入出力の方法は変なんだ。
  また簡単なプログラムでも書いて動作を確認するのか。
  うーん。何れにしても…複数の端末を開いている時には
  現在表示している端末を優先させたいのである。

  マルチスレッドにするとかそういうのは後で考えれば良い。
  寧ろシングルスレッドで動作する枠組みを整えた方が
  後々色々な事を実行しやすいのではないだろうか。
  poll 及び Windows の WaitForMultipleObjects をどう統合するのか。
  結局一方での結果を他方に何らかの手段で伝達するという方法しかないのか。
  つまりそれぞれに待つ為のスレッドを作って、
  サブのスレッドがメインのスレッドに通知を行うという形にする。
  twin.exe ならば Windows のループの方をメインにしなければならない。
  然し、そうすると優先順位などを付けるのが難しくなってしまうのではないか。
  とも思ったが現在 sleep している所をそれに置き換えるだけと考えれば、
  そんなに難しくもない様に思われる。

2019-07-26

* ttty: 入力 decoder について

  * 現在は ttty/screen 内に直接実装しているが入力の decoder は
    一般に様々のアプリケーションで使う物の筈であるから将来的には分離して
    他からも使える様にするべきである。

  * terminfo を参照する様に修正する
    ncurses のライセンスは MIT ライクなライセンスである。
    terminfo のバイナリ互換性は怪しい。ncurses を使うのが無難。
    ncurses が使えない時には自前のデコーダを使って誤魔化す。

* 何だか色々と考えがぐちゃぐちゃになって整理が付かない。
  ble.sh はかなり整理されているというか、
  やりたい事があらかた終わってしまったので安定した状態になっているという事。
  対して contra は実装しなければならない事、
  気になる事が多すぎて駄目になっているのである。

  やりたい事が多すぎるから最終的にどの様な構造になるのか決定できず、
  結果としてコードを整理しようにもどう整理したら良いのかが分からないから、
  コードの整理が進まないという事なのだろう。

  どの様に進めるべきかというとやりたい事を少しに絞って、
  その上で最終的にどの様にやりたい事を絞るのかという事を決める事である。

* twin: Console window を隠す方法 #D0122 に関して

  https://social.msdn.microsoft.com/Forums/en-US/e004a394-c6af-46f2-9158-acc200f3acfc/hiding-a-console-window?forum=vcgeneral
  % http://www.cplusplus.com/forum/beginner/12001/

  SW_HIDE で自分自身を起動し直して一番初めに起動した物はすぐに終了する、という方法が書かれている。
  今回の場合にそれでちゃんと動くのかというのは試していない。

2019-07-25

* scroll buffer に関して。

  * transfer mode (GATM) 等に対応する。
    つまり guarded な文字は空白等に置き換える処理を行う。
    空白に置き換える時には当然 line の version は増やす必要がある。
  * altscreen の時には transfer しない。
  * transfer として別の出力先 (ファイルなど) も対応できる様にする。

* twin の描画部分を分離できないかという事

  全く同じ物を X11 に対しても同時に実装するのは面倒だし、
  また機能を追加するのも面倒だしメンテナンスも面倒である。
  従って同じ処理をしている部分は処理を共通化するのが良い。
  そうでなくても再利用可能な形に色々と関数をまとめて置くのは良い事。

  画像の出力先は GDI, X11 だけに留まらない。
  例えば gif または bmp に出力したいという場合も考えられる。
  或いはもっと他の形式も考えられるかもしれない。例えば PostScript 等?

  2019-07-27 取り敢えず簡単に分離はしてみたが
  未だ現状の形式には不満がある。

  * そもそも bitblt だとか background buffer だとかを使えるかどうかで
    効率的な実装が変わるのである。X11 の場合には remote の
    background buffer に対して操作を実行するという事は可能なのだろうか。
    然し、何れにしてもこれは実際に遅いという事が分かってから
    インターフェイスを拡張する等すれば良いのである。

  * clip に関しては graphics の側で管理する事になっているが、
    これは renderer の側で clip 範囲も提供するべきである。

2019-05-26

* 複数の画面を切り替える場合はどの様に実装すれば良いか。

  manager の側では特に何もしなくても良い様な気がする。
  単に現在の app を切り替えるだけ。

  問題は描画の方である。切り替えたら表示内容を全てクリアして
  再描画しなければならない。dirty だけ設定しておけば自動的に
  クリアされるだろうか。

  本来は画面分割も一緒に考えて対応するべきなのかもしれないが、
  先に画面切り替えだけ実装してしまっても良い様な気がする。
  というのも、画面分割の変更の場合にも結局再描画は必要になるからである。

  画面分割の変更の場合にはどの様に更新をするのが良いのだろうか。
  m_dirty は分割毎に保持しておくべきなのではないだろうか。

  というか現状のGUI端末としての用途を完成する上では
  これは後回しでも良い気がする。中で screen を起動すれば良い。

2019-05-16

* settings: 設定ファイルを読み取る様にする
* settings: 装飾キーの設定をできるようにする

2019-05-10

* memo.txt の番号付について

  番号のついている行の数
  $ awk 'done && /^\* .*\[#D[0-9]+\]/ {print;} /^  Done/ {done=1}' ../memo.txt | wc -l

  番号のついていない行
  $ awk 'done && /^\* .*/ && !/\[#D[0-9]+\]/ {print;} /^  Done/ {done=1}' ../memo.txt

  重複する番号
  $ grep -o '\[#D[0-9]\{1,\}\]' ../memo.txt | sort | uniq -d

  参照一覧
  $ awk '/#D[0-9]+/ && !/\[#D[0-9]+\]$/ {print;}' ../memo.txt
  $ grc '#D[0-9]+'

2019-05-08

* manager: S-select で行選択。M-S-select で行末まで矩形選択

* term: 巨大なデータを貼り付けると input_buffer が大きくなってそのまま

* エラーメッセージだとかログファイルへの出力だとか整理したい。
  取り敢えず stderr に出力している所はログファイルへの出力に後で変更する。

* twin/draw: 縦書き表示に対応する為には
  装飾の類を全て再実装する必要がある。
  また、SCO の回転方向と座標補正に関しても確認する必要がある。
  font_store_t の displacement は x,y を交換して解釈すればいけるだろうか。

* manager: extract_selection 時に行を追跡するべきでは。
  というか実は選択されていたとしても追跡しなければならないのではないか…。
  これについては実装された後で考えれば良い。

* twin: サイズを変更している間は何もかも止まっている気がする。
  なので通知しても意味がないのでは。
  と思ったが、やはりサイズ変更通知は変更が確定してから起こっている?
  或いは家のマシンと学校のマシンで設定が異なる?

2019-05-07

* test: 1x1 でテストするとバグなど洗い出せるかもしれない。
  他に DECSTBM で幅を2にした時に安全に動くかや、
  DECSLRM で高さを2にした時に安全に動くかなど。

2019-05-06

* c2w 高速化に関して
  cat /dev/urandom における現在のボトルネックは c2w の気がする。
  実際にそうなのかも含めてテストする必要がある。

  - 少なくとも c2w を u < 0xA0 ? 1 : 2 の様な物に変えたら速度は改善した。
  - 或いは error_char を 0xFFFD ではなく '?' にした場合はどうだろうか。

* twin: write でブロックされると GUI も一緒に固まってしまうのでは…。
  未だ実際になったことはないが接続が切れるとそういう事になるはず。。

  更に複数のセッションを開いた時にどのように管理するのが良いだろうか。
  各 fd について全部 non-blocking で試して回るのは非効率の気がする。
  一方で、今 terminal_application に抽象化してしまったので、
  複数の fd に対して poll するというのは面倒である。というか、
  ttty で実装するとしても fd に対してだけ poll していれば十分なのか、
  というのも気になるところではある。一応、ユーザからの入力も
  アプリケーションからの入力も全ては fd を介して行われるのは確か。

  write しきれなかった分に関しては何処かにバッファリングしておく
  必要があるかもしれない。という事。

* ライセンスの追加
  考えるのは嫌なので BSD-3 にする。MIT にしていると Copyright の名前を
  すべて書き換えて公開するという輩が出てくる。そういうのを幾らも見てきた。
  しかし GPL の様に厳しいのは嫌である。という訳なので、BSD-3 にするのである。

* twin: mouse capture しないと際のところにある物を選択するのが面倒だ。

* twin: mouse が範囲外に出た時の down up のつじつま合わせ?

2019-05-05

* ansi: SLL, SLH の "それ以降の行" の解釈は変えるべきではないか
  現在は "それ以降に新しく現れた行" という事になっているので、
  既に存在している行には適用されない。

  例えば LF,NEL や FF や VT 等を実行した時に適用されるなど。
  然し、もしそうなのだとしたら結局 SLL SLH は暗黙移動でしか使われないので、
  余り意味がない事になってしまうかもしれない。つまり SLL,SLH を参照する時に
  毎回行の SLL,SLH を上書きするのだとしたら記録してある行の SLL,SLH が使われる機会がない。

2019-05-04

* twin: modifyOtherKeys に対応して出力を変更する。

* twin: modifyOtherKeys で修飾キーや、keyup の操作も送信するのか?
  調べてみたがそういう事はないようだ。
  RLogin に書かれている説明と xterm が送ってくる sequence は
  齟齬がある様な気がする。どの様にシーケンスが切り替わるのかは
  もっとちゃんと調べる必要がある。

  然し、調べていて思ったが実はこれには対応しなくても良いのでは。
  という気がしてきた。結局 ble.sh の様にどの様なシーケンスが送られてきても
  ちゃんと対応できる様にしなければならないのは確かだし、
  どんなシーケンスを送っても許されるのでは。
  modifyOtherKeys は C0 で表現できる物も全て encode してしまう。

  うーん。取り敢えずは modifyOtherKeys の機能は
  要らない気がするのでそのままにしておく。

* twin: surrogate pair の IME 入力はどの様に受信されるのだろうか。。

* 端末からの通知をどの様にして受け取る様にするのが良いか。

  沢山 on_term_resize だとか on_term_bell だとか
  そういう仮想関数を用意するのだろうか。
  或いは、単一の関数でメッセージ方式で処理する様にするのだろうか。
  どちらの方が効率が良いだろうか。
  結局単一の関数で受け取るとしても各関数に配分する事になるのだから、
  やはり on_term_* という関数を沢山持った抽象クラスを準備するのが良いだろうか。

2019-05-03

* twin: 普通に起動すると一瞬ウィンドウが表示される問題 [#tmp0001]
  ref #D0122 #D0145

  これは今の所解決できていない。

  * PE ヘッダの Subsystem を Windows (2) に書き換えると、
    何故か /bin/bash が対話モードに入れなくなってしまう。
    (Note: mintty は Windows Subsytem でちゃんと動いている)
  * 現在は Subsystem は Console (3) のままで
    表示されたコンソールは SW_HIDE して消す事にしている。
  * ショートカットの設定を弄って目立たなくする方法について #D0123 で考えたが、
    精々ウィンドウの大きさを小さくして不透明度を 30% まで下げるのが関の山。
    ショートカットをバイナリで無理やり編集して不透明度を 30% より小さくすると、
    何らかのチェックに引っかかって、寧ろ不透明度 100% になってしまう。

  何と検索していたら gcc に -mwindows を指定せよとの事…。
  https://stackoverflow.com/questions/18260508/c-how-do-i-hide-a-console-window-on-startup
  然し、これは自分で PE ヘッダを書き換えた時と同じ症状になるだけで問題は解決しなかった。

* twin: DECARM (キー長押しによる連続入力) の制御は面倒だ。
  そもそも対応する意味があるのかもよく分からない。
  長押しで連続入力できるのが普通の感覚である。

* twin: 使い物になる為に必要な機能は…。

  - ok: 単独で起動できる様にしなければならない。
    これはまあ制限はある物の許せる振る舞いではある。
    真面目な対応は後で考えれば良い。
  - 先ずスクロールバックできる様にならないと駄目。
    因みにリサイズした時にはみ出る行についてもスクロールバッファに送りたい。
  - コピー・ペーストの機能は必要。
    ペーストは欲しい。

  - フルスクリーン機能は欲しい
  - mintty はバッファ内の検索等ができる様になっている。
    これは ttty でも欲しい機能なので GUI では対応しない。

* twin: 端末からのサイズ変更の要求があった時にウィンドウサイズを更新する。
  対応できない大きさへの変更が要求された場合には変更し返す。

* twin: C-scroll で文字の大きさを変更したい。
  文字の大きさの変更に関しても端末に通知する。
  確認したら mintty はこの機能に対応している。

* [疑問] twin: 英語のフォント名を指定しなければならない理由?
  ref #D0116
  不便である。本来日本語のフォント名で指定できてしかるべきである。

* ansi: エスケープシーケンスを適当に出力する fuzzer が欲しい。
  少なくとも変な操作でクラッシュして死ぬ様な端末は信用できない。
  (Poderosa は実際にすぐクラッシュしてしまうのであるが…。)

* [保留] twin/draw: 圏点を描画するのに Unicode の圏点を使う可能性
  問題点: グリフが用意されていない可能性・位置大きさの調整が難しいこと。

* twin/draw: 高速化(部分描画に対応する)
  今までは行の高さを求める等の事を考えていたが面倒すぎる。
  特に新しく描画する行に関しては行の高さを求めてから被る先を決定しなければならないが、
  行の高さを求めるだけでもかなり処理が必要になるのではないか。
  その様に考えるともう一つの代替案として、隣の行までは一律に被る可能性があるとしてしまう事。

* twin/draw: フォーカスがない時はカーソルは表示しない?
  - 例えば Poderosa はその様にしている。
  - xterm は表示している。しかも点滅している。
    フォーカスを失って暫くすると点滅をやめる。
  - RLogin はフォーカスを失うとカーソルを消す。
    所でフォーカスを持っていても暫くすると点滅をやめる。
    一方で文字の blinking は無限に続ける。

* twin/draw: 背景画像
  背景だけの background buffer を作って良い気がする。
  というか背景画像は何れにしてもリソースとして持たなければならないので。

* ansi: マウス機能
  これは Poderosa に前に実装したのがある。

* twin/draw: FillRect と PatBlt と Rectangle と BitBlt のどれが速いのか。
  更に直線の場合は線を直接引くのと比べてどれが速いのか。

2019-05-02

* ansi: grapheme cluster については以下のリンクがよく整理されている。
  https://hydrocul.github.io/wiki/blog/2015/1025-unicode-grapheme-clusters.html

* twin/draw: 行をはみ出る描画がある時の実装方法について考察

  | 実のところ、行をはみ出ている文字が存在する時には、
  | BitBlt が使えなくなるなど色々と問題がある気がするが、
  | まあ、仕方がないのである。或いは、被っている行とそれに対する参照を
  | 記録してもし変更がなければ大丈夫という具合にするのだろうか。。
  | さて、実際にその様にしたとしても更新のなかった部分に関しては、
  | 上書きしないように気をつけないといけない。その様にしないと、
  | 二重に文字が書かれたりしてアルファを指定しているときなどに色の濃さが変化する。
  | アルファを指定していなかったとしても ClearType や Anti-alias で色の濃さが変化してしまう。
  | うーん。描画範囲を制限するよりは background buffer を2枚持っておいて、
  | 古い方から新しい方へ転送してしまう方が良い気がする。

  現在の表示内容を保持するデータ構造として以下の物を考える。
  (1) 各行について id/version 及び内容を保持する。
  (2) 更にその行に被る行の id と offset のリストを保持する。
  次にどの行を再描画する必要があるかについて調べる。
  (1) そして、更新の際には id/version の異なる行を invalidate する。
  (2) 更に invalidate された行を参照している行や、
    参照している行との offset が変化した行やも invalidate する。
    (再帰的な適用はしなくて良い。被っている他の行の内容が変化する事によって、
    更に新しく自身が他の行に被る内容について変化がある訳ではないので)
  (3) 全ての行についてその行が被る範囲を調べて、
    被る範囲の中にある行について自身がその行の被りリストに登録されているか、
    そして offset が一致しているかについて調べる。もし登録されていないか、
    offset に変化があればその行は invalidate しなければならない。
  描画を実際に行う。
  (1) BufferA に invalidate された行を書き込んでいく。
    その行に被る事が分かっている invalidate されていない行についても
    前景を書き込んでいく必要がある事に注意する。書き込む必要がある前景は
    その行をはみ出ているものだけであることは注意する。
  (2) BufferB から BufferA に invalidate されなかった行の内容を転送する。
    これで一応画面の内容は完成している筈である。
    背景画像との合成を考えると更に合成を実施する必要がある。
  (3) BufferA から BufferB にコピーする。
    その上で BufferA にカーソル等を書き込んで、
    それから BufferA から画面に BitBlt を実行する。

  * 点滅属性などを考えると各行について変更のあった
    アセンダ・ディセンダを求めてそれを処理に使うのは価値がある様に思う。

  * もし背景と前景を独立に描画してその後で合成するのだとしたら
    行内容の差分を考える時に背景と前景に分けて考える価値はある様に思う。
    その為には先ず行内容を背景と前景に分けてしまって良いと思う。
    背景と前景のそれぞれについて差分を取って更新の戦略を考える。
    但し、これは実際にバッファを分けて描画すると決まってから実装しても遅くない。
    今は考えなくても大丈夫である。

* twin/draw: 背景画像との合成を行う為には HBITMAP がアルファに対応していないといけない気がする。

  ? もし CreateCompatibleDC で異なる物が生成された場合には、変換しなければならない?
    或いは単に BitBlt が遅くなるだけなのだろうか?

  ? そもそも現在の PixelFormat を取得するにはどうしたら良いのだろうか。
    調べると GetBitmapBits という関数があるそうだ。
    https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/nf-wingdi-getbitmapbits
    然しこれは Win16 API なので、代わりに GetDIBits を使えとの事。

    うーん。これは丁度 C# でビットマップをバイナリで処理する時に使っている関数だ。
    その裏で実行されているのがこの関数なのだろうという気がする。
    まあ最終的にはこの関数を使って無理やり転送すれば良いという事である。
    然し、巨大な画像を転送するのには時間がかかりそうではある。
    うーん。やっぱり時間はかかるのだろうという気がする。

  実は合成するよりも再描画してしまった方が速いという可能性もある?
  と思ったが普通に考えたらそんな事はないはず。やはり手動でも合成した方が速い筈…。
  まあ、実測する価値はある様には思う。

2019-05-01

* twin: カーソルの形状の指定、色の指定、点滅など
  background buffer に描くのではなくて別に描画するべき。

  WM_PAINT による部分更新に際しては反転色で変な事が起こらない様に注意する。
  →Invalidate 領域を全て再描画するのだとすれば実は気にしなくても良さそう。

* twin/draw: 反転色部分の空白

  →これは背景色と前景を別々に描画する事にしたので問題ない。

* twin: cat /dev/urandom でフリーズした
  描画の振る舞いに関しても改善した気がする。
  暫く走らせてみる…と思ったらフリーズした…。こりゃ駄目だ。
  実は Visual Studio の C-A-p でアタッチできてしまう様だ…。
  調べてみると twin.exe!00418766 にいる様だ。これは…

  contra::multicast_device::dev_write(char const*, unsigned int)
  うーん。呼び出している関数は free で更に dlfree を呼び出している様に見える。
  しかも完全に停止している。何かのデッドロック状態になっているという事だろうか。

  うーん。例外が発生してそれでメモリの解放中に止まったという事?
  もう全然わからないので終了する事にした。

  分かっている事は直前に端末の幅が 1 文字しか無い様な、そんな動作をしていた事である。
  殆ど縦一列に表示されていて、しかし、時々長い行がある、というそんな感じ。
  これはどの様な場合に発生するだろうか。例えば勝手に端末幅が制限された時に起こる?
  端末の幅や高さを勝手に書き換える様なシーケンスには対応していない気もする。
  うーん。或いは、DECLRMM, DECSLRM が同時に設定されたのだろうか。
  しかし DECSLRM の場合には最低でも2列はある筈である…。
  と思ったが DECSTBM で 1 行になったりもしている…。
  或いは、何か別の理由でスクロール範囲が変わっているのだろうか。
  もしくは decawm が off になっていた等?

  * fixed: うーん。やはり Poderosa の上で twin を実行すると何だか滅茶苦茶な事になる。
    サウンドデバイスを呼び出しまくって固まってしまう。CPU もたくさん使う。
    mintty も何だか応答が悪くなってしまうのであった。
    これからは mintty の上の twin の上で twin を動かすという方式に変更してみる事にする。
    と思ったらそれでも何だか変なビープ音が出力される。これはどういう事だろうか。
    少なくとも screen の中で起動している内は変な音は出力されない。
    mintty 中の twin でもやはり同様に変な音が出る。
    うーん。screen/twin だと大丈夫である。screen/twin/twin でも平気である。
    これが意味する所は何かというと、BEL が伝達しているという事である。
    と思ったら screen の window list で確認すると、BEL がある事を示すマークが出ていた。
    つまり、BEL を伝達しているという事である…。

    然し、変である。BEL を何故…あー。
    do_bel() の暫定実装で取り敢えず標準出力に \a を書き込む様になっていた…。
    これは実のところ term に設定できる様にするべきである。
    何かイベントリスナーでも登録できる様にするべきなのである。

2019-04-30

* kill(sess.pid) しているが誤爆の心配はないのか。
  もっとちゃんと検知する方法が存在するのではないか。

* twin: bash を exit した時に自動で閉じたいが正しい閉じ方は?
  現在の実装だと単にアプリケーションを終了してしまっている。
  本当は WM_CLOSE 等を呼び出して閉じるべきなのではないだろうか。

* twin: ダブルクリックで起動すると一瞬で終了する。
  多分、途中で何かのエラーが起こってそれで終了しているのだと思う。
  ファイル等に出力しながら何処で止まっているかを探る必要がある。

2019-04-29

* ansi: IRM 対応。vttest (8) の insert mode が A...A になってしまう
  これは SM(4) を実行していた。IRM である。対応していない。

* [保留] twin: dead-char 対応

  dead-char (フランス語やスペイン語のキーボードで現れる) の仕組みがよく分からない。
  そして dead-char を入力する時にどのような順序でメッセージが送られてくるのかもよく分からない。

  ? 例えば WM_CHAR を見ていれば WM_DEADCHAR と同じ内容が見えるのだろうか。
    それとも WM_CHAR または WM_DEADCHAR のどちらか一方だけが送られてくるのだろうか。

  ? dead-char を入力しかけている状態でも WM_KEYDOWN が送られてくるのだろうか。

  ? ::ToUnicode/::ToAscii に指定する keyboard state はダミーの変な物であっても、
    ちゃんと (何処かに記録してあるキーボード状態を参照する等して) 正しく変換してくれるのだろうか。

    どうも、同じ引数で2回呼び出しても結果が変わる様なので、何処かに状態が記録されている気がする。
    (或いは勝手に keyboard state を書き換えてしまう等の事はあるのだろうか)
    しかし、何を元に状態を更新しているのかについてはよく分からない。
    渡した keyboard state によって内部状態を更新しているのだとしたら、
    ダミーの keyboard state を渡している限りは dead keys は受信できない。

  ? ::ToUnicode の戻り値が 3 以上の場合も存在しうるらしいが、
    最大で幾つなのだろうか。そしてもしバッファが足りなかった場合には残りは取得できないのか。
    https://stackoverflow.com/questions/42667205/maximum-number-of-characters-output-from-win32-tounicode-toascii

  ? 更に、実際に dead-char を受信するとしても修飾キーがついていた時に、
    1つ目の文字に修飾キーをつけるのか、
    或いは全ての文字に修飾キーをつけるのか、というのはよく分からない。

  mintty のホームページを見ていたら dead-char 対応も謳っている。

2019-04-28

* trace_line_scroll は DECSLRM,DECSTBM に対応している端末では
  表示幅が全体でなくてもこれらを使って対応できる筈。

  また、is_terminal_bottom での処理に関しても、
  DECSTBM が設定できるのであれば敢えて挿入する必要はない筈である。

* vttest: ESC ( B, ESC ) B, ESC ( 0 等を出してくる。
  文字コード関連も整備した方が良いのだろうか。

* 画面サイズが変更された時に端末に通知していない気がする…。
  tty_observer でちゃんとサイズ変更を検知して、
  更に出力しなければならない。

  というか変更された瞬間に実行するべきなのか、
  或いは表示する瞬間に実行するべきなのか。
  これは恐らく変更された瞬間に実行するべきである…。
  もし変更を指示したのがそのアプリケーション自体であった場合、
  アプリケーションは画面サイズの変更通知を待たずに、
  そのサイズを前提とした処理を実行してくるはずだからである。

* カーソル形状等に関しては表示の瞬間に前回と変更がないかを見て変更すれば良い。
  また decscnm (背景・前景反転) に関しても。描画の瞬間にチェックすれば良い。

2019-04-27

* [保留] なめらかなスクロール (mode_decsclm)

* tty_observer: Mode ?8 の変更を外側に伝達

* 他にも外に伝達するべき mode 変更について考える必要がある

  実は Mode ?5 の変更に際しても term から tty_observer に伝達があると良い。
  或いは tty_observer 側で前回の状態を記録しておいて丁寧に差分を取るか。
  しかし、volatile に変更を外に伝達したい場合もあるのではないかという気がする。
  (具体的には今は思い浮かばないので volatile な伝達は必要になってから考えれば良い。)

* 入出力の順序等に関して

  * 現在の実装で yes を実行したらどうなるのか確認した
    ちゃんとすぐに C-c が通じて yes を終了する事ができる。
    そう。本来そうでなければいけないはずなのである。

    一方で、他の端末はどうなのだろう。実は Poderosa が駄目なだけなのでは。

    - と思って試してみると xterm も RLogin も C-c
      を押してからだいぶ経ってから yes が終了する。

    - mintty に関してはそもそも yes を終了することもできず、mintty 自体がフリーズしてしまう。
      CPU 100% になっている訳でもなくデッドロック状態になっている様に見える。

    - 後、今気づいたのだが文字を入力していると Poderosa は結構 CPU を食っている。
      これはどうやら Google IME が CPU を食っているという事の様である。
      日本語の入力をしている時には 10% ぐらいになるが、
      英語の入力をしている時には上に上がってこない。

2019-04-23

* 縦スクロールの外側端末に対する描画に関して

  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)
  terminal multiplexer で縦スクロールをどの様に外部に伝達するのかについては
  確かに面倒であるという事が議論されている。

  a 例えば縦スクロールの直前に画面を全て更新して
    縦スクロールのシーケンスを送信するという手がある。
    しかし、そうすると縦スクロールを全て送信しなければならなくなる。
    大量の出力の末にスクロールしきった一番最後の状態を表示するというのができない。

  b 特に、画面が隠れていた時に行われた縦スクロールはどの様に処理するのか…。
    と思ったが、実はそれは気にしなくて良い気がする。画面が現れた時に、
    何れにしてもその時の状態は全描画しなければならないので、
    それまでに実行された縦スクロールなどは気にしなくて良い。

  c うーん。縦スクロールは DECSLRM に従って実行されると仮定すれば、
    実は DECSLRM で切って差分などを取る事によって移動を検出すれば良いのではないだろうか。
    DECSLRM が解除した後であっても最後にスクロールを実行した時の lrmargin を記録しておくという手もある。
    現在スクロールは do_vertical_scroll で実行しているので大域的な変更は必要ない。

    実際にスクロールと言うか内容の移動が検出できたとしてどの様に移動を実施するのか。
    例えば DECSTBM DECSLRM が対応できていたとして SU, SD で移動すれば良いのだろうか。
    IL, DL を使った実装は xterm で期待通りに動かない。xterm では DECSLRM を無視して
    本当に行を挿入したり削除したりするからである。一方で、SU SD で本当に期待通りに動くのか
    については確認していないのでわからない。

  というか実際にそれを実装するとしても DECSTBM, DECSLRM を外側の端末が対応している
  という事を確定できなければ使うことができないのである。
  これの実装に関しては後で余裕があれば考える事にする。

  或いは DECCRA に関しても最後に実行した時の座標を記録しておくというので十分の気がする。
  複数回実行した時に関しては考えない事にする。

2019-04-21

* 資料

  DECCRA もしくは DECSLRM について
  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)

  SCOSC と DECSLRM のシーケンスの区別について
  [LeoNerd's programming thoughts: ANSI vs DEC, arbitrary scrolling in terminals](http://leonerds-code.blogspot.com/2012/03/ansi-vs-dec-arbitrary-scrolling-in.html)

  端末判定について
  [端末エミュレータマニアから見たMinEdの実装のヤバさ - Togetter](https://togetter.com/li/380509)

* sixel の振る舞いについて少し調べてみた。

  - RLogin では文字として表示されている気がする。
    ICH などでずれるし、上書きすればそのマス目だけが潰される。
    色々と画像の継ぎ接ぎができる。

  - 一方で、過去の twitter の議論を観察すると、
    実機では ICH などでずれない様だ? 直接 VRAM 上に置かれているという説だそうだ。

  - mintty の実装は何か変である。

    | mintty の場合には ICH ではずれない。
    | 描画範囲はずれない。というか色々微妙な動作をする。
    |
    | - ICH(3) すると何も変化は見えない。DCH(3) すると画像の末尾が欠ける。
    | - DCH(3)ICH(3) も ICH(3)DCH(3) も変化は齎さない。
    | - DL(2) すると画像範囲が小さくなるだけで画像の一部が削られたりとかはない。
    | - IL(2) してもやはり画像の表示領域が消えるだけで画像が二つに分かれるとかではない。
    |
    | ここから推測するに、mintty は sixel のマス目かどうかの情報を文字と同じ様に保持しているが、
    | 一方で、そのマス目に表示する内容は相対座標か何かで決定している。
    | ICH 等によってマス目が画像の範囲外に移動した時には何も表示しない。
    | 元画像への参照と元画像の原点 (?) の位置を保持している。
    | 然し、原点を保持するにしてもスクロールして画面の外に出てしまった場合に
    | どの様に処理しているのか不思議である。
    |
    | - DECSTBM して sixel を表示してみて分かったが、
    |   mintty では単にスクロールした回数を記録しているだけの気がする。
    |   スクロール範囲外の sixel 画像も一緒にスクロールしてしまうのが観察された。
    | 然し、mintty は画面上から流れて出ていった画像を見る為にスクロールすると
    | 何か描画が変である。画像が残ったり残らなかったりしている。

    まとめると、mintty では文字と同様にそれが sixel の升目かどうかを保持している。
    元の sixel 画像がどれかだけを参照していて、元の画像のどの部分かの情報は保持していない。
    一方で sixel 画像の側に現在の表示位置を保持している。
    sixel 画像の位置はスクロールを実行する度に更新される。
    SU は sixel 画像の位置を更新するが、RI や SD は更新しない。
    何故この様な中途半端な実装になっているのか分からない。

    実機を真似ているという事なのだろうか。。

  - xterm は RLogin と同様の実装になっている気がする。
    DL(3) や IL(3) も試してみたがやはり行と一緒に画像が切り貼りされる感じだ。

  どれが良いのかは分からないがデザインとして納得できるのは RLogin/xterm の方式である。
  従って、もし対応するのであれば RLogin/xterm の方式で考える事にする。
  但し、現在の実装では文字以外の物体を置く仕組みを整備していないので後で考える。

  文字以外の物体を置くとしてどの様に置くのが良いだろうか。つまり参照方法。

  a 例えば object id を以て参照するというのは以前のアイディアである。
    うーん。結局 object id を以て参照するというので良い気がしてきた。
    但し、各升目に対して object を配するのはコストが高い気もする。
  b 或いは、ポインタを保持するという手もある。
    ポインタをデータメンバとして追加すると更にメモリを食うようになる。
    フラグが立っている場合にはポインタを保持して、
    フラグが立っていない時には属性を保持するという様にする、
    という事も考えられるが実装が複雑になる。

  更に、メモリ管理はどの様にするのかが問題になる。

  a 以前は手動で inc/dec して管理していたがとても面倒だし、
    直ぐにミスしてメモリリークしそうである。
  b かと言って ctor/dtor/copy 等でカウントするのは
    それはそれでコストが高い様に思われる。
  c 或いは参照カウントは諦めて毎回メモリをコピーする事にするか。
    これはメモリ確保解放が増えるので重くなる。
    更に、それが必要かどうかを判定する必要があるので、
    結局参照カウント方式と比べて何か楽になる訳でもない。
  d もう一つの可能性は行ごとにリソースを管理して、
    行が消滅する時に一気に開放するという物である。
    これは単一行でずっと処理を繰り返した場合に
    どんどんメモリ使用量が増えてしまうという問題がある。
  e 或いは GC の様に時々 mark/sweep を実施するというのでも良いかもしれない。
    mark/sweep のタイミングは n 回メモリ確保をした時点で実施する、などにする。
    この時に root オブジェクトは何処にあるだろうか。
    各ページ・スクロールバッファ・代替画面などにある。
    他にスタックの上などに置いてあったりはしないだろうか…。
    まあ、そんなには難しくないような気がする。
    この方法は一つの手であると思われる。

2019-04-20

* ansi (get_cells_in_presentation): prop の場合の動作
  prop の場合にちゃんと動作するかどうにかについてテストしていない。

* ansi (get_cells_in_presentation): 振り仮名・sixelなどの埋め込まれたオブジェクト
  振り仮名だとかの marker は適切に開始・終了等の並び替えを実行する必要があるのではないか。

* observer: 描画中は一時的にカーソルを隠す
  これについては現在の端末のカーソルの状態と term_t のカーソルの状態を
  管理できる様にしてから実装する事にする。

* DA2 に対する応答_
  https://qiita.com/kefir_/items/0bda5e55f43392420d66

  現在の impl2 ではただ単に画面の内容を追跡しているだけで、
  画面を自前で描画している訳ではないので、
  DA2 に応答しても仕方がない。
  然し、今後の実装としてはちゃんと自前で描画できる様にしたい。
  その時にはちゃんと DA2 に対する応答を書き込まなければならない。
  書き込み先を設定できる様にする必要がある。

* 描画に関して

  後、描画に関してはどの様にするのが良いだろうか。
  以前の構想だと端末の内部状態の管理とは別に、
  observer を用意してそこから端末の内部状態の変化を調べて表示するという話だった。
  然し、本当にそれで大丈夫だろうか。内部状態の変化をどの様に検出するのかとか、
  或いは、効率的な内部状態変化の適用方法などがあったとしてそれを如何に実行するのか。

  出力先が端末かそれとも GUI かによっても色々取り扱いが異なってくるだろう。
  例えばスクロールだとかに関しては出力先がどちらであっても、
  できるだけスクロールとして実装したい様に思う。
  例えば、その為には行IDの様な物を保持しておいて、それを元に行を追跡する。

  在る範囲の属性の変更等に関しては GUI が出力先の場合には何れにしても全て再描画である。
  一方で、出力先が端末の場合には実は

  a "属性の変更" という操作を送信した方が早いのではないか。
    x 大量の出力があった時に描画を省略したい場合には、
      却って属性の変更という操作を送信する様にするのは、
      全てを出力することを要求する事になるので避けた方が良いのではないか。

  b 実際に画面が有限の大きさである事を考えると、全部再描画しても問題ない様な気もする。

  c "属性を変更した" というイベントを何処かに記録しておいてそれを使って何とか操作を送信するか。

  d term で属性を変更する直前に画面状態を更新しておいて、その上で属性を変更しつつ
    属性を変更する操作を observer にも送るという手もある。

  うーん。画面の大きさが有限である事などを考えると、まあ行内容の更新は、
  変化のあった部分について全て再描画というので問題ない気がする。
  念の為、文字の部分一致についても調べてできるだけ短いシーケンスになる様には努める。
  (然し、それでも速度の遅い端末では問題になる気がする。)

  しかしできるだけ短いシーケンスというのはどの様に決定したら良いのだろうか。
  つまり、文字をシフトした方が短いのか或いは普通に出力した方が早いのか。
  a これはシフト対象について連続する文字の数にもよるだろう。
    更に、潰される文字に関しては連続していると解釈しても良さそうだし、うーん。
  b 或いは、もう単純な場合にだけ短くなる様に工夫して、
    ある程度以上複雑な更新が必要になったら、フルに描画してしまう事にするか。
  c もっと細かく考えたら何か動的計画か何かで最短になるシーケンスを算出できるのだろうか。
    確かに競技プログラミングの問題に出てきそうではある。

* DECSTBM の影響範囲
  MC, DECMC は DECSTBM, DECPEX の影響を受けるそうだ。
  DECOM についてもちゃんと DECSTBM に対応する様にする必要がある。

2019-04-14

* ansi: うーん。ECMA-48 を見て思う事は、実は ECMA-48 及び ANSI は端末の規格というよりも、
  ワープロの様な物の規格の様に思われてくるという事である。
  フルに様々なオブジェクトを埋め込める様なそういうデータ形式が想定されている様な気がする。
  JFY (text-justification) だとか PTX (ふりがな) だとかを考えると、
  端末の機能として実装するのはかなり難しい様な気がしてくる。
  実際の所はどうなのだろうか…。

  思うに完全に実装しようとすると遅くなってしまうので現在の mono/prop の様に、
  更に上の段階として full 的な物を用意して、
  そのデータ形式に於いて様々な入れ子の構造などにも対応するという形が良いのかもしれない。

  | うーん。というか PTX 等で振り仮名を振っている時にも中でフルに
  | 文字列を作成したりフィールドを作成したり領域を作成したりする事は可能なのだろうか。
  | 或いはそういった機能は未定義という事なのだろうか。
  | 改めて規格を確認してみたが何も書かれていない。細かい Note は書かれているが、
  | どの様に表示されると考えられるかという例について説明されているに過ぎない。
  |
  | 改めてデータ部と表示部の説明を確認してみる。
  | 何処にもどの文字位置も同じ大きさを持つとは書かれていない。
  | 更に一行に含まれる文字の数についても触れられていない。
  | 行の高さが同じであるとも書かれていない。
  | そういう事を総合して考えると、これは端末の規格というよりは、
  | やはりワープロソフトもどきの装置の規格の様である。
  | 或いは、もう実際にその様に実装してしまうというのも手かもしれない。
  |
  | prop から full に昇格した時の整合性はあるのだろうか。
  | 例えば prop で処理している時には先に文字列の終端を挿入して
  | 後で文字列の開始を挿入したとしてもその瞬間のデータ部における
  | マーカの関係を考慮に入れて入れ子の状態を認識する様になっている。
  | つまり、prop では HTML のソースを弄る様な形で処理が行われる。
  |
  | 一方で、full に昇格して現在どの入れ子の中にいるのかという
  | 入れ子構造の木の中で挿入を行う仕組みにしてしまうと、
  | 先に文字列の終端を挿入してから後で文字列の開始を挿入する
  | と言った操作が困難になる。というか、文字列の開始を挿入した時点で
  | 木の構造を再構築しなければならなくなってしまう。
  |
  | 現在求められているのはどちらであろうか。
  | "データストリームの編集" と考えれば HTML のソースを弄る様に、
  | 一次元的なデータを編集する様にして、
  | その瞬間瞬間での解釈を用いて表示を行う事になる。
  | やはりそちらの方が自然である様に思われてきた。

  [結論] データ部では HTML を編集する様にしてデータストリームを編集すると解釈する。
  また、その時に文字の幅などは特別に解釈して右での折返しを実装できれば望ましい。

  さて、問題は、PTX の様な物の幅をどのように取り扱うかである。
  うーん。PTX が含まれる場合には計算する時の x 位置の幅を
  リセットするとかそういう事になるのだろうか。

  - その場合には実は _prop_glb, _prop_lub の定義を弄るだけで
    対応できてしまったりはしないだろうか。

  - 双方向文字列はどの様に処理すればよいだろうか。
    双方向文字列に関しては振り仮名の中はスキップする様にするのが良さそう。
    これは双方向文字列を処理するルーチンの修正が必要になる。
    しかし、それさえ修正してしまえば実は終わりなのでは?

    と安易に考えてはいるが実際に対応しようと考えると、様々な考察やテストが必要になる。
    或いは、もっと安全なデータ構造を考えた方が良いかもしれない。

* ansi (_bdsm_shift_cells): ECH/ERM
  現在の実装では ERM で protected な部分に関しては、
  方向文字列などの状態は復元せずに、そのままデータ部で
  保持する様に実装しているがこの実装は適切だろうか。

  ユーザからすると変な振る舞いに見えるのではないだろうか。
  然し一方で、境界上に protected/unprotected な物が混ざっていると、
  方向文字列などの復元をどの様にしたら良いのかが非自明となる。
  或いは、方向文字列に関連する marker だけは unprotected であっても残す様にするのか。
  そしてそれ以外の unprotected 零幅文字は削除するという仕様にするか。

2019-04-13

* DAQ に対応する。
  protected/guarded の属性に関しては描画属性で対応する事にする。
  然し、input だとか HT の設定だとかに関しては描画属性で対応する物かどうかは微妙である。
  実際の所、始まりと終わりの marker を保持しておいてその間を領域と解釈するべきなのではないか。

  然し、SPA EPA 等と混ざっていた時に EA などが認識する "領域" はどの様に解釈すれば良いだろうか。
  また、SPA, EPA 等は全ての行に亘って検索するべき気もする。うーん。

  結局、DAQ は SPA, EPA 等で終了するという様に決めておかないと駄目な気がする。
  その様に考えると属性も DAQ と SPA で共通にして良いのでは。とも思うが、
  まあ、両者が混在した場合などを考えるとやはり区別したほうが良いか。。

  思うに EA が認識する "領域" と、DAQ 及び SPA-EPA がそれぞれ自分で把握している "領域" は
  独立であっても良いのではないかという事。

* line (_bdsm_shift_cells): erase unprotected cells におけるテスト項目
  境界上の大きな文字に対する補正として、
  その大きな文字が特に3文字以上ある時に
  境界から左端・右端への距離が分からない。
  現在の実装では両方試す実装になっているが、
  実のところ3文字以上の大きな文字に未だ対応していないのでテストしていない。
  3文字以上の文字が現れた時にテストを追加するべきである。

2019-04-10

* どの段階で term.initialize_line(line) が適用されるべきか不明瞭である。
  一番最初に何らかの編集が行われる時?
  それとも一番最初にカーソルが移動した時?
  或いは一番最初に画面に現れた時?
  或いは初めてタブなどが実行されて情報が必要になった時かもしれない? うーん。

  cur.y に値を代入している箇所はそんなにないので
  そのタイミングで実行するので良い気がする。
  その行に移動しなくても何か編集作業が起こる事があるだろうか。
  そしてその様な時には initialize_line を実行するべきだろうか。

  また移動せずに編集作業が起こったとしてもその瞬間に適用する必要はないのかもしれない。
  そもそも SLL SLH は暗黙移動に関する物で HT もカーソルの移動に関する物である。
  従って、カーソルがその行に始めて移動した時に処理するというので良い気がしてきた。

* TSM for DL IL

* ERM for EA, ED, EF, EL
  - done: ECH については完了した。
  - done: 取り敢えず ED と EL についても対応した。動作確認はしていない。
  - EA, EF についてはそもそも現時点で実装されていない。

* SEE for DCH DL ICH IL

* DECSTBM は現在のページだけに影響を与えるのだろうか。
  それとも全てのページに対して影響を与えるのだろうか。
  これはページに対応する時に改めて調べる事にする。

* sequence: 制御列などは最大長さを設定しておくべきでは
* sequence: 中に規格外の文字列が入っても許容する設定があっても良いのでは

2019-04-08

* ansi: 思ったのだが marker と通常の文字を区別する意味はあるのだろうか。
  表示する時に出力されるかどうか?
  文字幅が0かどうかの違いしか無い様な気がする…。
  例えば bidi の制御文字に関して考えると、
  正しくレンダリングされる為にはやはり制御文字も一緒に表示する必要がある。
  という事などを考えるとやはり通常の文字として埋め込んでしまう方が良いのでは…。

* ansi: 結合文字について
  やはり screen と Poderosa で振る舞いが異なる。
  というか UTF-8 ではない文字列が送られてくる様になる。

* attribute だとか character の拡張機能はどの様に処理するべきか。

  * 拡張オブジェクトの寿命管理はどの様にするのが良いか

    | attribute や character のコピーコンストラクタ等に処理を追加してしまう事にするか。
    | そうすると書き込みや読み込みなどの際に毎回チェックが入る事になり重い気がする。
    | 勿論、殆どの場合には拡張はないので if でフラグを検査するだけではある。
    |
    | 或いは、cell の側にオブジェクトなどを保持する為のポインタを設置するべきか。
    | 特に文字に関してはそちらの方が良い様な気もする。
    | "文字" というスカラー値でオブジェクトを運搬できる様にする必要性など実はないのである。
    | 然し、そういったオブジェクトの寿命は誰が管理するのだろうか。
    | 特に複数のセルで使い回されている時にどうするのか。
    |
    | 様々の事を考えると実は character に持たせるのではなくて
    | セル側に持たせるほうが自然に思われてくる。
    | 然し、一方で巨大な attribute をコピーする理由は何だろう。
    | attribute はそう頻繁に変更する物でもないし、
    | コピーして持ち回るほうが普通なのではないか。
    | Poderosa の場合には GC があるので自由にコピーして良かった。
    | C++ で実装する時にはどうするのが良いか。
    | よく考えたら C# で GC に頼っているのであれば、
    | C++ でも同様に実装しても良いのではないか。
    | つまり、"時々" 全体をスキャンして使われていなない属性を破棄するという事。
    | しかし、時々というのはどのタイミングだろうか。
    | 更に sixel 等の巨大なオブジェクトの場合には時々ではなくて、
    | やはり消滅する時にちゃんと始末しておきたい所である。
    | うーん。何とか全体をスキャンするコストを抑えつつ、
    | 参照カウントの更新の様な煩わしさを避けつつ、
    | という様にする事はできないだろうか。
    |
    | 例えば、画面の見える領域に関しては全体をスキャンする事にして、
    | そしてそれ以外の領域に関しては参照カウントで対処する等。
    | うーん。それが良いような気がする。
    | 画面の見える領域に関しては root オブジェクトとして取り扱う。
    | 画面から出ていった領域に関しては行を登録する時と、
    |
    | 行を削除する時に参照カウントを更新する事にする。
    | 以前の取り扱いよりも更に複雑になった気がしないでもないが、
    | まあ、この様にする位が高速で良いのだろうという気がする。

    画面の見える領域については参照カウントはしない。
    GC をする時に全体をスキャンして使われているかどうかを判定する。
    画面から出ていった部分については参照カウントを実行する。
    つまり、画面外 buffer に行を移動する時に inc して、
    画面外 buffer から行を削除する時に dec する。
    基本的に画面外 buffer に含まれる行は二度と編集が起きないという事は仮定する。

    ページ等に関しては退避する時に参照カウントを inc して、
    また復帰する時に dec する事にすれば良い。
    GC は一定の回数 attribute を生成する毎に実行する。
    大きなオブジェクトに関してはその都度チェックを実施すれば良い。

  * attribute に拡張属性を使用するか

    | 今 attribute は 4 bytes である。
    | extended attributes は 16 bytes ある。
    | 実はそんなにけちる程の物でもないかもしれないが、
    | 将来的に拡張する事なども考えるとやはり拡張性を持たせる?
    | 16 bytes あっても普通は使わないのである。と思ったが、
    | 最近では full color 対応なども出てきた。
    | そう考えると full color の為の 8 bytes はやはりあった方が良いのだろうか。
    | xattr に関してはそんなに使う頻度が高いとは思われないが、
    | しかし contra が広まるなどして拡張属性が広まれば
    | やはり使われる様になるかもしれない。
    | 文字を書き込む度に 16 bytes のコピーを何度も実施するのは微妙な気もするが、
    | しかし、うーん。現状で既に文字を書き込む度に物凄く色々な処理をしている。
    | 文字幅のテーブルを引いて、それから踏み潰される全角文字がないか確認して、
    | その上で書き込みを実施するのである。16 bytes のコピーをけちる所ではない。
    | 或いは、ASCII のみしか存在していない状況で最適化した実装をする事ができるだろうか。
    | 何れにしても 16 bytes (4 fields) のコピー程度は何の事はないだろう。

    16 bytes は文字の書き込み時に行っている処理の複雑さを考えれば
    大した手間とはならない (それを言い出すと拡張フラグのチェックも大した手間ではないが)。
    データサイズ的にはそんなに大きな物ではない。
    例えば 200字x10000行x16bytes = 32MB である。うーん。結構ある…。
    char 4B width 4B attr 16B だと 48MB であり、
    char 4B width 4B attr 4B だと 24MB である。2倍位の差になる。

    c 或いは画面から流れた内容を何らかの方法で圧縮して
      保持する方法などあるだろうか…。ANSI seq に変換して記録する等。
      然し、それはそれで複雑な行内容だった場合に困難が生じるし、
      複雑なオブジェクトがある場合には何れにしても困る。

    d 画面から流れた内容はファイルに書き出してしまっても良いのかもしれない。
      と思ったが、その時には拡張属性等はどう管理したら良いだろうか…。
      ファイルの中に領域を作るのも変だし、拡張属性・拡張オブジェクトだけ
      メモリ上に保持するというのも片手落ちな気がする。
      更にファイルに記録するとすると、そのファイルのインデックス等も
      管理しなければならない。ファイル内のどの位置が何行目に対応しているかという。

      然し、ECMA 48 の書き方を考えると画面から出て行った内容に対して、
      この様にファイルに書き出す機能という物があっても良い様には思う。
      それを画像として出力するのか、テキストファイルとして出力するのか、
      或いは、ASCII seq を含んだファイルとして出力するのかは色々。
      HTML にして出力してしまうという手もあるのではないか。
      sixel 部分に関しては適当に画像に変換してセルごとに保存してしまう。
      うーん。オブジェクトは確かに画面の外に出た瞬間に
      画像として残すだけで良い気がしてきた。

      一方で、昨今の Web インターフェイスの様な物を考えると、
      実は端末上でも領域に id でもつけて対話的な事ができるようにしても良いのでは、
      そしてスクロールして色々な情報を見られる様にして良いのではないか、
      等と考えないでもないが、まあその様な機能を実装したとして広まらないし、
      やはりやっても余り意味が無いような気がするので考えても仕方がない。

      本気でなにか広めるのだとしたら新しい OS でも作って、
      標準のターミナルでそういう面白い機能をふんだんに使った
      アプリケーションを提供する等しなければならない。
      しかし、余り複雑だとそれに追随するソフトウェアが現れないし難しい所である。
      精々ボタンを設置して、そのボタンが押された時に受信されるシーケンスを設定する位である。
      或いは terminfo に代わる様なライブラリを提供するか。

* [暫定実装] ansi: c2w の実装は中途半端な物である。
  結合文字などの文字幅 0 の文字の事を考慮に入れていない。
* [暫定実装] ansi: utf8_decode の実装も中途半端である。
  これは別の encoding の場合も考慮に入れて
  インターフェイスを考えておく必要がある。
  使う側もそれに合わせて実装する必要がある。

2019-04-05

* bidi: 情報を収集していたら余計によく分からなくなった。

  Unicode には bidi 関連の機能を制御する文字がある。
  それだけでなく文字の種類によって自然な文字の方向というのが存在して、
  アラビア文字等の場合には特に制御をしなくても勝手に文字の方向が決まる。

  contra の内部実装ではデータ部での論理配置を軸にして、
  表示上の移動などにも対応する事になる。
  表示部での操作を実装する為には、対応するデータ部での配置に変換できなければならない。
  その変換を実行するために必要なデータ構造は何だろうか。
  また、データ部・表示部における様々な操作に対してそのデータ構造を更新する必要がある。

  アラビア文字を挿入する度に周囲のアラビア文字との結合を考えるのは面倒である。
  従って、データ部・表示部の変換を実行する度に、
  行内にどの様な種類の文字が存在してどの様な配置になるのかという事を計算するのか。
  或いは、文字配置に関連するデータをキャッシュしても良い。
  或いは、やはり文字を挿入する度にそう言ったデータを管理する様にするのか。

  そしてマーカはやはり文字列としてデータ部の中に埋め込む形にするのが良いだろうか。
  その場合にはデータ部における明示的移動でマーカをどの様に設置することにするのか。
  文字を新しく挿入するとその右にあるマーカは削除する事になる。
  現在の実装のアイディアはこれに基づいている気がする。

  - 属性化領域(DAQ)・選択領域(SSA, ESA)・保護領域(SPA, EPA)
    これらはデータ部・表示部の変換に影響しない。
    従って独立に管理するのが良いのではないだろうか。
    また ECMA-48 に従うと表示部に対する範囲指定だが、
    用途を考えるとデータ部に対する範囲指定と考える方が良いのではないか。

    ECMAによると SDS, SRS の内部でこれらを設定する事はできない。
    然し、実際の端末ではそういった入力を受け取る可能性を排除できない。
    これらはその位置における SDS, SRS を解除すると見做す事にする。
    然し、その様に解釈すると DAQ, SSA, ESA 等のマーカーも全て
    記録しなければならないのではないだろうか…。

  - 方向付き文字列(SDS)・反転文字列(SRS)
    これらはマーカとして埋め込む。対応はその場その場で構築する。
    変なマーカの配置の仕方をしていてもちゃんとそれっぽく解釈する。
    折返しが起こる場合には一旦方向付き文字列を閉じて、
    改行してから再び同じ入れ子状態に復元する。

  - タブ(HT)
    これは事前に設定されているタブストップの位置と、
    実際にタブによって移動した時に起こるタブの確立を区別するべき。
    そして実際にタブで動いた時に起こるタブはまた内部に記録される。
    実際に発生したタブについて実は TCC を考えると
    文字も記録しなければならないのではないだろうか。
    うーん。従って現在の形式はやはり何か限界があるという気がする。

  うーん。簡単なプロトタイプ実装でも作って考えてみる事にする。
  UAX #9 を確認してみる。思いの外複雑である。
  というか先に UAX#9 を実装してから考えるのが良さそう。
  UAX#9 の為に一から作り直しになるのは面倒である。

  UAX#9 の要点をまとめつつ読んでいく。X1 の規則が滅茶苦茶長い。
  うーん。然し…これに従って並び替えた後に
  表示部での消去を実装するとどう振る舞うべきなのだろうか…。
  この様な複雑な処理を経ると最終的にどの様に切断したら
  見た目を変化させずに消去する事ができるのかという事を判定できない…。
  或いは表示部で範囲を決定するだけで、実際の消去はデータ部で実行して良いのだろうか。

  % UAX#9 の UBA の overflow_isolate_count と
  % overflow_embedding_count の取扱はこれで良いのか。
  % 例えば max_depth = 124 の時 LRI に失敗してその後に RLE に成功する事がある。
  % この時 oic = 1, oec = 0 になる。PDF が来るとそのまま処理される。
  % PDI が来ると oic-- して oec はそのままである。
  % 或いは max_depth = 124 の時 LRE に失敗してその後に LRI に成功したとする。
  % この時 vic = 1, oic = 0, oec = 1 になる。
  % PDI が来ると、vic=0,oic=0,oec=0 になってしまう。
  % そして PDF が来ると駄目になる気がする。
  →と思ったが、よく文章を読んでみると oic || oec の時必ず失敗する事になっている。
    従って失敗した後それが pop されるまでは成功する事はあり得ない。

  取り敢えず UAX#9 の実装を試みる事にする。

2016-10-19

* 方向付き文字列の対応
  - HT によるマーカの挿入
  - 各種テストの実装
  - マーカ個数の最大数を設定

2016-10-10

* ページについて。

  ページ関連の機能については一体どの様に実装するのが良いのかと悩んでいたが、
  RLogin のエスケープシーケンスを眺めていた所 RLogin はページに対応している事に気づいた。
  (もしかして xterm なんかも実装しているのだろうかと思って試してみたが実装していない様だ。
  mintty, screen, Poderosa も実装していない。)

  # 特に気になっていたのは画面の上端から流れて出ていった内容をある一定の長さで区切ってページとするべきなのか、
  # 或いはそれどころか画面内である一定の行数毎に区切ってページとするべきなのかという事であった。
  # それよりは画面内はやはりずっと同じページだし、
  # 上端から流れて出ていった内容もやはり同じページにあると考えた方が自然な気もした。
  # しかしそれだと他のページの内容を確認しにくいし、
  # SPH で設定した行は画面内の行ではなくて流れていった内容に含まれる行なのかなど色々わからない。

  RLogin の実装を見てみた所、ページは恐らく見えている範囲が 1 ページになっていて、
  各ページは altscreen と同様に差し替えられるという仕組みになっている様だ。
  上端から流れていった内容は別にページの一部とは考えれていない。
  ページの視点からは上端から流れて出ていった内容は飽くまで失われた内容という事である。

  結局、既存の実装があるのだからこれに従うのが良さそうだし、
  何よりなんとなくこの実装がそれ自体設計として良さそうに思われる。
  が、保険のためもう少しこの実装の声質について考えてみる。

  | なるほど確かに考えてみれば display で見えている範囲というのが丁度カーソルによって移動できる範囲であり、
  | それがプリンタに於ける一枚の紙とみなすのは自然である。そして上端から流れていった内容は、
  | 単に端末の追加機能として記録している物に過ぎず、端末の制御下にあるものではないと考える。
  |
  | と思ったがロール紙 (?) の様なのに印刷している場合はどうなんだろう。その場合には上端から流れていった内容も
  | やはり移動の対象としても良いような気がする。何よりページの移動というのは実際の印刷機では
  | 一体どのような動作に対応するのだろうというのが気になる。特にページを戻るというのは何だろう。
  | 普通のプリンタでは一度出力した紙はトレーに落ちて機械的に自動的に戻したりする事はできない。
  | そういう事を考えると一連の長いロール紙にページという単位の区切りを用意して前にスクロールしたり、
  | 後ろにスクロールしたりする事でページを移動するという風にデザインする事も可能である。
  |
  | そして規格の意図していることとは独立に、アプリケーションから見た時の、
  | 端末機能としての利便性という観点からも考えたほうが良いかもしれない。
  | そういう観点だとページの機能というのは、複数ある画面を切り替えるものとして実装するととても便利そうである。
  | 一つの画面の中に勝手にページ区切りができたりという風な設計だと使いにくいし、
  | また、手動でページ区切りを挿入するのだとしても別に便利だとは思われない。
  | そんなのはアプリケーション内で独自に別の管理の仕方をした方が楽に決まっている。
  | そういう意味で実装して意味のある機能か、という観点から言っても RLogin の実装は合理的である。
  |
  | また上端から出ていった内容に関しては、データの管理の観点から言って
  | 其処にカーソルを戻す事ができる様な設計になっているのは面倒である。
  | というか現在の実装を大きく書き換えなければならなくなり面倒である。
  | もしそれに対応するのだとしたら上端から流れていった内容に関しても、
  | ディスプレイの続きとして同じ配列の中で管理しなければならなくなるし、
  | そうするとメモリ効率などの点から行っても余り嬉しくない。
  | そもそも上端から流れて出ていった内容を確認する頻度というのは、
  | 画面内に文字を出力する頻度と比べれば小さい物だし、
  | どこかに掃き溜めの様に集めておくだけで良いのである。
  |
  | 一つの懸念は FF である。FF は規格どおりに実装するのだとしたら
  | 次のページに移動して SPH に移動するという物である。
  | (page or form と書かれているから頁ではなくフォームでも良いのかもしれない。
  | しかし form とは何だろう。実質 page と同じに扱って良い気がする。)
  | この実装だと、誤って FF を出力した場合に混乱を来す事になる。
  | 次のページに進むことによって今まで表示されていた内容が見えなくなるからである。
  | しかし混乱を来すとは言っても再描画すれば済むことだしそんなに致命的でない気もする。
  | 誤ってではなく意図的に FF を出力する様なプログラムも、LF や VT がある事を考えれば、ないだろう。
  | そう考えれば FF は本当に次の頁に移ってしまうという実装で良い気がする。
  | 一応 FF で LF と同じ動作になる様にできるオプションも付けておくのが良いだろう。
  | # 所で、複数のページがある時に現在のページ番号を表示する様にしても良い。
  |
  | もう一つの懸念は幾らでもページを追加できる様にするのかという事である。
  | 例えば FF だとか PPR を延々と吐き出すプログラムを作った時に
  | 端末はどの様に応答するべきかという事である。
  | 上端から流れていった内容に関しては通常は最大の行数を指定する事ができて、
  | それより沢山の行を出力する場合には順次ローテーとして古い行から消えていく。
  | しかしページの場合には PPA を用いてページ番号を明示的に指定して移動する事ができるので、
  | 古い物から順に消していくという作戦も使えない。或いは、その様に実装して
  | 消えたページに戻った時には空の内容を表示するという風にしたとしても、
  | 実際にいざ移動した時に新しく確保したメモリは配列にどの様に格納するのかという問題が生じる。
  | 勿論スパースな配列を実装して其処に記録するというのでも良いのかもしれないが、
  | それもまた変な実装である。何より使う側からすると謎の挙動に見えて分かりづらいだろう。
  | だとすると予めページ数に上限を加えるというのが現実的な解になるだろう。
  | とここまで考えて RLogin の実装はどうなっているのかというのを確認してみる事にする。
  | もし上限があれば何処かで止まるか、あるいはエラーになるかするし、
  | 上限がないのだとしたらメモリがどんどん増えていくというのを観察できるはずだ。
  |
  | $ for f in {0..10000}; do printf $'\e[ Qhello'$f'\n'; done
  |
  | 結果 RLogin の最大ページ数は 100 という事が分かった。最大ページ番号まで行くと、
  | それより次に行こうとしても何も起こらなくなる (※カーソル位置も動かない)。
  | もしかして設定項目に最大ページ数があるのかもしれないと思って確認してみたが、
  | [スクロールバックできるヒストリー行数] は設定できてもページ数は設定できない様だ。
  | しかし、[通信ログ] の項目に PAGE が云々と書かれているのでやはりページを意識した設計になっている。
  |
  | 更に RLogin のページを見ていると DECRQDE DECCRA DECRQCRA でページについて言及がある。
  | つまり、VT系列の端末ではページに対応していたと考えられ、
  | だとすると RLogin のページに関する動作は VT互換な物であると期待できる。
  | 従って、やはり RLogin の真似をして実装するしか無いだろう。
  |
  | 他に NP PP という機能がある。ECMA に従うと n-th following/preceding page to be displlayed
  | と書かれている。表示されるだけというのはどういう事だろう。
  | また active presentation position の変化は定義されないと書かれている。
  | 一方で RLogin の実装では上端から流れた内容を一時的に表示する
  | (というかスクロールバーの位置を変更する) 様になっている。
  | 現在位置は変化せず、次に最新の内容に変化があった時にはまたもとの画面に戻る。
  | つまり、PPA PPR PPB で操作される "page" と、NP PP で操作される "page" は異なるという事になる。
  |
  | ECMA-48 にも色々書かれている事が分かった。
  | - ED が ECMA では ERASE IN PAGE になっている事から、
  |   やはり page は ED の対象の範囲と同一であるべきで、
  |   だとすれば現在の page というのは現在表示されている範囲の事だと思うべきである。
  |   (ただ、これだけだと現在のページ以外のページがどういう形態を持つのか、つまり、
  |   上端から流れたデータをも含むのか、それとも別のバッファとして記録するのかは不明である)。
  | - 更に QUAD JFY に関する補足が ECMA-48 の付録にあって其処では、
  |   a display device with a multiple-page buffer では云々と書かれている。
  |   つまり page を扱える為にはそれ専用の特別のバッファを持っていると想定できる。
  |   ただ単に上端から流れていく情報を溜めておく装置は multiple-page buffer とは言い難いし、
  |   上端から流れていく情報を一定の行数毎に区切って移動できる様にしただけの物に
  |   新しく multiple-page buffer と名前をつけてそれを display device の特徴の一つとして挙げるのも変である。
  |   そういう事を考えれば、やはり規格的にも page というのは RLogin が実装している様に、
  |   それ専用の buffer に割り当てられる領域とするのが自然であろう。
  | - もっと ECMA-48 を見てみるとちゃんと [ECMA-48/6.3/3] に page について書かれている。
  |   また、[ECMA-48/6/2] にも書かれている。所で気になるのは、行は predetermined number of character positions
  |   からなると書かれている一方で、ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている事である。
  |   これについてはまた別に項目を立てて考察を行う事にする。

  [まとめ]

  - アプリケーションから見た時の利便性の観点からも RLogin と同様の実装が支持される。
  - DECRQDE DECCRA DECRQCRA などの存在から VT 端末も RLogin と同じ動作だろうと期待できる。
  - ECMA-48 的にも ED や Annex C の記述から、page 専用の buffer を持つディスプレイ装置が想定される。
  - NP PP は ECMA-48 的には一時的に他のページを表示するもの (?) の様だが、RLogin は上端から流れた内容を表示する。

  - PPA PPR PPB NP PP に関しては全面的に RLogin と同様に実装する。
  - FF はオプションで LF と同じか次のページに行くかを選べる様にする。
  - 頁数の上限を設定できる様にする。


  関連する制御機能を整理しておく。

  SPH SPL FF PFS
  PPA PPR PPB NP PP
  他にも未だあったような気がする…→ SEF だ。

  | * [2016-10-05] SPH/SPL の効果について
  |
  |   FF 及び implicit movement それから
  |   active presentation position does not normally go
  |   beyond the page limit position というのを実装する。
  |
  |   しかし、そもそも頁の概念を端末上でどの様に実装するべきかが明確でない。
  |   その他の頁を制御する制御機能の説明を調べて、
  |   その上で適切な頁の概念の再現方法を考える事にしたい。
  |
  |   また SLH/SLL と同様に頁毎に home/limit
  |   の値を設定する事ができるかどうか考察する。

  これに関しては行の属性と同様に、
  各ページに SPH, SPL を保持する様にする。
  同時に "現在の既定の SPH, SPL" も保持する。

2016-10-08

* emacs だとかのアプリケーションを動作させるだけであれば、
  terminfo のエントリにある物だけ対応しておけば実は十分という事に気付く。
  一々起動してどの様なシーケンスを送ってくるかを調べる必要はないのだ。

  infocmp xterm を見てみると意外と沢山ある。
  しかしキーシーケンスも多いのでどれが制御機能かぱっと見て分からない。
  後で terminfo の entries についても纏める必要があるだろう。

  序で infocmp ansi を見ると大分すっきりしている。
  というかキーシーケンスが全然ない。考えてみれば当然だ。
  ANSI 規格は制御機能しか定義していなくてキーボードは定義していないからだ。
  また、気になるのは ANSI 規格で処理系定義とされている機能についてだ。
  例えば xenl は infocmp ansi では書かれていないが、
  別に xenl でもそうでなくても ANSI 規格準拠の筈だ。
  後、altcharset (acsc) に普通に非 7 bit 文字が記述されているが、
  これらを utf-8 の環境で使うと何が起こるのか気になる。
  (ncursesw はちゃんと encode してから送信するのだろうか?)

* DECDWL, DECDHL の動作に関して。

  DECDWL, DECDHL, DECSWL は VT510 のページに記述がある。
  これらは行に対する属性として動作する。
  しかしこれらの属性を持つ行に関してカーソルの移動はどの様に働くのだろう。

  xterm, RLogin, mintty が対応していたので動作を観察してみる。

  - VT510 の DECDWL の説明によると元から行に存在していた
    内容の右半分は失われると書かれている。

  - xterm は DECDWL を設定した行であっても表示が二倍の幅になっているだけで、
    一行に収める事のできる文字の数は変化しない様である。
    つまり、画面の右端に行ってもその場では折り返されず、
    行の右半分だけが表示されないという動作になる。
    そして画面の右端に行って隠れた文字列はちゃんと記録されていて、
    \e#5 で行の文字の幅を元に戻すと画面の右端に行って隠れた文字列が戻ってくる。

    また、カーソル移動に関しては \e[C もしくは \e[D で移動すると、
    二倍の距離移動する様になる。つまり、文字数で移動する。
    (因みにカーソルの下に全角文字がある場合に \e[D しても半角分しか移動しない。)

    DECDWL の行で 4 文字目 (つまり7列目) にカーソルがある場合、
    \e[A で上に移動すると他の行の 4 文字目 (4列目) にカーソルが移動する。
    見た目に合わせて 7 列目にカーソルを移動する等という動作はしない様である。
    (ECMA-48 は presentation component での見たままの上下左右の移動に拘っている様なので、
    ECMA-48 を標準化している様な人からすれば \e[A は見た目の通りに 7 列目にするべきと考えるだろう。)

    DECDWL した瞬間にカーソルの位置が変わるかどうかも興味深い。
    xterm の実装では DECDWL した瞬間にカーソル位置は表示上右に2倍の位置に移動する。
    文字データの観点から言うと、DECDWL する前と後で指している文字は変わらない。

    結局のところ xterm の DECDWL, DECDHL の対応はただ単に "表示する時に横幅を二倍にしているだけ" であって、
    実際の端末の処理としては全然幅を認識していないという事になる。

  - mintty は xterm の動作を模倣している。

  - RLogin の場合には画面の見た目で行折り返しが起こる。
    つまり、DECDWL の行では半分しか文字を出力できない。
    然しながら、一旦行内を埋めてから DECDWL してそれから DECSWL をすると、
    また内容が戻ってくる。つまり、SLL を一時的に半分の位置に設定しているだけで、
    実際の内部的な表現としてはやはり一文字一セルで記録している物と思われる。

    面白い振る舞いとしては一旦行内を半分以上埋めて DECDWL をしてカーソルが画面外に出た状態で
    何か文字を出力すると、1文字目は何処にも出力されず、2文字目は行折り返しが起こって
    次の行に表示されるという事である。
    思うに RLogin は現在のカーソル位置が範囲外にあるかどうかをカーソルが移動した時に
    判定して記録しているのだろう。なので、カーソルが移動した後に設定が変わってカーソル位置がはみ出ても
    それを認識せずに文字を置こうとして失敗して、その後でカーソルを移動した時にようやく
    現在位置が範囲外であったという事に気づいて行折り返しを行うというそういう動作になっているのだろうと思う。

    カーソル移動については xterm と全く同じである。\e[C \e[D は2列ずつ移動するし、
    また \e[A \e[B すると前後の行の同じ列ではなく同じ文字番号の場所に移動する。

    所で DECDWL/DECDHL と sixel を組み合わせるとどうなるかを見てみた所、
    sixel の絵も横に二倍に引き伸ばされて表示される様である。
    序に DCH や DL も試してみたがちゃんと画像の一部が削除される様だ。
    これらの動作についてはまた後で様々の実装の間で比較する必要がありそうだ。

  結局、これらの実装が本当に VT の実機と同様なのかは怪しい。
  何れの実装でも行の右半分のデータを保持している。
  一方で、わざわざ VT の説明に行の右半分のデータは discard すると書かれている。
  これは、VT の実装では単に表示を二倍にしているのではなくて、
  丁度表示位置に対応するセルにデータを記録しているという事の気がする。
  だとするとカーソル移動は見た目での列に従って起こるべきだし、
  また行の内容が保持されたり折り返しがなかなか起こらなかったりという事もないのではないか。

2016-10-05

* RIS

  xterm ,screen, mintty はちゃんと表示内容も消去する。
  RLogin は RIS をしても表示内容を消去しない。
  Poderosa はそもそも RIS に対応していない。

* 基本的な移動機能その他

  > CUU CUD CUB CUF (現在位置・上下左右)
  > HPA HPB HPR VPA VPB VPR (記憶位置・行列)
  > CHA CNL CPL (行列)
  CPR
  DCH ICH ECH DL IL EL ED

* RI は一度消えた行ではなくて新しい行を挿入している @ screen
  RI IND

* Poderosa IL bug
  →バグ特定については 2016-10-12 を参照。

* http://invisible-island.net/vttest/

2016-10-04

* 本当に行毎に SLL/SLH の値を保持するべきなのか。

  subsequent lines と書かれているが、
  CUU 等で戻ってから上書きする場合には適用されないのか。
  また ED で erased state にされた行に設定されていた home/limit は消去するべきなのか。

  他に "以降の行" に適用される様な状態はあっただろうか。
  それらの機能の自然な動作も考慮に入れて考える。
  例えば SCP が以降の行に対して適用される物である。
  SCP の説明では現在行の内容の更新方法については述べているが、
  以降の行についての更新方法については述べていない。
  - 既に出力された行に再度移動して其処に新しく何かを書き込んだ時に、
    突然表示方法が変化するというのも変である。
    或いは、既に出力された行に移動した瞬間に変化するというのも変である。
    だとすれば、SCP が適用されるのは本当に新しく作った行に対してのみであるべきである。
    或いは LF もしくは NEL によって移動した時にのみ SCP を更新するというのも考えられるかもしれないが、
    しかしそれでも LF を単なる移動に使うという場合も考えられるし、やはり表示方法が突然変化するというのは変である。
  - ED によって空にした行については SCP はどう働くべきだろうか。
    ED によって空にした行についてはそれが新しい行であるかのように動作して欲しい。
    以前其処にあった方向性が残っているというのはおかしいからである。
    例えば中身が全て erased になっている行に限っては SCP の方向性が新しく適用されるというのはどうだろうか。
    しかし、それも不自然な気がする。周りの行が新しい SCP に影響されていないのに、間にある行だけ影響を受けるというのも変である。
    という事は、行自体に "この行は新しい行である" かどうかを保持するデータをつけておくべきだろうか。
    そして新しい行であった時に限って、現在の SCP をその行に適用し、"新しい行ではない" という様に書き換える。
  - では書き換えるタイミングは何であろう。例えば、一番初めに文字を書き込んだときであるべきか。
    それともカーソルを移動させた瞬間であるべきか。
    カーソルを一気に動かした場合にはどうするべきか。
    カーソルを一気に動かした場合にはスキップされた間の行にまで値が適用されるのは変な気がする。
    という事はカーソルを一気に動かした場合にはあいだの行には SCP は適用しないとする。
    そして、カーソルを一気に動かした場合と一歩ずつ動かした場合で同じ動作になって欲しいという事を考えると、
    結局カーソルの移動だけでは新しい行に属性を適用するには至らないという風にした方が良い気がする。
    つまり、行に対して具体的に何らかの変更が適用される時に初めて行の属性を適用するという風にする。

  さて SCP がこの様な動作をしている時に SLL/SLH はどの様に動作するべきか。
  カーソルを移動して前の場所に戻った時に、現在の SLL/SLH を用いて動作する方が良いか、
  それとも行が生成された時の SLL/SLH を用いて動作する方が良いか。

  % 普通に考えると現在の SLL/SLH を用いて動作したい所だが、
  % 一方で SCP での "以降の行" というのは新しく生成した行に対してのみ適用する事に決めた。
  % この時 SLL/SLH での "以降の行" を別の意味に解釈するのも変である。
  % もう少し考えてみる。SLL/SLH は行を生成した時の値を用いるという動作の方が自然に思われる様な例があるかもしれない。
  %
  % % 例えば、SCP で character path が反転している様な場合はどうだろう。
  % % DCSM(PRESENTATION) の場合には見た目によって位置が決まる。
  % % →しかし、よく考えてみたら SCP は表示部での character path つまり文字位置の番号自体を反転させるのであって、
  % %   記憶部と表示部の列番号の対応関係に影響を与える物ではない。
  % %   そして SCP の異なる行を跨った場合には、例え DCSM(PRESENTATION) であっても、
  % %   見た目に左右が反転している事を考慮に入れて表示部での列番号を移動するのではなく、
  % %   飽くまで表示部での列番号は保持したままで実際の位置は左右反転するという事になる気がする。
  %
  % うーん。でもやはり SCP での "以降の行 (subsequent lines)" との整合性から考えて、
  % SLL/SLH で設定される境界についても各行で保持して、
  % 新しい行に対してのみ現在の設定を適用するという様にするべきな気がする。

  →改めて規格を見てみると SCP の "以降の行 (subsequent lines)" は SCP の説明にしか出てこない。
    一方で、SLL/SLH の "以降の行 (lines of subsequnet line)" は TAB の設定などで複数回出てくる。
    さて、もし SLL/SLH を SCP と同様に各行で定義するとすると、
    整合性から考えて tab stop 等も全て行毎に管理しなければならなくなる。
    それは面倒であるし効率が悪そうな気がする。
    だとすれば、やはり SLL/SLH については共通の設定を一つ何処かに持っておいて、
    行毎には記録しないように変更するべきか。

  [結論]

  - 行には新しい行かそうではないかを識別するための属性をつける。
  - 新しい行に初めて文字などの書き込みを実行する時に、属性を適用する。
    また LF や NEL を実行した際にも属性を適用する。
    後 CR の直前にも実行しなければならない。というか LF の代わりに CR で実行するべき?
  - ED 等の消去関数を用いた場合には空になった行は新しい行としてマークする。

  これらについてはタブ関連の機能について調べてからで良いだろう。
  タブ関連の機能を見て、行毎に tab stop を管理しなければならなそうであれば、
  SLL/SLH も含めて行毎に管理をする様にする。
  もしタブは全ての行について共有なのだとすれば SLL/SLH もその様にする。
  →どうもタブ関連の機能は TSM で動作を切り替えられる様である。
    しかし TSM に影響されずに動作する DAQ(7) 等の機能も存在する。
    つまり基本的に character tab stop は行毎に管理して、
    但し、TSM = MULTIPLE の場合には特定の制御機能は
    全ての既存の行に対して作用するという事らしい。
    全体で共通の tab stop を管理するという様な事ではない様だ。

2016-09-25

* 各機能のテストコードを書く必要がある。

* BEL/HT/VT の正しい実装

* cell で毎回セルのアドレスを計算して取得するのではなくて、
  window.cur に現在のセル、もしくは現在の行へのポインタを保持した方が
  効率が良いのではないか。

2016-09-24

* planned programs

  - terminal multiplexer
  - terminal with graphical user interface
  - screen の様に複雑なことをする物が最終目的の一つだが、
    一方で、cygterm の様に他のプログラムとの仲介を行う物もあった方が良い。
    何かの折にそのようなシンプルな物が欲しくなることがあるだろうからである。

* ポーリングを O_NONBLOCK でやって sleep するのはやはり良くない?

  とはいいつつ入力と出力の両方を監視しなければならないので結局
  timeout を設定して交互に確認することになるので結局同じかもしれない。
  いや、然し同時に複数のオブジェクトを待つという種類の同期の方法が
  提供されていても良いはずだ。

  これについては今の所は致命的な問題になっていないので対処しない。
  後で余裕が出てきた時に正しい方法を模索する事にすれば良い。

2016-09-23

* PLD/PLU/SGR 10-19 の出力を実装する

* SGR 60-69 の実装方法について決める

  同時に複数の属性を on にできるのかそうでないのか。
  或いは出力先のターミナルに応じて処理を変えるべきか否か。

2016-09-22

* ルビ?

  ANSI や Unicode にルビの機能があるようである。面倒である。

  - ANSI に PTX という物がある。これはルビのための制御機能に見える。
    「CSI 1 \ 漢字 CSI 3 \ かんじ CSI 5 \」などの様にして使うものと思われる。
    行内に無理やり押し込めるのではなくて、隣の行に表示することを意図している様だ。

  - 更に Unicode にもそれ専用の文字がある。
    U+FFF9 .. U+FFFB  Interlinear annotation characters
    「<U+FFF9>漢字<U+FFFA>かんじ<U+FFFB>」などの様にして使う。

    <a href="http://unicode.org/reports/tr20/tr20-1.html">UTR #20: The Use of Unicode with Markup Languages</a>
    <a href="http://www.slideshare.net/xkawabata/2014-1109-texruby">TeXユーザの集い2014　発表資料（W3C Ruby）</a>
    <a href="https://en.wikipedia.org/wiki/Ruby_character">Ruby character - Wikipedia</a>
    <a href="http://www.wdic.org/w/CUL/%E3%83%AB%E3%83%93">ルビ ‐ 通信用語の基礎知識</a>

    U+FFF9 - U+FFFB にはそれぞれ IAA IAS IAT という略称が与えられている様だ。

    しかし Unicode も一体何を目指しているのか謎だ。変な制御機能を追加してドキュメントの構造を定義するのであれば、
    SGR だとかに対応する様な機能をつけて加えても良いような気がしてくる。勿論、論理的な意味構造に対応する物しか
    追加したくないという主張なのだろうが、誰が使うのか分からない妙な制御機能を付け加えるならばより明確な機能である
    描画属性ぐらい対応しても良い気がする。毒も喰らわば皿までという事である。

  * PTX と SRS, SDS の interaction についての問題

    | PTX は ECMA-48 を読む限り "普通は隣の行に表示する" などと書かれているが、
    | SRS や SDS など双方向テキストが混ざっている場合にどうするのかというのが謎である。
    | 逆方向の文字列に文字を追加するとその度に既に出力した文字列の位置はずれる。
    | そこに PTX が含まれていると "隣の行" の内容をふりがなで塗りつぶす事になるのではないか?
    | 更に、隣の行の上での双方向の構造がどのようになるのかも謎である。
    |
    | 改めて PTX の説明を読んでみると、PTX is used to delimit strings of graphic characters that are communicated
    | one after another in **the data stream** but that are intended **to be presented** in parallel with one another,
    | usually in adjacent lines. と書かれている。6.3/4 によると data stream はデータ部の中にあるデータの事と思われ、
    | だとすればデータ部の中ではルビは単に付加情報として取り扱われ隣の行には影響を与えない。
    | 実際に表示部に表示されるときにだけ隣の行に上書きして表示するものと考えるという事になりそうだ。
    | しかし、そうすると隣のセルに既に内容がある場合にどちらを優先して表示するのかといった問題が生じる。
    | 例えば、
    | a 常にルビを優先するか、
    | b 或いは常に本来のセル内容を優先するか
    | c もしくは後に描画したものの方を優先して表示するとか
    | a' 次の行の内容を優先するか
    | b' 前の行の内容を優先するという可能性がある。
    | d 或いは重ねて表示してしまうか。
    |   考えて見るに Unicode を完全に処理するとしたら行からはみでて表示される文字も表示したいし、
    |   そう考えてみると重ねて表示してしまうというのが現実的な解になるのだろう。
    |   また実際に其処にあるのに表示されない文字というのも変なので、両方表示したい。

    [結論]

    - データ部ではルビは付加情報として埋め込み、隣の行には影響を与えない。
    - 表示の際に具体的にどうするかは実装に任せる。
      一般的な実装としては表示の際に隣の行に表示する。
      隣の行に既に内容がある場合は重ねて表示してしまうのが良い。

    ※はみ出る文字があると再描画領域の計算などが難しくなるが、
      HTML レンダリングエンジンではそれをやっているのだし、
      何れにしてもふりがなだとかよりも先に実装することになるだろう。

* ANSI の記述によるとエスケープシーケンスは全て "文字" ではなくて "数" で指定されている。
  つまり、変な文字コードを使っていたとしても、エスケープシーケンスに含まれる
  '[' や ';' や '0' は ASCII における値を使わなければならない。
  従って、ソースコード中ではこれらは数字で表現するべきである。

2016-09-20

* original contra のコードの取り込み

  更にもっと古い ConsoleEscapeSequenceHandler についても統合を行いたい。

* gh-pages

2016-09-18

* 端末を作って遊ぶ。

* 端末の要素

  制御シーケンス・文字コードの解釈

    文字コードの枠組み iso2022 は制御シーケンスと渾然一体になっているので、
    どの様に取り扱うかは微妙である。既存のライブラリを部分的に使うかそれとも全部自前で処理するか。
    取り敢えず UTF-8 だけに対応してみるというのであれば大分楽である。というか自明である。

    制御シーケンスの最大の長さというものは決めておかなくても良いだろうか。
    幾らでも巨大なシーケンスを許容すると、超巨大なシーケンスを送りつけてメモリ不足にさせる、
    という攻撃が可能になってしまう。例えば、巨大なシーケンスはファイルに書き出すなどとしても、
    ディスク容量に依存してしまう。そういう訳で制御シーケンスの長さに制限を与えるのが現実的である。
    しかし現代に於いては巨大なデータを送りつける用途もある。
    シーケンスの種類に応じて適応的に処理するべきな気がする。

  バッファの管理

    内部的なデータの表現方法が鍵になる。この定義によって性能が規定される。

    そもそも何が必要か。行、文字、文字幅、属性の管理が必要だ。
    更に unicode grapheme clusters を考えると、結局文字はどう頑張っても可変長になる。
    属性については種類を限定せずに幾らでも拡張可能な様に設計するのが無難だ。
    また、画像だとかのインライン要素も管理しなければならない。

    同時にメモリ効率や変な脆弱性が入らない様にしたい。

  bidi

    既存の各 terminal が bidi をどの様に処理しているのかは確認しておく必要がある。
    特に行折り返しの時にはどうしたら良いのだろう。
    http://unix.stackexchange.com/questions/100811/are-there-terminal-emulators-that-support-bi-directional-text

    うーん。ある場所に hoge (表示 egoh) と出力して、その後にカーソルを色々移動した後に
    hoge の末端に移動して fuga (表示 aguf) と出力したとする。この時にこの二つの文字列が結合して、
    agufegoh という表示になるとそれは変だ。という事は bidi に対応する場合には、
    どの部分が連続して出力されたものなのかという情報を保持する必要がある。

    例えば属性を用いてこれを表現するなどはどうだろう。或る属性がついている文字は、
    次の文字と結合して bidi になる。最後の文字には bidi 属性は設定しない。次の文字とくっつかない為に。
    但し、最後の文字を削除する場合には前の文字から bidi を削除しないと勝手に次の文字とくっついてしまうので注意する。

    →ECMA-48 を読んでいたらわざわざ bidi の為に presentation component
    と data component という物が用意されている様だ。[ECMA-4.8/6.1]

  描画部

    この部分はただ愚直に実装すれば良い。何も問題はない。
    但し、更に別の端末に対して出力を行う場合には terminfo 等を参照せねばなるまい。

  キーシーケンスその他

    逆にユーザ側からアプリケーションに向かって送信されるデータ。
    これについても愚直に実装すれば良いだけである様に思う。
    但し、別の端末から受け取ったデータは翻訳する必要がある。
    これはやはり terminfo 等を参照する事にする。


------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2019-07-27

* scroll back と selection 色々考えなければならない [#D0164]

  * done: scroll buffer 内の選択も考慮してコピーを行う
    選択範囲の更新の際に scroll_buffer も毎回全てチェックするので遅いかもしれないが、
    まあ仕方がないだろう。物凄く巨大な scroll_buffer を考えない限りは大丈夫だろう。

  * done: 現在は term 自体に scroll_amount を保持しているが、
    これは view に依るのではないか。
    複数の view があれば複数の scroll_amount が可能の筈。
    という事を考えればまた一層挟んでも良いのではないかという気がする。

  * done: うーん。実は manager に expose するインターフェイスだけを集めた
    view 的な何かを定義した方が良いのかもしれない。
    これは上の項目で考察した人によって見ている箇所が違うという
    振る舞いにも通じる。

    →これは取り敢えず term_view_t として実装を分離した。
    現状では terminal_application に紐づけているが、
    将来的には独立させて複数の view を持たせられる様にする。

  ? 選択範囲の状態は画面 (view) 毎に持つべきなのではないか?

    | ここで問題なのは人によってそれぞれ選択したいという事があるのではないか、
    | という事である。同じ画面を複数の場所で見ていて、
    | それぞれで選択できた方が振る舞いとしては自然の筈である。
    |
    | その為には選択の情報と実際の表示内容の情報を別々に記録する必要がある。
    | 或いは、選択の情報は開始点と終了点だけを記録して、
    | 描画を実施する際に毎回開始点と終了点から範囲を計算するのだろうか。
    | それは重い。
    |
    | 一方で ECMA-48 が定めている selection はどの様に取り扱うべきか。
    | これはどの画面で見ても同様に選択されている状態になるべきなのではないか。
    |
    | a 例えば、ECMA-48 で定めている selection とユーザの選択は別物として扱う。
    |   これはそれぞれ操作するのに別の操作方法を用意する必要があるという事であり、
    |   そしてそれは使いにくいという気がする。
    | b 或いは、ECMA-48 で定めている selection は全画面にその場で適用して、
    |   それらの selection の設定・解除と画面上での選択は同様に扱うという事。
    | c 現状のように選択状態は全て共有するという事にする。
    |
    | うーん。実装が面倒なので取り敢えず c のままで良い気がする。
    | これが自然か不自然なのかは結局よく分からない。
    | 然し、何れにしても選択した文字列が端末の内容が幾らか変化しても保持されるのは
    | とても分かりやすい振る舞いの様に思われるし (他の端末はそうは行かない)、
    | もしこれを独立したデータ構造で実現しようとすると、
    | 端末の状態変化を追跡しながら更新しなければならずそれは不可能に等しい。
    | それならば端末の状態に選択状態を含めてしまって、
    | それで一緒に選択状態を更新させてしまうというのは自然な実装である。
    | 寧ろ他の端末よりも良い実装になっているのではないだろうか。

    [結論]

    ECMA-48 の定める選択範囲や、端末自体が選択範囲の情報を使って動作する事
    などを考えると選択範囲は唯一であった方が自然である。
    つまり、選択範囲の状態は現状の様に端末状態の中に含ませてしまって良い。
    またこれにより端末変化に対する選択範囲の追跡などが可能になっている。

* view の導入に関して [#D0163]

  | 導入しようと考えたがよく分からなくなった。
  | そもそも view は何処に配置するべきなのか。
  | terminal_application の中なのか、
  | term_t の中なのか、それとも renderer の中なのか。
  | 思うに view をどの範囲で共有してどの範囲で独立に取り扱うのかという事に依存する。
  | そして terminal_application とは何なのかという事についても改めて考え直す必要がある。
  | 現状だとそもそも term_t と terminal_application を分けて置く必要性が分からない。
  |
  | 更にスクロール機能というのは manager が管理するべき事なのか、
  | それとも terminal_application が管理するべき事なのかという事。
  | 描画についても manager のレベルで対応するべき事なのか、
  | それとも terminal_application のレベルで対応するべき事なのか、
  | というのが謎である。
  |
  | 結局描画だとかそういう事を考え始めると board+term は一緒になっていた方が、
  | (少なくとも現在の段階の実装では) 便利である。
  | terminal_application に関しても、実はもうくっついて居た方が便利なのではないか。
  | とも思ったが、まあ view の分離はしておく事にしようと思う。
  |
  | 問題は現状では terminal_application は固有の m_term を保持しているが、
  | 一方で、複数の画面で m_term を共有する時にどの様な構造が望ましいのか、という事。
  | terminal_application は manager の中の terminal の状態であると考えれば、
  | うーん? そもそもどの様な概念が必要であるかに関して列挙する必要がある。
  |
  | (1) term_t ... これが screen における buffer の役割である。
  | (2) terminal_application
  |   ... これは実は application というよりは pane なのではないか。
  |       とも思ったが良く分からない。
  | (3) panel ... これが実際に表示する画面なのではあるまいか。
  |
  | この様に考えると更にもう一つの階層を用意するという事だろうか。
  | うーん。然し、全ての terminal_application でスクロールバックや
  | 画面の一分表示という機能を使う訳ではないのである。
  | 否、少なくとも画面の一部分表示という機能に関しては pane の都合上必要である。
  | 問題はスクロールバッファを保持するのかどうかや、
  | スクロールバッファまでスクロールバックの対象とするのかどうか、という事である。
  |
  | 取り敢えず暫定的でも良いから結論を考える必要がある。
  |
  | * 画面の一部分表示の機能は提供する
  |
  | * スクロールバッファまでスクロールバックの対象とする機能
  |   a これを既定で使える様に実装して設定で使えなくするか、
  |   b 或いは既定ではそれを想定せずに実装して、
  |     使いたい時には自前で行を差し替える等して対応するか。
  |   これはどう考えても a の方が良いという気がする。
  |
  | * terminal_application は様々なキー入力を受け取って、
  |   それに応じて様々な動作をする。
  |   描画は term_t に対して実行するという様に動作する。
  |
  |   スクロールバッファについては意識しない。
  |   と思ったが上下左右のコマンドを受け取って
  |   スクロールを実施したりするのは manager の方なのか、
  |   それとも terminal_application なのかという問題が残る。
  |
  |   結局何が問題なのかというとスクロール機能というのは、
  |   各仮想端末の枠に備わっている機能なのか、
  |   それともそれを表示している manager の側の機能なのか、
  |   という事である。
  |
  |   うーん。もし terminal_application が端末に対応するのだとしたら、
  |   実はスクロールだとかそういう機能というのは manager 側に
  |   一任するべきなのではないかという気がする。
  |   或いは manager 側で pane に対応するとしたら、
  |   その pane 毎に管理するべき物なのである。
  |   というか実は term_view_t というのは pane に対応する物と考えるべき?
  |
  | 取り敢えず m_view は manager の側で管理する事にした。
  |
  | 結局一つの問題は何かというと term の機能が複雑すぎて、
  | それをちゃんと描画する為にはやはり term 自身の状態が必要という事にある。
  | そうでなければ term の為に描画を拡張する度に、
  | その拡張部分について各描画エンジンに対して個別に owner draw を定義しなければならない。
  | 不毛である。その様に考えれば各描画エンジンは初めからフルに term に対して描画を行うしか無い。
  |
  | 或いは描画に影響を与えるであろう機能を全て board の側に移行するという手もある。
  | しかし、少なくともモードの類は全て移動しなければならないし、
  | それに関連してごっそりと色々な物を移動しなければならないのではないか。

  * 先ず board と term はくっつけるかどうか? これについては保留
  * view は描画に必要な情報のインターフェイスとして取り敢えず実装する。
    スクロールの機能はおまけでつける。
  * 混乱の元なので取り敢えずは term_t のレベルから application のレベルに移行する。
    更に manager のレベルに移行するのは後で良い。

* tx11: 終了時のエラーメッセージ [#D0162]
  ウィンドウを [x] ボタンで閉じると変なエラーメッセージが出て良くない。

    XIO:  fatal IO error 11 (Resource temporarily unavailable) on X server ":10.0"
      after 12 requests (12 known processed) with 0 events remaining.

  調べてみると正にそれを解決するのだという記事が見つかる。
  https://qiita.com/SUZUKI_Masaya/items/e73791e20d78be640729
  その通りに書いてみたら解決した様な気がするが実際よく分かっていない。

2019-07-25

* ttty: スクロールバック対応 [#D0161]

  よく考えたら ttty は色々と対応が不足している。
  そもそも入力をデコードしていない気がする。

  * terminfo を使う事に関して → これは独立項目で取り扱う事とした

    | 現在は適当に実装しているが本来は terminfo 等を参照して
    | 動作を決定するべきである。然し ncurses はライセンスがある。
    | その事を思うと自前で terminfo のデータベースを解読する等の事が必要になるだろうか。
    | →ncurses のライセンスについて調べてみた所どうも MIT ライクなライセンスだそうだ。
    |   また、terminfo のバイナリ形式は標準化されていないので
    |   読み取れたり読み取れなかったりするそうだ。
    |   結局新しく何か変なものを作るよりは全て ncurses に任せて置くのが無難か。
    |
    | 大体の terminal は殆ど同じだろうと思って調べて見たがどうもぜんぜん違う様だ…。
    | うーん。世の中には変な端末がある物である。例えば khome について調べた所、47種類あった。
    | そもそも CSI シーケンスの形をしていない物など色々ある。
    |
    |   572 ^[[H      12 M-^@G    2 ^[^E
    |   324 ^^        10 ^[[f     2 ^K
    |   148 ^[[1~     10 ^[[2~    2 ^AN^M
    |   106 ^[H       10 ^[$A     2 ^A?^M
    |    73 ^[h        8 M-^?M-   2 M-^[26~
    |    71 ^[OH       6 M-^[1~   1 ^[{
    |    68 ^^PF       5 ^[p^M    1 ^[[G
    |    59 ^A         5 ^[[Y     1 ^[[44~
    |    55 ^H         5 ^[^R     1 ^[@
    |    37 ^[[26~     4 ^[c      1 ^[#G
    |    32 ^[[7~      2 ~^R      1 ^[^[E
    |    28 ^[[214z    2 ^]       1 ^Z
    |    27 M-^[H      2 ^[[OH    1 ^W
    |    25 ^[?        2 ^[R^M    1 M-^[44~
    |    21 ^[E        2 ^[G      1 M-^[ A
    |    14 ^Y         2 ^[!S
    |
    | この惨状を見たらまあ ncurses に依存しても良いかなという気分になる。
    | というよりそもそも sequence decoder で対応できる雰囲気ではない。
    | trie でも構築してそれを使って読み取る枠組みも一緒に使う必要があるのでは。
    |
    | 何れにしても、大体の端末で動くようにするという目的で、
    | ncurses が使えない時の為の自前のコードも書いておく事にする。
    | 取り敢えずは最初は面倒なのでそれで行く事にする。

  * 入力のデコーダを実装する
    取り敢えず入力のデコーダを適当に実装した。
    現在は ESC によるメタ修飾と SS3 によるキー等には対応していない。

    と思ったが ESC によるメタ修飾を認識しないというのは致命的である。
    修正する事にする。と思ったがどうやったら良いのかが分からない。
    ESC を取り敢えず置いておいて後でくっつけるという事ができたろうか。
    或いはよく分からない ESC を通過させるという機能はあっただろうか。
    というか ESC # 等がエスケープシーケンスとして解釈されてしまうのではないか、
    という事などを考えていくと input_decoder は sequence_decoder とは別に実装するべきなのでは。
    逆に良く分からないのは iso2022 に従っている時には M-# はどの様に送信するべきなのだろうか。

    というより良く考えたら M-\ だとか M-] や M-^ や M-_ だって制御列として取り扱われてしまう。
    うーん。input_decoder は sequence_decoder とは完全に別であるべきなのである。
    然し乍ら、M-[ は特別に "CSI として使われるので入力できない" というのが認められている気がする。
    % そういう意味でいうと M-] も "OSC として使われるので入力できない" になっていて良い気がするし、
    % その延長で考えると M-^ や M-_ も怪しい物である…。うーん。
    % 改めて調べてみるとアプリケーションに対して "OSC" が使われる事はない様である。
    % 取り敢えずはそういった制御列は処理しないという形で良い気がする。

    結局 input_decoder を再実装する事にして再実装した。

  * 改めて考えてみたら unicode にデコードしていない気がする…。

* twin: スクロールバックの描画 [#D0160]

  term を弄って行を取得する部分を書き換える?
  もしくは描画する側で適当に選んで取り出すのが良いか?
  スクロール状態をどの様に表現するか?
  スクロールバッファ内の位置を保持するのか、
  或いは、特定の行の位置を保持するのか。
  例えばスクロールバックしている間に回転したらどうするのか等。
  或いはスクロールしている間は端末の更新を止める等。

  twin の描画部分を見ると直接 board を参照している。
  これを term 経由になる様に変更したいのである。
  →取り敢えず manager 及び twin は term 経由でデータを参照する様に変更した。
  また manager で scroll_amount を設定できるようにしたい。

  取り敢えず動くようにする事が第一である。
  うーん。色々設計について考えてしまう。
  例えばスクロールしない terminal_application の場合もあるのではないか、等。
  更に、terminal_application が複数ある場合にはどうするのか、等。
  然し、そもそも形ができあがっていない段階から考えても無限に時間がかかるだけである。
  取り敢えず動く事を念頭に実装してそれでテストして、
  その後で必要になったら実装する。整理する、という具合にしなければならない。

  twin に実装してみたら意外とちゃんと動いている。

  x fixed: と思って選択しようとしたらクラッシュした。
    というか初期状態でクリックしようとしただけでクラッシュする。
    何かと思ったら無限再帰呼び出しになっていた。修正した。

  x ok: 選択が全くできなくなっている。
    スクロールしていない状態でも駄目。
    と思ったら、これはデバグの為にコードをコメントアウトしていただけだった。x

  x fixed: カーソルの位置が変である。
    これの事は考えていなかった。対応する。対応した。

  * fixed: DL で削除した行が transfer されるのは変な気がする。
    然し、他の実装ではどうなっていただろうか。
    というか、SU で移動した行は transfer されて良い。
    DL で移動した行を transfer するのは変、という気がする。
    ECMA-48 の意図的に。
    →やはり DL/IL では transfer しない様に変更する事にした。

* スクロールバックに対応したいという気がする [#D0159]

  先ず始めにバッファを用意しなければならない。
  これは term のレベルで実装するべきか、
  或いは board のレベルで実装するべきか。
  altscreen だとか或いはページだとかの概念を考えると、
  board のレベルではなくて term のレベルで実装したい気がする。

  | 然し、改めて考えてみると board のレベルで対応しても良いのではないだろうか…?
  | そもそも altscreen だって board の機能なのか term の機能なのかというと微妙である。
  |
  | ? というか board とは何か。
  |   今改めて観察してみると board は幅と高さと行の集合の様である。
  |   それに加えて presentation direction と行IDの管理が含まれている。
  |
  | ? presentation direction が board に所属しているのは何故かというと。
  |
  |   | a 表示する際に必要だから。つまり board だけで何らかの表示状態を表したかった。
  |   |   然し、現状では term の中の様々な状態も一緒に参照しなければまともに表示できない。
  |   |   そういう意味で既に分離に失敗しているのである。
  |   | b 然し一方で抑、行毎に direction という物が存在している。
  |   |   従って、board 自体の direction を
  |   |   行の direction の既定値として保持するのは自然である様な気もする。
  |   |   そして実際に確認してみるとその様な実装になっている。
  |   |
  |   | つまり結論としては行毎に方向を保持していて、
  |   | その設定の一つとして "全体の方向を既定値として用いる" という物があるので、
  |   | その為に board に既定値を保持しておく必要があるのだという事。
  |
  |   →行毎に方向を保持している。盤も既定値として方向を保持するのが自然
  |
  | ? 行IDの管理は board で行うべきなのかそれとも term で行うべきなのか。
  |
  |   今調べてみると結局 m_line_count を使用しているのは board の中だけである。
  |   altscreen の時にだけ m_line_count をコピーする様になっている。
  |
  |   然し、今気づいたのだが altscreen に m_line_count をコピーするのは良いが、
  |   その逆は実行しなくても良いのだろうか…と思ったが、
  |   考えてみたら altscreen の側で行を追加したりする事はないので関係ない?
  |   というか抑、コピーする必要性はあったのだろうか…。
  |   と思ったが、恐らく altscreen と本体の buffer を swap する時の対策なのだろうという気がする。
  |   →確認してみた所確かにそういう事だった。
  |
  |   然し、この様な実装は不自然といえば不自然である。
  |   抑、cur だとか m_line_count を使っていないのに記録している。これが変だ。
  |   width/height, lines, presentation_direction だけ保持していれば良いのではないのか。
  |   というかそもそも width/height だって必要なのか怪しい所である。
  |
  |   結局 std::vector<line_t> と presentation_direction だけ保持すれば良い気がする。
  |   ページの場合にはどうなのだろうか。うーん。ページも考えると微妙な気がしてきた。
  |
  | うーん。同時に色々の事を考えすぎている気がする。
  | 問題は altscreen, page, scrollback のそれぞれの形式を共通にするか、
  | 或いは独立にするのかという事と、更にそれぞれに現れる m_line_count を共通にするか
  | それとも独立にするのかという事。そして、もし共通にするのだとしたら、
  | 新しい行の挿入などは誰が実行するのかという事。
  |
  | 取り敢えず scrollback だけ対応する事にしたい。
  | 問題は行の削除を誰が実施するのかという事。
  | board の中で実施するのか、或いは外から実施するのか。
  | 現在の実装では board の中で実施する事になっている。
  | もし消えてなくなる行の内容を別の場所にコピーするのだとしたら、
  | その書き込み先を引数に指定する必要があるのではないだろうか。
  |
  | うーん。やはり何処にスクロールバックの情報を記録するのかという問題は残る。
  | スクロールバックしている間の表示を行う時は
  | 描画ルーチンに対してそのスクロールバックした行を渡さなければならない。
  | board と term を分ける事の利点は描画をするのに term 依存である必要はない、
  | という判断だった様に思われるが現状として tstate に描画が色々依存するので、
  | 実際には board だけでは描画できないという事。
  | またスクロールバック等に際しても board を変化させれば良いと考えていたが、
  | それは非効率的である様にも思われる。と考えたが、考えて見るにスクロールバック
  | している状況というのはそんなにないので一時的に board の状態を弄っても良い筈?
  | 然し、スクロールバックした状態でデータを受信した時などの事を考えると、
  | やはり実際の現在の board と表示の為に使う board を二つ管理しなければならなくなる。
  | 等という事を色々考えるとやはり term のレベルでスクロールバックを提供するのが適当ではないか。
  |
  | 諸悪の根源は board と term を分けている事である様な気がしてきた。
  | そもそも board を独立して使うアプリケーションが存在するかもしれない、
  | という様に考えたが実際にそういうアプリケーションを作る事があるのかは疑問である。
  | 或いは ncurses の中は簡単な window としてそういう物があるのかもしれないが、
  | その上で term を実装するというのはやはり無理がある様に思われる?

  色々考えた結果として board と term は将来的に統合する事にする。
  tstate に関しても統合の方向を考える様にしたい。
  或いは少なくとも大幅に整理してもっと小さな単位でメンバにする様にしたい。
  そして実際の動作は全て term 及びフリー関数で制御する様にするのである。

  現状は何が問題になっているのかというと
  機能の分離がちゃんとできていないという事。
  様々なメンバを跨ぐ処理になってしまっているのだという事である。
  フリー関数で制御する代わりにこれらのデータメンバのクラスを通して
  ある程度の機能を実装してしまうという可能性も考えられる?

  何れにしても全体的な設計について考える為には、取り敢えず、
  スクロールバックとページ機能を実装してみるというのが手である気がする。
  現段階では全て term 側で実装する事にする。
  特に tstate の上でスクロールバックなどを実装する事にしたい。
  或いは tstate ではなくて term の上で直接実装するか。。
  抑、tstate はモードだとか振る舞いに関する簡単なフラグを保持する物にするつもりだった。
  大きなデータを保持する予定はなかったのである。それが今や altscreen 等まで格納している。

  然し、制御機能を追加する度にメンバを増やすというのも不毛な感じはする。
  もっと動的にデータを追加・削除する仕組みにしても良いのかもしれない。
  ブラウザのDOM要素等は既にその様な実装になっているのだろうという気がする。
  文字列を識別子としてメンバを辞書に格納するという事なのである。
  速度的な観点でいうとその様にすると遅くなってしまう懸念があるので余りしたくはないが。。

  [何も考えずに term 上にスクロールバック機能を実装する]

  取り敢えず term 上に消滅した行を移動する事にした。
  実装した。然しそれを閲覧する機能はつけていない。
  これは別項目で議論する。

2019-07-24

* ttty.exe が常にデータを出力し続けている気がする [#D0158]

  確認するとカーソルの表示・非表示の状態を変更する
  コードは必ず毎フレーム出力される。
  然し、これに関しては描画がそもそも為されないのであれば必要ない筈である。
  然し、現状のコードでは描画が実際にされるかされないかは分からない。

  a 一つの方法は実際に描画が必要と分かった時にカーソルの
    表示・非表示を切り替えるという事。
    然し、実際に描画が行われるかどうかに関しては、
    呼び出した先の関数の中で処理していたりして面倒である。

    かと言って描画する関数自体にチェックを入れるとしても、
    描画を実際に行う時に毎回チェックする様にするのは非効率的である。

  b 或いは最初に描画が起こる可能性についてチェックして、
    もし描画が起こらないと判定できるのであればその場で関数を抜けてしまえば良い。
    考えてみればチェックはそんなに難しくなさそうだ。

  取り敢えず b の方針で行く事にする。実装した。

2019-06-02

* 2019-05-15 カーソルの移動などがあったら multiple click は解除するべき [#D0157]
  他のボタンによる移動なども検出するべき。
  というより他のボタンを途中で押した場合にもクリアするべき。
  →これは #D0156 で一緒に対応した

* 2019-05-15 manager: mouse の判定をもっとちゃんとする [#D0156]

  * down/up の整合性に関しては呼び出し元で管理する事にしたので
    manager の側では気にしない事にする。

  * 考えている内に何だかわからなくなった。
    望ましい動作は一体なんだろう。特に複数のボタンを同時に押した時。
    例えば mouse1_down mouse3_down mouse3_up mouse1_up の時の動作は何か。
    うーん。Poderosa の振る舞いを見ると mouse1_up で click が発生する。
    一方で mouse1_down mouse3_down mouse1_up mouse3_up の時には
    代わりに mouse3_up による rclick が発生する。
    つまり、up の時に他のマウスボタンが押された状態になっていなければ
    対応する click/rclick が発生するという事だろうか。
    然し、現状の Poderosa の振る舞いに倣わなくても良いのである。
    ユーザにとってもっと自然なふるまいはあるだろうか。
    途中で他のボタンを押した場合には click/rclick は発生するべきではないのではないか。

    a 例えば直前の down に対応する up だったら click になるという設定だとどうだろう。
      これだと 1down 3down 3up 1up の時に 3up で rclick が発生してしまって自然ではない。
    b 或いは直前の down に対応する up でありかつその間に他のマウスボタンによる
      イベントが発生していなかくて、かつ他のボタンが押されていない状態だったらどうだろう。
    c Poderosa (もしくは Windows?) の様に up した瞬間に単独だったらOKという実装?
      これは実は分かりにくい気がする。

    b で実装するとしたらどの様にすれば良いか。
    実は現在のマウス状態を記録して置かなければならない。
    うーん。改めて考えてみると c の振る舞いの方が分かりやすい気がする。

  * 後思ったのだがこういうマウスの down/up/drag から
    click/double click などを再構築するというのは普通に
    他の application でも使いたくなる物の筈である。
    という事を考えるとクラスとして独立させた方が良い様に思う。
    その場合には onclick だとか ondblclick だとかのイベントを登録できる様にする必要がある。
    インターフェイスとして実装するのと各メンバ関数で実装してデリゲートにするのとどちらが楽だろうか。
    デリゲートにすると親ポインタを関数ごとに渡さなければならず非効率的な気がする。
    一方でユーザーインターフェイス周りの仕様なのだから非効率でも問題ない気もする。

    どちらの場合でも初期化の時に this を渡したり event に代入したりするのを何処かに書かなければならない。
    という事を考えると初期化が必要という点に関して悩む必要はない。
    それは外部に独立させる場合には必ず支払わなければならない代償である。

    デリゲートで登録する様にするのはインターフェイスを実装するクラスとして、
    std::function を並べた物を用意すれば adapter になるので、
    インターフェイスで登録できる様にする方がより一般的な実装になっている。
    逆にデリゲートで登録するのをインターフェイスで実装できるようにするのは
    効率が悪くなるだけでまるで意味がないので考えなくて良い。

    従って、インターフェイス経由でイベントを通知する様にする事にする。

  * 後、up と down の間で修飾キーが変化した場合にはどうするのだろうか。
    この場合については途中で操作を少し修正しようとしたのだと解釈する事にして、
    そのイベント (click, dblclick) が起こった瞬間の修飾を使うという事にするので良い。

  * "現在アクティブなボタン" というのは multiple click 及び、
    drag 及び click で同じ物になるだろうか。或いは排他的な物になるだろうか。
    或いは、両方保持して置かなければならないといった事になったりするだろうか。

    問題は drag による selection が他のボタン状態の変化によって妨げられるかどうかである。
    例えば左ドラッグをしている途中で右マウスボタンを押下したらどうなるか。
    これは drag をキャンセルするのが自然である。

    * drag ... 複数のマウスボタンが押されている時はドラッグと解釈しない。
      他のボタンが押された時には動作はキャンセルされる。
    * click ... 他のボタンが押されている時には発生しない。
      これを検出する為には現在のマウスの状態を内部で追跡する必要がある。
    * multiple click ... これは click を引き金として起こす。
      前回の button を記録しておく必要がある。

    逆に言えば click 及び drag に関しては "現在アクティブなボタン"
    というのを覚えておかなくても良いのではないだろうか。
    現在アクティブなボタンを覚えていたとしても他のボタンが押されていないかどうか
    というのを判定する必要がなくなる訳ではない。

    と思ったが、drag に於いて左ドラッグで始めた物を終わらせずに
    途中で右ドラッグに変更した場合にはどの様に動作するべきだろうか。
    うーん。ドラッグとして扱われるべきではない気がする。

    ドラッグのボタンに関しては一番始めに押下したボタンを記録しておいて、
    もし途中で他のボタンが押されたらそれを無効化するという様にするのが良い。

  * 取り敢えず実装した。後は動作テストを行えば良い。

    x fixed: mouse_move してから選択しても multiple click が有効のままである。
      mouse_move で色々と無効化する様に修正した。

    x fixed: 試してみると選択によるクリップボードへのコピーが実行されていない。
      また装飾キーが存在していると選択がされない。
      これは現在の選択キーの検索の際に key を直接比較しているのがいけなかった。
      key の中でもマウスのボタンのフラグに大して検査を実行する様に修正した。

2019-05-15

* manager: a-0 で文字の大きさを元に戻す [#D0155]
  キーの配置を変更する事にした。動いている。OK
  a-+, a-- で拡大縮小ができる様にする。

  取り敢えず現在の所は a として Menu キー (VK_APPS) を割り当ててはいるが、
  正直な所押しにくい。自分で各装飾キーの意味を設定できる様にして、
  自分専用の設定として右 Alt を a に割り当てたい気もする。
  或いは prefix キーを登録できる様にする。
  色々試すと CapsLock や 無変換・変換・カタカナキー等は IME が反応してしまうので、
  勝手に装飾キーとして使ってしまうとかそういう用途には向かない。

* manager: 文字の大きさ拡大縮小の仕方が変な気がする [#D0154]

  やはり何か変だ。考え直さなければならない。
  現在の式は ceil(xpixel0 pow(1.05, zoom_level) + zoom_level) になっているが、
  これだと + zoom_level の部分で比率が変わってしまう。
  比率を保持する様に修正しなければならない。

  その為には y 方向だけに上の式を適用して、
  x 方向に関しては比率で計算するという具合にしたい。
  ではその場合に x 方向が limit を満たす様にする為には
  どの様に zoom_level を制限すれば良いという事になるだろうか。

  xpixel = ceil(ypixel * (xpixel0 / ypixel0)) という式で計算される。
  xpixel_min <= xpixel <= xpixel_max が満たされる様な ypixel は何かという事。

  xpixel = (ypixel * xpixel0 + ypixel0 - 1) / ypixel0
  - xpixel >= xpixel_min
    →ypixel * xpixel0 + ypixel0 - 1 >= xpixel_min * ypixel0
  - xpixel <= xpixel_max
    →ypixel * xpixel0 + ypixel0 - 1 >= xpixel_min * ypixel0 + ypixel0-1
  よって、 xpixel_min*ypixel0 - (ypixel0-1) <= ypixel * xpixel0 <= xpixel_min*ypixel0.
  次に A <= B*C という条件を A/C <= B 的な形に変形したいとする。
  うーん。(A+C-1)/C <= B ならばOK
  従って (xpixel_min*ypixel0 - (ypixel0-1) + (xpixel0-1))/xpixel0 <= ypixel
  また A*B <= C という条件を A <= C/B 的な形に変形したいとする。これはそのままでOK
  つまり、ypixel <= xpixel_min*ypixel0/xpixel0 という事になる。

  何だか分かりにくい式である。。。
  整理すると A*B <= C <=> A <= C/B,
    A <= B*C <=> (A+(C-1))/C <= B,
    A/C <= B <=> A-(C-1) <= B*C という事になる。
  うーん。恐らく整理しても綺麗な形にはならないのだろうという気がする。

* C-wheel による文字の大きさの変更に対応する [#D0153]

  wheel_up/down が送られてきていない気がする
  調べてみるとちゃんと WM_MOUSEWHEEL は発生している。
  と思ったら Ctrl を押している時のみというフィルタを自分で書いていたのだった。
  ちゃんと送られてきている。また、タッチパッドで wheel up/down が逆になっている気がしたが、
  本当のマウスで実行してみるとそういう事はなかった。つまりタッチパッドは、
  スクロールを反転させる為に勝手に向きを逆にしているという事なのだろう。

  さて。zoom down/zoou up を実装する為には何が必要か。
  先ず、列数・行数の調整が必要である。更にフォントの初期化も必要になる。
  フォントの大きさに関しては何か式で表現したい所である。
  後、最大のフォントの大きさと最小のフォントの大きさについても。
  最小の列数・行数と最大の列数・行数についても意識する必要がある。

  列数・行数に関しては既に WM_SIZE で実装している筈である。
  最初にフォントの大きさを決める所から始まる。
  うーん。問題は manager の方から GUI の方にリサイズの要求を提出するという事である。

  だらだら実装していたらできてしまったが構造として綺麗かどうかは微妙。
  また問題が出てきた時に構造は整理する事にする。

2019-05-10

* manager: 結局ダブルクリックで単語選択については実装されていない [#D0152]
  単語の範囲は取り敢えず簡単に実装する。
  - (2click) ASCII記号類とそれ以外で考える。
  - (3click) 空白とそれ以外
  - (4click) 行選択

  実装したのはいいけれども画面に表示されない。不思議だ。
  m_dirty は設置されている。ちゃんと該当箇所は呼ばれている。
  自分で明示的に set_selection を呼び出しても反映されない。
  あー。分かった。ループを回す時の y1 の代わりに y を用いていた。
  つまり、折角選択範囲を設定しても他の行に適用するはずの
  clear_selection を自身に改めて適用していたので
  何処にも選択範囲がなくなっていたのである。

  それでも未だ選択範囲が微妙に変だ。修正する。

2019-05-09

* session: ダブルクリックで選択できる様にする [#D0151]
  トリプルクリックで行を選択。
  これは時間を自分で計る必要がある。

  他の端末は選択範囲をどの様に決定しているのだろうか。
  Unicode のテーブルを使っているのだろうか。
  Unicode の表を持ってくる必要がある。面倒である。

  何れにしても記号かそうでないかで判定する。
  また表示部ではなくて当然論理的な順序を保持しているデータ部で
  連続する範囲を選択するのが自然である。

  * 2019-05-08 そもそもダブルクリックやクリックはどの様なタイミングで発生するべきか。

    % Win の UI を見ると mousedown の時点で両者とも発火している気がする。
    % でも実際にそうだったろうか。気になるので調べてみる。
    % と思ったら検出できなくなっている。。mouse_event で goto defproc にしてみても駄目。
    % dyna2018 で試してみてもやはり駄目である。何か変化した事はあっただろうか。
    % mouse event に対してすべて DefWindowProc に流す様にしても
    % やはりクリックやダブルクリックが発生しなくなっている。
    % 不思議だ。改めてメッセージを見るとやはり WM_LBUTTONDBLCLK というのが存在している様子。
    % もしかすると前から送らてきていないという事だったろうか。よくわからない。
    % それにこれだと結局通常の click については検出できないという事になる。自分で判定する必要がある。

    調べてみると window style に CS_DBLCLKS を指定しないとこのメッセージは発生しないそうだ。
    http://gurigumi.s349.xrea.com/programming/visualcpp/sdk_mouse2.html
    つまり以前から発火はしていなかったという事になる。また、目的のタイミングについては
    上記のサイトに既に書かれていたので改めて試さなくても良い気がしてきた。

    うーん。mouse down が double click に置き換えられるという事だろうか。
    もしそうだとすると、素直に WM_LBUTTONDBLCLK を使って実装すると
    mouse down した瞬間に double click の動作が発動するという事だろうか。
    他の実装がどの様になっているのかについて確認したい。
    mintty については2回目の mouse down で発動している。
    その様に考えるとやはり double click triple click に関しては mouse down で
    発動させてしまうという事にする。

  だらだらと書いていたらダブルクリックやらクリックやら右クリックのコードが完成していた。
  何か考え忘れている物があるような気がしてならないがまあ気にしない事にする。

  * 後、twin の側でちゃんと down drag up が consistent になる様に補正を行う様にしたい。
    現在のマウスの状態を記録しておいてそれに反する動作をした時には、
    release を呼び出すか down を呼び出すか或いは無視する。

  取り敢えず実際に動かして試してみる事にする。

  * 右クリックが効かないと思っていたら、
    よく考えたら右クリックは mouse3 と定義したのだった。修正した。
    取り敢えず問題なく動いている様な気がする。

    manager の側からは Windows のクリップボードは見えない、
    というか依存するわけには行かない。
    という事なのでイベントを定義する必要がある。
    ここで疑問なのは各イベントに対して関数オブジェクトを設置するのが
    良いのか或いは一括で様々な関数を提供するクラスを作成してしまうのが良いのか。
    うーん。Windows プログラミングで一つずつ関数を設定する方法が主流だったのは、
    どの様な種類のイベントが存在するのかという集合が予め決まっている訳ではなかった為。
    つまり、Window の中に様々なコントロールを設定して、
    そしてそれぞれのコントロールに対して少数の操作を定義するという事。

    今回はそういうパターンではない。設定の対象はそんなに多くなくて、
    しかし定義しなければならない操作は沢山ある。そういう理由で、
    一つのクラスに仮想関数を沢山設定する必要があるのである。

  次に色々と実装しなければならない。

  * done: 先ず右クリックで貼り付けができる様にする。
    貼り付けに関しては先ず初めに term_t にその機能を追加する。
    temrinal_application にその機能を追加する。
    取り敢えず clipboard_paste 関数を呼び出す様にした。
    clipboard_paste 関数は後で実装する。

  * done: コピーをどの様に実施するか。
    現在の端末画面から選択されているセルの内容を抜き出す。
    同時に適切な空白の padding をする必要がある気がする。

    % 先ず初めに SSA による選択も含めて選択の一番左の列を決定する?
    % というより一番始めに SSA が存在する行を取得するのが先?
    % 一番始めの行だけは初めから選択する事を許可する?

    矩形選択の場合とそれ以外の場合で適切に処理する必要がある。
    或いは一番始めの行の最初の文字を起点として、
    矩形選択の場合にはそれより前にある空白を
    無視するという実装でも良いのかもしれない。

    或いは各行で最初に ssa が設定されているセルが行頭にあると考える?
    guarded の事を考えなければそれが自然である様にも思われる。
    然し、実際には全角文字があって半角ぶんだけ選択セルの開始位置がずれていることもある。
    guarded なセルによってずれていることもある。

    矩形選択の場合とそれ以外の場合で処理を分ける事を考える。

    * 通常の範囲選択の場合には基本的には列は保持する様に空白を補填する。
      但し、始点または終点に一致する時に限り空白類は削除する。
      行ごとに抜き出す事を考えるとその一致する可能性のある位置を
      行に渡さなければならない。というか始点と終点の内でより前方にある物だけ考えれば良い。
      むしろ両方チェックするのではなくてその様にするべきである。

    * 矩形選択の場合には選択範囲の中で一番左にある列を取得して、
      その位置からの offset で切り出す様にする?

      矩形選択をした時に全ての行で全角の真ん中にあって、
      一番左のセルの位置がマウスで指定した物とずれている場合にはどうする?
      これは見た目を優先するべきである。ユーザはその様に指定したつもりなのだから。
      その様に考えると、やはり一番左にある列で考えるべきなのだろうという気がする。

      では全ての行で guarded になっていた場合はどうなのだろうか。

    * その行に選択されているセルが存在しないがマウスではちゃんと
      範囲を指定したという場合にはどうするのか。そのときは空行にする必要がある。
      つまり終点の行までは少なくとも空行であったとしても切り出す。

    選択状態にない時にどの様に振る舞うべきかも気になる。
    その時には普通に SSA 属性のついている行を選択するべきである。

    というか明示的な選択を行った時に存在する他の SSA を取り込んでも良いのかというのは疑問である。
    囲んだ瞬間にコピーする場合には取り込まない方が良い気がするが、
    一方で囲んだ後で出力された SSA などがある場合には C-c 等でコピーできてしかるべき気もする。
    前者の場合に関しては選択を開始した瞬間に他の選択は全て解除しているし、
    よく考えたら選択を更新する際にも全て解除しているので、そもそも他の SSA は存在しない。

    うーん。取り敢えず line_t 側で実装するべき事は何かというと。
    指定した x データ位置よりも後に存在するセルに関してコピーを実施するという事。

    * done: 先ず line_t に selected cells を抽出する関数を定義するという事。
      うーん。途中で trunc や gatm 等について考えて実装しなければならないのではないかと思ったが、
      それらは選択する瞬間に選択フラグを設定する為に使うのであって、
      一旦選択が終わってしまったら単に選択フラグを参照すれば良いだけである。
      従って、選択フラグを見るだけで良いのである。

      DWL 等におけるスペースの取扱はどうなるのだろう…。
      選択されていない範囲は幅に応じたスペースの数になる。
      選択されている領域に関しては実際に其処にある文字という事になる。
      その時に幅も考慮して空白を挿入するべきなのかどうかという話。
      うーん。矩形選択などの場合を考えると取り敢えず空白を挿入する事にする。

      取り敢えず実装した気がする。

    * done: 今は選択範囲に対する実装を行っている。
      取り敢えず実装した。動かしてみて内容を確認した。次に進む。

    * ok: 因みに終点と始点をそれぞれ計算する時には先にデータ位置に
      変換してから前後を決めなければならない事に注意する
      確認したところ、これは selection_update では正しく実装されていた。

  * done: clipboard_paste で使う為に terminal_events を twin.cpp 側で実装する。

* クリップボードからのペーストはここ。 [#D0150]
  http://nienie.com/~masapico/api_sample_clip01_c.html

  RLogin は実は OSC(52) seq でクリップボードの内容を取得・設定できるそうだ。
  これはかなり危ない機能なのではないだろうか。。

2019-05-08

* twin: 端末のリサイズができなくなっている [#D0149]
  サイズ変更がちゃんと伝播していない…。
  前まではちゃんと伝わっていたはずである。
  最近 reset_size のコードを変更したのでそれが原因だろうか。。

  取り敢えず調べる。調べると pty.cpp の set_winsize に到達していない。

  * 後気づいた事はウィンドウをリサイズしている途中に
    どんどんサイズ変更のメッセージが送られてくるという事。
    ウィンドウのリサイズを完了してからで良いのではないか。
    現在の実装だと例えば emacs を表示していた場合、
    物凄い勢いでウィンドウサイズの変更が送られてくる事になる。

    と思ったが、よく考えたらまあセル単位で変更があった時にだけ
    送るのだからそれ程には酷い事にはならないという気もする。

  とここまで来て端末まで変更の通知が行っていないのは、
  セル範囲で変更があったかどうかの判定するタイミングを間違えているのではないかという事。
  調べたら違った。というか見てわかった。

  terminal_application を確認すると
  reset_size(w, h) と reset_size(w, h, xpx, ypx) が独立に実装されている。
  両方上書きする様にしなければならないのである。
  片方を使ってもう片方を実装するという様になっていなければならなかった。
  以前はその様な実装になっていたが width/height だけ変更する時に効率が良い様に書き換えたのだった。
  しかし、実際にリサイズが重い処理であるのであれば、それはリサイズを実装している側で、
  以前と比べて変更があったかどうかを自動的に判定するべきなのではないかという気がする。
  確認すると board_t::reset_size はチェックを行っている。
  pty_connection::set_winsize ではチェックを行っていない。
  これはチェックを行う様に変更する。

* マウスが点滅する。WM_MOUSEMOVE で SetCursor すれば良いのではなかったか [#D0148]
  SetCursor のページを確認すると Windows クラスで cursor を NULL にしておかないと駄目と書かれている。
  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setcursor
  確かに自分の設定している Window クラスを確認すると LoadCursor で ARROW を指定していた…。
  実はここに IBEAM を指定しておけばわざわざ自分で SetCursor をする必要はなかったという事なのではないか。
  →実際のところそうだった。修正した。そのままでちゃんとI字カーソルになってくれている。

2019-05-07

* term: read_buffer_size を大きくしても 256 までしか上がらない可能性? [#D0147]
  少しテストで走らせている時に確認してみたらそんな雰囲気であった。
  read_from_fd 関数の中で出力してみたところやはりそうであった。
  65536 を request しているのに 256 しか読み取っていない。
  これは Cygwin の制限なのだろうか。或いは一般にそうなのだろうか。

  状況に応じて修正する必要があるかもしれない。
  もし linux でも常に上限が 256 なのだとしたら、
  何度か繰り返し呼び出しを試して一気に変換しても良いのではないか。
  →chatoyancy の上で確かめてみたところ 4095 が上限の様である。
    4096 で request したら 4095 だけ書き込まれた。
    64k で request しても 4095 だった。
    システムによって nonblock で書き込まれる量が異なるという事なのだろう。

  或いはその場でループを回したらもっと沢山取れたりはしない、
  という可能性も残っている。

  うーん。気になるので繰り返し呼び出す事にした。
  時間を計測してみると 64kb 読み取るのにかかる時間は 2645ns であり、
  更に 64kb を term_t, sequence_printer 等で処理するのにかかる時間は
  28ms 程度であった。まあ、ビジー状態であれば 28ms ぐらいの遅延があっても
  良いだろう。しかし、これは今使っている性能の良いパソコンの話であるから、
  実際にはもう少しバッファサイズを小さくしても良いのではないかという気がする。
  16kb まで縮める事にした。

* 行内に保持できるセル数に上限を設けるということ [#D0146]

  現状の実装では一つの行に marker を何個でも挿入する事ができる。
  然し、この実装だと攻撃として marker だけを大量に送りつける、
  という物が実現してしまう。なので上限を設けるべきである。
  これは cluster extension についても同様である。
  a 一つの制限のかけ方は行内の合計のセル数に上限を設ける方法。
    この方法だと制限に引っかかった時に有限幅の文字が保持できなくなる。
    或いは合計のセル数が或る値よりも多くなったら有限幅のセルしか挿入できなくする。
  b もう一つの制限のかけ方は行内のゼロ幅のセル数に上限を設ける。
    この方法だと現在の行内のゼロ幅のセル数を覚えて置かなければならない。
  c 或いは、一つの境界辺りのゼロ幅のセル数に上限を設ける。
    これは微妙である。或る境界に集積して marker を設置したいという状況は考えられる気がする。
  更に上限に達した時にどの様に振る舞うべきかも考えなければならない。
  これは上野それぞれの方法に応じて考えれば良い。

  制限をどの様に設定するのかについても考えなければならない。
  例えば現在の端末幅に応じて設定するのか、
  或いは十分に大きな値に設定しておくのか。
  というか、よく考えたら現在の端末幅であっても制限をかけなければ駄目だ。
  mintty の様にいくらでも zoom out できる様な端末の存在を考えると、
  横幅に制限をかけるとしても 500 とかではなくて 2000 とか
  4000 ぐらいあった方が良いのかもしれない。

  contradef 辺りに limit を定義しておくのが良いのではないか。
  名前空間はどうするか contra に直接書くのだろうか。
  或いは contra::limit とかそういう物にするか。

  % 語呂の良いものを考えたくなる気もする。limit 的なラテン語はあるのだろうか。
  % terminus というのがある。然し逆に変換すると border になった。うーん。
  % restriction は restrictiones praestituere になった。うーん。
  % 余り変な事は考えずに contra::limit にするか、
  % 或いは物理の用語か何かから取ってくるか。
  %
  % contra から始まる英単語を列挙しておくのも良いのかもしれない。
  % 検索しようと思ったが検索できない。Web 上の辞書で検索すると熟語も一緒に
  % 引っかかってしまって、実際のところ熟語が 6000 ぐらいあって
  % その中に埋もれてしまっている。駄目だ。まあ、後で考える。
  %
  % - contradict (使用済み)
  % - contract (意味的には微妙)
  % - contrabass (調べると実はメモリとかI/Oとかのバスは bus だそうだ)
  % - contribution (でも活用は語呂が合わないので使えない)
  % - controversial
  % - contrast (コマンド名にするには長い)
  % - contravariant, contravariance

  余り色々の名前空間に散逸はさせたくない。一方で contra に直接入れるのも違う気がする。
  contra::limit なのか contra::limits なのか。<limit> <limits.h> 等の前例を見ると、
  どちらでも良い気がする。limit を limitation の短縮と思えば limit でも大丈夫の気がする。

  取り敢えず insert_marker は maximal_cells_per_line に対応した。
  insert_graph は勝手に改行して別の行に行くし、
  そもそも有限の幅の文字しか挿入しないので、
  1つの行にどんどん累積していくという事はない筈。

* 2019-04-29 twin: コンソールが一瞬表示されてしまう問題をどうにかする [#D0145]
  ref #tmp0001

  % FreeConsole は効果がなかった。
  % ShowWindow(GetConsoleWindow(), SW_HIDE); は一瞬表示されてしまう。
  % そもそもアプリケーションの種類というかそういうのを指定できないのだろうか。

* 2019-04-29 [自然解消] twin: ウィンドウの背景色の設定 [#D0144]

  % ::SetClassLong(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(0,0,0)));
  % 等の様にして設定する事ができる様である。ちらつきを抑える為には、
  % 一番大きな面積を占めている色にこれを設定しておくのが良い気がする。
  % 取り敢えず WM_CREATE 辺りに置いておく事にする。
  % →というか、自分で RegisterWindowClass しているので、
  %   その時のパラメータに指定すれば改めて指定しなくてもよかった。

  →これはダブルバッファリングにした為に余り意味を為さなくなった。忘れる事にする。

* refactor: pty_connection へのパラメータの受け渡しが無駄な気がする [#D0143]
  やはり pty_connection に関しても初期化用のクラスを作成するか、
  或いは pty_connection と terminal_session をくっつけるかする。

  pty_connection はそれ単体として使えそうなクラスになっているので、
  やはりくっつけるのは止める事にしたい。
  或いは、terminal_session_parameter クラスをそのまま渡す様にするか。
  →すべて terminal_session_parameter で渡す様にしたら綺麗になった気がする。

* ttty が起動しなくなっている [#D0142]
  impl1 は起動する。impl2 が起動しない。
  これは move した後のオブジェクトに触っていたのが原因だった。修正した。

* ansi: 現在 UTF-8 に合わない文字はどの様に解釈されていたのだったか [#D0141]
  勝手に無視するのではなく U+FFFD に置き換えるのが適切と考えられる。
  https://www.jpcert.or.jp/java-rules/ids11-j.html にも書かれている。
  と思ったが、既に NUL や DEL は規格に従って無視している。
  うーん。まあ、検査を行う前にそういう文字コードの処理はちゃんとしているべきなのである。
  現在のコードをチェックした所、無視していた。
  実は無視しているから高速に動作しているという可能性?

  後、非正規の UTF-8 についてもちゃんと棄却する事にする。
  全て U+FFFD に置き換える事にした。と思ったら速度が低下した。

  うーん。更に挿入に関しても一文字ずつ書き込むのではなくて、
  行内に入る限りは一気に挿入する様にした。
  しかし、微妙に高速化したものの 10% ぐらいしか変化しなかった。
  という事は、文字の挿入ではなくて行の挿入に時間がかかっているのだろうか。。

  - ok: 或いは、ちゃんとまとめて挿入する機能が働いていない?
    確認した所ちゃんと働いている様に見える。
  - 然し、改行の挿入をやめてみてもやはり速度は変化しない。
    という事は、実は c2w に時間がかかっているという事なのだろうか。
  - 文字幅の計算を (u < 0xA0 ? 1 : 2) といういい加減な物に変更したら
    だいぶ改善した。つまり文字幅計算が悪い…。
    それでも未だ多少の時間がかかっているが、
    これは文字を処理する事自体の重さであろう。
    それに文字幅を不当に大きく評価しているので、
    改行などの処理も却って大きくなっている面もある。
    後で高速化について考察する時には文字幅の関数を改善するべき。

    或いは別のテスト方法として error_char を '?' にしてしまうという事。
    そうすれば c2w の最初のテストで引っかかる筈である。
    と思ったがリモートだとテストできない。

2019-05-06

* twin: カーソルを変更したい [#D0140]
  変更するようにした。WM_MOUSEMOVE の度に呼び出すのがセオリーの様だ。

* twin: 環境変数を設定する様にする [#D0139]
  何故か HOME が適用されないと思ったら chdir する必要があった。

2019-05-05

* twin: mouse move の頻度 [#D0138]
  よく考えたら、今全ての mouse move イベントを報告している。
  前回から変化があった時にだけ通知すれば良いのではないだろうか。
  但し、px, py を使いたい事もあるので端末で送る時にだけ前回からの x, y の変化を見る事にする。

* ansi: やはり何だか振る舞いが変である [#D0137]
  emacs で編集しているとカーソルの位置がずれる。
  これは或いは VT だとか FF だとかの振る舞いの違いに起因するのだろうか。
  しかし、emacs が VT やら FF やらを使っているとは考えにくい。

  Emacs の出力するシーケンスを確認したら LF BS BS 等として移動している。
  つまり、LF を下に移動するシーケンスと考えている様である。
  一方で contra の既定の振る舞いは何だったか。
  確認すると mode_lnm で変化する様になっている。
  また lnm は既定で true になっていた。既定で false に変更する事にした。

  念の為に mintty と RLogin で確認するとやはり既定で false だった。
  序に DECRQM にも対応した。

* twin: 選択範囲に対応したのは良い物の [#D0136]
  実は選択は見た目で行うのではなくてデータ部で行うべきなのではないか。
  つまり、双方向対応で反転文字列等がある場合には、
  反転を考慮に入れた上で選択範囲を決定しなければならないのではないだろうか。
  だとすると現在の様な実装では難しい。データ部で属性を付加してしまうのが速いのではないか。
  そうすれば line.version を加算するだけでちゃんと表示も更新される。

  また、末尾の空白を選択しないだとか GRCM 等に従って
  選択できない物を判定するだとか、そういう複雑な判定をする場合にも、
  現状の様な位置文字ずつその場で判定する方法だと難しいのではないか。
  それよりは全体に対して選択を計算してしまう方が計算としては楽の筈である。

  所で選択に関連して SSA, ESA はどの様に処理するのが望ましいか。
  例えば、選択されている状態にして、その状態でコピー等の操作をすると
  コピーされるとか、そういう風に使う事ができるのではないだろうか。うーん。

  そういう風に考えると実は SSA のフラグで
  選択を管理してしまっても良いのかもしれない。

  決めた。。選択範囲は SSA, ESA のフラグを使って実装する事にする。
  * done: 先ず初めに現在の反転コードは削除する。

  * done: うーん。取り敢えず行内で指定範囲を選択するコードを書くことにした。
    然し、効率だとかを考えて色々工夫してみたが、よく考えたら実際にはもっと複雑である。
    うーん。実装し直す事にする。

    GATM, truncate_nul, trancate_sp, dcsm 等のオプションがある。
    更に、よく考えたら全角文字の場合には範囲内に
    完全に収まっている場合以外には選択しない。

    結局以下に書いた効率の良さそうなコードは全く使えない
    という事が分かったので、ここに残して供養とする。

    | static bool mono_set_selection_simple(std::vector<cell_t>& cells, curpos_t x1, curpos_t x2) {
    |   curpos_t const iN = m_cells.size();
    |   curpos_t const i2 = std::min<curpos_t>(x2, iN);
    |   curpos_t const i1 = std::min<curpos_t>(x1, i2);
    |   curpos_t i = 0;
    |   xflags_t dirty = 0;
    |   while (i < i1) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= a;
    |     a &= ~attribute_t::ssa_selected;
    |   }
    |   while (i < i2) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= ~a;
    |     a |= attribute_t::ssa_selected;
    |   }
    |   while (i < iN) {
    |     auto& a = m_cells[i++].attribute.xflags;
    |     dirty |= a;
    |     a &= ~attribute_t::ssa_selected;
    |   }
    |   return dirty & attribute_t::ssa_selected;
    | }
    | static bool prop_set_selection_simple(std::vector<cell_t>& cells, curpos_t x1, curpos_t x2) {
    |   std::size_t const iN = m_cells.size();
    |   std::size_t i = 0;
    |   curpos_t x = 0;
    |   xflags_t dirty = 0;
    |   while (i < iN && x < x1) {
    |     auto& cell = m_cells[i++];
    |     dirty |= cell.attribute.xflags;
    |     cell.atrribute.xflags &= ~attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   while (i < iN && x < x2) {
    |     auto& cell = m_cells[i++];
    |     dirty |= ~cell.attribute.xflags;
    |     cell.atrribute.xflags |= attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   while (i < iN) {
    |     auto& cell = m_cells[i++];
    |     dirty |= cell.attribute.xflags;
    |     cell.atrribute.xflags &= ~attribute_t::ssa_selected;
    |     x += cell.width;
    |   }
    |   return dirty & attribute_t::ssa_selected;
    | }
    |
    | // GATM や末尾空白を考慮に入れなくて良い場合は効率的な実装を使う
    | if (!trunc && gatm) {
    |   if (!m_prop_enabled) {
    |     if (mono_set_selection_simple(m_cells, x1, x2)) m_version++;
    |   } else {
    |     if (prop_set_selection_simple(m_cells, x1, x2)) m_version++;
    |   }
    |   return;
    | }

    まあ、何だかわからないが行の更新に関しては完成した気がする。
    但し表示部における選択には対応していない。
    というか表示部における選択というのはまともに実装できる物なのだろうか。
    うーん。対応するデータ部における範囲は細切れになる。
    そして方向文字列などの形状を保つ為には色々なマーカを追加しなければならない。
    選択しているだけなのに変なマーカを挿入すると色々と破壊されてしまう。
    従って選択している時には唯表示のためだけに ssa_selected を設定して、
    実際にデータを切り出す時にはマーカなどを指定して見た目を保つ様にしなければならない。

    というかその事情はデータ部でも同じなのではないか。とも思ったが、
    普通に考えたら選択してコピーというのはデータを保って欲しい
    (見た目ではなくて) ので、そのままで良いのである。
    何れにしても表示部における選択は需要がない様な気がするので取り敢えずの所は実装しない事にする。
    念の為インターフェイスとして引数に dcsm を取るようにはするが、エラーを出力して終了する。

  * 更に表示部での座標から。

  取り敢えず全て実装した。選択領域についてはOKである。

* twin: 何だか色合いが自分のなれている物よりも濃い [#D0135]
  RLogin とは同じ位の色合いだが、うーん。

  Poderosa のソースを見ると i==0?0:i*40+55 と書いてある。
  うーん。現在の実装では 51*i でやっているが切り替える事にする。
  6x6x6 color cube の式は色々だ。

* twin: 無限ループになった [#D0134]
  今度は分かりやすい無限ループである。関数の場所を見ると。
  input_key 関数の中で起こっている。これは今編集したところだ。直した。

* ansi: mouse events の encoding に対応する [#D0133]
  これは ?1000, etc に一緒に対応する必要がある。

* [勘違い] twin: と思ったら今度はまた DECDHL で下線が引かれる様になってしまった。 [#D0132]
  何故だろう。何か変な所を触ったろうか…。
  直近の変更の装飾を描画する時に零幅の文字をスキップする様にしたのが悪いのか。
  戻してみたが関係なかった。と思ったら demo.sh の方がいけなかった。
  下線を引くシーケンスを書きかけてそのまま放置していたのだった。

* ansi: 気付いたのだが ERM が RLogin と逆だ [#D0131]
  ECMA-48 を確認した所逆だった…。修正した。

* 2019-05-03 twin: 選択・貼り付け [#D0130]
  これはマウスを実装してからにしたい。
  Windows の仕組みではなくて端末の仕組みを使って選択・貼付けを実装したい物である。

  | うーん。色々考えた結果、やはり選択は term_t の側で実装する事にする。
  | mouse down/up が全て通知されているのであれば term_t の側で実装できて然るべきなのである。
  | と思ったが本当にそれで良いのだろうか。実は間に何か挟むべきなのではないだろうか。
  |
  | terminal multiplexer としての機能も考えると term_t ではなくて、
  | 更にその上の枠組で実装するべきなのではなかろうか。
  | うーん。今、term_t に input_key という機能を取り付けてしまった。
  | うーん。然し、これは本当に適切だったのだろうか。
  |
  | もう少し落ち着いて考えてみる。
  | ユーザが何か入力する。入力内容は取り敢えず符号化されずに
  | アプリケーションに到達する。アプリケーションはそのまま処理しても良い。
  | 一方で、端末の向こうのアプリケーションに伝達したければ、
  | 端末に入れる事になる。そして端末は符号化して送信する。
  | 端末の行き先では受信したバイトを復号してまたキー入力にして、
  | そしてそのアプリケーションで利用する。端末の符号化と復号は透過的でなければならない。
  |
  | うーん。結局単純化されたインターフェイスを定義して、
  | それに従って端末はアプリケーションの振りをする。
  | という様に振る舞う必要があるのではないだろうか。
  |
  | 単純化されたインターフェイスとは何か。現状では以下の通り。
  | (1) キー入力・マウス入力を受け付ける。
  | (2) 現在の画面の状態を提供する。
  |   画面の状態を実際に描画するのは twin_window_t 側に任せる。
  |
  | では通常のアプリケーションはどうなのだろう。
  | 先ず (1) については共通で良い。一方で (2) に該当する物はない。
  | 強いて言えば標準出力として色々な文字列を画面に出力するという事になる。
  | 結局、端末を介して (2) を獲得するという様に考えるべきなのかもしれない。
  |
  | うーん。つまり、アプリケーションの種類に応じて形態が色々という事。
  |
  | * 通常のコマンドは標準入力を受け取って標準出力に出力するだけ。
  |   これは一種のこういうインターフェイスと見ることができる。
  |
  |   interface input_and_output {
  |     void write(data);
  |     event output(data);
  |   };
  |
  | * 一方でテキストエディタ等は上記の interface の様であるが、
  |   実際には内部でより複雑な事をしている。
  |
  |   interface interactive_application {
  |     void input(key);
  |     event draw(canvas);
  |   }
  |
  |   実際に実装される時には input_and_output を実装するアダプタが
  |   これを操作する事になる。adapter は標準入力を受け取ってそれを
  |   キーの列に翻訳して application に渡す。そして application が
  |   何か画面状態を更新したら adapter はそれを update するシーケンスを
  |   生成して標準出力に書き出す。
  |
  |   丁度これと同じ事をするのが GUI でもある。
  |   ユーザの入力からキーの列を生成して input とする。
  |   画面の状態を更新したらそれを実際に描画する。
  |
  | * 或いは、キー入力を受け取ってまた画面状態を提供するが、
  |   実際には input_and_output を介して実際のアプリケーションと通信をする、
  |   というものも存在する。
  |
  |   実のところ term_t の位置付けは何処にあるのだろうか。
  |   term_t というのは単なる画面状態なのか、
  |   或いは単独の application の振りをする物なのか。
  |
  |   また terminal_session は一体何なのか。
  |   現在の実装だと term_t の初期化を行うためのクラスにしかなっていない。
  |
  |
  |   うーん。現在の実装だと term_t の様々な物に依存して
  |   実際の画面表示が変化する。つまり、term_t 自体が状態でもある。
  |   あらゆるアプリケーションは term_t をインターフェイスとして通信するという事?
  |   従って terminal multiplexer を実装するとすると、
  |   新しい term_t を作ってその中で term_t を動かすという事になるのではないか。
  |   そうしなければ、twin や ttty は更に複数の term_t を切り替えるという操作を
  |   実装しなければならなくなるのではないか。
  |
  | 何だか色々と形のない事を考えてきたが、まあ実際に実装して、
  | その時の雰囲気で自然に決めて行けば良い様なきもする。
  | 今回の場合には term_t で実装するのではなくてその前に何か噛ませたいという事である。

  term_t はやはり状態に徹したい。具体的なアプリケーションというよりは、
  "標準入出力しか持たないアプリケーションに薄いインターフェイスを提供する"
  のが目的である。勝手に入力を解釈して文字列の選択等を行うというのは変である。

  | では何故 twin の側で提供しないのかというと、同じ仕組みを ttty にも
  | 実装したいからである。もっと言うと Win 以外の GL だとか Qt だとか、
  | 別の枠組みの上で端末を実装する時にも同様に必要になる機能である。
  | なので、共通化したい。twin は単にキー入力を受け取ってその共通の枠組に渡すという事と、
  | その共通の枠組にユーザーインターフェイスとして画面描画を与えるという、
  | そういう薄い物にしたいのだという事なのであった。
  |
  | そう考えると何か共通の "端末アプリケーション" という物を作って、
  | それの上で選択等を実装するべきなのではないだろうか。
  | そしてその "端末アプリケーション" はユーザの入力を処理して、色々の事をする。
  | 各子供端末に対して入力をそのまま伝達することもあれば、
  | 端末の処理をとは異なる (選択やコピーなどの) 操作を提供する事もある。
  |
  | 現在の構造だと terminal_session がそれに近い様な気もするが、
  | これは何だか微妙である。実のところ、これは単に接続を開始するだけのクラスである。
  |
  | 結局アプリケーションから見た "仮想端末" が term_t であって、
  | ユーザから見た "端末エミュレータ" というアプリケーションが twin/ttty であって、
  | そしてそのエミュレータアプリケーションの共通構造というか、
  | 本体部分を今から twin から切り出そうという事を考えている訳なのである。
  |
  | んー。"端末アプリケーション" は子供の端末を複数持つ。
  | 実はその子供というのは端末でなくて別のアプリケーションでも良いし、
  | と思ったが任意のアプリケーションという事にすると描画ルーチンの共通化ができないので、
  | やはり書込先のデータは term_t という事になるのではないかと思う。
  |
  | 所で Window 分割等をした時に twin はどの様に対応するべきなんだろうか。
  | 現在の実装では分割の事は考えていなくて全体に描画する気でいる。
  | ウィンドウ分割には対応する気はなくてやりたければ中で起動した
  | terminal multiplexer に任せようと思っていたからである。
  | しかし、今になって考えてみれば terminal multiplexer と機能やインターフェイスを
  | 統一するのだとすれば、twin 自体にも画面分割が在るのが自然である。
  |
  | 以下の様な構造になっていると考える事にする。GNU screen と同じである。
  |
  | screen _>_ session ___ terminal
  |                     \_ terminal
  |                     \_ terminal
  |
  | % 結局、session が実際の端末のアプリケーションであって、
  | % screen が描画を担当しているに過ぎない。
  | % また勝手に接続したり抜けたりする事ができる。
  | %
  | % * screen が ttty や twin に対応する。
  | % * session が今から作ろうとしている機能である。
  | % * terminal は pty_session 及び terminal である。
  |
  | 思考が堂々巡りになっていて良くない。
  | twin から別プロセスの session に attach するとしてどうやって
  | データをやり取りするのだろうか。直接 session の中の term_t に
  | アクセスできればそれが一番良いがそういう訳にはいかない。
  | そういう枠組みを整えるのはとても難しい。
  | というか C++ のコンパイラレベルのサポートが必要になる気がする。
  | だとすると結局その "接続" というのはエンコードされた物になるのではないか。
  |
  | 結局 screen _> session の接続は任意にできる物ではないという事になる。
  | というか ttty の時にのみ適用できる概念である。
  | 然し、一方で twin でも複数の端末を開ける機能は是非に欲しい。
  | 従って、実際に上記の様な構造にするかはともかくとして、
  | session 部分の機能は必要なのである。

  次の様な構造にする。screen (ttty や twin に相当) が
  session (共通部分) を描画したり入力を渡したりする。
  session は terminal を複数開いたりタブ管理したり画面分割の操作を
  提供したりする。

  | うーん。screen/session は GNU Screen 用語であって、
  | しかも改めて考えるとやはり役割が異なるので名前を変更する。
  |
  | GDI/Win32 -- multiplex_t -- term_t
  |
  | 真ん中の名前はどうしようか。multiplexer とか、terminal とか、
  | lexer, user, session, controller, うーん。
  | 然し、本当に ttty と twin で同じ機能を提供するのだろうか。。。
  | タブ管理や画面分割までは未だ良いが、タブの選択だとか
  | そういうインターフェイスまで考えると実は一つの term_t の上で
  | 実現してしまった方が良いのではないか。その時には結局、
  | ttty を内部で呼び出す事になる。でもそれだと常に二重に term_t
  | を起動しているという状態になりそれはそれで変な気がする。
  | うーん。実は session 本体が動作するための term_t というのを
  | 別に用意しても良いという事なのかもしれない。
  |
  | 名前は contra... というのに合う名前にしても良い。
  | window_manager_t 等という名前でも良いし、
  | tab_manager_t でも良いし terminal_manager_t という名前でも良い。
  | うーん。タスクマネージャだとかウィンドウマネージャだとか、
  | そういう用語がある事を考えれば terminal_manager で良い気がしてきた。

  結局、以下の様な構造にする。

  terminal_interface (twin, ttty, etc.)
   \_ terminal_manager
       \_ terminal_application (term_t + pty_connection, etc)
       \_ terminal_application
       \_ terminal_application

  取り敢えず名前は暫定的に上記の物としてコードを整理する。

  (1) done: #D0126 先ずは board_t を term_t のメンバに昇格する。
  (2) done: #D0129 terminal_manager クラスをもう準備してしまおうか。
  (3) さて。マウス操作は terminal_manager の上で実装すれば良い。

    先ず選択操作に関して。
    選択範囲はどの様に表現されるだろうか。
    これは terminal_manager の提供する始点と終点を用いて
    twin_window_t 側で描画する事にすれば良い。
    カーソルを描画する前に描画する。

    描画はともかくとして選択の開始点及び終点を記録する様にする。
    描画にも対応した。

* twin: terminal_manager 導入 [#D0129]

  そして terminal_manager 自身も terminal_application とするか?
  と思ったが自身が独立した term_t を持つ訳ではないので、
  これに関してはまた考え直す事にする。

  うーん。然し、これは実装するべき事なのだろうか。
  うーん。或いは terminal_session のまま機能を拡張して、
  その内に修正するべきなのではないだろうか。。

  うーん。term_t から input_key 等のデコード部分を
  奪おうと考えているが本当にそれで良いのだろうか。
  やはり端末の機能としては共通する所があるのだから、
  そのままでも良いのではないだろうか…とも考えたが、
  書込先がないのに input_key が存在していても仕方がない。
  では、何処がそれを担当するのだろうか。例えば
  terminal_session では openpt による書込先に限定している。
  然し、これがまた別の書込先である可能性もある。
  その場合にも全く同じに実装するのは変である。

  という事を考えていくと実は input_key を
  decode する専用のクラスがあっても良い気がしてきた。
  そのクラスは書込先デバイスを保持して、term_t からの要求に従って書込を行う。
  まあ、こういった枠組みに関しては term_t を使って動作する別の
  プログラムが現れてからで良いという気もする。

  何れにしても、取り敢えずの実装としては
  terminal_session の上で選択機能を実装する事にするのである。

* twin/draw: 回転した文字の位置の補正はフォントの大きさに依存するのでは [#D0128]

  * と思ったら起動しなくなっていた。修正した。

  * と思ったら SLH の動きが変である。
    これは分かった。SLL は実行すると現在行と、それ以降の行の
    line limit を設定するのであって、既存の行の line limit は保たれるのだ。
    という事を考えると、実は現在の振る舞いが元々意図した振る舞いである。

    "それ以降の行" というのが何かにも依るが…。
    それ以降に新しく追加した行という意味?
    これについては別項目として残しておく事にする。

    取り敢えず SLH ではなくて DECSLRM を使って実装する。

  * うーん。やっぱり回転中心の計算が誤っている気がする。
    修正する。うーん。何だか計算方法がよく分からなくなって来た。

    そもそも横幅を計算するのに progress を用いているが…。
    progress を回転中心の計算に使って良いのかは謎である。
    というのも文字の大きさによる補正を行う為に
    次の文字のシフト量を progress に加算してしまっているからである。
    と思ったが、回転文字の場合にはそういう変な小細工はしていない気がする。
    と思ったが駄目だ。そのシフトを打ち消す様に自身の progress を弄っている。

    つまり progress は自身の幅を計算する為には使えないという事。
    total_progress 的な変数を用意して其処に論理的な progress 量を指定するべきでは。

  * そもそも displacement の計算が怪しい。
    dx += dx2 にして、その後で DECDWL に対して dx*=2 だけしている。
    本当にそんな計算で良いのだろうか。

    dx1 を全体の shift で dx2 をサイズ依存の shift である事を考えると、
    その文字の移動量は dx1 + dx2 * w である。これは DECDWL に対しても同じ筈である。
    さて、DECDWL の時には w が倍化する一方で、dx1 はそのままである。
    なので、dx1 がイタリック補正由来であるならば dx1 の方を倍加しなければならない。

  * 更に italic 補正のある時の回転中心は微妙である。
    イタリック補正によるずれは全体に作用するが回転中心を変える物ではない。
    うーん。取り敢えず今は回転が在る場合にはイタリック補正は起こらない事になっているので、
    まあ、気にしない事にはする (回転量0の時だけ位置がずれるのは変な気もするが気にしない)。

    或いは、そうなのであればやはり単純に progress の中心を回転中心としてしまうのが良いのかもしれない。

  結局今やっている事は、progress の中心を回転中心にしたいが、
  全体の shift の分だけは横にずらしたいという事である。
  結局回転中心は (xR - xL) + (dx - dxW) という事になる。

  うーん。まとめると displacement には色々種類があって、

    dx = dxT + dxI + w * dxW
      dxT は全体の並進, dxI はイタリック補正,
      dxW は文字サイズ変更によるずれの補正

  となっているが回転中心は xR - xL + dxT で計算したいという事。
  現在の実装では元々 dxT = 0 なので気にしなくて良い。
  もし将来的に dxT が有限になるのだとしたら、
  それを get_displacement で取得できる様にする必要がある。

* ansi: less の使っている altscreen で残像が残る [#D0127]
  画面をクリアし忘れている?
  使っているのは 1049 の筈である。
  自分で試してみた所クリアできていない…。後で修正する。
  →これは不便なのでチェックしてみたらとても簡単なミスだった。修正した。

* refactor: board_t は term_t のメンバとして保持してしまう? [#D0126]
  そうすると一つの board_t に対して複数の term_t がある、
  というような状況にできなくなってしまうが、然し一方で、
  その様な変な事をする動機はあっただろうか。
  現在 cur は board_t 側に1つしかないので、
  複数の term_t が操作しようとしても混線するだけである。
  結局一つの term_t に対して複数の操作する人がいるという、
  それだけの事になるのではないだろうか。

  cur は term_t に持たせる事にする。或いは、その上で、
  一つの board に対して複数の term_t が存在するという事にはならないか。
  うーん。何だかよく分からなくなって来た。
  結局、一つの board に対して term が複数あるという具体的な状況が
  思いつかないので、実際に board は term に持たせて良い気がする。

2019-05-04

* twin: マウスイベントを捕まえる事にする [#D0125]
  面倒なので以前 Poderosa に実装した時の物を参考にする。
  うーん。余り参考にならない感じだ。
  というか他の端末がどの様に動作するのかを先ず初めに調べなければならない。

  その為には受信バイトを調べるプログラムを書かなければならない。
  或いは ble.sh の受信部分から調べるか。
  ble.sh の受信したキーを全て /dev/pts/12 に書き込む様にした。

  emacs がどの様なマウスモードを有効にするか調べる。
  1000, 1002, 1006 を呼び出している。調べる。
  うーん。1002 は smMouseMotionCell なのでマウスの位置の追跡である。
  取り敢えず 1000 と 1006 を出せば良い気がする。RLogin で調べる。

  ESC [ < 0 ; 7 5 ; 3 8 M ... mousedown
  ESC [ < 0 ; 7 5 ; 3 8 m ... mouseup
  0 ... 左クリック, 16 ... Ctrl+左, etc. は gh にまとめてあった。

  - RLogin は中クリックには対応していない様子だ。
  - RLogin はマウススクロールに対しては up up up up up を送信してくる。
    スクロールの時の down/up がどうなっているかは気になっていたが。
    xterm で試してみると M (つまり押下) としてスクロールが送られてくる。
    CSI < m は送られてこない様子である。

  - 何と…xterm では中クリックが 1 で右クリックが 2 である。
    RLogin では右クリックが 1 である。うーん。
    mintty は xterm に従っている。

  1002
    うーん。32 はマウスの移動の意味を持つ様である。
    RLogin はドラッグしている時にのみマウスの移動を通知してくる。
    左ドラッグは 32 で右ドラッグは 33 である。

    xterm で見ると 32 は左ドラッグで 34 は右ドラッグだ。
    中クリックによるドラッグには対応していない。
    左と右を同時に押している時には 32 である。

  1003
    1002 はドラッグしている時にだけマウス移動を通知してきたが、
    1003 はそれ以外の時にも移動を通知してくる。
    35 である。

    xterm の振る舞いを見ると 1000,1002,1003 は排他的であり、
    一番最後に指定された物が有効になる。また1000,1002,1003
    の何れを使って解除しても全て解除される。

  1001
    xterm これを使ったら操作ができなくなってしまった。
    xterm 自体が固まっている訳ではない。
    他の端末から bash を kill したらログアウトされたのが画面で確認できた。
    うーん。キーボード入力を無効化してしまう何かなのだろうか。。
    これは良く分からないので今後は使わない様にしよう。。

    RLogin で試したらどういう物か分かった気がする。
    1000 がマウスクリックの為の物であれば、
    1001 はマウスによる選択を許す為の物だったのだろうという気がする。

  大体わかった様な気がする。現状で必要なのはどの様なタイミングで
  どの様な情報を検知しておけば良いかだったので、具体的なシーケンスの形式
  についてはどの時にどのイベントを通知するかしないかは考えなくても良い。
  基本的にはマウスボタンの押下・解放と、マウスの移動・スクロールなどである。
  実は focusin focusout も 1004 で送られるが、これはマウスと独立。

  DEC Locator 等と言っているのは
  DECSLE DECLRP DECELR DECRQLP DECEFR である。
  何れにしても pixel 単位と升目単位で現在位置が分かれば良いのである。

  取り敢えずマウスイベントを捕まえる。
  Poderosa は .NET Framework に依拠しているので参考にならない。

  うーん。マウスイベントをどの様に定義したら良いのか。
  様々な組み合わせを考えると無限にある様な気がするが…。

  先ず mouse1..5 で 5 種類ある。
  それぞれについて 押下・解放(選択)・移動 が定義される。
  また wheel について up/down がある。
  ボタンを押していない状態での移動 move もある。
  うーん。実はそれだけ? だとすれば全部定義してしまえば良い気がする。

  取り敢えず term_t の側では空実装にしておく事にする。
  今は枠組みを整えるのが先である。
  序に focus と blur にも対応する事にした。OK

* twin: HOME を設定する [#D0124]
  以下に home directory の取得の方法は書いてある。
  https://stackoverflow.com/questions/2910377/get-home-directory-in-linux
  まあ、実装した。OK

* twin: 一瞬表示されるコンソールを目立たなくする為にショートカットを弄る案 [#D0123]

  ショートカットの設定を弄るとウィンドウサイズや
  位置や透明度を指定できるので、できるだけ目立たない様に
  0,0 の位置でできるだけ小さく 30% の透明度にしている。
  しかし、それでも一瞬表示されるし、透明度を高めても
  タスクバーには確実に一瞬表示されるし微妙である。

  | ショートカットの設定をバイナリで勝手に弄ることはできるのだろうか。
  | 其処に wShowWindow 等があったりはしないだろうか。
  | 検索したら以下の場所にショートカットのバイナリフォーマットが書かれている。
  | https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/16cb4ca1-9339-4d0c-a68d-bf1d6cc0f943
  | プロパティで設定できたのは ConsoleDataBlock という部分であろう。
  | うーん。そういう設定は見つからない。次の ConsoleFEDataBlock という所も違う。
  | 見ていて気付いたのは不透明度に関する設定は載っていないという事。undocumented なのか。
  |
  | 設定を書き換えて binary dump してみる事にする。
  |
  | $ 透明度を30%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity30.od
  | $ 透明度を31%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity31.od
  | $ diff -bwu twin.lnk.opacity30.od twin.lnk.opacity31.od                                                                contra.git master (e5191cf) /src
  | --- twin.lnk.opacity30.od^I2019-05-04 11:40:35.427901900 +0900
  | +++ twin.lnk.opacity31.od^I2019-05-04 11:40:39.821501300 +0900
  | @@ -59,7 +59,7 @@
  |  0001640 63 f6 08 f9 16 34 45 95 19 80 e1 cc 4b 27 a6 c3
  |  0001660 ff 97 c0 00 6d e9 11 9d b4 70 8b cd 54 4c 9f cc
  |  0001700 00 00 00 02 00 00 a0 07 00 f5 00 01 00 29 23 01
  | -0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[00]
  | +0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[08]
  |  0001740 00 10 00 36 00 00 00 90 01 00 00 2d ff 33 ff 20
  |  0001760 00 b4 30 b7 30 c3 30 af 30 00 00 74 00 54 00 54
  |  0002000 00 46 00 6f 00 6e 00 74 00 5f 00 5f 00 00 00 00
  | @@ -77,7 +77,7 @@
  |  0002300 01 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00
  |  0002320 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00
  |  0002340 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00 11
  | -0002360 00 00 00 06 00 00 00 00 02 00 00 00[4d]00 00 00
  | +0002360 00 00 00 06 00 00 00 00 02 00 00 00[50]00 00 00
  |  0002400 11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff 00
  |  0002420 00 00 00 00 00 39 00 00 00 31 53 50 53 b1 16 6d
  |  0002440 44 ad 8d 70 48 a7 48 40 2e a4 3d 78 8c 1d 00 00
  |
  | うーん。二箇所書き換わっている。checksum か? 面倒だ。
  | 更に言うと単純な和ではない。変化量が異なる。
  | 或いはタイムスタンプだったりはしないかとも思ったがそれだともっと書き換わっているはず。
  | でもチェックサムにしては 00 の量が多い 1B しかないチェックサムというのも変だ。
  | また書き戻してみる事にする。
  |
  | $ 透明度を30%に編集する
  | $ od -vt x1 twin.lnk > twin.lnk.opacity30.od.2
  | $ diff -bwu twin.lnk.opacity30.od twin.lnk.opacity30.od.2                                                                contra.git master (e5191cf) /src
  | --- twin.lnk.opacity30.od^I2019-05-04 11:40:35.427901900 +0900
  | +++ twin.lnk.opacity30.od.2^I2019-05-04 11:45:02.550927500 +0900
  | @@ -59,7 +59,7 @@
  |  0001640 63 f6 08 f9 16 34 45 95 19 80 e1 cc 4b 27 a6 c3
  |  0001660 ff 97 c0 00 6d e9 11 9d b4 70 8b cd 54 4c 9f cc
  |  0001700 00 00 00 02 00 00 a0 07 00 f5 00 01 00 29 23 01
  | -0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[00]
  | +0001720 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00[08]
  |  0001740 00 10 00 36 00 00 00 90 01 00 00 2d ff 33 ff 20
  |  0001760 00 b4 30 b7 30 c3 30 af 30 00 00 74 00 54 00 54
  |  0002000 00 46 00 6f 00 6e 00 74 00 5f 00 5f 00 00 00 00
  |
  | 成る程。前者はどうでも良い値という事なのかもしれない。
  | という事なので、後者について書き換えを実行してみる事にする。
  | 先ず値の解釈について 30% から 31% にしたら 0x4d から 0x50 になった。
  | これは10進数で77から80になった。255*0.3=76.5,
  | 255*0.31=79.05 と一致している気がする。或いは、77/255=0.3019,
  | 80/255=0.3137 と見るべきなのかもしれない。これを 0 に書き換えたらどうなるだろう。
  |
  | バイナリを書き換えるのは面倒だ。と思ったら以下にコマンドでできると書かれている。
  | https://kagasu.hatenablog.com/entry/2016/09/06/083536
  |
  | % $ cp twin.lnk twin0.lnk
  | % $ printf '\x00\x00\x00\x00' | dd of=twin0.lnk bs=1 seek=$((0x236C)) count=4 conv=notrunc
  | %
  | % そうしたら全く表示されなくなった。まあ、これで我慢するしかないのだろう。
  | % 然し、ショートカットを生成しなければならないので、面倒である。
  | % 後、この状態でショートカットを編集するとどうなるのだろう。。
  | %
  | % うーん。何度かやってみると全く表示されないという事はなくて、
  | % 偶に一瞬だけ表示される様である。不透明度0であっても。
  | % 然し、不透明度100の時は必ず一瞬表示されていたので、それよりは良い。
  | % また、不透明度30にしても0にしても余り違いはない気がする。
  | % 実はショートカットを読み出す時に0は30に補正されるのかもしれない。
  | %
  | % dd を実行するとファイルの長さが伸びてしまって駄目だ。
  | % しかし、ショートカットとしては動作している様なので取り敢えず気にしない。
  | % ファイルサイズは実は truncate コマンドで縮められる。
  | %
  | % しかし不透明度のフィールドが一体何処に格納されているのかは気になる。
  | % ConsoleDataBlock の BlockSignature は 0xA0000002 なのだそうだ。
  | % 02 00 00 a0 で検索してみる。#1703 にあった。アライメント等関係ないのか…。
  | % ここから ConsoleDataBlock は #169F から始まると分かる。
  |
  | うーん。何か変だ…あー。od は8進数なのか…。
  | 改めて: 02 00 00 a0 は #3c3 にある。ConsoleDataBlock は #3bf から始まる。
  | 問題のバイトは #4fc にある。offset は 317 である。うーん。
  | ConsoleDataBlock のサイズは 204 の様なので、opacity は別のブロックにある。
  | #48b(=#3bf+204) を見ると 0x000000c7 0xa0000009 がある。次のブロックだ。
  | というか最初の uint32 はブロックのサイズなのか…。
  | 問題のバイトはこのブロックの offset 113 にある。
  | ブロックの種類は PropertyStoreDataBlock だそうである。
  | ショートカットの文書には形式は書かれていない。
  |
  | [MS-PROPSTORE].pdf という文書を見る必要がある。
  | https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-propstore/39ea873f-7af5-44dd-92f9-bc1f293852cc
  |
  | 取り敢えず PropertyStoreDataBlock の中身だけ抜き出す。長さが c7 という事は、#552 まで続くはず。
  | 切り出すと以下の様になっている。
  | 000000 82 00 00 00 31 53 50 53 07 06 57 0c 96 03 de 43
  | 000010 9d 61 e3 21 d7 df 50 26 11 00 00 00 03 00 00 00
  | 000020 00 0b 00 00 00 ff ff 00 00 11 00 00 00 01 00 00
  | 000030 00 00 0b 00 00 00 ff ff 00 00 11 00 00 00 02 00
  | 000040 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00 00 04
  | 000050 00 00 00 00 0b 00 00 00 00 00 00 00 11 00 00 00
  | 000060 06 00 00 00 00 02 00 00 00 4d 00 00 00 11 00 00
  | 000070 00 05 00 00 00 00 0b 00 00 00 ff ff 00 00 00 00
  | 000080 00 00 39 00 00 00 31 53 50 53 b1 16 6d 44 ad 8d
  | 000090 70 48 a7 48 40 2e a4 3d 78 8c 1d 00 00 00 68 00
  | 0000a0 00 00 00 48 00 00 00 11 33 db 8a 80 72 0a 43 bd
  | 0000b0 cb 72 cc bd c4 c5 a0 00 00 00 00 00 00 00 00
  |
  | うーん。何か変だ…。サイズは 82 という事になっている。
  | これだと #4 + #82 = #86 までしかないという事になるが…。
  | まあ、余り気にしない事にする。0x53505331 は一致している。
  | 後、サイズ #82 は自身も含めてのサイズの様に思われる。
  | というのもすぐ次にまた別のデータが始まっているから。
  | そして長さも一致している。
  | 次に来るのは GUID だそうだ。
  |
  | % 96 03 de 43 9d 61 e3 21 d7 df 50 26 11 00 00 00
  | % 更に続きのデータは以下の様になっているが、最早追跡できない。
  | % 03 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00 00
  | % 00 01 00 00 00 00 0b 00 00 00 ff ff 00 00 11 00
  | % 00 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00 11
  | % 00 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00
  | % 11 00 00 00 06 00 00 00 00 02 00 00 00[4d]00 00
  | % 00 11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff
  | % 00 00 00 00 00 00
  | % GUID の符号化が分からない…。
  | % 9603de43 9d61 e321 d7df 502611000000
  | % 43de0396 619d 21e3 dfd7 000000112650
  | % https://en.wikipedia.org/wiki/Universally_unique_identifier によると…。
  | % Microsoft は最初の3つは little endian で後ろの2つは big endian だそうだ。
  | % 43de0396 619d 21e3 d7df 502611000000 検索しても当たらない…。
  | % 43de0396 619d 21e3 を検索しても 9603de43 9d61 e321 を検索しても当たらない。
  | % Microsoft が内部的に使っていて文書も何もないという事なのだろうか。
  |
  | 然し、うーんやっぱり変な気がする。と思ったら切り出し方が変だった。
  | GUID 07 06 57 0c 96 03 de 43 9d 61 e3 21 d7 df 50 26
  | GUID {0c570607-0396-43de-9d61-e321d7df5026} 検索したら当たった…。23件ある。
  | うーん。しかし他の人も同じ様に LNK ファイルの中身を見てみてこんなのがありましたという感じである。
  | 初めの3フィールドだけ見てもよく分からない。中身の形式について見る。規則性がある。
  |
  |   11 00 00 00 03 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 01 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 02 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   11 00 00 00 04 00 00 00 00 0b 00 00 00 00 00 00 00
  |   11 00 00 00 06 00 00 00 00 02 00 00 00 4d 00 00 00
  |   11 00 00 00 05 00 00 00 00 0b 00 00 00 ff ff 00 00
  |   00 00 00 00
  |
  | [size(4byte) ID(4byte) ?(1byte) ?(4byte) value(4byte)] x 6 + 0x00000000 に見える。
  | 根拠は得られなかったが、まあ、何か拡張データとして透明度が設定されている様だ。

  まとめると、ショートカットのバイナリフォーマットの形式外で不透明度が記録されている。
  具体的には PropertyStoreDataBlock の中の拡張データとして、
  GUID {0c570607-0396-43de-9d61-e321d7df5026} (undocumented) のデータとして登録されている。
  中のバイナリの構造を見ると ID6 に対して 0x0000004D という値で不透明度 30% を指定している。

  所で不透明度を無理やり書き換えるコマンドは正しくは以下の通り:
  $ printf '\x00\x00\x00\x00' | dd of=twin0.lnk bs=1 seek=$((0x4FC)) count=4 conv=notrunc
  うーん。実際に試してみると、これを実行すると寧ろ不透明になる様だ。
  つまり、変な値を書き込むと強制的に不透明であると解釈され直す。

  うーん。ショートカットを弄るという滅茶苦茶な方法はまあ、
  面白いアイディアではあるかもしれないが現実的ではない。
  これはやめる。

* twin: エクスプローラから起動できない原因を調べる [#D0122]
  調べてみると一応イベントループの中に入って何回かは回転している様である。

  うーん。sess.is_alive に失敗している。
  プロセスが生きているかどうかのチェックで死んでいるという事だろうか。
  うーん。戻り値を取得すると 65496 という巨大な値になっている。???
  もしかして bash の起動に失敗している? 環境変数で PATH を設定していないのが悪い。
  実際に bash.exe をその辺にコピーして試してみると起動しない。
  色々の DLL を参照している様子である。

  mintty の場合にはどういう事になるのだろうと思って試してみると、
  mintty 自体は起動するが、ちゃんと bash の起動が失敗した事を検出している様である。
  cygcheck ./mintty.exe としてみると cygwin-1.dll のみに依存している様だ。

  cygcheck ./twin.exe とすると似た様な物だ。
  但し、cyggcc だとか cygstdc++ だとかも参照している。
  うーん。-static-libgcc -static-libstdc++ を指定したら
  まあ cygwin-1 だけに依存する様になった。
  配布する時にはそちらの方が良いだろう。
  必ずしも Cygwin ユーザが cyggcc, cygstdc++ を持っているとは限らないので。
  まあ、それでもバイナリが大きくなってしまうので取り敢えずは入れなくて良い。

  - 因みに Cygwin で入っている mintty 603kb は strip されている様である。
    twin は現時点で strip して 429kb なので、
    変な機能を実装している事とC++で書いている事を考慮に入れれば
    可也健闘していると言えるのではないだろうか。

  - 話が脱線している。問題は如何にして PATH を設定するのかという事である。
    というか、Poderosa でも同様の事をしていた様な気がする。調べる。
    うーん。Poderosa では特に何もしていない様な気がする…。
    作業ディレクトリはユーザの home に設定してしまっている。
    cygterm の中で何かいい具合にやっているのだろうか。
    うーん。cygterm の中でも PATH を設定している形跡はない。うーん。何だかわからない。
    自身の環境変数に登録してしまっている可能性についても考えたが、そんな雰囲気もない。
    まあ、Poderosa の事は忘れる事にする。

  - 結局の所、自前で PATH に値を追加してしまえば良いのである。
    しかも、恐らく Cygwin PATH に /bin と /usr/bin 辺りを追加してしまえば、
    後は勝手に cygwin-1.dll が Windows PATH に適切な場所を設定してくれる。
    その前に現在の PATH を出力してみる事にする。出力してみたら、
    確かに /cygdrive/c/... ばかりで /usr/bin 等が指定されていない。

    因みに mintty がどんな環境変数を設定するのか確かめてみると
    /usr/local/bin 及び /usr/bin を足している。
    Poderosa で起動してみると /usr/local/bin:/usr/bin:/usr/bin が追加されている。
    誰が追加しているのか分からないが取り敢えず twin でも /usr/local/bin:/usr/bin
    を追加してみる事にする。うーん駄目だ。

  - execl の次にエラーメッセージを出力する様にしたら出た。
    つまり、execl に失敗しているという事である。
    うーん。errno を確認すると No such file or directory となっている。
    これは mintty と同じエラーメッセージである。
    うーん。そもそも cygwin-1.dll をコピーして起動してみるという起動の仕方自体が駄目の気がしてきた。

    twin.exe を /bin/ にコピーして起動してみるとちゃんと起動した。
    更にショートカットを作って起動できる様にしてみる。

  - うーん。やはりコンソールが表示されてしまう。
    ショートカットの右クリックから確認すると mintty.exe の時とは異なるタブが表示されている。
    Windows コンソールの設定を行う項目達である。という事を考えれば、
    やはりコンパイル時に何らかのサブシステムの指定などが抜けているのだろう。

    うーん。やっぱりこれの気がする…。
    https://docs.microsoft.com/ja-jp/cpp/build/reference/subsystem-specify-subsystem?view=vs-2019
    WinMain ではなくて main を使っているのがいけないのかと考えて、
    猫でも分かるの WinMain のプログラムをコンパイルして同様に起動してみたが、
    やはりコンソールが表示される。つまり、普通にやっているだけでは
    常にコンソールをターゲットとしたバイナリになってしまうという事。

    実は PE ヘッダにサブシステムが書かれていたりはしないだろうか。
    http://home.a00.itscom.net/hatada/mcc/doc/pe.html
    によると確かに PE ヘッダの中に書かれている。
    所で PE ヘッダの情報を書き換えるプログラムがなかっただろうか。
    fork failed の問題を解決する時に使った様な…。

    うーん。絶対合ったはずだが検索してもその解決方法のページ自体見つからないし、
    自分の wiki にメモとして書いた様な気もしたが該当しそうなページが分からない。

    あ。分かった。peflags だ。(compgen -c -- '' | grep pe して見つかったが、
    普通に pe で始まるコマンドを探せば見つかったのだった。) peflags の --help で見る。
    然し、peflags コマンドでは subsystem は変更できない様だ。
    となると、勝手に PE header をバイナリエディタか何かで書き換えるしかないのか。

    結局プログラムで読み取って書き換える事にした。
    調べてみると確かに mintty は subsystem が 2 になっている。
    猫でもわかるのサンプルプログラムに適用してみたところ
    確かにコンソールは表示されなくなった。

  - 一方で、twin に対して実行してみたところ起動はする様になったし、
    裏で bash が動いてはいる様な気がするが、何にも応答がない。
    入力した文字列のエコーバックは行われる様である。
    C-d で終了する。また touch hellowww.txt としたら、/usr/bin/hellowww.txt ができた。
    つまり /usr/bin/ の上で何かが動いているという事になる。もしかすると
    コマンドプロンプトが動いているのだろうか、、と思ったがそれだと C-d で終了する理由が分からない。
    もう少し動かしてみる事にする。

    dir > hello.txt として見たら CMD のそれではなくて ls の結果が出力される。
    うーん。bash が -i なしで実行されているという事だろうか?
    ログインシェルとして実行する必要があるのでは。

    cd してそれから echo $HOME > aaa.txt したら ~/aaa.txt にファイルが出来た。
    やはり bash が動いているがログインシェルになっていないという事である。
    うーん。中で bash -l として起動しても何も起こらない。
    echo $- の結果は hBs である。set -i してみたが変化はない。

    * done: bash -l で起動するのを試みる
      →うーん。やっはり変化はない。そもそも端末に繋がっていないという事なのだろう。
    * done: subsystem version を確認する。
      →これに関しては mintty も 4.0 だったので違いはない。関係ないだろう。
    * done: AllocConsole を試してみる事にする。
      AllocConsole しても現在の現象は変化しない…。
      これは最早 mintty の起動シーケンスを見に行くしかないのだろうか。

    逆に subsystem を書き換えずに FreeConsole を実行したらどうなるのだろうか。
    これは直ぐに終了してしまう。これはこれで何か理由があるのだろうが、
    まあ、この方向性については後で考える事にする。

    * done: tty が割り当てられていないのかという事を確かめる。
      /dev/pty24 がちゃんと割り当てられている…。不思議だ。

    https://docs.microsoft.com/en-us/windows/console/console-functions
    コンソールの割当などを上記のページで確認するのも良いかもしれない。

    * reject: CreatePseudoConsole というのがある様なのでそれで適当に作って、
      その後に AttachConsole できないかと思ったが両方の説明を読むと
      そういう事ができるような物ではないようである。

    * reject: うーん Poderosa から起動する時はどうなっているのかと思ったら、
      ProcessStartInfo で CreateNoWindow を指定して起動している。
      つまり内部では cygterm.exe の Console 的な物が存在しているという事か。。
      CreateProcess の説明を見ると STARTUPINFO 構造体に色々指定できるようで、
      恐らく http://chokuto.ifdef.jp/urawaza/struct/STARTUPINFO.html を見た限り、
      CreateNoWindow は SW_HIDE を wShowWindow に指定するという事の気がする。

      実は PE header を見たら CreateNoWindow に相当する何かがあったりしないだろうか。
      ない様だ。どうもそういう雰囲気ではない。
      何れにしても STARTUPINFO を指定するのは起動する側のプロセスだから、
      こちらからはどうしようもない。

    * 現在は起動した瞬間に
      ::ShowWindow(GetConsoleWindow(), SW_HIDE);
      としているが、暫くはこれで我慢するしか無いという事なのか。

    * unknown: mintty がどうしているのかについて確認するしかないのか
      src/winmain.c に main 関数があった。特に何か変な事をしている様子もない。
      というかよく考えたら twin の症状は bash がちゃんと起動してくれない事だった。
      という事を考えたら実は起動時の処理を見るのではなくてシェルを起動する所の
      処理を見なければならないのではないか…。うーん。色々と違うので参考にするのはやめる。

      そもそも mintty は WSL や MSYS にも対応している様である。

    * reject: 或いは GetConsoleWindow() を乗っ取って
      自分のウィンドウにしてしまうという事も可能だったりするのだろうか。
      と思ったが別のメッセージループが回っている筈なので、
      自分でループを回したい場合には都合が悪い。

      と思ったが勝手に WndProc の中でメッセージループを回しても良い気がしてきた。
      終了する時には PostQuitMessage だけして自分ではメッセージを処理せずに抜ける。

      しかし勝手に乗っ取るにしても親の設定したメニュー項目はどうするのかだとか、
      色々問題があるのは確かである。うーん。それにもしそうしたとしても、
      一瞬、親の設定した状態でウィンドウが表示されるのには変わりない。
      何の解決にもなっていない。これなら SW_HIDE する方がましである。

2019-05-03

* というか、mwg/except.h を添付する方が良い気がする [#D0121]
  →これは実際に mwg/except.h をコピーしてきてそれを使う様にしたら簡単にできた。
  問題は発生していないのでOK

* twin/draw: 文字の blinking [#D0120]
  xterm は文字の blinking は速いのも短いのも同じ速さ。
  RLogin は速さを変えている。一方が他方の2倍の速さ。
  mintty は速さを変えている。点滅の速さは独立の様である。
  Poderosa 4.3.5b は当然対応していない。

  xterm と mintty はフォーカスを失っている間は点滅しない。
  RLogin はフォーカスを失っている間も点滅している。
  対応した。動いている。

* twin/draw: proportional を指定した時は ExtTextOut ではなくて [#D0119]
  TextOut を使う様に変更して良いのではないだろうか。
  これで完全に対応できたとは言い難いがまあ無難な描画方法だろう。
  しかし、その時には空白類はスキップできない事になる。

  実装してみた。Times New Roman で試してみたが何か変だ。
  単語内部はまあ良いとしても、単語と単語の間の空白の大きさが気になる。
  →proportional の時には空白も可視文字として取り扱う事にした。
    一気に長い文字列を proportional で描画すると配置がずれるが、
    まあ、今後変な align のタブなどにも対応する事を思えば、
    これぐらいなら良いというかこの様に振る舞うべきである。
    (カーソルの位置と実際の表示の位置がずれてしまう事は
    この様な場合には最早気にしない。表示の為だけの機能と思う事にする)

* twin/draw: WM_PAINT の時は裏のバッファを表に転送するだけで良いのではないか [#D0118]
  その様に変更した。

* twin/draw: 点滅 [#D0117]
  カーソルの点滅は取り敢えず実装する。

  点滅に関しては WM_TIMER でも発生させれば良いだろう。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win47.html

  どうも Poderosa や RLogin の振る舞いを見ていると、
  点滅に関しては入力のタイミングでリセットされている様である。

  xterm でも同様のようである。
  うーん。文字を出力したりカーソルを移動したりする度にリセットされている。。
  一方で内容に変更が伴わない場合にはリセットはされていない。
  内容の変更は line の id/version で追跡するとして、
  カーソルの位置・形状は自前で記録して比較を行う事にする。
  文字の blinking のタイミングとは独立の様である。

  取り敢えず SetTimer する事にする。
  と思ったが、内容に変更があったら SetTimer するという事なので、
  内容に変更がなかった場合には更新しない。
  内容に変更があったかどうかを確認しなければならない。
  つまり一番最初に内容に変更があった時にだけ再描画する様に修正する必要がある。

  * done: 先ず初めに WM_PAINT では再描画ではなくて、
    既に描画してある内容を転送する様に実装する。
    但し、最後に描画してからサイズが変更になったりしていると、
    失敗してしまうので再描画が必要になる。

    うーん。どういう時に更新が必要になるのだろうか。

    (1) 内容の部分更新が必要な場合
      - 行などが更新された

    (2) 内容の完全な更新が必要な場合
      - パレットが変更された
      - 背景色が変更された
      - フォントが変更された
      - その他描画に関する設定が変更された

    うーん。変更に伴う描画内容の更新は全て twin の自発的な
    再描画に任せるとすれば WM_PAINT の時には無駄な更新は一切行わなくて良い。
    完全に転送するだけで良いのである。但し、画面のサイズが変更になっていたりすると、
    その時には完全な再描画が必要になってしまう。

    うーん。画面のサイズが変更になった時にだけ
    現実的に問題になってしまうので再描画を実施する事にした。OK

  * done: 次に…。前回と比べて状態に変更がない時にのみ更新を行う事にする。
    取り敢えず変更があった時にのみ表示を更新する様にした。
    ちゃんと動いているのかどうかについては分からない。

    本当はカーソルの描画と本体の描画を分離して
    より効率的にしたいがそれは後で実装する。

    で何をしたかったのかが分からなくなった。
    カーソルの変更があったら timer をリセットするという事だった。
    しかし、render_window を呼び出した時点でいつも timer をリセットすれば
    良かったのではないか? と思わないでもない。
    現状だと画面に動きがなくても何か受信していたら timer がリセットされる、
    という様な状況からそういう時には timer がリセットされないという様に変わっただけである。

    まあ、理想的にはそうなのであるが、実は現状の実装では余り
    気にしなくても良かったのではないかという気もする。
    何れにしても準備はできたので次に進むことにする。

  * done: うーん。描画内容に変化があったら点滅をリセットする、
    という事にしようと考えたが点滅自体によって描画内容に変化が起こるので、
    単純に考えたらこれでは駄目である…。

    % うーん。どういう変化があったのかという事を tracer の側で記録して、
    % それにアクセスできる様にするのが良い気がする。
    % うーん。実際にはもっと処理の需要に応じた判定方法がある気がする。
    % 始めに全て判定してどうのこうのではなくて、
    % 処理を一回通してその結果としてこうでしたね、という形になっていて欲しい。
    %
    % 後、カーソルが見えない設定になっている時には timer を設定しなくて良い。
    % 現状の問題点は何かというと再描画するかどうかが
    % カーソルに変更があったかどうかに依存しているという事。
    %
    % 更に文字の点滅による再描画についてもカーソルはリセットしない。
    %
    % 結局再描画するかどうかの判定と、
    % カーソルをリセットするかどうかの判定は違うという事。
    % そして、実はカーソルをリセットする必要がある時には、
    % カーソルをリセットしてから再描画しないと駄目。
    % カーソルの点滅状態を点灯にしなければならないから。うーん。

    少し真面目に実装したら整理がついた。
    実装もせずに変に枠組みだけで整理しようとすると、
    実際にどう実装されるかの実態がわからないから変な事になるのである。
    また大幅に書き換えた。まあ動く様になった気がする。
    タイマーのリセットもちゃんと正しい条件になっている気がする。

  * done: 次に WM_TIMER で処理を行う。
    実行してみると点滅しない。変だ。調べると、
    ちゃんと描画を要求する部分では点滅している事になっている。
    つまり、カーソルを描画したりしなかったり。
    しかし、カーソルを描画しなかった時に何も起こらない…。

    あー。分かった。何も描画しなかったからこそ、
    前回の内容がそのまま表示されているという事なのである。。
    うーん。前回表示状態だったら消して、という事をしなければならない。
    というか、前回のカーソル位置も覚えておいて状態を復元しなければならないのでは。

    うーん。駄目だ。それを修正しても点滅してくれない…。
    座標計算を間違えているだろうか。。と思ったら簡単なミスだった。
    直した。点滅している。まあ、満足である。

  * done: カーソルに点滅の on/off の設定がある事を忘れていた…。
    設定した。また、タイマーは点滅していない時やカーソルを
    表示していない時には off にする事にした。

* twin: 日本語フォント名が認識されていない [#D0116]
  「ＭＳ 明朝」などとしても失敗する様である。
  然し、その他のフォントの英語名が分からない。検索しても出てこない。
  ようやく以下のページが見つかった。
  https://oshiete.goo.ne.jp/qa/9530867.html "HGMaruGothicMPRO" だそうだ。
  更にこれを使って検索すると色々出てきた。
  http://www.htbasic.jp/tip/p021/
  | MS明朝               "MS Mincho"
  | MSゴシック           "MS Gothic"
  | HGゴシックE          "Hgsgothice"
  | HGゴシックM          "HGGothicM"
  | HG丸ゴシックMPRO     "HGMaruGothicMPRO"
  | HG教科書体           "HGKyokashotai"
  | HG行書体             "HGGyoshotai"
  | HG楷書体PRO          "HGSeikaishotaiPRO"
  | HG創英角ゴシUB       "HGSoeiKakugothicUB"
  | HG創英角ポップ体     "HGSoeiKakupoptai"
  | HG明朝B              "HGMinchoB"
  | HG明朝E              "HGMinchoE"
  | ＤＦPOPクリップW7    "DFPOPClip-W7"
  | ＤＦPOPコンW7        "DFPOPCorn-W7"
  | ＤＦブラッシュＲＤW7 "DFBrushRD-W7"
  | ＤＦフリー流線W3DF   "DFFreeRyuSen-W3"
  | ＤＦ華康ゴシック体W3 "DFGothicP-W3"
  | ＤＦ華康明朝体W3     "DFMinchoP-W3"
  | ＤＦ華康ゴシック体W3 "DFKanTeiRyu-XB"
  | ＤＦＰ極太丸ゴシック "DFMaruGothic-UB"
  | ＤＦ極太明朝体       "DFMincho-UB"
  | ＤＦＰ太丸ゴシック体 "DFMaruGothic-SB"
  | ＤＦ中丸ゴシック体   "DFMaruGothic-Md"
  | ＤＦＰ中楷書体       "DFKaiSho-Md"
  | ＤＦ唐風隷書体W5     "DFTFLeiSho-W5"
  | ＤＦＰ特太ゴシック体 "DFGothic-EB"
  | ＤＦ風雲体W7         "DFFuun-W7"
  | ＤＦ平成明朝体W7     "DFHSMincho-W7"
  | ＤＦ麗雅宋           "DFLeiGaSo-W9"
  | OMEJDICライト標準    "OMEJDIC"
  | メイリオ             "メイリオ"

* ansi: 二重打ち消し線がないのは意外である [#D0115]
  機能を追加するとしたら波下線なども欲しいし
  更に下線の色も変更できる様にしたいなど色々ある。
  しかし、そういうのは extended flags だとか、
  或いはオブジェクトとして定義できる様にするだとか、
  そういうのが良い。

  一方で実は RLogin は SGR(64) で圏点の代わりに二重打ち消し線を表示している。
  というか SGR(60-63,66-69) で 8 bit も使っているのは変である。
  同時に複数設定するのは変だという事を考慮に入れれば
  (65 でクリアできる事からもこれらはそれぞれ独立に選択できるのではなくて、
  何れか一つのみを選択できるようにするというのが自然である) 4bit で済む。
  そもそも何故この様なスイッチにしたのかというと RLogin に対して透過的にする為である。

  RLogin は SGR(60-63) に対してそれぞれ右縦線・右二重縦線・左縦線・左二重縦線としている。
  これは…うーん。拡張機能として提供する事にして、ANSI SGR(60-63,66-69) は選択式に変更する。

  * done: 取り敢えず先ずは 60-63,66-69 の定義を変更する事にする。
    60-64,66-69 を exclusive に固定し、4bit で表現する事にした。
    (今は 10 種類の値があるので実は未だ余裕がある。
    圏点の種類にでも実は対応できるかもしれない。)

  * done: RLogin の左右の線・二重線に対応した。4bit 使う。
    SGR(8460-8465) で対応した。

* twin/draw: 取り敢えずテキスト修飾を描画する事にする [#D0114]

  気付いてしまったのだが decdhl の属性があると
  あらゆる物について通常の描画と横2倍・上半分・下半分の
  4種類の描画を用意する必要が出てくる。面倒な事である。

  何れにしても描画だけはする。
  これは文字とは違って離れた物を同時に描画する必要はないので、
  背景色と同様に一様に実装してしまう事にする。
  ascii_nul な升目に関してはスキップする。

  打ち消し線や下線などに関しては連続する升目について
  同時に描画した方が都合が良いので、背景色と似たように実装する。
  色々考えると draw_background を改造するのが良いのではないか。

  * fixed: うーん。実際にやってみると何故か下線と一緒に打ち消し線が表示される。
    自分で printf で出力してみると再現しない。不思議だ。
    また、ble.sh の問題かとも思ったが同様に SGR(9) で打ち消し線を表示する
    xterm などで再現していないのは変だ。つまり、やはり contra のバグである。

    うーん。分かった事。これは下線と連動して出ている訳ではない。
    なにか別の属性と連動して現れている。うーん。特定の前景色に連動している気がする。
    あれ。。前景色のビットはどうなっているのだったか。。
    うーん。別に重複が在る様には見えない。調べてみると SGR を設定した後の
    aflags の値には別に変な所はない。とすれば読み出すところで変な事が起こっている?

    あー。分かった。auto xflags = attr.aflags としてしまっている所があった。修正した。

  * done: 取り敢えず試験的な実装が動く様になったのでその他の装飾についても
    追加して行く事にする。取り敢えず overline である。
    →下線に関しては全て対応した。結局、上か真ん中か下しかなかったのだった。

  * 次は各文字に対する装飾である。丸と四角と傍点が存在する。

    % 傍点に関しては…。実は文字を描く時に対応するべきだったのかも知れない。
    % 何故ならば ExtTextOut で一括で書いた方が良かったから。
    % というかフォントに依存する筈である。
    % 然し、文字として描くのはそれはそれで変な気もする。
    % 第一、位置の調整をどの様にしたら良いのか。
    % 所で Unicode に傍点ってあるのだろうか。ちゃんとある様であるが大きさが使いにくい。
    %
    % というより wikipedia によると横書きでは黒丸という事なので、
    % 取り敢えずの所は気にしないで手で黒円を描画する事にする。
    % https://ja.wikipedia.org/wiki/%E5%9C%8F%E7%82%B9
    %
    % 本当はフォントに応じてそのフォントの圏点を使いたい所だが、
    % そもそも字形が定義されていなかったり、大きさの制御が難しかったり、
    % 位置の制御が難しかったりしそうなので取り敢えずは使わない事にする。

    傍点は黒丸で自前描画する。

    円の描画は以下に書かれている。取り敢えず実装する。
    http://www.kumei.ne.jp/c_lang/sdk/sdk_25.htm

    実装した。

* vttest(2): decsc で属性が復元されていないという事に気付いた [#D0113]
  カーソル位置が範囲内になる様に修正した時に、
  属性を適用するコードが実行されなくなってしまっていた。修正した。

* twin/draw: 日本語変換している間はカーソルは表示しない [#D0112]

2019-05-02

* twin/draw: フォントについても実装してしまう事にする [#D0111]

  先ず初めにどの様な属性がフォントに影響を与えるかについて調べる。

  bold/faint 3pat,
    太字・通常・細字
  italic/fraktur 2pat,
    通常の直立体か斜体か。fraktur はフォント自体を
    切り替えるので寧ろフォントとして扱う。
  pld/plu/frame/circle 3pat,
    通常の大きさ・小さめ・より小さめの3段階
  sco 8
    8種類の角度
  sgr(10-19)
    これは10種類+frakturの11種類
  decdwl など 3pat
    3種類

  うーん。合計で 3x2x3x8x11x3 = 4752 の可能性がある。。
  全てについてフォントを生成していたらメモリを物凄く食ってしまう。
  やはりキャッシュしておくのは一部だけにするべきの気がする。

  取り敢えず覚えておく物に関しては
  (1) 10-19+1 の 11 pattern
  (2) bold/faint, italic の 6 pattern

  回転と倍幅の文字などはその場で生成する。
  過去に使ったN個までは記録しておく。
  plu/pld/frame/circle に関しては小さめだけで十分(2pat)と判断する。
  実は faint については通常の太さと変わらないのではないか。
  特に現状の GDI の機能だと細字にしても何か描画結果に違いが出るとは思われない。
  faint なフォントについては永久記録ではなくて一時記録にして良い気がする。

  因みに circled, framed は RLogin では二重囲み線、一重囲み線として実装されている。
  また、文字毎に囲んでいるのではなくて連続する同じ属性の範囲で囲んでいる。

  余り変な機能は今は考えずに実装した方が良いのかもしれない。

  * fixed: 回転を実装してみた物はいいものの何だか変だ。
    ごろんごろん転がる石の様な動きをする。
    もっと細かい角度で回転させてみてみる。
    普通に回転しているように見えるが回転の原点がずれている気がする。

    詳しくキャプチャして画像に線を引いたりしてみると。
    回転の原点はちゃんとあってそれに従って回転はしている。
    つまり、回転+変なシフトではなくてちゃんと回転である。
    回転の原点の位置も問題ない様に見える。
    しかし 90 度に比例しない角度の時だけ、
    回転前の画像が y 方向に幾らかずれている気がする。
    文字の大きさ自体が変わっている等の事はないようだ

    文字の大きさ自体も変化させてみようか。
    実際に文字の大きさを変えて試してみた所、やはりひくひくしている。
    うーん。つまり、ずれの量は絶対量で決まっているのではなくて、
    文字の大きさに対する相対量で決まっている。何れにしてもずれの方向は
    y 方向だけの様に見えるので適当に値を決めて試してひくひくしない様にする。

    うーん。文字をうんと大きくして試してみた。
    ypixel = 104 の時には先ず文字の大きさは変化していない。
    x 方向に 1px 進んでいる。y 方向に 32px 進んでいる。
    もう少し小さい文字の時にも x は 1px 進んでいた。
    ypixel = 52 の時には x 方向に 1px 進んで、
    y 方向には 15px 進んでいた。
    ypixel = 26 の時には x 方向に 1px 進んで
    y 方向に 9px (8.5--10px) 進んでいた。
    うーん。y 方向の進み方は a ypixel + b の線形関係かとも思ったが、どうだろう。

    a 104 + b = 32
    a 52 + b = 15
    a 26 + b = 9

    係数を整理する。4a+b=32, 2a+b=15, a+b=9
    最小二乗残渣は R = 21a^2 + 3b^2 + 14ab -334a -112b + 1330
    最小を与える a, b は? 42a+14b-334=0, 6b+14a-112=0
    よって 14a=112-6b を代入すれば 0=3(112-6b)+14b-334=2-4b -> b = 1/2
    更に a = (112-3)/14 = 109/14.
    書き換え前の係数で考えれば
    f(ypixel) = 109/14/26 ypixel + 1/2 = 109/364 ypixel + 1/2 という事になる。
    実際に入れてみると f(104) = 31.64, f(52) = 16.07, f(26) = 8.28 である。
    また、109/364=0.29945 である。

    うーん。b=1 に固定してみるとどうなるだろうか。
    4a=31, 2a=14, a=8 残差は R=21a^2-320a+const 最小値を与えるのは a = 160/21
    f(ypixel) = 1+(160/21/26)ypixel = 1+(160/546)ypixel
    →f(26)=8.61, f(52)=16.23, f(104)=31.48 という具合になる。
    因みに 160/546=0.293 である。まあ f(ypixel)=

    この様に考えてみると。std::round(0.3ypixel) 辺りが妥当なのかも。
    0.3ypixel について 26,52,104 に対してそれぞれ 31.2,15.6,7.8 である。

  * done: decdhl bottom に関する表示位置の補正。

  * decdhl の描画範囲制限に関して
    描画範囲の制限は以下に載っている関数でできる様だ。
    https://stackoverflow.com/questions/358611/how-to-set-g

    よく考えたら decdhl, decdwl をテストする方法が存在しない…。
    対応する事にする。取り敢えず対応した。SGR(0) でクリアできないのは都合が悪いので、
    SGR(0) でクリアする事にする。というか、今までは DECDHL, DECDWL 等を
    実現する為の枠組みと考えていたが、これは新しい SGR の属性と考えた方が良いかも知れない。

    或いは、SGR(0) でクリアはできるがその他の操作では SGR 属性としては扱われない、
    という感じの取り扱いにしても良いかもしれない。現実的にはそれで良い気がする。
    さて、ちゃんと動くことを改めて確かめる。OK 位置に関しては大丈夫。

    これから Clip について試してみる事にする。
    以下のページの方が詳しく書かれている。
    http://wisdom.sakura.ne.jp/system/winapi/win32/win134.html
    以下に Region 関連の関数の一覧がある。
    https://docs.microsoft.com/en-us/windows/desktop/gdi/region-functions

* ansi: SLH, SLL をクリアできないのは不便すぎる [#D0110]
  と思って実装を確認してみたらちゃんと無引数で呼び出せばクリアされる様になっていた。

* twin: S8C1T, DECCKM の時に送信されるシーケンスが変だ [#D0109]

  再現させる。S8C1T ... ESC SP G で DECCKM は SM(?1) である。
  実際にやってみると再現した。然し、送信されているのは M-^O で一文字であった。
  つまり、ble.sh は M-^O に対応していないというだけの事。
  或いは普通に考えれば S8C1T に対応しているアプリケーションは少ない。

  後、S8C1T の状態で bash にログインすると minencoded char 0x9B というのが出る。
  つまり、utf8 encode を介さずに CSI が送信されているという事。
  これについても修正する必要がある。
  うーん。これは丁度枠組みとして重複している部分である。

  * 先ず初めに terminal_session の送信部分を term の方に移動する。
    もしかすると同じ仕組みを他にも使いたくなる事もあるかもしれないが、
    それはその時に共通部分を括りだせば良い。今は未だ切り出す必要はない。

  * done: term_t における関数名をどうするか。
    枠組みを統合するにしても関数名が悩ましい。

    % term_t は2つの物の間に位置するので通信をするにしても
    % 入力・出力が2つずつあって関数名がややこしい事になる。
    % 整理しておいた方が良いかもしれない。
    %
    % 基本的にはアプリケーションとの通信がメインであると思えば、
    % input と言えばアプリケーションに対する送信である。
    % 一方で、端末の状態に対する操作と考えれば端末に対する書込は
    % write という事になる。read というのは何だろう?
    % うーん。本当に4種類の物があるだろうか。
    %
    % ユーザと端末とアプリケーションがいて、
    % ユーザからの入力は端末で符号化されてアプリケーションに送信される。
    % アプリケーションからの出力は端末で可視化されてユーザに見える様になる。
    % そう考えれば実は余り複雑ではない。
    % 4種類あるのは passive かどうかという事の違いの気がする。
    %
    % 通常はアプリケーションからのデータは間欠的にやってくる。
    % データが届いたら処理をするという形でデータの送信元が主導権を持っている。
    % term はそういう意味で常に受け身なのである。term 自体が手動して読み取るという事はない気がする。
    % 逆にユーザからの入力はどうだろうか。実はこれについても送信元が主導権を握っている。
    % 時々 term 自体が何かを送信したりはするがこれも送信をする側が主導権を持っている。
    % そういう意味でいえば passive かどうかという区別もないのである。
    %
    % うーん。結局全て term に対する入力という形で処理されているので、
    % 2つを区別するのに関数名が困るという事である。
    % アプリケーションから来て端末を制御するのに使われる関数は write である。
    % これはこれで良い気がする。端末を canvas か何かの様に考えた命名である。
    % しかしだからと言ってユーザからの入力は read ではない。
    % もしアプリケーションが読み取り元でそちらが主導権を持っていれば read で良かったがこれは違う。
    % ではユーザからの入力は何かというと input なのだろうか?
    % うーん。やっぱり変な気がする。send だろうか。respond は取り敢えずそうしてみたが変である。
    % input の方がましである。うーん。やっぱり現在の設計というか構造が変なのである。
    % term が一体何なのかが意味不明である。

    うーん。まあ input としておけば、それが端末画面に対する書込ではないと分かるので、
    input ということで良い気がする。もしより良い案が見つかればその時に置換すれば良いだけである。

  * fixed: term_t::respond と terminal_session::put_flush は統合した。
    その過程で misencoded char の問題も修正した。

  * 後は ble.sh の側で対応すれば良いだけである。
    CSI に対して何かユーザーのキーバインドを割り当てるという事もないだろうし、
    やはり CSI 等に対してもキーバインドを追加して良い気がする。
    というか現に ble.sh の枠組みでは CSI シーケンスとして読み取っている物に関しては、
    ちゃんと CSI を解釈する仕組みになっている。
    個別に登録している物だけ対応していないというのも変である。
    取り敢えず対応した。動くか試してみる事にする。
    →ちゃんと動く事を確認した。OK

* twin: いつの間にかに日本語入力が起動したりしなくなったりしている… [#D0108]
  と思って色々試していたら実はメッセージループで hWnd に限っていたのがいけなかった。
  他の hWnd を対象として IME_COMPOSITION 等が送られてくる様なのである…。
  更に変換の途中で部分確定した時の座標を再設定しなければならない。

  Poderosa の実装を確認するとデータを受信する度に調整を再実施している。
  うーん。実は IME_COMPOSITION だけでも十分な気もする。試してみる。
  試してみたら駄目だった。うーん。やっぱりデータを受信した直後に実行しないと駄目だ。

* twin/draw: 次に背景色に対応しなければならない [#D0107]

  背景色の塗りつぶしはそんなに時間がかかる訳でもなさそうだし、
  それに離れている四角を塗りつぶすためには別々に塗りつぶさなければならないので、
  結局別々に API を呼び出さなければならない。従って連続する部分だけ塗りつぶせば問題ない。
  対応した。色々とバグも潰した。動いている。

* 取り敢えず文字色に対応したい [#D0106]

  その前に背景色を全て描画してから前景を描画する様に変更したい。
  これは行をはみ出ている文字などを描画することがあるからである。
  行をはみ出ている文字は他の行の背景色で塗りつぶされて欲しくない。

  取り敢えず文字の背景色が書かれない様にする。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win21.html
  int SetBkMode(HDC hdc , int iBkMode); を使えば良いそうだ。
  設定した。ちゃんと動作している事を確認した。

  | うーん。そもそも半透明とかアルファとかに対応しているのだろうか…。
  | だんだん怪しくなってきた。まあ、何れにしても可能な範囲で対応して、
  | もし難しければその時には自前で実装するという事にすれば良い。
  | 結局速度が問題になるのでできるだけ単純で高速な方法を使って、
  | それが難しいときにだけ自前で実装した方法を使う事にすれば良い。
  |
  | もし半透明に対応していなかったとしても色々やりようはあるのである。
  | BitBlt っぽい AlphaBend という関数も在る。
  | この関数でどれだけの事ができるのかという事も含めて、
  | 色々試してみないと分からない。

  とにかく前景色だけでも描く様に変更する。
  前景に関しては先に枠線だとかを描いて、
  その後で文字を書き、それから打ち消し線を描く、という順番が良い。
  しかし、そうだとしても先に文字を描く部分を完成させるのである。

  因みにフォントを大量に生成したくはないので、
  下線だとか打ち消し線だとかは自前で描画する事にする。

  * ok: いい加減に grapheme cluster が ExtTextOut で
    どの様に表示されるか調べなければならない。
    surrogate pair についても同様である。

    | うーん。新しいプログラムを作って其処で試す事にするか。。
    | 試してみた所、TextOut は全然駄目である。
    | 次に ExtTextOut は文字幅を自分で指定できる分だけ
    | 表示位置の乱れはなくなっている。
    |
    | 色々試した結果を整理すると、先ず初めに
    | ExtTextOut に指定する進み幅は加算された結果が使われる。
    | つまり、Grapheme cluster の中で幅をどう配分しても、
    | 最終的に表示される結果には何の影響もない。
    | そういう意味で現在の実装のまま
    | 最初の文字に幅を持たせて計算しても問題はない。
    |
    | 何故か知らないが ExtTextOut の結果によると、
    | 結合文字の類は次の文字に対する相対座標で表示されている。
    | ちゃんと進み幅の計算では前の文字とセットで考えられているのに不思議である。
    | うーん。これは Windows がおかしいんだ。もしくはフォントがおかしい。
    | 気にしない事にする。真面目に考え始めたら自分でフォントのレンダリングコードを書く羽目になる。
    |
    | 或いは、freetype を使うか。
    | % 然し freetype は GPLv2 である。LGPL ですらない。
    | と思ったら FreeType License という物とのデュアルライセンスである。
    | そして FreeType License の方は比較的自由な感じである。
    | なので気になったら FreeType を調べてみるのが良い。
    | ただ Grapheme cluster だとかに対応しているのかなどは不明瞭である。

    [まとめ]

    - TextOut ではなく ExtTextOut を使うべき。
    - ExtTextOut で cluster に与える進み幅は総和だけが意味を持つ。
    - ExtTextOut の表示は微妙。乗り換えるなら freetype である。

  * うーん。どうも調べると COLORREF は透明には対応していない様子。
    結局自分で合成する事になるのだろうか…。
    或いは Brush を頑張れば何とかなったりするのだろうか。
    Brush を探すと memory bitmap を使って brush を定義できるそうだ。
    しかしそれだと完全な透明か完全な空白しか定義できない。。

    うーん。以下のページを見ると矢張り諦めた方が良い感じがする。
    或いは GDI+ に移るか。GDI+ は遅いという話だが…。
    https://stackoverflow.com/questions/9443070/gdi-object-hbrush-translucent

    調べると転送が遅いのだという。実は自分で作った HBITMAP の上で
    HDC を生成してそれに対して Gdiplus::Graphics g(hdc) を生成すれば速いという話も。。
    http://miyano.s53.xrea.com/cgi-bin/sb/log/eid77.html

    うーん。その他の処理はどうにでもなるが文字描画のアルファに関しては
    自前で描くのは困難である。やはり Gdiplus::Graphics を起動するしかないのだろうか。。
    まあ、これに関しては後々考える事にする。

2019-05-01

* ansi: DECSCUSR で 0 を指定した時のカーソル形状は、 [#D0105]
  1 と同じ "ブロック・点滅" であるが、これは別に VT に従う必要はないのではないか。
  つまり 0 を指定した時にはユーザの指定したカーソルの形状を用いるというので良い気がする。
  なので、0 の値を取ることも許容する。ブロックは 100 という事にした。
  点滅するかどうかもで指定するのかは…取り敢えず点滅という事にする。

  或いはユーザー設定に従う? resource_cursorBlink が XOR
  になっているので実はこれを変更する事によって既定値を変更できるのではないか。
  と思ったが何か微妙な気がする。振る舞いが反転するというのは分かりやすいのだろうか…。
  まあ、分かりにくいかもしれないがこれで設定はできるので良いという事にする。

  取り敢えず適当に実装した。twin の側でも実装した。

* twin: カーソルの位置が分からないのはいい加減に分かりづらい [#D0104]

  カーソルを表示する。表示するのである。
  さて反転するのにはどうしたら良いのだったか。
  反転する為の関数が存在した様な気がするが。
  検索しても分からないので Poderosa の自分の編集した部分を探す。
  なるほど。PatBlt という関数が存在する様だ。
  http://wisdom.sakura.ne.jp/system/winapi/win32/win103.html

  取り敢えず自分の好きな形のカーソルを表示できる様にする。
  うーん。本当は点滅が欲しい所であるが、
  点滅をする為にはタイマーなどで制御をしなければならない。
  それと現在の実装では background buffer に直接 cursor を描いているが、
  これは double buffering の部分更新と相性が悪い。
  まあ BitBlt は高速なので余り気にしなくても良いのかもしれないが。

  後々考える事にする。

* twin: 所で FillRect という関数があるという事が判明した [#D0103]
  http://wisdom.sakura.ne.jp/system/winapi/win32/win103.html

  Rectangle なる関数で縁の処理が難しいなどと言っていたが
  初めからこの FillRect という関数を用いていれば良かったのではないか。
  試しにこの FillRect で縁が変にならない事を確認する事にする。
  →ちゃんと動作している。初めからその様にすれば良かったのだ。

  更に、RECT を走査する関数として SetRect, SetRectEmpty, OffsetRect などなど、
  色々な関数があるという事が分かった。

* twin: サイズ変更に対応したら以下のエラーが出た [#D0102]

  mwg_assertion_failure! b.cur.x() < b.m_width || (b.cur.x() == b.m_width && b.cur.xenl())
    @ ansi/term.cpp:2006:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)

  うーん。何処かで何か間違えている…。少なくともサイズを変更した時には b.cur.x() < b.m_width
  になる様に調整をしている筈である。という事は別の箇所でカーソルを移動した時に何か間違えているという事になる。
  カーソル移動は今は全て関数になっているのでその時にどういうスタック呼び出しになっているのかを
  出力すれば良い。しかし、面倒である。簡単なそういう枠組みを揃えるのも良いのかもしれないが…。
  例えば mwg/except.h で好きなフレームでそういうのを設定できる様にするなど…。

  * fixed: 各シーケンスの直後に検査する様にして回してみたら意外とすぐに引っかかった。CSI S である。
    調べると原因が分かった。to_presentation_position してから to_data_position してそれを set_x している。
    然し、始めに右端に居た時には単に xenl を消してしまう事になる。
    他の箇所で実行しているのと同じ様に set_x_keeping_xenl を呼び出す事にした。
    と思ったがこの set_x_keeping_xenl というのは何だろう。
    これは実は右端から sll に移動した時でも同様に xenl が入りっぱなしになるのではないか。
    そしてそれは望む動作ではないのではないかという気がする。
    set_x_keeping_xenl を呼び出している箇所を全て確認してみる事にする。
    うーん。全て update_x に変えてしまって良い気がしてきた。直した。

  * fixed: 回している内に次のエラーが発生した。CSI G である。思い切り範囲を超えている。
    mwg_assertion_failure! b.cur.is_sane(b.m_width), "cur: {x=98, xenl=0, width=80} after CSI G"
      @ ansi/term.cpp:2036:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)
    調べると do_cha である。これは丁度 set_x を観察していた時に hpa で修正したのと同じ問題だった。
    これは直ぐに直した。

  * ???: 次のは C0/C1 で発生している…。何か物凄い値になっている。
    mwg_assertion_failure! board().cur.is_sane(board().m_width), "cur: {x=19, xenl=-2147292284, width=6867512} after C0/C1 4096"
      @ ansi/term.cpp:2069:void contra::ansi::term_t::process_control_character(char32_t)
    というか本当に実際の値なのだろうか。board() が変な値を返してはいまいか。
    というか 4096 というのは何だろう…。コードを見たら mwg_assert に渡す引数を間違えている。
    実際のところ受信した文字が x として表示されている。つまり 19 = 0x13 = DC3 である。変だ。
    ascii_dc3 に対しては何も実行していない筈なのである。

  * done: 更に vpa や hvp や cup 等についても DECOM でない時の振る舞いを修正した。

  * 次に出たのは以下の物である。なるほど。確かに記録した位置を復元する時に問題が発生するのは道理である。修正した。
    mwg_assertion_failure! b.cur.is_sane(b.m_width), "cur: {x=18, xenl=0, width=16} after CSI u"
      @ ansi/term.cpp:2046:void contra::ansi::term_t::process_control_sequence(const contra::sequence&)

  今の所は新しいクラッシュは発生していない。

* twin: サイズを大きくできるようにしたら [#D0101]
  今度は描画に矢鱈と時間がかかる様になってしまった。
  空白やら何やらも描画しているのが悪いのである。
  空白については描画しない様にする事にした。
  (但し、下線などについては描画する必要があるし、
  反転部分についても特別に描画する必要がある事には注意する)。

  空白や null の描画に関してはスキップする様に修正してみた。
  改善した様な気がする。実際に時間を計測してみるとやはり速くなっている。
  一方で、BitBlt は時間はかからないのだろうか…と思ったが、
  BitBlt は全画面を対象にしているのにも関わらず高速である。
  殆ど 0ms (resolution は 15ms しかないのでなんとも言えないが 20 行から
  30 行に1回 15ms と表示されるぐらいなので少なくとも 1ms より短い) である。
  一方で、全画面に対して文字を描画していると 300ms といった時間がかかっている。

  更新のある部分だけにしたり、移動した行は BitBlt したりすればもっと改善するだろう。
  一方で、結合文字などではみ出た物がある場合にはどうしたら良いのかは微妙である。
  そういった物は実は行毎に別の bmp に保存しておいて、それから BitBlt すると良いのだろうか…。
  文字を回転する場合なども同様である…。後、現在は背景色の上に文字を書いているが、
  背景色を指定せずに元からあった内容の上に合成する様にするとまた時間がかかるのではないだろうか。

* twin: サイズ変更に対応する [#D0100]

  サイズ変更にも対応した。動いている気がする。
  サイズ変更に関しては board の大きさの変更と
  仮想端末への通知の二種類が必要になる。

  また board の変更において保存していた altscreen とのずれがどうなるか気になる。
  と思って確認してみたらちゃんと考慮に入れていた。大丈夫。
  また lmargin, rmargin は一緒に更新しなくても大丈夫なのだろうか。
  と思って確認してみたがこれも大丈夫そうである。

  取り敢えず動いている様な気がするので大丈夫という事にする。
  所で、adjust window size と adjust terminal size のどちらが先に受信されるのだろうか。。
  確認する必要がある気がする。→一応確認してみた所先に window size が調整される様である。

* twin: サイズの調整を行う [#D0099]

  先ずは一番最初に起動時の高さを調整しなければならない。
  以下にキャプション部分の既定の高さを取得する方法が書かれている。
  https://stackoverflow.com/questions/28524463/how-to-get-the-default-caption-bar-height-of-a-window-in-windows
  取り敢えず SM_CYBORDER SM_CXBORDER が枠の幅で (3D の時はちゃんとそれに応じて CYEDGE 等と同じ値になる)、
  SM_CYCAPTION と SM_CYFRAME と SM_CXPADDEDBORDER を使っているそうだ。
  しかし 他に SM_CYSIZEFRAME とか SM_CXSIZEFRAME がある。
  うーん。それぞれ何なのか分からない。取り敢えず出力して試してみるのが良さそうである。

  →そもそも現在の _WINVER では SM_CXPADDEDBORDER は対応されていなかった。

  取り敢えず
    windowWidth = clientWidth + 2 * SM_CXBORDER
    windowHeight = clientHeight + 2 * SM_CYBORDER + SM_CYCAPTION
  で計算して初期化してみたところ、
    clientSize=(560, 390) expected
    SM_CXBORDER=1
    SM_CXEDGE=2
    SM_CXSIZEFRAME=8
    SM_CXFIXEDFRAME=3
    clientSize=(546, 376)
  となった。CXBORDER と CXEDGE は異なる値になっている…。
  うーん。取り敢えず…上記リンクに従って SM_CXSIZEFRAME (SM_CXFRAME に等価) を使う事にする。

  | // チェックに使ったコード
  | mwg_printd("clientSize=(%d, %d) expected", clientWidth, clientHeight);
  | mwg_printd("SM_CXBORDER=%d", GetSystemMetrics(SM_CXBORDER));
  | mwg_printd("SM_CXEDGE=%d", GetSystemMetrics(SM_CXEDGE));
  | mwg_printd("SM_CXSIZEFRAME=%d", GetSystemMetrics(SM_CXSIZEFRAME));
  | mwg_printd("SM_CXFIXEDFRAME=%d", GetSystemMetrics(SM_CXFIXEDFRAME));
  | //mwg_printd("SM_CXPADDEDBORDER=%d", GetSystemMetrics(SM_CXPADDEDBORDER));

  と思って調べていたら実は AdjustWindowRectEx という関数が存在して、
  http://kitano.plala.jp/~kitano/winfaq/11/11-1.htm
  それを使えば client size が正しくなる様に補正する事ができる様だ。

* twin: 今は物凄く適当な描画しか行っていないのでちらつきが激しい [#D0098]

  ちゃんと描画するにはダブルバッファリングにするというのと、
  更新を変更のあった行だけに絞るという事。
  実のところダブルバッファリングにするだけで十分なのかもしれない。
  全体を描画するのにそんなに時間はかかっていない様な気がするから。
  また、端末の画面を変更しているアニメーションを表示する訳でもない。

  調べると自分で Compatible bitmap を使って明示的にダブルバッファリングしている例。
  https://qiita.com/kero_dgu/items/981706aaa7fb64daab11

  然し、Windows に元から備わっているダブルバッファリングがちゃんと動くならば、
  それを使うのが良い。と言っても前に試した時には色々調べた挙げ句結局、
  上記の方法と同様に compatible bitmap を作った様な気もする。
  取り敢えず試すだけ試してみる事にする。

  http://home.a00.itscom.net/hatada/windows/tips/doublebuffering01.html
  うーん。ここの説明を読むとやはり適当に Windows の機能を利用しただけでは
  ちらつきは完全には防止できない様に書かれている…。
  実際に WS_EX_COMPOSITED を試してみた。やはりちらつきを抑える事はできない。
  前よりはましになったかもしれない、というぐらいの事である。やめる。

  InvalidateRect(hWnd, NULL, FALSE) とすると WM_PAINT が全体に対して送られてくる。
  これを使っても再描画する事ができるのでそれを使ってみた。
  WS_EX_COMPOSITED で前よりはちらつきが少なくなった気がするが、
  それでもやはりちらつきが微妙に起こっているので double buffering にしてみる事にする。
  | @@ -382,9 +384,10 @@ namespace twin {
  |            if (msec > 20) break;
  |          }
  |          if (processed) {
  | -          HDC hdc = GetDC(hWnd);
  | -          render_window(hdc);
  | -          ReleaseDC(hWnd, hdc);
  | +          // HDC hdc = GetDC(hWnd);
  | +          // render_window(hdc);
  | +          // ReleaseDC(hWnd, hdc);
  | +          InvalidateRect(hWnd, NULL, FALSE);
  |          }
  |
  |          while (::PeekMessage(&msg, hWnd, 0, 0, PM_NOREMOVE)) {

  結局やはり double buffering を自前で実装してみる事にした。
  それでもちらつく様だったら仕方がない。取り敢えず試すだけ試してみる。
  http://home.a00.itscom.net/hatada/windows/tips/doublebuffering01.html
  を参考にして hdc を生成してみるが、カレントスクリーンに互換、というので大丈夫なのか?
  というか以前 Poderosa に同様の実装をした気がする。確かめてみる。
  Poderosa で自分が書いた時にはカレントスクリーンに互換、としたのではなくて、
  受け取った hdc に互換の hdc を作っていた。取り敢えず自分の実装の方に従う事にする。
  そちらの方がより安全であろう。

  うーん。変だ。実装してみた物は良いがそれでもちらつきが発生する何故だろうか。
  誰かが勝手に内容をクリアしている? → WS_EX_COMPOSITION を外したらできた。
  つまり、自前で double buffering している時には WS_EX_COMPOSITION は外す必要があった。
  これで完全にちらつきがなくなった気がする。

2019-04-30

* [OK] cat /dev/random を実行すると何故か行内容が clear されなくなる問題 [#D0097]
  不思議である。普通に実行していれば clear されなくなるという事はないのに、
  /dev/random を実行すると一瞬だけ実行したのであっても、
  何故か行内容が消えなくなってしまうのである。

  不思議な事である。clear しているのに clear されないという事が果たしてあるのだろうか。
  或いはもしかして SPA が混ざって来ている? うーん。その可能性もある。
  試しに printf '\e[6l' で ERM を外してみたら直った。つまりそういうことだった。
  更に printf '\e[6h' としてその上で '\eW' (EPA) として見たらそれでも直った。

  また色々試すと今度は行の位置などがおかしくなった。
  これについては以前も似たような事があった。VEM だろう。
  '\e[7l' として見たら直った。つまり、ちゃんと色々のモードが動いているという事である。

* 色々と構造を整理したい [#D0096]

  取り敢えず impl2 及び impl3 は共通部分を括りだして
  ttty という枠組みに纏めたいという気がする。
  後、tty_observer というのは何だか分かりにくい。

  * done: tty_observer も ttty の枠組みに統合してしまうのが良いという気がする。
    一方で ttty の rendering を実行する部分と session を管理する部分は独立でも良いのかもしれない。
    その場合には print_screen は rendering を実行する部分に任せるのが良いのではないか。
    少なくとも SGR の apply をする仕組みは括りだして置く必要がある様な気がする。

    contra::dict::tty_writer と contra::ttty::buffer に分ける事にした。

  * done: dict が ansi を参照しているが本来は逆であるべきである。
    attribute_t 等については dict に移動しても良いのではないか。
    →早速その様に書き換えた。

  * done: うーん。impl.hpp にある fd に関する操作は実は device として
    一つのクラスにしてしまうのが良いのではないのか。
    →まとめた。twin.cpp はこれを使って動く様になった。

    impl2.cpp と impl3.cpp についても更新する。
    というか impl3.cpp に至っては早速 terminal_session を使っても良いのではないか?
    とも思ったが multicast_device になっているのを忘れていた…。
    取り敢えず一番初めの段階として pty_session を使う様にする。

  * 取り敢えず impl2 及び impl3 の共通部分は括りだして
    ttty/screen.hpp とした。しかし括り方が変な気がする。
    現状では do_loop に渡す引数で動作の切り替えを行っているが、
    これは本来別の方法で実装するべきなのではないか。

    というか、そもそもクラスとしてくっつけたのは良かったのか。
    impl2 と impl3 は完全に異なる動作の仕方をする物であるから、
    実は別々のクラスにした方が良かったのではないかと思わないでもない。

    まあ、その辺りの整理に関しては追々考える事にする。

* twin: C-RET を押したらハングした [#D0095]
  何かあるのだろうか…。再現性が在る事は確認した。
  コードを確認してみると、確かにこれだと無限ループになる。修正した。
  序に、未だ対応していないキーの送信にも対応した。

* twin: 実際に端末に接続して動かしてみる事にする [#D0094]
  また何だかつまらない事で止まっている気がする。
  次にするべき事はもう早速端末に接続する事なのではないだろうか。

  さて。termios が必要である。今までは既存の termios をそのまま使っていたが、
  今度はゼロから作らなければならない。どの様にするのが正しいのだろうか。
  以下のページに依ると既定値は /usr/include/termios.h にあると書かれている。
  http://tldp.org/HOWTO/Serial-Programming-HOWTO/x115.html
  /usr/include/sys/termios.h の中に定義が書かれているが何が既定値かは分からない。
  以下の様なマクロが定義されてはいたが、これが他の環境でも使えるのかは分からない。

  #define TTYDEF_IFLAG    (BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
  #define TTYDEF_OFLAG    (OPOST | ONLCR)
  #define TTYDEF_LFLAG    (ICANON | ISIG | IEXTEN | ECHO | ECHOE | ECHOKE | ECHOCTL)
  #define TTYDEF_CFLAG    (CREAD | CS8 | HUPCL)
  #define TTYDEF_SPEED    (B9600)

  https://stackoverflow.com/questions/16782715/termios-default-for-standard-terminal-session
  を参照してみると、openpty に対して NULL を指定すれば既定の sane な termios になるそうだ。
  取り敢えず何も設定せずに開いてみる事にする。

  後、ループを合成しなければならない…。GetMessage を非同期に実行する方法はどうするのか。
  複数スレッドで実行する方法、SetTimer/KillTimer を瞬間的に実行して無理やり GetMessage を止める方法、
  MsgWaitForMultipleObjects を使ってチェックする方法が載っている。
  https://stackoverflow.com/questions/10866311/getmessage-with-a-timeout
  以下のページには PeekMessage に空の引数を指定する事でメッセージがあるかどうかチェックしている。これが良さそう。
  http://www.sm.rim.or.jp/~shishido/mainloop.html
  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-peekmessagea

  うーん。PeekMessage 及び GetMessage に hWnd を指定して呼び出してみた所、
  どうやら WM_DESTROY または WM_QUIT が来ない。WM_QUIT は hWnd なしで来る様だ。
  もしくは WM_DESTROY を受信した時点で、状態を変更しなければならないという事か。
  調べたら WM_DESTROY は受け取れるが WM_QUIT は受け取れない。
  従って GetMessage が失敗する事が永遠にない、という状態だった。
  WM_DESTROY を受け取った時点で hWnd = NULL として、
  hWnd が有効の間だけループを回すように修正した。直った。

  うーん。取り敢えず起動はしている。Bash も動いている気がする。
  しかし何も表示されない…。次に何も受信されない。
  先ず表示されなかった理由は何かというと、BeginPaint 等をして render していると、
  invalidate の領域だけにしか描画されないという事。
  GetDC で得た物を使えば全体が描画される。

  次に、何だか反応がないように思われたのは文字が送信されていない?
  更に出力バッファをクリアし忘れていたのでどんどん大量に入力される様になっていた。

* twin: IME に関しては難題であると思ったが、実は猫でも分かるに載っていた [#D0093]
  http://www.kumei.ne.jp/c_lang/sdk3/sdk_278.htm

  結局何だかよく分からないので Poderosa の実装を観察する。
  どうやら WM_IME_STARTCOMPOSITION で ImmSetCompositionWindow を呼び出すだけで良い雰囲気である。
  実際にやってみると思うように動かない。変な位置に表示される。
  と思ったら Poderosa では基底の WndProc を呼び出していた。
  DefWindowProc を呼び出せば良いのだった。動く様になった。
  実はこれで完了なのではないだろうか。

  所で背景色・前景色は指定できるのだろうか。。
  もしかするとコントロールの背景色・前景色を使っているのかもしれないと思って変更してみた。
  https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q10139369610
  ::SetClassLong( hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush( RGB(0,0,0) ) );
  然し、やはりIMEの候補表示に使われる前景色・背景色とは関係がない様だった。

  或いは、変換中の文字列を自前で描画するという様にするしかないのだろうか。
  しかし、それはさすがに面倒である。というか本当に可能なのかもよく分からない。
  mintty は対応していないようであるし Poderosa も対応していない気がする。
  従って、これに関してはわざわざ自前で描画する必要もない。このままで良い。

  実は、ImmSetCompositionWindow を指定するだけで動く様になってしまった気がする。簡単だった。

2019-04-29

* twin: キー入力を受信する方法について調べる [#D0092]
  結局の所これは Poderosa を参考にするのが良い。
  Poderosa を自分で弄った時に色々と苦労した所である。
  同様に処理を行えば良いのではないかという気がする。

  取り敢えず VS で Poderosa を開く事にする。というか重い。
  取り敢えず問題の物が書かれているファイルは分かった。
  TerminalControl.cs で色々処理している。

  mwgSendChar, mwgSendKey, mwgSendAltKey, ProcessCmdKey 辺りから。
  更に、遡ると、ProcessDialogKey, OnMouseWheel である。
  うーん。何か変な物を override していた様な気もするが…。
  他に OnKeyPress もある。OnKeyPress のコメントに IME で確定すると
  「WM_IME_CHAR、WM_ENDCOMPOSITION、WM_CHARの順でメッセージが送られてくる。」
  と書かれている。うーん。IME を有効にするにはどうすれば良いのだったか。
  他に OnMouseDown, OnMouseUp, OnResize 等。

  OnLostFocus で ClearIMEComposition という関数を呼び出している。
  うーん。IME 関係の処理は WndProc 内部で実行している。
  WM_IME_COMPOSITION, WM_IME_START_COMPOSITION,
  WM_IME_ENDCOMPOSITION を見ている。

  取り敢えずメッセージを出力する事にする。

  うーん。WM_KEYDOWN を調べると。修飾キーが取れない様だ??
  https://stackoverflow.com/questions/33051983/how-to-get-modifier-key-eventaltctrlshift
  結局毎回 GetKeyState で自分で状態を確認するしかない様子である。

  仮想キーコードから文字に翻訳するには MapVirtualKey(wParam, MAPVK_VK_TO_CHAR) という関数を用いるそうだ。
  或いは、一旦 VSC にしてからその後で ToAscii で文字に変換する。
  https://stackoverflow.com/questions/318777/c-sharp-how-to-translate-virtual-keycode-to-char
  https://msdn.microsoft.com/ja-jp/windows/ms646306(v=vs.80)
  https://stackoverflow.com/questions/3864153/on-windows-how-do-we-convert-a-virtual-key-code-to-the-shifted-character

  * うーん。dead-keys はどの様に取り扱うべきなのか。
    ToAscii ではなくて ToUnicode に変換した方が良さそう。
    https://stackoverflow.com/questions/42667205/maximum-number-of-characters-output-from-win32-tounicode-toascii
    然し、一度に複数の文字に decode される事もあるそうで、どうしたら良いのか分からない。
    というか、そもそも dead-char を入力する時に dead-char が完成するまでのキーボード入力はどうなっているのかだとか色々謎。
    もし、dead-char が完成するまでのキーイベントも全て拾っているのだとしたら、
    dead-char を解釈してしまってはいけない気がする。それに kbstate に変な物を指定しているが、
    この時にちゃんと dead-char を decode できるのかも謎である。という訳で dead-char に関しては今の所対応しない事にする。
    単に無視する事にする。

  * 様々のキーの組み合わせに対してどの様に動作するべきかについて整理して置く必要がある。

    a 先ずアルファベットのキーに関しては:
      (1) 修飾キーがある場合には小文字に変換して修飾を付加する。
      (2) 修飾キーがない場合には capslock の状態を考慮に入れて変換する。
    b それ以外の文字キー・記号キーに関しては
      (1) Shift を考慮に入れて文字に変換し、Shift 以外の修飾を付加する。
    c カーソルキー・関数キーの類はそのまま修飾を付加して処理する。

  IME に関しては別項目で考えることにする。

* twin: 取り敢えず GUI を作り始めてみるという事 [#D0091]

  段々出来てきて些末な事をやり始めている。
  次にしなければならないのは何かというと。
  GUI を作ることではないだろうか。
  その後に attach detach の機能を実装するのである。

  GUI は何で作るのが良いだろうか。
  取り敢えずよく知っている Windows で作るのが良い気がする。
  然し、よく考えてみたら Windows でスクラッチで GUI を書いたことは無いような気もする。

  まあ http://www.kumei.ne.jp/c_lang/index_sdk.html の辺りを参考にすれば良いきもする。

  * done: 然し、Windows で作るのだとすれば取り敢えず Cygwin 上でコンパイルできるようにしなければならない。
    と思ったらコンパイルが通らない。libmwg を最新に更新してコンパイルし直して、
    それから contra の Makefile に追記する。-std=c++17 でなくて -std=gnu++17 にしないと fileno がなかった。

    更に posix_openpt や grantpt の類が見つからないというエラーメッセージが出る。
    然し、それは変である。cygterm でも使っている筈だし、それに検索すると Cygwin 1.7 で既に
    posix_openpt が実装されたと書かれている。ヘッダを検索すると stdlib.h と fcntl.h である。
    然し、両者を include しても見つからない。
    検索すると /usr/include/cygwin/stdlib.h に定義が見つかった。
    そして /usr/include/stdlib.h から cygwin/stdlib.h は include している筈だ。変だ。
    明示的に include <cygwin/stdlib.h> しても駄目だ。中を除くと __XSI_VISIBLE >= 600 でなければ見えないそうだ。
    % そもそも __XSI_VISIBLE が定義されていない様だ。grantpt は __XSI_VISIBLE が定義されているだけで存在する筈。
    うーん。勝手に定義してしまって良い物なのだろうか…。

    cygterm を確認してみると…何と全く posix_openpt だとか openpt の類を使わずに実装されている…。
    これは参考にならない。もしくは今後これを参考に書き直したりする必要があるかもしれない。

    うーん。調べてみると <sys/features.h> に __XSI_VISIBLE 0 が定義されている…。
    更にその中を除くとコメントに _XOPEN_SOURCE >= 600 と書かれている。
    うーん。つまり #define _XOPEN_SOURCE 600 とか 700 とかしておけば良いという事だろうか。
    うーん。取り敢えず通る様になった。

  * done: 取り敢えず簡単なサンプルをコンパイルする。
    と思ったら文字化けする。UNICODE にする。
    と思ったらリンクできない。調べてみると wWinMain には対応していない疑惑。
    少なくとも MinGW は対応していない。MinGW が fork してから
    cygwin が更新指定しなければ今も使えないという事になる。
    https://cat-in-136.github.io/2012/04/unicodemingw32twinmainwwinmain.html

  * [保留] ダブルクリックで開くとコンソールが表示されてしまう。
    wWinMain が使えない弊害だろうか。消す方法はあるのだろうか。
    以下のページに依ると FreeConsole(); を呼び出せとか、ShowWindow(GetConsoleWindow(), SW_HIDE); を呼び出せとか書かれている。
    https://forum.openframeworks.cc/t/switching-from-console-application-to-gui-application-loses-custom-icon/15279
    https://social.msdn.microsoft.com/Forums/vstudio/en-US/16b5aff3-2aff-4434-a3d7-bc5048f66572/how-to-make-a-console-apps-window-invisible?forum=csharpgeneral
    FreeConsole() は試してみたが何も起きない。ShowMessage に関しては一瞬だけ画面が表示される格好悪い。
    本来は表示されない方法がある筈なのである。

    或いは UNICODE でない方法で実装するべきなのだろうか。
    と思って WinMain から起動する様にしてみた所関係なかった。
    やはりコンソールが表示されてしまうのであった。UNICODE に戻す事にした。

    取り敢えずこれは後で処理する事にする。

* vttest(2) の origin mode test が駄目 [#D0090]
  一番下に表示されると言っている行が一番上に表示されている。
  動作を調べる事にする。

  \e[23;24r\r\n の直後に "この行は一番下" と出力し始めている。
  これが意味する所は、 DECSTBM で原点に移動するという事である。

2019-04-28

* bug: vttest で抜けてから ls すると背景色が適用されていない領域ができる [#D0089]
  どうも前回と内容が同じ時に起こるスキップの様である。
  然し、IL や DL で消滅した行に関しては old_content は clear() されている筈である。
  trace_line_scroll の中で不整合が起こっているという事だろうか。

  動作をもう少し詳しく見てみることにしてみた。
  問題が起こっている時には DL で 23 行消して IL で 0 行挿入している。
  (そもそも削除しっぱなしで良いのか、同じ行数だけ挿入する必要はないのか
  という話もあるがまあ後で考える事にする。)

  一方で、screen_buffer の方でどれだけ clear しているのか、
  というのを観察してみると 1 行しかクリアしていない。
  うーん。これは実際に移動した1行についてだけクリアしているという事。
  その他の行についてもクリアしないといけないのである。
  修正した。ちゃんと動く様になった。

  * done: 画面が一番下にない限りは削除するだけでなくて
    同じ行数だけ挿入しなければならないのではないか?
    これもその様に修正した。

    取り敢えず一番下にいるかどうかを is_terminal_bottom という変数を参照して決める事にした。
    現在は is_terminal_bottom は定数だが、今後実際に使う場合にはその時の状況に応じて
    設定する変数とする。

* 変だ xenl の時に \b をすると2文字戻ると思っていたが、 [#D0088]
  xterm の上で試してみると1文字しか戻っていない様に見える。
  何かそういう設定が存在するという事なのだろうか。

  RLogin で試すとちゃんと2文字戻る。
  xterm は何か特別な条件で戻ったり戻らなかったりするのだろう。
  よく分からないのでこれはそのままで良いという事にする。

  * ok: xterm の行末での全角文字を潰す時の振る舞いについて:
    % 後、xterm は行末で あ\e7\e8\ba 等とすると
    % "あ" の左半分だけを表示できる。
    % つまり、全角文字の途中で半角文字を踏み潰しても OK になる。
    % 例えば "え\ba" 等としても全角文字が消去される。
    % 行末以外で "え\e7\e8\ba" としても全角文字は消去される。
    % 行末で "あ\ba" とすると全角文字は消去されない。
    xterm は行末で "あ\ba" とすると全角文字の左半分だけが残る。
    これはバグだろう。この振る舞いに関しては再現しなくて良い。

* うーん。実行していて気づいたのだが、実は DECSLRM が設定されている時に [#D0087]
  右境界の右側にいる時に文字を出力すると改行せずにそのまま出力される。
  更に、同じ位置に居ても実は xenl として其処に留まっているのかどうかが
  ちゃんと記録されている様である…。つまり…。
  カーソル移動を大幅に修正しなければならない。

  更にカーソル移動によって実際のところカーソルが動かなかった場合、
  というのも存在すると思われるがその場合には xenl 状態をクリアするべきなのか、
  クリアしなくても良いのか…。

  これは大きな変更になりそうなので独立した項目で処理する事にする。

  [実装]

  * done: 先ず初めに cur に xenl を記録できる様にする。
    振る舞いを見るに実は xenl が設定されている時には、
    本当は最後の文字ににカーソルがあるけれども、
    色々の制御機能において行末にある振りをしているという事の気がする。

    然し、insert_graph だとかの実装の都合を考えると、
    やはり行末の位置にカーソルを置いて置いた方が便利な気がする。
    一方で行移動などが起こった時に行の最後の位置に
    移動するという振る舞いをどの様に再現するか。

    振る舞いに関して SU,SD 等は xenl を保持する。
    CUU,CUD,VPB,VPR や VPA 等は xenl を保持しない。
    DECSC, DECRC は xenl を保持する。
    VT,FF の類は xenl を保持しない。

    取り敢えず実装した。今の所は問題なく動いている気がする。

  * do_sm_decawm は範囲外にいる時に範囲内に強制して良いのか?
    xterm の振る舞いを調べてみると、xenl が
    設定されている時に 1 文字戻しているだけの様に見える。
    取り敢えず b.cur.adjust_xenl() だけ呼び出す事にした。

  * done: insert_graph の調整
    うーん。取り敢えず範囲外にいたら範囲を広げて考える様に修正した。
    また SIMD の時には xenl は考えない事にした。
    直ぐに次の行に移動する事にする。

  * done: do_bs の調整

    うーん。xterm の振る舞いがよく分からない。
    vttest を実行している時には BS の前に xenl で後退している様に見える。
    然し、手動で行末に行って其処で \b を出力しても 1 文字しか戻らない。
    一方で RLogin は手動で行末に行って其処で \b を出力すると2文字戻る。
    また DECSLRM の右境界に行っても \b でちゃんと2文字戻る。
    よくわからないので、取り敢えずは RLogin の振る舞いを真似る事にする。
    xterm については何か発動条件の様な物が存在するのだろう。

    SIMD の時の振る舞いがどうなるべきかはよく分からないが、
    取り敢えずそれっぽい振る舞いで実装する事にした。

* 2019-04-23 DECSLRM の時の動作テスト: SU,SD,LF,IL,DL のそれぞれについて [#D0086]

  どうやってテストを作るのが良いのだろうか。
  実はシェルスクリプトでも作った方が良いのかもしれない。

  DECSLRM を実行したらコアダンプしてしまった。
  エラーメッセージは出力されていない。
  compose_segments の line_segment_transfer の時のバグだった。修正した。
  取り敢えず do_vertical_scroll は動いている様だ。
  SU,SD,SL,SR は do_vertical_scroll を使って実装されている。
  IL,DL も do_vertical_scroll で実装されている。
  LF も do_generic_ff -> do_vertical_scroll という具合に実装されている。
  その様に考えれば現状で do_vertical_scroll が動いていたのでまあ大丈夫だろう。

  但し、m_prop_enabled = true の時については誰もテストしていない。。
  取り敢えず m_prop_enabled = true の場合でも動いてはいるようである。

* vttest が decmode 3 4 5 8 40 45 を要求している [#D0085]
  2019-04-28 残っているのは ?45 だけである。
  ?45 は何だったかというと、"行頭BSによる上行右端移動" と書かれている。
  xtBSBackLine という名前を与えて実装する事にした。

* [自然解消] ansi: clear screen で DECSTBM の原点に移動する? [#D0084]
  そもそも clear screen はどの様なシーケンスで実施されているのだったか。
  $ TERM=xterm infocmp | grep 2J を見ると \e[H\e[2J の様である。
  つまり原点に移動している。しかし、原点と言っても \e[H である。
  つまり DECOM の影響を受けて移動先の位置は変わるのだと思われる。

  clear screen という機能はそもそもない。terminfo のシーケンスで自動的に原点に移動する。
  DECOM にも対応しているので、恐らく他の端末で実行した時と同じ振る舞いになっている筈。

* DECALN の実装 [#D0083]
  これで恐らく vttest 1 はちゃんと通る様になった筈。

* DECLRMM の説明を読むと [#D0082]
  DECLRMM が有効の時にしか DECSLRM は margin を設定できないとなっている。
  つまりいつでも DECSLRM が設定できるが DECLRMM がないと効果が発揮されない、
  という事ではなくて DECLRMM が有効でないと margin を設定できないだけで、
  既存の margin は有効であるという解釈なのだろうか。

  xterm で試す。
  - % xterm で DECLRMM 及び DECSLRM を設定して試そうとしているが発動しない。
    % もしかして、未だ実装されていないとかそういうことだったりするのだろうか。
    % 或いは、無効になっているとか。。
    → -ti 340 で起動すると無効になる様だ…。
  - 改めて xterm-344 で起動してみると…。
    ?69l した瞬間に margin の設定をクリアする様である。
    うーん。面倒なので、xterm の振る舞いには追随しない事にする。

  RLogin で試してみる。
  - % やはり ?69 は現在設定されている margin が有効か
    % 無効かだけを制御していて、DECSLRM が margin を設定できるかどうかとは
    % 関係ない動作をしている様に見える。
  - ?69 を設定して margin を設定して、
    ?69 を解除して設定しても margin は有効であった。
    ここから分かる事は ?69 を解除しても margin がその場でクリアされる訳ではないという事。
  - ?69 を設定して margin 10;25 を設定し、
    ?69 を解除して margin 10;50 を設定し、
    ?69 を設定すると、どうやら 10;25 になっている様子だ。
    つまり、?69 が設定されている時にのみ DECSLRM は margin の設定を変更する。

  これについては端末によって振る舞いが異なるので
  取り敢えず contra では RLogin の振る舞いにする。

* vttest: test 2 を実行してから test 1 を実行すると着色が反転する [#D0081]
  調べてみると test 2 は反転状態で最後に DECSC (ESC 7) を実行している。
  そして test 1 は何故か最初に DECRC (ESC 8) を呼び出している。
  然し、xterm や RLogin は影響を受けていない。
  何か途中で実行している物が影響を与えて DECSC された内容をクリアしているのかとも思ったが、
  調べてみてもよく分からない。ESC 0 と ESC B は試してみたがクリアしてはいない。
  CSI J 及び CSI 2 J も当然関係なかった。CSI ? 3 l も関係なかった。

  不思議だ…。実際に impl3 が見ているシーケンスを出力するスクリプトを書いてみた。
  そのスクリプトを xterm に食わせてみたら反転するのが再現する。
  という事は xterm が見ている内容と impl3 が見ている内容が異なるという事。

  infocmp を確認しても \eB や \e0 が含まれる様な項目は見当たらない。
  うーん。DA2 で 67;0 という変な物を返しているのが悪いのかと思って、
  それを 61 や 67 に変えてみても症状は変わらない。

  a うーん。という事は受信する時点で何かを間違えている可能性?
    何らかのシーケンスが消滅しているという可能性はあるのだろうか。

    うーん。やはり変だ。やはり受信する時点で何か内容が変化している気がする。
    例えば E で囲むというのが実行されていない…。E で囲むというのは何に依って引き起こされるかというと。
    ESC#8 によって引き起こされる…。あれ、もしかして ESC#8 が ESC 8 に翻訳されている?
    何と、そうだった。手で \e#8 を出力すると \e8 が記録されている。
    これが意味する所は escape sequence の中間バイトが記録されていないという事。

  b screen でもやはり \e7\e8\e8 で反転状態になってしまう。
    detach して attach してもやはり反転状態はそのままなのでそうなのだろう。
    一方で、screen から vttest を実行した時には、
    一瞬だけ反転する様子が見えるがその後に通常の表示に戻るのが見える。うーん。

  原因は a だった。遡っていくと、そもそも # が受信されていない疑惑…。
  分かった。sequence で ESC を受け取った瞬間には has pending ESC の状態になって、
  その次に文字を受け取った時に初めて ESC # のペアでエスケープシーケンスを開始する。
  それなのに ESC だけしかシーケンスに記録されないというバグだった。

* vttest (2): 三行の****が現れる筈の所4行現れている [#D0080]
  出力されているシーケンスを確認すると **** を2行分ずつ出力しているが、
  decawm SM(?7) が入っている時と入っていない時で試している。
  もしかして decawm というのは xenl 等の機能ではなくて、
  新しい文字が来てもずっと其処に留まるという動作の物なのだろうか。。

  うーん。振る舞いを色々と調べると現在の実装は微妙だ。
  xenl と decawm の両方を参照して処理を分ける必要がある。

* bce というのが erase の時に使われる着色を制御している気がする [#D0079]
  対応した。mode_bce を見て erase に使う属性を変更する。

  と思って色々と動かしていたらどうも bce というのは背景色だけを適用するのであって、
  その他の属性は適用しない様に思われる。例えば反転を適用すると前景色と
  背景色を入れ替える事になるが xterm 及び RLogin の振る舞いを見ると、
  背景色がそのまま表示されている。

* 行内容の更新は先頭一致部分と末端一致部分だけ活かす様にする [#D0078]
  #D0077 の様な方法を考えるととても複雑になって、
  色々と新しいデータ構造をメモリ確保しなければならなくなって微妙な気がするので、
  取り敢えず先頭一致部分と末端一致部分だけを使って処理する事にする。

  (それでも末端一致部分は DCH 等すると一致しなくなってしまうので、
  結局先頭一致部分しか一致させない場合になってしまう事も多いが、
  これに関しては取り敢えずは気にしない事にする。)

* [棄却] 動的計画で最短の出力で行内容を更新する方法? [#D0077]
  現在の実装では行の追跡は行っているが、行の更新は全て再描画している。

  これは結構考察が必要な気がする。
  基本的には diff のアルゴリズムと同様で、
  しかし、スキップなどがあったりした時のコストが異なる。
  diff の場合にはスキップのコストが一定だったので何とかなったが、
  今回の場合にはそう簡単ではない。何しろ二次元の表であるマス目に来たとしても、
  其処に来るまでの経路で描画属性が異なるはずで、それも考慮に入れないと
  実際にどれだけの出力が行われるかはわからないからである。

  よく考えてみたら proportional の場合にはもっと複雑になる。
  →余りに複雑になるし本当にそれで効率的になるのか分からないので取り敢えず棄却する。

2019-04-27

* vttest: DECCOLM 後のカーソル位置 [#D0076]
  うーん。未だ表示位置が変である。調べると DECCOLM を unset している。
  この瞬間にカーソルを原点に移動するべきという事か。
  然し、やはり駄目である。と思って再度実行したら動く様になった。

* vttest で気づいたのだが BS は行末にいる時に一文字戻ってから作用する。 [#D0075]
  これを修正したら何だか良い感じになったが…。

* vttest で全然駄目だと思ったらどうやら DECOM を使っている様だ。 [#D0074]
  RLogin を確認すると DECOM で変化するのは
  HPA HPR VPA VPR HVP CHA CUP なのだそうだ。
  然し、HPR, VPR がどう影響を受けるのかというのは謎である。
  →RLogin で試してみた所 HPR, VPR は DECOM が有効の時に
    範囲内に confine される様になる様だ。

  * do_cux の lrmargin の制限はちゃんと行方向の反転を意識しているのだろうか…。
  * 更に、RLogin では RS,GS 等の移動も影響を受けるのだろうか。試すと影響は受けない様だ…。

* mode ?4,?5,?8 [#D0073]

  4 はスクロールに関する話。これに対応すると滅茶苦茶遅いので対応したくない。
  というか現在の機構だと対応が困難である。一行変更する度に画面更新をかけるのだろうか。

  5 は背景色の設定だが…。よく考えてみれば現在の実装だと、
  背景色は外側の端末の設定をそのまま使う前提である。
  そういう意味において内部で背景色を設定できる様にしても良いのではないかという気がする。
  うーん。然し、背景色を設定したとして…面倒だ…。

  8 はキーボードを実際に持っている端末でないと意味がない。
  これに関しては外側の端末に伝達しなければならない。

  取り敢えず背景色が設定されている時の output について実装する事にする。
  幾つかの実装方法を考える事ができる。

  a sgrcap の方で設定を弄って既定の前景色・背景色を設定する時に
    前景色・背景色を設定する様に書き換える様にする。
    この方法の問題点は設定を term の中で書き換えるのが難しいという事である。
    また、やはり出力先の端末の性質と中の端末の設定は独立にしたい。

  b もう一つの方法は attribute_t を描画時に渡す時にそれを修正して渡すという事。
    前景色・背景色の設定は何処に保持するのが良いだろうか。
    tty_state の中に保持するか、或いは、sgrcap の中に保持するか。
    うーん。実際に term に対して背景色を問い合わせたりするという事があるという事も考慮に入れると、
    やはり term の中に現在の前景色・背景色について設定できるようにするのが良い気がする。

  c 或いは board_t の中で既に背景色や前景色を設定した状態で記録する。
    これは微妙な気がする。やはり独立にしたいという気がする。

  apply_attr する時に既定の前景色・背景色があればそれを上書きする事にする。

  * reject: screen_buffer に格納する前に既定の前景色・背景色を適用してしまう?
    うーん。差分を取って行を更新している事などを考えると、
    背景色の変更に関してはキャッシュに記録した方が良い気がする。
    後、背景色の変更があった時には全体を更新しなければならない。
    うーん。逆に全体を更新しなければならないのであればキャッシュをクリアすれば良い訳で。
    という事を考えると、やはり既定色についてはその場で設定するというので良い気がする。

  * done: とにかく。先ずは既定の前景色・背景色を attribute に適用するコードについて考える。
    結局最後まで実装した。動いている。まあ、これで良いだろう。

  * done: 次に mode ?5 で既定の前景色・背景色を弄る様にする。
    改めて説明などを読むと、これは明るいか暗いかというよりは反転しているかどうか、
    という話の様なので実は既定の前景色・背景色の設定の話ではない気がしてきた…。
    うーん。これは結局、反転として処理する事にした。

  x fixed: 反転として実装したら妙な感じになった。
    自分で指定して着色している物まで反転していて良いのか。
    その様に考えると実はやはり前景色・背景色の既定色の
    入れ替えとして考えるべきなのではないか。

    xterm で試してみると実際に既定色のみの入れ替えになっていた。
    また、DECSCNM の説明に反して明暗は固定ではなくて、
    その端末の既定の背景色・前景色に依存して変わる。

    →その様にして実装する事にした。
    前景色・背景色が設定されていない時には分からないのでそのまま。

* BUG: ansi: 何故か知らないが空白が入力される様になってしまった… [#D0072]

  うーん。ble.sh 側の問題ではない筈。というのも、他の端末では症状が出ていないので。
  respond() を消すと問題がなくなる。という事は DA2 のシーケンスを構築しているところが悪い。
  うーん。見てもよく分からない。或いは DA2 のシーケンスの中身によって何か変な事が
  ble.sh 側で起こっている可能性もなくはない。
  うーん。respond() だけ呼び出しても変な物が出力されている。
  respond() を2回呼び出しても1回しかスペースは入力されない。

  もしかして初めから変な物が入っている可能性がある?
  と思って初期化の所を見てみた所、サイズを指定するつもりで 32 が指定されていた。
  これがサイズではなくて要素の初期化であると見なされて空白が挿入されていたのである。
  更に、よく考えてみれば初期化の時に指定するのはサイズではなくて、
  capacity の方である筈なのでここで指定しても仕方がない。
  コンストラクタの中で reserve を呼び出す事にした。

* ansi: 端末サイズ変更関連に対応する [#D0071]

  * done: 端末のサイズを変更した時に行内容を truncate する。
    そうしないと全角文字などが化けて出たり座標計算がおかしくなったりする。

  さて、vttest でどの様に動作するのが正しいのか確かめる為に実行してみると、
  そもそも screen では何やら変な動作をする。
  Poderosa に下って実行してみようとしたら Poderosa が固まってしまった。
  結局まともに動作する端末は余りないという事なのだろうか。

* というより DSR に応答する様にしなければならない [#D0070]
  現在は何も応答していない。というか、そもそも制御機能の登録もしていなかった。
  不思議だ ble.sh が DSR(6) を発してはいなかったか。。
  或いは ambiguous width を emacs にしているから飛んできていないだけか。

  何れにしても vttest を実行する上で DA1 だか DA2 には応答したい。
  応答する為には応答の書き込み先を用意しなければならない。

  * done: 適当に DA1 には応答する様にした。
    然し、今度は vttest が DECRQSS を要求している。
    うーん。実装していない。

  * done: DA2 についてはうーん。取り敢えず適当に CSI > 6 7 ; 0 c を返す事にする (67 は 'C')。
    中で ble.sh が DA2 を要求しているので ble.sh が受信した内容を確認する。

      $ echo $_ble_term_DA2R
      67;0

    OK. ちゃんと返答できている。

  * done: というか返答に使う CSI は S7C1T 等の設定に応じて切り替えるべきでは。
    更に "\x1b[...c" 等ではなくて ascii code で出力するべきである。

  * done: vttest を実行してみると DECRQSS を送ってくる。
    DECRPSS を返信する様にした。

* bug: vttest を実行しようとしたら表示が滅茶苦茶に乱れる、と思ったら tab を使うとなる様だ [#D0069]
  tab は全て nul か sp に変換しているつもりだったのにそのまま挿入されているという事になる。
  うーん。調べる。やっぱりカーソル移動しか実行していない気がする。
  或いはカーソル移動するともう駄目なのだろうか。
  →そうだった。カーソル移動だけで座標計算が駄目になる。
  と思ったら pus_spaces の中身を展開した時に変数を書き換えていたのが駄目だった。

* というか sequence で ^@ や ^? を読み飛ばしているつもりだったが読み飛ばせていない。 [#D0068]
  うーん。不思議だ確認してみると ascii_nul または del は無視している筈…。
  そもそも graphic character としても挿入されない。全く処理されない筈なのである。

  * fixed: うーん。そもそもエラーメッセージに ^@ という文字が含まれているのがおかしい。
    と思って確認したらちゃんと変換するのを忘れている。直した。NUL と表示される様になった。
  * fixed: うーん。もしかすると中途半端に終了してしまったシーケンスを処理しようとしている?
    調べてみるとそうだった。process_invalid_sequence を呼び出す前に set_final で
    問題の文字を設定してしまう事にした。

    そして実際にシーケンスの途中に改行だとかタブだとかを混ぜて来ている…。
    この時にどう振る舞うべきなのか…。改めて ECMA-48 を確認してみたが何も書かれていない。
    screen はちゃんと対処して vttest を通っている。という事は何か期待される動作があるという事。
    a もしかするとその改行だとかタブだとかを改めて制御機能として処理するという事なのだろうか。
      現在の contra の実装では単に捨ててしまっている。
      と思って改めて処理する様にしてみたが全然駄目だった。
    b 或いは単に途中に C0 が含まれていても無視する様になっている??
      試しに無視する様にしてみたら駄目だった。
    c 或いは途中に現れた C0 は独立に処理してしまう?
      その様にしたら通る様になった。

    vttest は CR HT VT に対してしかこの振る舞いを要求していない。
    他の制御文字に関してはどうなっているだろうか。
    RLogin で試すと (1) FF も埋め込める。(2) 流石に他のエスケープシーケンスは埋め込めない。
    (3) 制御シーケンスの中に ESC が来た時、その ESC は次のエスケープシーケンスの先頭として使われる。
    つまり、ESC も一緒に廃棄されるという訳ではない。(4) LF も埋め込める。(5) 8bit NEL は埋め込めない。
    恐らく UTF-8 デコード前にもう駄目になっているのではないかという気がする。(6) 実は C1 は全て認識している。
    FS, GS, RS, US による移動も認識している。

2019-04-23

* cat memo.txt すると右端にごみが残ってしまう [#D0067]
  これは何だろう。描画ルーチンで m_width + 1 だけ ECH すると消える。

  | 何処かで一文字消滅しているのだろうか。或いは screen が文字幅を勘違いしている?
  | というか、impl3 の方で文字幅を勘違いしているのかもしれない…。
  | と思ったが、screen で観察する限りはちゃんと最後のごみは 80 桁目に収まっている。
  | と思ったら screen を detach/attach すると消える。
  | という事はこれは contra 側の問題でもなく screen 側の問題でもなく、
  | Poderosa の問題という事になるだろうか。
  | 直接 Poderosa から ./impl3 を実行しても問題は発生しなかった。
  | という事はこれは screen が Poderosa に出力する時に起こる何らかの不整合だろう。

  結論: screen の Poderosa に対する描画が何か変である。contra ./impl3 は関係ない。

* 行の追跡と再描画の省略 [#D0066]
  次に実装するべきは何だろうか。

  恐らく行毎に変更があったかなかったかを検出する事と、
  行事体の移動を追跡する事である。
  その為には前回の行の内容 (というかその瞬間に端末に表示されているであろう内容) と、
  行番号と version 番号などなどである。
  行番号と version が一致していれば更新の必要はない。
  一致していなければ行内容を照らし合わせて変更のあった部分以降について更新を行う。

  行番号の追跡に関しては全画面の時には実施するが、
  他の内容も表示されている時には DECCRA もしくは DECSLRM がないと難しい。
  逆に DECCRA 及び DECSLRM が使えるのであればそれを使ってスクロールする様にしても良い。

  * done: 取り敢えず各行に固有の id が割り振られる様にする。
    set_id をする場所は何処だろうか。board_t の中で新しい行を入れている所で割り当てる。

    ? 後 term.cpp で clear_content を呼び出している箇所はどうだろうか。
      clear_content を呼び出しているのは EL(2) 及び ED である。
      これらに関してはまあ新しい行と認めなくても良い気がする。
      全削除をしている事によって追跡の必要はなくなるという事の気がするけれども、
      然し、概念としては実際には削除していない。結局どちらでも良い気がするが…。
      id を描画の目的だけで用いるのだとしたら新しい id を割り当ててしまって良い気がする。
      一方で id を別の目的で将来使用したくなる可能性まで考えると
      新しい id は割り当てない方が良い気がする。
    →結論: EL(2) 及び ED では新しい id は割り当てない事にする。

  * done: id 及び version が変化した行だけを再描画する。
    これは直ぐに実装する事ができた。そんなに大変な事はなかった。

  * done: id を用いた行の追跡を実行する。
    これは scroll が有効な場合とそうでない場合があるので on/off できる様にする。

    というか、これは先ず始めに差分のアルゴリズムで最長の一致を求める必要があるのではないか?
    と思ったが、よく考えてみると端末のシーケンスには行を挿入したり削除したりするコマンドはあるけれども、
    行の順序が交換される様な操作は存在しない。従って、最長の一致は共通の id を持つ行を特定するだけで良い筈。
    もし順序が交換される様な場合もあるとしても、さしあたっては簡単なアルゴリズムで十分であろう。

    取り敢えず決めなくてはならないのは共通部分をどの様に決定するのかという事である。
    これは実は前の表示内容の各行がどれだけ移動したかという情報で良いのではないか。

    行の移動の最適な方法は何だろうか。
    先ず始めに各位置で削除と挿入をそれぞれどれだけ行うかを決定する。
    挿入を実行した時に内容がはみ出てしまうと問題に鳴るので削除は先に実行する。
    その後で挿入を実行すれば良い。

    では screen_buffer の方の更新はどの様に行うのか。
    screen_buffer は配列なので削除と挿入を毎回行っていると効率が悪い。
    実際には各範囲毎に移動量が決まるはずで、それに従って移動を実施すれば良い。
    若い番号に移動する場合には何も考えなくて良い。
    大きな番号に移動する時にはふみつぶさない様に保留する。
    最初に踏み潰されない要素が見つかった時にその要素から順に移動すれば良い。
    その様に考えると移動量ではなくて移動先で管理した方が良い様な気もしないでもない。

    うーん。結局、削除・挿入・screen_buffer の更新は独立に実施するのが良さそう。
    実装した。本当にこんな実装で大丈夫なのか確認はしていないが、まあ取り敢えず動いているには動いている。

* 2019-04-21 DECSLRM が設定されている時 SU, SR, 及び暗黙移動による rotate で内容を切り貼りする [#D0065]
  内容を切り貼りする為にはある行の内容を切り出して、
  別の行に貼り付けるという事をしなければならない。

  更に mono の場合と prop の場合が混在していた時にどうするかについて考えなければならない。
  表示部での切り貼りとデータ部での切り貼りの二種類の可能性についても考える必要があるだろうか。
  ECMA-48 によると SU, SD, SL, SR は表示部におけるスクロールであった。
  従って、表示部に於いて複雑な切り貼りを実行する必要があるのではないだろうか。
  うーん。DCSM を感知する様にしても良いのではないかという気がする。
  表示部で切り貼りされたらアプリケーション側では現在の状態の追跡が困難になるのではないか。

  然し、将来的な対応だとか実装の自然さなどを考えるとデータ部における切り貼りも一応対応したいと思う。
  後、この様な機能を使う頻度を考えると多少効率の悪い実装になっても構わないという気がする。

  compose_segments に渡す line_segment_t に親の行を指定する事ができるようにすれば良い気がしてきた。
  後でまた観察する。一方で mono_compose_segments についてはどうだろうか。
  これもそんなに悩まずに実装する事ができそうだが、一方で、
  呼び出し元で処理すればより効率的な実装ができそうな気もしないでもない。

  * done: 取り敢えず、SU,SD,IL,DL 迄は対応した。

  x fixed: うーん。試しに動かしてみたらスクロールが動かなくなっている…。
    そして動かなくなったのは一つ前のコミットの様である。
    diff を見てみたが何が行けないのかすぐには分からない。
    取り敢えず insert_graph を確認してみる。

    何と折返しが起こっていない、と思ったがよく見るとそもそも
    画面の右端に達していないので折返しが起こっていないというだけだった。
    という事は do_nel が怪しい。特に do_generic_ff が怪しい。

    * fixed: 調べるとそもそもスクロールする所まで進んでいない…。
      というか spl の値が何故か 80 になっている。直した。

    と思ったら直っていない。動作を調べていくと一応 rotate(1) までは呼び出されている。
    うーん。不思議である。ちゃんと呼び出されている。

    うーん。確かに rotate をする時としない時で振る舞いは異なるが変である。
    後、initialize_cells の効果も変である。別に負の shift が起こっている訳でもない。

    うーん。IL DL の方の問題の気がしてきた…。でも変だ。コメントアウトしても何も変わらない。
    IL と DL を即座に抜ける様に修正しても画面の内容が消えたりスクロールしない問題はそのまま。
    やはり rotate が変なんだろうか…。rotate を全くしない様に変更すると、
    出力した内容の1行目だけが表示される様になる。
    最終行だけが表示されると期待するのに何故1行目だけなのだろう…。
    或いは、別の行に何か表示しているのだろうか…。

    1. うーん。先ず prompt で enter を押しても rotate が起こっていない様子である。
      bash --norc で起動するとちゃんと rotate が起こっている。
      これが意味する所は IND もしくは IL, DL による行挿入が動作していないという事。
      また、bash --norc で起動したとしても次々に行内容が消滅する。

      うーん。もしかして書き込み位置がおかしくなっている?

    * fixed: 今気づいたが spl の値が変だ。1 多い。これは修正した。
      然し、振る舞いが微妙に変化しただけで依然として何かが変だ。
      因みに implcit_spl を呼び出している所はこの箇所だけである。

    未だ治らないと思ったらテストの為にコメントアウトしたコードを修正したら直った。OK

  * 次に暗黙的移動で起こる shift_lines についても DECSLRM の影響を受ける様に修正する。
    もう他には shift_lines を呼び出している箇所はない。

2019-04-21

* ICH と DCH についても DECSLRM に対応した [#D0064]
  ECH については RLogin も xterm も DECSLRM の影響を受けていないので保留する。

* SLH,SLL と DECSLRM は同一視しても良いのだろうか [#D0063]
  例えば、ECMA-48 を参照すると SLH, SLL が SU や SD の範囲に影響を与えるとは書かれていない。
  然し、DECSLRM は SU や SD の範囲に影響を与えるという前提の様である。
  少なくとも Tw 上の議論ではその様な前提で行われている様に見える。
  うーん。やはり ECMA-48 を見ても SLH, SLL でスクロール範囲が制限されるとは読めない。

  しかし暗黙移動に対する影響は両者とも同じ様に見える。
  どの様に実装するのが良いだろうか。
  例えば暗黙移動に関する関数に関しては両方を参照する様にして、
  スクロールに関する機能からは DECSLRM だけを参照する様にするなど。
  また、SLH, SLL は subsequent lines という話なのだから、
  行毎に情報を保持する事にする。
  DECSLRM は全体で一つの値を保持するという事にする。

  その様に実装を修正する事にする。

  * done: というか DECSLRM を実装する事にする。
    実装は殆ど DECSTBM と同様で大丈夫。
    調べて分かった事は DECLRMM モードにも依存するという事。

  * fixed: xterm の振る舞いを観察すると変な引数を与えて
    DECSTBM が効かない時には原点に移動する動作も行わない様である。
    今までの実装だと変な引数を与えた時でも原点に移動していたので修正した。

  * done: DECLRMM 用意した。

  * done: 範囲を取得する関数。関数名を考える必要がある。

    うーん。現状で slh sll で取得するのは line_home, line_limit としているが、
    似たような関数名だとどれがどれか分からなくなってしまうので、
    それぞれが何を取得するのか分かりやすい方が良いのではないだろうか。
    例えば slh, sll で設定するのは暗黙的移動による範囲であると考えて良い。
    一方で decslrm で設定するのは暗黙的移動による範囲に加えて、
    スクロールの範囲やカーソル移動の範囲も制限する。

    うーん。slh, sll による設定は implicit_{left,right}_boundary と言った感じである。
    一方で decslrm は完全に範囲を制限している。scroll_left, scroll_right なのか、
    という感じである。うーん。違う。スクロールに関しては decslrm の設定だけ参照する。
    CUF, CUB に関しても decslrm の設定だけ参照する。
    implicit_left と implicit_right に関しては両方の設定を参照する。

    実装した。DECLRMM を参照しつつ決定する。

  * done: implicit_home,limit は引数に line_t const& を受け取る様にしたい。

  * done: board_t::line_home,limit は廃したい。

  * done: RLogin では CUF CUB が影響を受ける。HPB, HPR は影響を受けないのだろうか。
    これについては後で調べる事にする。→調べてみた所 HPB, HPR は影響を受けない様だ。
    従って、取り敢えず CUF, CUB だけ修正する事にする。

  * done: FF の類は SPH, SPL と DECSTBM の両方を参照する様に変更する。

* bug: less で上にスクロールした時に何も表示されなくなる [#D0062]
  何故だろうと思って出力されているシーケンスを観察すると、
  表示されている文字列と表示されていない文字列の出力の間に RI が呼び出されている。
  つまり、RI を呼び出した瞬間に画面がクリアされているという事だろうか…。

* bug: emacs 上で括弧の対応の強調が起動されると描画位置がずれる [#D0061]
  出力されているシーケンスを観察すると何と CR HT HT BS という列で移動を行っている…。
  一体どういう移動方法だ…。ESC [ 1 5 ` か ESC [ 1 5 G で良いのでは?
  と思ったが、確かに 1 byte 少なくて済む…。terminfo か何かの移動テクニックなのだろうか。。

  それと同時に CR HT HT BS に対して現在の実装はどの様に反応するだろうか。

  x fixed: というか、現在の実装では HT に対して 0 埋めを実行しているが、
    実は HT は移動だけしか行わない?→どうやらそのようである。
    現在の実装では 0 で埋めているので修正が必要になる。修正した。

  x fixed: しかしこの修正だけだと未だ振る舞いが変である…。
    →うーん。分かった tab で進む位置の計算を間違えていた。
    現在の位置が丁度タブの位置になっている時に移動しない様になっていた。

  o 実は右端に行った時の振る舞いが変なのでは…。
    と思ったが、改めて見た所、ちゃんと std::min で抑えてあるので大丈夫。
    本来はこれについても line_limit か何かで制限するべきではある。

  何れにしてもずれは発生しなくなったのでよしとする。

2019-04-20

* ansi: rotate を DECSTBM に対応する [#D0060]
  今の実装だと改行などで範囲の外に出てしまう。

  x fixed: さて、対応したつもりだがそれでも何故か文字列を入力して行って
    改行を実行すると範囲の外に出てしまう。
    と思ったが改行で一番下にいるかどうかの
    判定を修正していない気がする。→修正した。

  x fixed: 動かなくなった…と思ったが、
    これは rotate の呼び出し方を反転していたのが問題だった。修正した。

* altscreen が動いていない気がする… [#D0059]
  調べるとどうも set_mode(true) しか受信されていない様である。
  と思ったら get_mode(mode_altscreen) に対応していなくて
  常に false が返る様になっていた。つまり、false に設定しようとしても、
  常に既に false になっているから特別の処置は不要であると判定されていたという事。
  修正した。altscreen は無事に動作する様になった。

* impl3: 取り敢えず端末画面の内容を出力する様にしてみた [#D0058]

  先ずは簡単で良いので画面内容を出力し続ける様にする。

  * fixed: TIOCSWINSIZE の問題
    % できたと思ったが内容がおかしい。どうも出力がおかしいのではなくて
    % 実際に端末画面の内容がおかしいようである。調べてみると、
    % LINES, COLUMNS の内容がおかしい。
    % slavefd に対して TIOCSWINSIZE を実行しても反映されない。
    % masterfd に対して TIOCSWINSIZE を実行しても反映されない。
    % ループの中で何度も masterfd に対して TIOCSWINSIZE を実行すると反映される様だ。
    % しかし、それだといかにも非効率的というか変な事がおきないか心配である。
    % 更に、不自然である。ちゃんと正しい方法が存在する筈である。
    % 思うに bash が起動した瞬間からちゃんと winsize を設定していないといけないのでは。
    % と思って create_session の内部で一番始めに設定する winsize の時点で
    % ちゃんと目的の幅・高さに設定する様にしたら解決した。
    →仮想端末を開いた時の初めの TIOCSWINSIZE の時点で最終的な値を設定する必要があった。

  * fixed: mode_vem の既定値が true になっていた問題
    bash だと内容が正しいが ble.sh だと内容がおかしい。
    これは IL, DL の実装が変だからの様な気がしてきた。
    画面内容が少しずつずれていくからである。
    というか IL, DL を実行するにしても上にずれていくのは変である。
    bash で問題になっていないのだから改行などによって起こる
    スクロールが問題になっている訳ではない様に思う。
    と思ったら mode_vem の既定値が true になっていた。修正した。

  * fixed: 日本語を正しく出力できていない。
    然し、どうも print_screen では正しく出力できている様だ。
    つまり、端末内容は問題がないが出力に問題があるという事だろうか。
    或いはバイト値で格納されている?
    うーん。そちらの様な気がしてきた。
    つまり、入力時に UTF-8 ではない変な解釈になっている。

    tty_player_device を見ると term_t::write を呼び出している。
    調べると term_t::printt はちゃんと encoding に対応しているが、
    term_t::write は encoding に対応していない様である。

  * done: 後、着色もちゃんと反映する様にしたいのである。

    取り敢えず先ずは着色を反映される様にする。
    と思ったが現在の実装だと並び替えなどを実施した際に、
    属性を取得する事ができない。属性も取得する様に拡張するのは面倒である。

    a 或いは、line の側で並び替えを実行した時のセルの配列を取得する関数を用意するか。
      処理に時間がかかる様になってしまうのではないかと思ったが、
      よく考えてみると現在の暫定実装について考えると、
      文字列の入れ子を何度も走査するので一括で取得した方が明らかに速い筈である。

    b メモリが無駄になるなどの事を思うならばセルに対するポインタの配列でも良いかもしれない。
      と思ったが、現状でセルは 16B でポインタは 8B なので対して節約になっていない。
      寧ろポインタ経由でアクセスする為に遅くなってしまうのではないか。
      その様に考えるとポインタの配列にするぐらいならば直接セルの配列にする。

    文字列の情報を用いて反転を実施する事にする。
    所で update_strings で得られる文字列で記録しているのは、
    文字列の座標範囲であって、cell のインデックスではない。
    という事はこれを使って実装する事はできない。
    update_strings でインデックス情報も取得する様にするか、
    或いは一からループを書き直してその場で反転を実施する様にするか。

    取り敢えず今の所は他の箇所でインデックス情報を参照するかどうかも分からないので、
    表示に於ける並びを取得する関数で新しくループを記述する事にする。
    然し面倒なのは cluster 等は元の順番を保持する様に反転しなければならないという事。
    cluster の部分だけ予め反転させて置いて、最終的に正しい向きになるように調整しなければならない。

    取り敢えず適当に実装を初めて見る事にする。

    取り敢えず実装は完了した。実は文字列がある場合にはテストはしていないのだけれども、
    それについては追々テストを追加して行く事にする。

  * [自然解消] うーん。並び替えも含めてどの様に処理するか考え直す必要があるかもしれない。
    取り敢えずの所は get_cells_in_presentation で実装する事にした。

  * 保留: うーん。emacs みたいに描画中にカーソルを
    一時的に隠すというのは有効かもしれない。

    所でちらつくのは単に fflush が足りていないだけではないかと思ったが、
    実際に試してみると、ある程度は現在の位置にカーソルが表示される様にはなるが、
    やはり fflush しても余りちらつきは変わらない。

    \x1b[?25l で隠す様にしてみたが対して変わらない様だ…。
    というか \x1b[?25l 等を実行してしまうと現在の端末の状態に応じたカーソルを破壊してしまうので、
    もし使うとしても現在のカーソル状態をちゃんと管理する様にしてからでなければならない。
    何れにしても余り効果が無いようなのでこれについては今の所は off にしておく。

  * done: 次は更新があった時にだけ画面内容を出力する様に書き換えたい。
    後、変更があったかどうかについては version を参照する様にしたい。
    また、行に id を割り当てて追跡する様にしたい。
    然し、これらの実装は恐らく複雑になるので別項目で処理したい。

* 2019-04-14 RLogin では FS/GS/RS/US に対して ADM-3 互換と称してカーソル移動を割り当てている [#D0057]
  一方で xterm, mintty ではその様な機能は存在しない様である。
  FS-US は単に何もしない機能という事になっているからこれに対応しても良いかもしれない。
  しかし、この様なシーケンスを用いたプログラムが書かれる事があるのだろうか、
  という事を考えるとやはり対応しても仕方がないのではないかという気もする。
  まあ、RLogin に倣って対応するというので良い気がする。

* ansi: bug: 画面内容が全く保存されていない。何処かでクリアされている? [#D0056]
  改行が効いていないのかもしれないと思ったが今までのテストでちゃんと動いていた筈である。
  実際に何か別のコマンドを呼び出してみるとちゃんと複数行になっている。
  という事は何らかのシーケンスが画面をクリアしていると考えるのが自然である。

  どうやら調べてみると IL で全てが消滅している様である。
  shift_cells の引数が負の時に移動方向が反転してしまっているバグがあった。修正した。

* DECSTBM と IL DL 等の関係を調べる [#D0055]

  DECSTBM の影響範囲に関しては RLogin のエスケープシーケンスのページが詳しい。
  http://nanno.dip.jp/softlib/man/rlogin/ctrlcode.html#SGR
  CUU CUD CNL CPL IL DL SU SD
  後 MC, DECMC というのも DECSTBM, DECPEX の影響を受ける。

  取り敢えず勘で実装してしまった。RLogin で振る舞いを確認した方が良さそう。
  先ず初めに DECSTBM に変な引数を与えた時にどの様に振る舞うかに関して。

  - %%先ず初めに DECSTBM の第二引数は最終行ではなくて、最終行の次の行である。%%
    →どうやらこれは勘違いの気がする。単に ble.sh のステータス行を数え忘れていただけだった。
  - fixed: 巨大な値を指定すると最終行までと見なされる。
  - fixed: 範囲が潰れる様な指定の仕方をするとスクロール範囲に対する変更は実行されない。
  - fixed: 引数 0 もしくは空欄は既定値を意味する。開始の既定値は画面の一番上で、
    終端の既定値は画面の一番下である。

  更に、IL 及び DL がどう振る舞うかについて。まあ、これは確認してなくても良いだろう。
  また、同時に SU SD SL SR についても実装をしておきたい。
  それから CUU, CUD 等も影響を受けるそうだ…。

  * done: DECSTBM の振る舞いについて確認して gh に記述した。
  * done: SU, SD, SL, SR の振る舞いについても確認を行った。
  * done: SU, SD, SL, SR の実装。
  * done: CUU, CUD, CUF, CUB, CPL, CNL の修正。

* ansi: DECSTBM の対応 [#D0054]
  emacs を起動してみると凄い勢いで
  DECSTBM (set scrolling region) を実行している。
  つまり DECSTBM に対応した方が良いのでは。という事。

2019-04-17

* ansi: Alternate Screen Buffer には対応しないと行けない [#D0053]

  仕様について確認を行う。

  ?47 と ?1047 でバッファは共有の様である。
  ?1047 は ?47 を設定して更に代替画面をクリアするという事の様だ。
  また、?1047 の値と ?47 の値は DECRQM で確認すると連動している。
  ?1049 も連動している様子である。双方向に変更が伝わる。

  実は alternate screen buffer は VT の機能ではない様だ。なんで名前はついていない。
  誰が一番始めに実装したのだろうか。xterm には xterm と書かれている。

  関連して ?1048 の設定・解除は実は \e7 \e8 と等価になっている。
  現在の状態は記録されていない。
  取り敢えず表面上だけでも実装する事にした。

  うーん。後は altscreen の board を用意するだけで良い気がする。
  或いは board ではなくて lines だけでも良いのかもしれない?
  presentation_direction だとかも保存されるのだろうか…。
  然し、SPD 等で変換する場合なども考えると、
  altscreen の SPD と本体の SPD は独立が良い気がする。

* ansi: やはりモードの登録方法を考える必要がある気がする… [#D0052]
  一覧表から自動生成する事にしようか。

  * 一覧表を作るところから始める事にする。
    何が必要だろうか。

    1. 名称
    2. type = flags, accessor
    3. flags 内のインデックスは自動生成すれば良い
    4. mode_type = ansi, dec, contra, etc.
    5. mode_param = 番号
    6. 既定値

    $1--$4 に上記の 2. 1. 4.5. 6. を入れて一覧表を作った。

  * さてどの様に実装しようか。
    実用性を考えると実は今と同じで良いのではないか?

    と思ったが ansi1 だとか dec2004 だとかの情報は
    mode_spec に埋め込まなくても良い。どうせ辞書から引かないと行けない。
    そして辞書から引くのだとしたら辞書に登録する時に必要になるだけで、
    別に mode_spec に埋め込んでおくのは冗長である。
    今までその様にしていたのは表を作るのが面倒だったからである。

    そうすると flags か accessor かという情報と
    それぞれに対応した index だけ記録しておけば問題ないという事になる。

    a 先ず値に関して。
      accessor_flags = 0x10000 として
      後は flags, accessor それぞれに対して順に 0...n まで生成すれば良い。
    b 規定値の設定部分も生成する。
    c 辞書に登録する部分も生成する。

    実装した。動いている。異常もない。

2019-04-15

* emacs が SM(34) と SM(?25) を送ってくる [#D0051]
  SM(?25) は DECTCEM である。カーソルの表示・非表示である。
  他にもカーソル関係はある。SM(?12) はカーソルの点滅を制御する。

  * 次に SM(34) について。

    | 調べてもそういったものは無いようだ。
    |
    | もしかして terminfo から拾っているだろうかと思って
    | 調べてみると TERM=screen-256color であって、screen のマニュアルには
    | "normal cursor visibility" と書かれている。infocmp を見ると、
    | cnorm=\E[34h\E[?25h と書かれている。cnorm はカーソルを表示するという奴である。
    | うーん。よく見てみると cvvis=\E[34l になっている。cvvis は very visible
    | つまりカーソルをよく見える様にする、という事である。
    | という事はやはりカーソル形状をブロックにするという物と思って良さそう。
    |
    | all-escapes.txt によると 34 33 は WYSTCURM, WYULCURM という名前の様である。
    | それぞれ "カーソルの形は下線" と "カーソルは点滅しない" である。
    | 調べているとカーソルの形状・点滅・表示に関しては錯綜している。
    | まあ現時点では contra は GUI を持たないので適当に空実装という事にしておく。

    まとめると
    Mode 32, 33, ?12, ?13, ?14 は Wyse 及び xterm でカーソルの点滅のon/offに使われている。
    Mode 34 は Wyse 及び screen でカーソルの形状の変更に使われている。

  * mode についての getter/setter?

    | 後、これらに関しては重複する設定の様な気がするので、連動させる為に
    | getter, setter を設定できる様にしたい。
    | また、後で observer から設定変更を検出する為にも getter, setter の仕組みは
    | 何れにしても必要になるのではないかという気がする。
    | と思ったが、getter, setter と onchange は違う気もする。
    |
    | board に追加しようとして思ったのは、端末の状態は board に含まれていない。
    | つまり tty_observer は実は term に対しても observe を実行する必要がある。
    | まあ、それはそういう構造でも良いという気がする。
    | getter というよりも setter だけが必要?
    | と思ったけれども実際に記録されない様なフラグや他のフィールドから算出される様な
    | フラグに関しては getter も特別な物に差し替えるのが良い。
    | そして、それは term.cpp の側で処理するというよりも、
    | tty_state の側で処理する方が適切である様に思われる。

    →取り敢えずのところはその場に switch で書き込む事にした。
    もっとちゃんとした感じの実装にするのは増えてきてからという事にする。

  * 他にカーソル関係で形状と点滅を同時に制御する制御機能があった筈。
    これとの相互作用は一体どうなっているだろうか。
    うーん。& で良い様な気がする。つまり、片方が点滅を抑制していれば点滅は抑制される。
    と思ったが…うーん。片方が点滅を指定していれば点滅するという考え方も存在する。
    因みに既定値は点滅である。という事を思えば点滅が既定であって、
    どちらか一方で点滅を抑制する指定があったら点滅しないという設定で良い気がする。

    | xterm の動きを観察する。うーん。よく分からない。
    | 分かった事は menu の Blinking Cursor は反転として働いているという事である。
    | というか DECRQM を実行してしまえば良いのでは。。
    | 実際に実行してみると ?13 は認識していない。?14 も認識していない。
    | うーん。xterm の説明書に書かれているのは手元の xterm の振る舞いと違うという事なのか。
    | 最新の xterm で追加された機能なのかもしれない。
    | とにかく menu 項目の設定 (説明書によると ?13 らしい) は反転させる効果という事。
    | 更に DECSCUSR の値を変えても ?12 の値は常に 2 (RM) のままである。
    | 本当に ?12 はカーソルなのだろうか…。更に、SM(?12) にしても RM(?12) にしても
    | DECRQM(?12) の結果は変化しない。これが意味する所は…。
    | 実は一度でも DECSCUSR を使うと ?12 は inactive になるのだろうか。
    | RIS SM(?12) DECRQM(?12) を試してみたがそれでも状況は変化しない。
    |
    | うーん。つまり実は xterm は対応していないという事?
    | Cygwin の xterm の version は 330 と書かれている。
    | 最新版の xterm (344) をダウンロードしてコンパイルして実行してみた所、
    | ?13 も ?14 もちゃんと有効になっている。?12 も設定に応じて変化する。
    | これで改めて設定を確認してみる事にするのである。
    | ?12 は SM/RM で変化する。?13 は RM のままで SM/RM では変化しない。
    | ?14 は permanently set という状態を返す様である。
    |
    | % DECSCUSR は説明と比べると反転した状態になっている。
    | % そして、メニューが表示されていないので分からないが、
    | % メニューに於いて Enable Blinking Cursor の
    |
    | DECSCUSR は ?12 と連動するという所まで確認できた。
    | メニューとどう連動するかは良く分からない。
    |
    | man xterm に詳しく書かれていた。cursorBlinkXOR が設定されていない時は、
    | どちらか一方でも blink になっていれば blink する様である。つまり or。
    | うーん。メニューを設定する方法は不明だが、
    | % うーん。-bc で起動すると反転していない。+bc で起動すると反転している。
    | % DECSCUSR の仕様の方を勘違いしているだろうか…。
    | 勘違いだった。ちゃんと期待した通りの動作になっている。
    |
    | 因みに #330 はどれだけ古いのかと思ったが、
    | 調べると 2017/06/20 なので特に古くもない。

    まとめると。
    1. xterm が ?12 ?13 ?14 に真面目に対応したのは割合最近の話である。
    2. ?12 の設定は DECSCUSR による設定と連動している。
    3. ?13 の設定は cursorBlink resource の値を反映する。
      SM/RM では変更する事ができない。
      因みに cursorBlink resource は false true always never の4種の値を本当は取る。
    4. ?14 は常に set という事になっている。
      set の時は片方だけ set (blinking) の時に、blink する。
      reset の時は一方でも set ならば blink する。

2019-04-14

* BDSM の実装。これは DCSM の有効・無効の判定部分に影響を与える [#D0050]

* 2019-04-13 選択範囲や属性化領域はどの様に処理するのが良いのだろうか [#D0049]

  | ? 例えば選択範囲は入れ子にすることができるのだろうか。
  |   他の領域と overlap がある場合にはどの様に取り扱うべきか。
  |   領域は或いは他方が一方を必ず包含する様になっているのだろうか。
  |
  |   うーん。用途を考えると入れ子にしても仕方がない気がする。
  |   なので on/off で解釈してしまっても良い気がする。
  |   因みに属性化領域の説明には選択領域で終了するなどは書かれていないので、
  |   互いに overlap する事が可能である様な気がする。
  |
  |   つまり、属性化領域・保護領域・選択領域は互いに overlap 可能の様に思われる。
  |
  | ? 属性化領域も入れ子にすることができるのだろうか。
  |   と思ったが DAQ の解説によると次の DAQ が現れたらもう其処で終わるとの事。
  |   なので入れ子はないと解釈して良い。
  |
  | ? 他の実装はどうやっているのだろうか。
  |   例えば DECSCA の様に描画属性に紛れ込ませていたりはしないか。
  |
  |   例えば VT510 は対応しているのだろうか。調べてみると SSA-ESA も SPA-EPA も DAQ も対応していない。
  |
  |   RLogin を見ると文字消去ガード開始・終了、としていて SPA-EPA と同じ取り扱いという事になっている。
  |   具体的にはどういう実装になっているだろうか…。ERM も機能として実装している様だから試してみる。
  |   printf '\e[41mabcdefghijklmnopqrs\ra\eVBC\e[20Cx\t\td\eWefg\e[m\e[2K\n'
  |
  |   - どうも試してみると SPA-EPA はやはり描画属性の如くに処理されている気がする。
  |     というのも物理的に SPA と EPA の間の文字列が保護される訳ではなくて、
  |     時間的に SPA と EPA の間に入力された文字が保護されている様子だからである。
  |   - 更に EPA をした後に上書きした部分に関しては削除されない様子である。
  |   - また HT による移動では1文字目だけに属性が適用されて、
  |     それ以降のスキップには属性は設定されていない。
  |
  |   printf '\e[41mA\eVBC\eW\e[10P\e[m\e[2K\n'
  |   これだと行末に描画属性が適用される事になるが、
  |   実は其処には保護は適用されていない。うーん。
  |   つまり、描画属性とは別に管理されているという事になるのか。
  |   実は文字を書き込む時に設定されるという事だろうか。
  |   だとすると ht で一文字だけ適用されるとも理解できるかもしれない。
  |   或いはできないかもしれない。
  |
  |   xterm も実は対応している様子だ。xterm の場合には HT では属性は保存されない。
  |   HT でスキップした範囲は保護の対象ではない。EL や DCH 等で挿入された空白は保護の対象ではない。
  |   などなど。
  |
  |   これらの事を考慮に入れて "領域" はどの様に定義されるだろうか。
  |   - 例えば HT でスキップした場合に同じ "領域" と見做して良いのだろうか。
  |     それとも別の領域と思うべきなのか。或いは、保護を実行する時に何回目の保護領域なのか
  |     というのを覚えておくとかそういう手もあるかもしれない。然し、実装が面倒だし、
  |     振る舞いとしても分かりやすい物であるとは言えない。
  |   - 或いは保護領域の範囲と実際に保護される文字は別でも良いのかもしれない。
  |     例えば SPA を実行した位置と EPA を実行した位置を覚えておいて、
  |     その間を保護領域であると解釈する等。
  |
  | ? また、表示部での範囲を指定するのだろうか。
  |   それともデータ部での範囲を指定するのだろうか。
  |
  |   DAQ の内部で文字列を使用した時の動作は未定義という事になっていた。
  |   これを考えるに DAQ は属性として処理してしまって良い気がする。
  |   更に、未定義というのはデータ部で範囲を抽出しても良いし、
  |   表示部でデータを抽出しても良いという意味に取れるのではないだろうか。

  contra の実装では以下の様にする。SPA, SSA, DAQ は何れも描画属性の一部として記録する事にする。
  これらの属性がカーソルに設定されている間に入力された文字についてだけ属性を適用する事にする。

  領域はどの様に定義するのかは微妙である…HT によるスキップには現在属性は設定していない。
  他の実装でもそうなっている気がする。但し、RLogin に関しては1文字目だけに属性を設定している。
  うーん。取り敢えず NUL は跳ばす事にして同じ属性になっている範囲を領域という事にする?

  * protected guarded などについて意味を確認しておく。
    protected は削除されないし変更されないという事。
    guarded はデータストリームとして転送されない・補助装置との間で転送されないという事。

  * ERM に同時に対応したい気がするが面倒である…。
    全て消去するのならばともかくとして protected だけ残して消す。
    mono の場合には簡単である prop の場合にも簡単である。
    問題は prop&presentation の場合である。

    というか ERM が影響を受けるのはどれだったか…EA, ECH, ED, EF, EL である。
    うーん。shift_cells のフラグとして erm を追加するのは良しとして、
    どの様に対応するべきだろうか…。

    現在の実装は compose_segments に依っているが、
    実はこれは表示位置から計算されたデータ位置を使って抽出を行っていて、
    各セルのインデックスで抽出を行っている訳ではない。
    つまり、marker によって protected, unprotected が混ざっているかもしれないが、
    そういった物は全く関係なく全て切り出す様になっている。
    erase なので unprotected な marker は削除したい。
    或いは、単に protected なセルだけ残して他を全て削除するという処理方法でも良いのだろうか。
    うーん。取り敢えずそういう方針で実装する事を考えてみる事にする。
    それによって見た目が変な事になっても知らない、という事で。

    取り敢えず少しずつ実装する事にした。
    mono, prop&data については実装した。

    prop&presentation については compose_segments で実装されている。
    考慮に入れなければならない事が色々ある。

    - done: というか、そもそも protected な文字が含まれている行というのは
      余りない。みんなそんな機能は使っていない筈である。
      という事を考えると、実は、事前に protected があるかどうかだけ
      チェックして、含まれていなければ普通の処理方法で良いという事。

      含まれている場合には多少重い処理になっても気にしないという事にする。

    - done: 先ず初めに境界上に protected な全角文字が存在する時、
      現在の compose_segments の実装だとうまくできない。
      これは compose_segments の呼び出し元で範囲を調整する様にしたら良いだろうか。

      % 但し、どちらの方向に調整するのか等も含めてよく分からない…。
      % 然し、境界上に全角文字が存在する場合、
      % 必ずそれは表示範囲の端にある筈だから、
      % どちらの方向にずらしたら良いのかは自明なのでは。
      % つまり、範囲を広げる方向にずらせば良いのである。
      % 従ってこれは気にしなくても大丈夫。

      やはり全角文字がある場合にはどちらの方向に調整したら良いのかわからない…。
      特に全角文字の幅が 3 以上あって、境界の右側と左側で幅が異なる場合に。
      幅が同じ場合には適当に幅を拡張すれば良いだけなのである。

      然し、異なる場合には先ず初めに現在の文字の方向性を取得して、
      それに基づいて修正する量を決定する必要がある。
      或いは、二種類試してより良い方向を選べば良いのだろうか。
      二種類の xL, xR を pL, pR に変換して試すというのをやってみたが、
      よく考えると xL, xR でも文字列マーカの左右で結果が異なる筈である。
      なので xL, xR -> pL, pR の方向の変換は信用できない。
      一方で、pA, pB -> xA, xB の方向の変換は多分大丈夫である。
      うーん。本当だろうか。依然として曖昧さが残る気がするが、
      まあ、"その位置の右にある有限幅の文字の位置" になっていた筈で、
      その場合にはちゃんと変換される筈なのである。

      取り敢えず実装した。

    - done: 次に考えなければならないのは…。
      零幅文字を含むのか含まないのかという事である。
      うーん。境界上の零幅文字については元々削除しない方針なので、
      残す必要はない、というか残してはならない。
      その他の零幅文字については残すべきである。
      では何処が端の境界に対応していたのか、という情報は得られるだろうか。
      現在の実装だと難しい。

      これも無理矢理に実装した。本当に動作するのだろうか…。

  x fixed: うーん。テストケースを作っていたらアルゴリズムに不備が判明した。
    やっぱり真面目に反転しているかどうかを判断しなければならないという事なのか。

    * done: うーん。向きまで考えるのは面倒だけれども、convert_position を境界の左側について
      計算する関数があれば向きも自然に分かるのでは? という様に思われる。
      その様な関数を作るのは簡単だろうか。思うに、range.begin 及び range.end を +epsilon
      したアルゴリズムを作れば良いのではないかという気がする。
      そうすれば現在の位置が相対的に境界よりも左側にいるという事になる。
      と思って convert_position の実装を観察してみるが…うーん。
      +epsilon しても動作に変化はない。というか寧ろ -epsilon しないと動作が変化しない。変だ。
      というより反転部分の処理の方が効いている? end-1 - (x-begin) としている。
      これは文字の位置を意識した処理になっている。境界について処理をしているのだとしたら、
      end - (x-begin) とするべきなのである。
      文字の位置を意識した時は xL+0.5 = end - (xL+0.5-begin) より
      自然に xL = end-1 - (xL-begin) が導ける。

      では、文字の右端と左端の変換で違いはどうなるだろうか。
      うーん。+epsilon 作戦で実装してみたが全然駄目だった。真面目に考える事にする。
      と思ったが、単に +epsilon した時に条件式がどう変化するかを逆に考えていた。
      a < b → a < b + epsilon ⇔ a <= b という事だった

      と思ったが、それでも駄目だった…。"境界の左側" にあるのは元々の状態の時であって、
      一回反転が起こった時には "境界の右側" になっている…。
      実装した。従来の convert_position の実装に組み込んだ。

      然し、よく考えてみたら逆方向の変換の事を考えていなかった…。
      うーん。やっぱり分からない。反転回数によって結果が変わるのである…。
      というか現在文字の位置の変換は問題なく行えているのだから、
      それと反転回数を元に結果を修正すれば良いだけでは?
      というわけでその様に実装し直したら簡単に動作する様になった。

    convert_positions を拡張したのでそれを使って計算する事にする。
    と思ったがどうやって計算したら良いのかよく分からなくなった。

    取り敢えず boundary の位置がどうなるかを判定すれば良い筈である。
    その時に境界の右隣の位置を追跡するべきか、或いは左隣の位置を追跡するべきか。
    実は、これはどちらでも良い。全角文字が跨っている時には、
    どちらで計算しても同じ筈である。全角文字の途中で文字列が切れている事はないので。
    また、丁度境界の上に乗っていた時にはちゃんと _prob_glb で一致している位置が返ってくる筈で
    その時には何も処置しなくて良いという事が直ちに分かるのでやはり問題ない。
    その様に修正した。うーん。取り敢えず動いているから良いという事にする。

2019-04-13

* 2019-04-12 ansi: 行末ECH後のカーソルの位置は? [#D0048]

  (これは調べたやはり端末によって色々である。contra-gh に追記した。)

  以下に於いて B が行末に表示されれば最後の文字に移動している。
  B が行頭に移動していれば ECH,DCH,ICH に於いて行末に留まる。
  printf '\e[100CA\e[@B\n'
  printf '\e[100CA\e[PB\n'
  printf '\e[100CA\e[XB\n'

  RLogin で試すと最後の文字に移動する。xterm でも同様である。
  Poderosa と screen は行末に留まる。mintty は行末に留まる。

* 2019-04-11 どうも to_presentation_position の仕様を前と変えてしまった [#D0047]
  presentation position は文字進路の方向にするべきだった。
  今は左から右という事になっている…。

  各実装でちゃんと結果がどうなるか確認する必要がある。
  - convert_position
    これは既に修正した。と思ったが、to_data_position 側を修正していない。
  - curpos_t line_t::_prop_to_presentation_position(curpos_t x, curpos_t width, bool line_r2l) const;
  - void line_t::calculate_data_ranges_from_presentation_range(slice_ranges_t& ret, curpos_t x1, curpos_t x2, curpos_t width, bool line_r2l) const;
  - というか line_r2l が関わってくる関数は全てこれが問題になる気がする。

  取り敢えず機械的に書き換えてみたが本当に大丈夫なのかは不明である。
  一通りテストを書いておく必要がある気がする。
  特に data における ECH, ICH, DCH は確認しておきたい。

  実際にテストを少しずつ追加していたらバグが出た。
  DCSM(PRESENTATION) に於いて正しく抽出できていない?
  と思ったが、調べてみると ECH の後の様子は問題ない。
  SDS(1) がちゃんと動作していない様である。

2019-04-12

* ansi: EL について DCSM(PRESENTATION) でも !m_prop_enabled の時は簡単に実装 [#D0046]
  というか ECH ICH DCH に関しても実装が term.cpp と line.cpp に分散しているが、
  基本部分だけを line.cpp に移動して、
  細かい動作については term.cpp で指定する様にできないだろうか。

  a 例えば、insert delete 等の操作を仮想的に行う事によって
    compose_segements の引数を構築する等…。
    つまり {{0, 10, insert_fill}, {10, 20, delete}} 等の引数を渡す。
    これをデータ部で実行するか或いは表示部で実行するかは line 側に任せる、など。

    うーん。ICH の実装を見て思ったが delete して insert したり、
    insert して delete したりするのは無駄である。
    データを移動してそれから消去すれば良いだけの筈なのである。
    insert, delete を分けるという事は2回も移動を行っているという事になる。

    そう言った移動を体系的に操作として記述する事は可能だろうか。
    そしてそれに基づいて !m_prop_enabled の場合、
    data && m_prop_enabled の場合、表示部 && m_prop_enabled の場合に分けて
    適切に効果的な処理方法を算出する事が可能だろうか。

    例えば !m_prop_enabled の場合を考えてみると、
    1. move {a..a+delta} to {0..delta}
    2. erase {delta..a+delta}
    の様に記述する事ができる。表示部 && m_prop_enabled の場合に対応する為には、
    先ず初めに、[0..width] という状態があって、(1) の操作によって
    [a..a+delta][delta..a+delta][a+delta..width] という領域に分かれる。
    更に (2) の操作によって真ん中の区間が消去されるという具合になる。
    こう言った区間の演算はどの様にして実行するのが良いのだろうか。
    場合分けして真面目に実装するのだろうか。
    しかし、どの程度複雑なケースまで考慮に入れるのかというのも気になる。

  b 「実は重複がない・順序が保たれる」という条件の下では、
    現在の compose_segments の形式の方が便利なのではないだろうか。
    各範囲について移動が必要かどうかも含めて判定する事ができる気がする。
    然し、動かす順番に気をつけないと何処かの範囲が移動している内に
    別の範囲が塗りつぶされるという事故が起こる可能性もある。
    というか本当にどの範囲も一回だけの移動で移動できる様になるだろうか。。

    少なくともどの範囲も最終的な移動量は確定している。
    その時に他の範囲を踏み潰す様な事があれば移動を延期しなければならない。
    例えばある範囲の移動について考えることにする。
    その範囲が左に動くとする。その時に左側にある範囲を踏み潰す様であれば、
    その左側にある範囲は先に動かさなければならない。その範囲は必ず左側に動く筈である。
    という事を繰り返し考えていけば必ずすぐに移動できる範囲に達する筈である。

    つまり、最初の範囲から順番に見て行って、
    右側に動かす場合には踏み潰される範囲がないかを確認して、
    一番最初に踏み潰されない範囲があればそれを移動する事にすれば良い。

  試しに実装してみる事にしようか。。
  取り敢えず compose_segments をどの様な場合でも動く様に修正した。

  * 実装してみて思った事はこの様な複雑な処理をするぐらいであれば、
    普通に移動を2回するぐらいの方が速い気がするという事である。
    更に _prop で同様の物を実装する為には余計に複雑な処理になってしまう。
    とにかく潰した全角文字を変換した後のスペースを何処かに記録する必要がある。
    そしてそれを記録していると余計にメモリの確保・解放の回数が増える。

    しかくよく考えてみたら今回実装を統一したのは
    効率をよくする為ではなくて今後の実装をすっきりした物にする為である。
    あらゆる制御機能を実装する度に同じコードを何度も書くのは不毛である。
    従って、統一的で一般的なインターフェイスを用意して、
    今後はそれを使って処理を行う様にしようというのが目的だった。

    insert/delete をくっつけて要素の移動を少なくする事ができる
    という話は副次的な利点であったのである。
    なので、この実装によって速度が遅くなったとしても、
    まあ実装する意味がなかったという事にはならない。

  * もっと効率の良い実装の方法はないだろうか。
    現状だと全角文字を潰した事によって発生する空白を
    どの様に記録したらよいかが分からない。
    これを記録する為には新しいメモリ領域を準備する必要がある気がするが、
    それで新しいメモリ領域を準備するぐらいであれば、
    実は既存の compose_segments と同様に処理するのと大差ない。

    或いは、実装を一般的にしすぎという事なのかもしれない。
    例えば segments の数は最大でも 2 か 3 という具合に
    制限して実装しても良いのかもしれない。
    左右の不変部分と、真ん中の消去・削除・移動部分という具合に。

    ECH の場合には真ん中を削除して代わりに何かを挿入する。
    DCH の場合には左端を固定して、真ん中を左に移動するという操作である。
    ICH は実は DCH と逆の動作になっている。
    SR や SL も似た様な実装になっている。
    EA 等については実は ECH を使って実装できてしまう。
    なので余り気にしなくても良いのである。

    然し、SEE を考慮して DCH 等をするとまた具合が異なる気がする。
    左右の不変部分があって、それとは別に内部に移動する文字列がある。
    この場合最大四箇所で全角文字の処理をしなければならない。

    うーん。これは結局何を意味しているのだろうか。
    実は一般的なインターフェイスは、もっと簡単にできるのではないか。

    beg, end, xL, xR, fillL, fillR で指定する事ができるという事だろうか。
    つまり最終的に [0..beg] [fillL] [xL..xR] [fillR] [end..width]
    という形になる様な編集である。
    或いはもっと簡単にする事はできないだろうか。
    beg, end, xL, xR, shift でも大丈夫の気がする。
    それどころか beg, end, m, bool LR で行ける気がする。
    LR=0 の時 [0..beg][m..end][fill][end..width] になる。
    LR=1 の時 [0..beg][fill][beg..m][end..width] になる。
    或いは beg, end, shift で大丈夫の気がしてきた。
    ECH は [beg..end] 以上に shift が起こる場合と捉える事ができる。

    所で見た目は同じかもしれないが DCH ICH ECH で
    境界上の零幅文字の処理の仕方が異なるのではないかという気がする。
    これは引数で制御する様にすれば良いのだろうか。
    うーん。それが良い気がする。

  * 何やら振る舞いがおかしいと思ったら
    to_presentation_position が負の値を出している。
    convert_position の実装を眺める。何だかよく分からない。
    どうしてこのコードで to_presentation_position が計算できるのだろう…。

    q = 0 に初期化して、
    x を含む反転範囲があると、q = end - 1 - (q - beg)
    を実施する、という具合にしている。
    そして最後に p = x - q という様にしている。
    うーん。p = x - q についての漸化式に書き換えたら分かるだろうか。

      p = x - q = x - (end - 1 - (x-p -beg))
        = x - ((end-1)+p-(x-beg))
        = 2x - p -(end-1+beg)

    何だか分かりそうで分からない。
    結局反転によってどれだけずれるかを積算していると考えたら良いのだろうか。

      xold - beg == end-1 - xnew という事を思えば
      xnew = end-1 - (xold-beg) という式を得る。
      xnew+xold = end-1 - beg と言っても良い。

    結局分からないけれども最後の反転の条件がおかしいことだけは確かな気がする。
    従って最後の反転の条件を書き換えた。一応直った気がする。
    しかし、今度は CUF が変な気がする。to_presentation_position は、
    lr になる様に修正を行う物である。一方で CUF は rl の時は、
    方向が反転している物と思って移動を行っている。

  まだテストが通っていないが presentation position の定義に誤りがあったので
  改めて全体的に手を入れる必要が出てきた。従って、一旦ここで commit する事にする。

2019-04-11

* ansi: ICH ECH DCH で挿入される空白の属性 [#D0045]

  どうも ICH ECH DCH で新しく現れる空白領域には現在の属性が適用されるらしい。
  例えば DCH した時に行末に補填される空白にもちゃんと現在の背景色が適用される。
  これは RLogin 及び xterm, mintty で確認した。
  Poderosa でもそうなっているが多少バグがある。
  screen の場合には属性は解除される。
  大勢に倣って現在の属性を適用する様に変更する事にした。

  * done: また全角文字を踏み潰す場合には
    其処に適用する属性は元の文字の属性という事にする。
    - write_cells を確認する
      _mono_generic_replace_cells に関しては元から属性は全て設定されているのでOK。
      _prop_generic_replace_cells に関しても lfill, rfill でちゃんと属性を読んでいる。
    - _prop_reverse は特に踏み潰す様な操作はしていない。
    - copose_segments を確認する。これは其処にある文字の属性を使う様に修正した。

  * done: HT についても現在の属性を適用する?
    と思ったが、これはどの端末でも現在の属性は適用されていなかった。
    contra では寧ろ現在の属性を適用していたので、適用しない様に変更した。

  * done: ICH ECH DCH で挿入される空白について。
    これは外部から属性を指定する必要がある。
    伴って ech や ich や dch についても属性を指定する。
    面倒な事になっているが仕方がない…。
    また、dch に関しては右端をクリアしていたが、
    右端に属性を適用する為にちゃんと余白を fill する様に変更する必要があった。

    compose_segments を使わない時の実装についても同様に
    fill_attr を指定して dch に関しては余白を明示的に insert する必要があった。

  * done: EL と ED に関しても修正する。
    何と EJ や ED で埋められる領域についても現在の属性が適用される様である…。
    clear_content 等と言っている場合ではない…。

  * 実は IL (CSI L) や DL (CSI M) によって挿入される行についても?
    少なくとも RLogin は現在の属性を使っている。xterm, mintty もである。
    Poderosa と screen は違う。空の行を生成する様である。

    というか IND や RI についてはどうなのだろう…。
    やはり属性が適用されている。と思ったら実は LF ですらそうである。
    つまり、新しい行があれば必ず全体に色が適用されるという事である。
    それならその様に実装すれば良いのである。

    これで IND も RI も LF も IL や DL も全部属性が適用される様になったはず。

* DECSCA ... これは描画属性に含めてしまって良い気がする [#D0044]
  DECSC,DECRC で一緒に復元されるとの事なのでそういう実装なのだろう。

* ansi: DECSC, DECRC に対応する [#D0043]

  DECAWM DECOM の状態と属性とカーソル位置を保存する。

* ansi: DECSET, DECRST に対応したい [#D0042]
  SM, RM と同時に対応した。
  然し、結局認識していないモードが受信された時にメッセージを表示しておきたいので、、
  煩い認識できない〇〇のメッセージが表示されるのは変わらない。
  というか、覚えておいて二回目以降は表示されない様にするというのも手かもしれない。
  とも思ったが、そういうのは出力した後に処理するべきである。
  どの様なシーケンスがどのくらいの頻度で呼び出されているかが気になる事もあるかもしれない。

* ansi: ESC k や OSC(0) によるタイトル設定に対応した [#D0041]
  プロンプトからこれが出力されて画面に表示されるのがうるさいので。

2019-04-10

* ansi: VEM for DL IL →DL IL の対応と同時に対応した [#D0040]

* ansi: SLH for ICH DL IL → これは対応した。mode_home_il というモードを作った [#D0039]

* [完了] 2019-04-05 ansi: 新しい端末の定義として ansi_term というのを作る事にした。 [#D0038]

  取り敢えず動く物から作る事にする。

* [完了] 2019-04-05 行のデータ構造の変更の可能性 [#D0037]

  | Unicode 対応等を考えると現在の形式は色々微妙である。
  | 先ず結合文字などが入ってくると特別にメモリ領域を作らなければならない。
  | (但し、これは特別なオブジェクトを保持する時には
  | やはり特別にメモリ領域を作らなければならないので同じ事かもしれない。
  | 然し、そういったオブジェクトは数が限られている一方で、
  | 結合文字などは余りにも簡単に出力する事ができてしまう。)
  | Grapheme cluster も考えて実装するとなると、
  | もう少し柔軟なデータ構造の方が望ましいのではないかと思われる。
  |
  | 結局どのような事を考えているかというと、
  | 行は幅などを考えずに文字の列で表現し、
  | その中に bidi を制御する文字なども含めるという事にする。
  | 座標からデータ内部の位置への変換をスムーズにする為に、
  | B木で各節に合計を保持する?
  | 或いは、行内の文字数がそんなにないと思えば直列に文字を保持しても良い気がする。
  |
  | Proportional なフォントなどを使う場合も考慮に入れて文字の幅は自由にする。
  | 全角2半角1でも良いし、或いはもっと細かい単位でも良いという事にする。
  | 元々の端末の考え方だと全て1だが、今や全角文字のためにその取り扱いは崩れている。
  | 従って、最早2だろうが何だろうが全部真面目に処理するしかないのである。

  行は単にデータ位置とは独立に文字の列として保持する。

    Unicode の bidi や SRS, SDS 等の文字列や、属性化領域・フィールド
    等の情報を保持する為には任意のゼロ幅の文字も保持できなければならない。

  Q. データ位置は行内の文字の番号なのか、仮想的な座標なのか。

    | というかそもそもECMA-48におけるデータ位置とは何だったのかが分からなくなってきた。
    | データ位置には埋め込まれたマーカーはカウントされるのだろうか。
    | 今までカウントされないと考えていたが本当だろうか。
    |
    | 文字が受信された時の事を考えると、受信した文字は次の"マーカー"を上書きするのではなくて、
    | 次の"文字位置"を上書きするのである。という事を考えるとデータ位置というのは
    | bidi の並び替えを実行する前の座標と考えるのが自然である。

    A. データ部における仮想的な座標であるべき。

    何故ならば (1) 文字を受信した時その "座標位置" にある文字を上書きするのであって、
    行内のN番目の文字を置き換えるという訳ではない。(2) データ位置は全角文字の途中にも
    移動する事ができる。

  Q. grapheme cluster で保持するか文字で保持するか

    | そうすると再度文字の表現方法から再考が必要になるのではあるまいか。
    | 今、行を Unicode 文字列で表現する事にしたので、
    | 実は grapheme cluster をそのまま複数の文字として行内に埋め込む事ができる。
    | 或いは今までどおりに特殊文字として毎回登録して使うという様にもできる。
    | どちらの方が良いのだろうか。
    |
    | UAX#9 等を考えると、並び替えの時に面倒なので grapheme cluster の単位で保持したい気もする。
    | 一方でメモリの確保・開放などの効率を考えると grapheme cluster は展開して埋め込みたい気もする。
    | そうすると並び替えなどの操作が色々面倒になってしまう。
    |
    | うーん。考えて見るに通常の使用方法における速度を保証する為には、
    | 内部に grapheme cluster だとか marker だとか R 文字だとか変な物が含まれていない、
    | というフラグを用意しておいて、そのフラグが立っている時は高速な処理にして、
    | そのフラグが立っていない時には低速な処理に切り替えるという手がある。
    |
    | 高速な処理にしている時には wide_extension を有効にしておいて、
    | 低速な処理にしている時には wide_extension を無視するという具合にする?
    | 実は wide_extension は結合文字や grapheme cluster の二番目以降の文字を格納するのに使えるのでは。

    wide_extension 文字を復活させる。
    grapheme cluster は wide_extension と同様の取り扱いにする。
    更に grapheme cluster, marker, R/AL 文字の有無で処理を切り替える。
    これらがない時にはデータ位置と文字インデックスは一致する。

* [消滅] 2016-10-31 bidi: ICH, DCH, ECH に際してどの様に設置されている文字列を更新するかが問題になる。 [#D0036]

  % つまり、文字列の更新とはマーカの位置をどの様に更新するのか、
  % 或いは削除するのかという問題に帰着する。
  %
  % | 先ずは方向付き文字列しかない場合について考える (つまり TATE などの設置されていない場合)。
  % | ICH に関してマーカに隣接していない場合には単純にそれより後ろにあるマーカを移動すれば良い。
  % | また、DCH に関しても削除領域がマーカに隣接していない場合にはやはり後ろにあるマーカを移動すれば良い。
  % | しかしマーカに隣接している場合の取扱は微妙である。
  % |
  % | 先ず ICH に関しては比較的簡単に処理できそうな気がする。
  % | 挿入位置に丁度マーカが設定されている場合にはどの様に処理するべきか。
  % | 挿入位置のマーカは動かさなくて良い。
  % | では現在位置とその左側の位置に挿入を行おうとしている場合にはどうすれば良いか。
  % | (これは HEM で逆向きに設定されている場合のことを言っている)。
  % | どの様な場合にこの HEM を使うのかよくわからないが例えば SIMD と一緒に使うのだろうか。
  % | だとすると HEM が設定されている場合には現在位置に存在しているマーカも一緒に動かす必要がある。
  % | # しかしこの動作で丁度よい気がする。マーカが現在位置以前にあるものと現在位置より右にあるもの
  % | # の二つに分類されて、HEM に応じて片方のグループがまとめて動くという形になっている?
  % | # →ちょっとこの考え方は説得力に欠ける。
  % | 一方で、ICH において反対側で消去される部分のマーカをどうするのかという問題が残る。
  % |
  % | ECH, DCH, ICHシフトによって失われる領域のマーカの取り扱いに関しては、
  % | insert character 時の文字が置かれる場所の掃除を行う時の手法をそのまま使うのが自然に思われる。
  % | なので、insert character 時の処理がどの様になっているのかを改めて確認し、
  % | どれだけ再利用できるか、どれだけ書き直さなければならないかについて考える。
  % | 望ましいのは insert character で用いているコードを拡張して、
  % | 引数などのオプションに依って動作を切り替えて様々な消去の場合に対応できる様にする事である。
  % | (insert character の実装では任意の文字幅に対応できる様になっていた筈なので、
  % | 自然に拡張できれば嬉しいが…。)
  % |
  % | insert character 時の消去についてまとめる。
  % | 実装は board.cpp の board_line::update_markers_on_overwrite にある。
  % | 既に結構複雑な処理になっている様である。
  % | 先ず引数は curpos_t beg, end 文字の左端と右端を指定する。
  % | つまり、消去する領域の右端と左端と考えて良いだろう。
  % | そして beg <= p < end にあるマーカについてのループを考える。
  % | a bidi string の場合には
  % |   内部に存在するマーカは simd に従ってマーカを右端か左端に移動する。
  % |   その移動によって文字列が潰れる場合には始端・終端マーカを一緒に除去する。
  % |   更に、終端マーカの場合には直前に開始マーカまたはフィールド開始がある場合に除去する。
  % | b aligned string の場合には
  % |   基本的に削除を実行する。但し、simd に応じて左端または右端に存在するマーカは削除しない。
  % |   これは自然なデータの流れによって aligned string が開始して初めの文字が挿入される時に
  % |   直前に設置した aligned string マーカが削除されないという条件と同じであり、
  % |   それが自然な動作に丁度なっている。
  % |   更に、直後の aligned string marker が aligned string 終端の場合にはそれも一緒に削除する。
  % |
  % | 問題はこの動作は ECH や DCH ICH においても自然なのかどうかという事である。
  % | 実は余り自然ではないのではないかという予感がしている。
  % | 様々なケースを想定して考える必要があるだろう。
  % |
  % | 先ずは ECH について考える事にする。
  % | a bidi string 開始が ECH 消去領域の内部に存在する場合の動作は何か。
  % |   もし対応する終端がやはり ECH 内部にあるのだとしたら
  % |   その終端と一緒に削除するのが自然である。
  % |   また、もし対応する終端が ECH 外部にまで及んでいるのだとしたら、
  % |   その bidi string 開始は ECH 消去領域の終端に移動するべきである。
  % |   さて、その時 SIMD が逆になっている場合に ECH 消去領域の開始に移動するという事はありえるか?
  % |   →その動作は変な気がする。
  % |
  % |   ではそもそも何故文字挿入時にはその様な動作になっていたのだろうか。
  % |   例えば全角文字を挿入する時には [直前][現在] という様になっている升目を上書きする。
  % |   内部に存在している bidi string 開始マーカは左端に移動するのが自然と思われるというのも、
  % |   文字を挿入する前のカーソルの位置は確かに現在位置より前にあるのだからその時点で文字を挿入すれば、
  % |   その文字に押し出されて左端に移動するというのは自然だからである。一方で SIMD が設定されていない時には、
  % |   [現在][直後] というセルの並びになっているのだから、文字の挿入に依って現在位置から後方に向かって
  % |   マーカが押し出されるのだという風に解釈する事ができる。
  % |
  % |   さて、ECH を実行する際にも似たような解釈をする事は可能だろうか。
  % |   ECH で後方に向かって削除をする時には単純にマーカを終端に設置すれば良い。
  % |   では、現在位置から前方に向かって削除をする時にマーカを前方に移動するのは自然だろうか。
  % |   - 例えば、それが直後にそこに SIMD を用いて文字を書き込んでいくという事を想定しているとする。
  % |     うーん。もし現在位置が文字列の内部に存在していて現在位置の文脈を以て領域を拡大しようと
  % |     考えるのだとしたら ECH によって左側にマーカがずれるというのは自然である。
  % |     しかし ECH で消去をしようとしているのに bidi string の領域が増えるというのも変である。
  % |     また、ECH というのはやはり文字を挿入するという訳ではないのだから bidi string は長くならなくて良い気がする。
  % |     →やはり ECH で現在の階層の領域が拡大されるというのは無理がある様な気がする。
  % |   - そもそも update_markers_on_overwite では "文字を挿入した後" のマーカの位置を想定して設計された物である。
  % |     従って、削除した瞬間のマーカの配置を表す物ではない。つまり、"削除してから挿入する" という様な形にはなっていないのである。
  % |     つまり、マーカの移動は文字の挿入に固有のものであって、領域の確保によって起こる物ではない。
  % |     その様に考えるのだとしたら、別に ECH によってマーカを移動させたりしなくても良いような気もする。
  % |     しかしやはり ECH というからには其処に設置されている諸々のマーカが除去されてほしくもある。
  % |     →うーん。やはり ECH された領域の中ではマーカは存在してほしくない。
  % |   - しかし完全に階層構造を消去領域の中で解いて除去してしまうというのも変である。
  % |     というのも ICH や DCH を用いる場合には、現在のカーソルの位置に於ける階層構造の上で削除や挿入を行うのが自然であり、
  % |     それと整合性を取る為には ECH も同じように現在位置における階層で消去を行いたいからである。
  % |   - そうすると消去領域の内部に一部でも含んでいる階層については、消去領域の端まで移動を行い、
  % |     消去領域を完全に含む階層に関しては何も変更しないというふうにするのが現実的である。
  % |     しかし、その様な動作を実際に行った時にそれは自然な動作になるのかというのも考えておく必要がある。
  % |     例えば abc[defg]hijk という風になっていて現在位置が f にあるとする。
  % |     前方に向かって 1-3 文字消去する時には abc[   g]hijk という様になる。
  % |     更に前方に向かって 4 文字消去すると ab    [g]hijk という形になる。
  % |     また、初めに 3 文字消してそれから 4 文字目を消去すると ab [  g]hijk という形になる。
  % |     この様な不連続性は実際に行った時に気にならないだろうか。
  % |
  % |   | というかそもそも DCSM が表示部になっている時には一体どのように処理したら良いのか謎である。
  % |   | 一つ一番簡単な実装方法は一文字ずつ消去した時とまとめて消去した時の結果が同じになる様に設計して、
  % |   | それから消去対象の位置について一つずつ消去を実施していくという物である。
  % |   | 一文字ずつ消去しても動作が変わらない様にするというと、消去位置で完全に階層構造を解除するという物が考えられる。
  % |   | - その様な実装だと ICH をどの様に処理するのかが疑問として残る。ICH でも完全に階層構造を解除するのか、
  % |   |   或いは ICH に関してはその時の階層構造を尊重して挿入を行うのか。
  % |   |   特に DCSM で表示部になっている場合にはどの様に考えるのが良いのだろう。
  % |   |   特に ICH に伴うシフトをどの様に行うのかというのも問題である。
  % |   |   もし完全に階層構造を解除するのだとしたら、(1) 先ずは見た目に従って文字列を完全に分割する
  % |   |   (2) その後でシフトを実行するという様にできる。注意するべきは (1) でも字の並び替えが必要になるという事である。
  % |   |   ただ (1) さえ実装してしまえば後は簡単である。
  % |   |
  % |   |   また DCH について考えてみると…もし階層構造を完全に解除してからシフトなどを行うという事にしていると、
  % |   |   ある階層構造の中の或る文字を削除した時に、その文字があった箇所の前後で bidi string が分かたれてしまい、
  % |   |   見えない "切れ目" ができてしまう事になる。
  % |   |   その後の文字の書き込みなどで正しく bidi が処理されなくなるという問題が生じる。
  % |   |   そもそも DCH 等の非自明な操作を行ったときでも bidi が保たれる様に要求するべきかという話もあるが、
  % |   |   できるならば自然でありなおかつ予想可能な振る舞いをするのが良いように思う。
  % |   |
  % |   | - うーん。思うに DCSM で表示部だったとしても文字列の範囲をどの様に縮めるか、
  % |   |   もしくは拡大するか、文字列を削除するかといった様な論理はデータ部の時と同じである。
  % |   |   違うのはデータの表現方法との間に複雑な変換が必要になってしまうという事のみである。
  % |   |   従って、余りデータの変換方法などについては考えない様にして、
  % |   |   先に見た目での文字列の処理方法を与えるほうがよい。
  % |   |   編集が実際にデータ部にたいしてどの様になされるかの変換については後で考える事にすれば良い。
  % |   |
  % |   | さて DCSM に対して作用する事も考え合わせれば update_markers_on_overwrite は恐らく使えそうにない。
  % |   | この既存関数とは別に新しく考えるのが良いような気がする。
  % |
  % |   [結論]
  % |
  % |   - DCSM(PRESENTATION) に関しては先に見た目での文字列の消去・短縮を決定してから、
  % |     それを実現する様にデータ部に対して加工を行うという様に考える。
  % |     恐らく複雑な文字のシフトを伴う変換が起こるがそれについては後で考える。
  % |   - update_markers_on_overwrite については忘れる。
  % |
  % | うーん。やはり ECH においては其処にある bidi string は全て除去するのが自然な気がする。
  % | 一方で DCH は現在の階層において削除を実行する。
  % | ICH は現在の階層において挿入を実行する。端から出ていった物に関しては ECH と同様に消去を行う。
  % | それを元にして再度ルールを決め直すのが良い気がする。
  % |
  % | 次に問題になるのは aligned string のマーカの移動に関してである。
  % | ECH に於いては消去範囲の中に aligned string マーカが存在する場合に削除を行う。
  % | 隣接している場合には削除は行わなくて良い。
  % | 問題は DCH や ICH を行う際に移動範囲に ECH が含まれていたとしてそれを一緒に移動するかどうかである。
  % | 一緒に移動しないと文字だけがずれるので変な事になる。
  % | 一方で一緒に移動すると全て解除するというのも変な気がする。
  % | 或いは、aligned string の内部にある文字列は移動しないという風にする可能性もあるかもしれないと思ったが、
  % | やはりそれは ICH してから何かを上書きするという様な使い方などを考えるに、文字列を動かさないのは駄目である。
  % | 結局、一緒に移動せざるを得ないという風に考えるのが良いだろう。
  % | では、中に設置してある tab stop についてはどうするか。一緒に動かすかそのままかという選択肢がある。
  % | MULTI の場合には DCH でずれる様になっていると全体で共通のタブという状態が崩れてしまう。
  % | その事を考えればずれないという実装にするのが自然である様に思う。
  % | つまり、後になってまた HT 等で移動を行った時は DCH をする前の位置にまた上書きをするという形になる。
  %
  % [結論]
  %
  % - ECH は階層構造も全て消去する。内部の aligned string marker は削除する。
  % - ICH, DCH は現在の階層構造において実行する。DCH において内部の aligned string marker は削除する。
  %   ICH においてシフトで押し出される内容はその階層で削除する。つまり、DCH で削除する。
  %   (実は ICH と DCH は全く同じ実装で行けるのではないかという気がする。)
  % - 何れにしても隣接する aligned string marker はそのままである。
  % - SIMD の影響は受けない。代わりに HEM の影響を受けても良い。
  % - DCSM(PRESENTATION) の場合には表示部における消去・挿入・削除をデータ部にどの様に反映させるかについて考える必要がある。
  %   単純に表示部の範囲をデータ部の範囲に写像して消去を行うと駄目である。階層構造がばらばらになってしまう。
  %   上の階層にある文字列から順に適用していって分割統治で行くような感じに実装したい。これは後で考える。
  %
  % ----------
  %
  % 次に考えなくてはならないのは DCSM(PRESENTATION) の時にどの様に表示部での編集をデータ部での編集に変換するかである。
  % それを考える為には先ずどの様に問題を分割して、そして個々の場合についてどの様に場合分けをするかが重要になる。
  %
  % 取り敢えずは aligned string については考えない事にする…というか、aligned string に関しては
  % データ部と表示部での差異については考えないという実装だったはずだ。
  % つまり、aligned string に関しては特別の変換は必要ないという事になる。
  % また方向付き文字列の内部に aligned string が含まれているという事も設計上無いはずだから、
  % 結局 aligned string の削除についてはデータ部と表示部での差はないという事になる。
  %
  % 問題は方向付き文字列が存在する時の処理についてである。先ず初めに ECH について考える。
  % ECH の領域と方向付き文字列がどの様な関係になるのかというのには幾つかのパターンが考えられる。
  % 1 先ずは ECH の領域が方向付き文字列に完全に含まれている場合である。
  %   今 ECH の領域が eb <= x < ee として方向付き文字列が sb <= x < se であるとする。
  %   sb <= eb && ee <= se の時 ECH 領域が方向付き文字列に含まれていると判断する。
  %   この場合には方向付き文字列内部の座標で ECH を実行する様にすれば良い。
  % 2 次の場合は ECH の領域が方向付き文字列を完全に含んでいる場合である。
  %   これは eb <= sb && se <= ee という条件で表される。
  %   この場合には単純に方向付き文字列諸共削除してしまえば良いだけの話である。
  %   1 かつ 2 の場合には 2 の取り扱いで良いだろう。
  % 3 次のパターンは eb < sb && ee < se という様な場合である。
  %   この場合には消去領域は二つに分割される。
  %   先ずは eb <= x < sb に当たる部分に関しては現在の階層で消去を行う。
  %   そして sb <= x < ee に当たる部分に関しては更にその方向付き文字列の内部で消去を行う。
  % 4 逆に sb < eb && se < ee という場合もあるが、これは 3 と同様に処理すれば良い。
  % 結局以上のことを文字列の入れ子階層に従って実行すれば良いという事である。
  % ここで注意しなければならないのは 3, 4 において ECH は階層構造を消去するという事である。
  %
  % ----------
  %
  % | この時方向付き文字列の中身をシフトしなければならない。
  % | どのタイミングでシフトを行うか・どの様にしてシフトを行うかについてはまた考える必要がある。
  % | というか 1 の場合にも分かたれた２つの部分それぞれについてシフトを実行しなければならない気がする。
  % | 更にどんどん文字列が入れ子になっている場合には単純なシフトでは済まないだろう。
  % | 一体どの様に処理すれば良いだろうか…。一つの方法は一旦表示部に内容を転写して、
  % | 消去を行った後で再びデータ部に転写する方法である。この方法は簡単で安全であるが、余りスマートでない様にも思う。
  % | もしもっと簡単に位置関係・シフトなどを表す表式があればそれを採用したい。それについて考える。
  % |
  % | 一回数式にしてみようとも考えたが複雑になりそうである。
  % | 数式を見ても簡単な形に単純化することができるとは思われない。
  % | 一旦簡単な場合で考えてそれから入れ子がある場合を考えていくという様にしたい。
  % | 入れ子のない一番単純な場合で反転領域の内部を消去する場合は、
  % | 右の端に残ったデータと左の端に残ったデータを交換しなくてはならない。
  % | つまりシフトもしくは swap の様な物が必要になる。
  % |
  % | とここで思ったのだが入れ子が複雑になっている場合はシフトもしくは swap の組み合わせで対処できるようには思われない。
  % | というのも、原理上入れ子を組み合わせる事によって任意の置換を表現する事ができるはずで、
  % | 表示部での単純なシフトでさえデータ部では複雑な置換になりうるからである。
  % | 置換は循環の組み合わせで書くことが出来るが独立な swap で組み合わせて書くことはできない。
  % | つまり、何れにしても原理上は swap やシフトを複数回実行しなければならない訳である。
  % | なので、シフトを複数回ではなくて一回で実行するという事に拘る事はできないし、しなくても良い。
  % | 結局、シフトの組み合わせで実装するという事を受け入れて良い気がする。
  % |
  % | 入れ子の構造がある場合の問題は、交換する領域 (右端のデータと左端のデータ) の境界が
  % | 更に内側の文字列の内部にあるという場合である。しかし、これに関しては
  % | 内側にある文字列から順番に交換・消去を実行していけば良い。
  % | 先に内側から交換すれば、外側の文字列で交換を実行する時には
  % | 丁度内側の文字列の境界が交換領域の境界に一致する様になっている。
  %
  % [まとめ]
  %
  % DCSM(PRESENTATION) の時は ECH は見た目が変わらないようにデータ部で文字の並び替えを実行しなければならない。
  % 特に反転文字列内部で消去部分の右側にある部分と左側にある部分の内容を交換する必要がある。
  % 表示部・データ部の変換および文字の並び替えに関しては、内容交換を階層ごとに実行する事によって行う。
  % 入れ子階層の一番深いものから順に消去・分割・内容交換を実行していけば良い。
  %
  % ----------
  %
  % 次に考慮しなければならないのは文字列を切断した時にどのようにマーカを更新するのかという事である。
  % 交換に際してマーカも一緒に交換しなければならない。そのまま愚直にその様にするのが良さそうである。
  % "交換を全て実行した後の位置" というのを計算するのは面倒そうである。
  % (或いはオフセットを計算できるだろうか?)
  %
  % - うーん。というか文字列を分割する時の表現はどの様にするのが良いか。
  %   マーカにするべきかそれとも文字列の配列にするべきか。
  %   マーカで交換をそのまま実施するのは困難を極める。というのも、
  %   マーカが必ず開始と終端のペアになっているとは限らないからだ。
  %   という訳でマーカで移動を行うとしても正規化などの操作が必要になるだろう。
  %   更に正規化したとしても一つの文字列が "開始" と "終端" という複数の (離れた) 要素からなるため、
  %   移動・交換などの処理が面倒である。但し、"文字列" の配列であったとしても
  %   入れ子になっている子孫も一緒に移動しなければならない事を考えると大した違いはないかもしれない。
  %   何れにしても正規化という手順を踏む必要性がある事を考えれば、
  %   マーカでの処理は諦めて普通に "文字列" で並び替えを実行して、
  %   その後でそれをマーカに逆変換する方が自然である。
  %
  % ----------
  %
  % 2018-02-19 暫く時間を置いたので現状でどこまで実装したのかが何だか良くわからない状態になっている。
  %
  % ToDo: 後シフトの際に中途半端に全角文字の半分だけシフトするという事がない様にする。
  %   消去される領域が中途半端に被っている場合にはその全角文字全体を削除する必要がある。
  %   また、そもそもマーカが全角文字の中途半端な位置に挿入されない様に設計しておく事も必要である。
  %   (ただ、それでも何かの拍子にマーカが全角文字の途中に置かれる事も考えられなくはないので、
  %   その様な中途半端な事が起こっても大丈夫な様に設計したい。)
  %
  % ToDo: ICH, DCH についても場合分けを考える必要がある。
  %
  % 2019-04-04 ECH について時間を費やし過ぎである。
  % うーん。紙に書くなどして簡単に実装することはできないのか。
  % そもそもどの様に方向付き文字列を表現していたかを確認する必要がある。
  %
  % board_line に std::vector<line_marker> m_markers; というメンバがある。
  % line_marker は curpos_t position と nested_string_type stype というメンバを持つ。
  % nested_string_type には方向付き文字列、反転文字列、
  % 横位置合わせ文字列 (string_aligned) の三種類がある。
  % というか string_aligned とは何だったか…。
  % 確認すると TATE TALE TAC TCC 等である。
  % これらは次の string_aligned が現れると其処で範囲が終わると見なされる。
  %
  % * update_markers_on_overwrite の実装を見ると、
  %   1. aligned string は次の aligned marker が現れる迄の範囲を表す。
  %   2. aligned string の終わりは方向付き・逆転文字列の終わりを表す。
  %     これは workaround というよりも実際にそういう表現を正当な物として許す。
  %
  %   というより update_markers_on_overwrite の実装が変な気がする。
  %   これに対応するテストという物は存在するのだろうか…。
  %   うーん。明らかにテストは実装されていない。
  %   勝手に実装し直す事にする。
  %
  % うーん。そもそも現在の表現方法自体がおかしい気がするが…。
  % まあ、これで実装を続けるとするとどうなるだろうか…。
  % とも思ったが、やはり微妙である。
  % ICH だとか DCH だとか色々実装しなければならない物は沢山ある。
  % その時にも毎回この様に複雑な事を考える必要があるのだろうか。
  % もっとすっきりした表現で簡単に実装する事はできないのだろうか。
  %
  % 例えば ECH を実装する際には、文字列の開始位置・終了位置を
  % 削除範囲の両端に寄せれば良いのでは。
  % その上で空の文字列を削除する様にする。
  % TATE 等で設置した aligned 文字列は単に削除する事にする。
  % と思ったが、途中で方向付き文字列の内部で消去が起こった時は微妙。
  % 方向付き文字列の内部のままという事にしておくと、
  % 後から其処に何かを記入した時に意図しない表示になってしまう。
  % 従って、現在の実装では方向付き文字列を分断して、
  % 其処には文字列が現れない様にするという様に実装している。
  % うーん。結局昔の考察の通りに ECH は階層構造も全て削除するという仕様にする。
  %
  % DCSM(PRESENTATION)の時の動作については。
  % というか DCSM(PRESENTATION) はどの様に実装しているのだったか。
  % 恐らくカーソル位置はデータ部での位置になっている。
  % それを表示部での位置に変換して更に其処から右にN文字進んだ場所までを削除領域とする。
  % それをデータ部での消去に変換する必要がある。
  %
  % 最終的な結果は完全に階層構造を取り除いた状態というのは DCSM(DATA) の時と同じ。
  % うーん。競技プログラミング勢だとあっという間に実装してしまうのだろうか…。
  % 取り敢えず、データ構造は考えない事にして、構造とアルゴリズムについて考える事にする。
  %
  % (1) 表示部における範囲を決定する。
  % (2) トップレベルの反転文字列から再帰的に処理を行う。
  %
  % うーん。どうも滅茶苦茶構造が汚い。全く駄目だ。実装し直したい。
  % そもそも marker で文字列を表現しようとしたのは何故だったか。
  % 1. 実際の文字の配列と別個に管理したかった。
  % 2. 受信するのは開始マーカと終了マーカである。
  % という事だった。従って、marker で管理するのが自然であるとの考えであった。
  % 然し、marker による表現は実際の構造を反映しているとは言い難いので、
  % 具体的な操作を実装しようとすると対応するマーカを探し出すという事を
  % 毎回実行しなければならない。従って、色々と面倒な事になってしまう。
  %
  % 実は文字列に関しては真面目に木構造で保持した方が良いのではないだろうか。
  % うーん。

  これはデータ形式を変更して実装し直した。

* ansi: SPD の実装 [#D0035]

  見た目を変えずに charpath が反転する為には
  データ部での反転を実行しなければならない。
  然し、strings などがあると複雑になってしまう。
  どの様に処理するのが正しいのか。

  因みに strings は終端していない場合は強制的に終端しても良い物だろうか。
  例えば反転文字列を書き込んでいる途中で SPD による反転が実施されたとする。
  この時反転文字列の続きを記入できる様にするべきだろうか。
  考えてみるにそうではない気がする。やはり反転が起こったらその時点で固定化する。
  つまり、strings は終端を明示的に挿入する様にするという事なのである。

  さて、どの様に実装したら良いだろうか。
  update_strings は実行する必要がある気がする。

  a 例えば以下の様に実装する。
    先ず update_strings で得られた結果を反転する。
    然し単純に逆転させれば良い訳ではない。
    開始点について昇順に元々並んでいるが、
    これは終端点について昇順であるとは限らない。
    そして、それに基づいてマーカーを挿入しながら
    文字を順番に登録していく。
    中に含まれていた文字列のマーカーは全て無視する。

    と思ったが色々問題がある。
    零幅文字と文字列開始・終端の順序が保たれない。
    それに update_strings を end について
    ソートし直さなければならないのは面倒。

  b 例えば、始めに文字列終端を設置していく。
    完全に設置して対応が取れている状態になって、
    その時に始めて反転を実施し始める。
    反転する時には予め update_strings で得られた
    情報を元に開始マーカーと終了マーカーを入れ替える。

    或いは update_strings のルーチンを改造して、
    その時にもう開始マーカーと終了マーカを入れ替えるべきだろうか。

  取り敢えず b で実装できた気がする。

* ansi: カーソル移動について。 [#D0034]
  これは色々調整が必要かと思っていたが
  実は表面的に書き換えたら簡単に動く様になってしまった。

* ansi: SGR 等。 [#D0033]

  取り敢えず鬼門だった ICH, DCH, ECH の類を実装できたので、
  SGR 等の機能について移植していく事にする。

  うーん。これらの属性は拡張フラグを使って実装されている。
  面倒なので attribute_t に沢山関数を生やして実装する事にする。
  後で拡張したくなっても大丈夫な様にする為に。

* ansi: ICH, DCH も同様に実装するべき? [#D0032]

  どの様に実装するべきだろうか。
  ICH に関しては現在の位置に文字を挿入する。

  SIMD の影響は受けない様である。HEM の影響を受ける。
  DCSM の影響も受ける。

* ansi: ECH 取り敢えず実装した。まあこんな物だろうか…。 [#D0031]

2019-04-08

* ansi: ECH (DCSM(PRESENTATION)) [#D0030]

  さて、問題の ECH である。これの実装をどの様に考えるか。
  思うに Unicode Bidi を考え始めると訳が分からなくなるし、
  もっと言うと Unicode Bidi を考慮に入れて端末にシーケンスを
  送ってくる様なアプリケーションが存在するとは思われない。
  強いて言えばユーザが画面を見た目で操作する為にその様な物を送るぐらいか。

  さて、今となっては NUL が segment separator の役割をしているので、
  DCSM(DATA) の時には単に ECH は NUL を書き込むだけで良い。
  NUL を書き込んだ場所より後の反転の効果は解除されるが、
  まあ、データ部は marker も含めた文字列の集合なのだと思えば、
  その様な振る舞いは自然なのである。

  DCSM(PRESENTATION) の時にはどの様に取り扱うのが良いのだろうか…。
  表示部に於ける各点に対応するマス目を消していけば良いのだろうか。
  然し、そうすると変な事になる気がする。更に境界上に乗っている
  marker をどの様に取り扱うのかが謎である。
  というか PRESENTATION というからには、やはり見た目を保持したい気もする。
  Unicode bidi を対応しないという決断をした今、実はその様な実装は可能の気がする。

  文字列 m_strings_cache の情報は使う前提である。
  結局、前半部分までの文字列と、後半部分までの文字列を生成して、
  それを接続するという事にすれば良いのではないだろうか…。

  前半部分までの文字列は内容を変更しない様に構築しようとするとどうなるか?

  * ゼロ幅の文字の取り扱い

    | 取り敢えずゼロ幅の文字をどの様に取り扱うのか決めておく必要がある?
    | ゼロ幅の文字も一緒に反転して表示する前提にした方が良いだろうか。
    |
    | 例えばデータ部で ...[A|B|C|D]... となっていて
    | 表示部で ...[D|C|B|A]... となっている時に、B 以降を削除するとする。
    | 得られる結果は表示部で ...[D|C|] という事で良いのだろうか。
    | というか ECH はできるだけゼロ幅を残す様に実装すると考えれば、
    | 実はあんまり考えなくてもゼロ幅文字をいつも残す様にしておけば良い気がする。

    →ゼロ幅の文字はできるだけ拾う様にする。

  うーん。取り敢えず…。前半部分の範囲を取得するコードを書く事にする。

  | 早速何がどうなっているのか分からなくなった…。
  | 結局何をしたいのだったか。
  | 持っているデータは何かというとデータ部で見た時の入れ子の構造である。
  |
  | 外から中に見て行った時に、反転を起こす。
  | 更に範囲で見ているので範囲が分断されたり色々する。
  | 分断された範囲をそれぞれどの様に取り扱うのか。
  |
  | 例えば [] で切り取り範囲を () で反転範囲を示すと、
  | 以下の様な場合には [>>>(<<<)>>>] 三分割される。
  |
  | 或いは [>>>(<<<]<<<) という様な場合には、
  | () に要求するのは後半の3文字である。
  | うーん。実は要求はデータ位置で行っておけば良いのではないか?
  | 何だかよく分からなくなってきた。データ位置というか、
  | その反転範囲に取ってのデータ位置というべきである?

  a うーん。ちゃんと木を作ってから処理すればできる気がするが、
    今のデータ構造の儘で単純に深さ優先で並列に処理する事は可能なのだろうか。
    そのノードの中に入る時に座標を変換して、そして出る時にまた変換を戻す。
    そんな風にして処理していけるのだろうか…。
    行ける筈だが何だか面倒な感じしかしない。
    先ず、ノードに入る・出るというのを検出しなければならない。

  b うーん。特にノードを出たというのを判定するのが難しいのではないか。
    と思ったが、それは parent を記録しておいて、それが減ったら抜けたと思えば良いのか?

    前回処理した i と現在の parent を比べる。現在のノードが前回処理したノードの
    子供ならば i - 1 == range.parent になる。現在のノードが前回の兄弟ならば、
    strings[i - 1].parent == range.parent になる。前回のノードが抜けたのであれば、
    strings[i - 1].parent > range.parent になる。
    そんな感じに先ずは抜けたとか入ったとかを検出できる様にしたい。

  取り敢えず b によって入ったり抜けたりするのは試験的に実装した。

  | この段階でどの様に実装したら良いのだろうか。
  | 少しずつ考える事にする。今見ているのは常にデータ部での範囲である。
  | 基本的には文字を削除するのと等価なのでデータ部での順序は保たれる。
  | 問題は切り取る範囲をどの様に動的に管理するのかという事である。
  | 実は簡単な気がしてきた…。
  |
  | と思ったがそうでもない。途中で範囲が二つに別れたりする…。
  |
  |   表示部   ----[--**]**--
  |   データ部 ----[**--]**--
  |
  | うーん。push する度に結局何処か別の場所に範囲を記録しなければならないのだろうか。
  | 更に入れ子が増えていくとどんどん分裂していく事になる。これに対処するのは難しい。
  | 結局スタックか何かを用意して処理していくしかないのだという気がする。
  | そして、現在の範囲は現在のノードの中でのみ有効と考える。
  | →残っている断片をスタックに記録して処理する事にした。実装できた。
  |   動作テストもしてみた。ちゃんと動いている。

  スタックに分断した断片を記録する事にして、範囲取得は実装してテストした。

  * ネスト状態の復元について

    うーん。然し、本当にこんな実装で良いのだろうか…?
    というか文字列の始まりと終わりについて記録しなくて良かったのだろうか?
    またネスト状態の追跡をしたいという要望もあるのである。
    もしネスト状態の追跡をしたとして、範囲で拾った物の前にネスト状態の復元を置いたとする。
    しかし、範囲で拾った物に既にネスト状態の更新が含まれていたらどうするのか?
    うーん。含まれていたり含まれていなかったりの気がする。
    という事を考えてみると実はネスト状態の復元に必要な点もリストに含めておく必要がある?

    本当だろうか。境界上の marker は全て拾う様になっているので、
    境界に至る直前のネスト状態を復元すれば良いという事になるのではないか。
    然し…境界上の marker を全て拾うというのはそれはそれで厄介である。
    重複して前後して拾ったりはしないのか? と思ったがデータ部の上でちゃんと
    順番に列挙する様になっているので境界が重複しているという事はない筈である。

  うーん。と思ったけれどやはり微妙な気がしてきた。
  必ずしも先頭ではないのである。少し動かしてみる。
  必要なのは丁度先頭に来た部分に対して状態を復元する事である。

  因みに削除直前の部分に関しては特に処理は必要ない。
  というのも NUL を置いた時点で其処で文字列が強制的に終了するからである。

  * 因みに NUL にした所に文字を書き込んで行くと、
    文字列が延長されて混ざり合ってしまう。
    この様な振る舞いをよしとするかどうかは微妙である。

    a まあ、再び同じ内容を書き込んだら復元できるという様に考えたらこれでも良い気がする。

      x と思ったが、表示部でそうなる様に文字を書き込むというのは困難がある。
        実際に書き込みが行われるのはデータ部であって、
        データ部に於けるデータの並び方に関しては既に並び替えられてしまっているので、
        再び復元する事は不可能である。

    b 或いは、何らかの文章を途中に書き込むのが目的と思えば、
      勝手に混ざり合ってしまうのは都合が悪いという考え方もある。

    その様に考えると実は、ちゃんと終端して置いた方が良い気がする。
    →終端する様に実装した。

  * テストが不十分な気がする。
    もっとちゃんとテストするにはどうしたら良いか。
    テストコードを書いた。幾らか試した。動いている気がする。

  * find_innermost_string についてもテストして置きたい。
    →テストを書いた。ちゃんと動いている。完璧な気がする。OK

* ansi: to_data_position [#D0029]

  これの実装はどうしたら良いのか…。

  [>>>>[<<<<x<<<<]>>>>]

  持っているのは presentation_position なので、
  反転範囲が終わるまで見ないと分からない気がする…。
  うーん。一旦、完全な string のリストを作ってしまう事にするか…。
  そして外側から順に中に入っていくという作戦。
  これが元々の contra の実装である。

  もっと簡単にする事は果たして可能なのだろうか。
  うーん。一旦、対応する終端までジャンプすれば可能なのだろうか。
  とも思ったが、其処から更に後退していく等の処理を考えると、
  やはり一旦完全な string のリストを作ってしまう方が楽の気がする。
  これは既存の実装を参考にするのである。

  実装した。動いている。

* ansi: to_presentation_position [#D0028]

  nested_state を追跡する事で計算できるだろうか。
  要するに目的のデータ点 x を含む nest について
  深さを以下の様に書いた時 (x を含まない nest は書かない)、

  [>>>>[<<<<x<<<<]>>>>]

  x より前にある >>> と x より後にある <<<< の数を集計すれば良い。
  また、都合上 x と同じ位置にあるマーカーは x の直前にあると見做す。
  先ずは x が現れるまでループを回す事を考える。
  その間に nest を開いたり閉じたりする事になる。
  x に出会った時にどの状態になっているかを調べる。

  nest を記録する時に何を記録するべきだろうか。
  始まりの位置? それから方向?
  stack の中にある逆方向の文字列の数も調べておくべき。
  途中で中断できる様にしたいので。

  contra::ansi における文字列の入れ子の解釈

  1. SDS(1) SDS(2) SRS(1) によって文字列を開始する
  2. SDS(0) によって対応する SDS に当たるまで全部閉じる。
    SRS(0) によって対応する SRS に当たるまで全部閉じる。
    対応する物がない場合には無視する。
    例えば SDS(1) aa SRS(1) bb SDS(0) cc SRS(0) は [aa[bb]]cc と解釈される。
  3. NUL に当たった時は全部閉じる。
    (但し、NUL は HT 等によってフィールドを移動した時に設置される。)

  取り敢えず実装した。幾つかテストケースを試してみて動いているからよしとする。

* ansi (line_t::proportional_glb): [#D0027]
  もっとまともなデータの保持の仕方はないだろうか…。

  a 例えば std::multiset で良いのではないか
    % …と一瞬思ったが、ICH や DCH をする度に位置を全て書き換えなければならず非効率的である。
    % と思ったが、実は ICH/DCH の頻度は低いし全て位置を書き換える方法の方が効率的なのでは。。

    x 然し、その場合には monospace の時とデータ構造を切り替える必要がある。
      o 何れにしても工夫をするのであればデータ構造を切り替える必要があるのは確実である。

  b 或いは最後に触った位置を記録しておけば良いのかもしれない。
    どうせ前から後ろに向かって書き込んでいく場合が殆どなのだから、
    実は最後に触った位置を記録しておけば問題は起こらない。

  →取り敢えず b の様にして最後の位置を記録する様にした。
    SIMD で逆方向に進んでいる時は毎回全て計算する事になるが、
    まあ気にしない事にする。

* ansi: wcwidth に相当する物を自分で実装する [#D0026]
  これは ble.sh にテーブルがあった筈なのでこれを流用する。
  →これは enc.c2w に実装した。contra::encoding::c2w である。
  取り敢えず現在の端末の c2w_width_emacs でテストを続ける事にする。

  monospace 側も non-monospace 側も正しく動作している様に見える。

2019-04-05

* [棄却] bidi: 文字列の構造はマーカではなくてちゃんとした構造に変更する [#D0025]
  そもそも文字列はそんなに頻繁には使われないので複雑な構造でも大丈夫の筈。
  但し、文字の記入などのあらゆる操作に対して文字列がある場合には色々と考察が必要になる。

  取り敢えず試験実装として現在の実装と並列にする事にする。
  試験実装の構造には prefix として xxx をつける事にする。
  リスト構造にしようか、或いは vector にしようか。
  そんなに要素が増えないと思えばリスト構造である。
  メモリを節約しようと思うとリスト構造になるだろうか。
  然し、最悪の使用方法の場合を考えると vector の方が効率も良い。
  実装は断然 vector の方が楽である。

  うーん。属性化領域だとか色々考え出すと余りにも複雑である。


2016-10-19

* [2016-10-14] "文字列" データ構造再考 [#D0024]

  | -- 方向付き文字列の表現について --
  |
  | タブなどの仕様について調べた結果、"文字列" の記録方法に変更を加えた方が良いような気がする。
  | タブの仕組みの内に TATE, TALE, TAC, TCC という物があって、これは
  | ある HT と次の HT または CR, NEL の間を一つの単位として
  | 表示する時の配置を指定する物である。
  |
  | SRS, SDS の文字列の内部で HT や VT を行った時の動作が未定義になっているのはそういう事だろう。
  | また、他にも文字列のある場所にカーソルを移動して其処に文字を挿入すると、
  | 文字列の内部に文字が挿入される形になるという仕様についても合理的な実現方法を考えなければならない。
  | 思うに、SRS, SDS は "data stream の中に文字列の開始を意味するマークを挿入する" という意味なのだから、
  | その通りにデータ部の中身を一つの stream と思って其処にマークを挿入するという風に処理するという手があるのではないか。
  | しかし、それをそのままやるとデータ形式を全く変えなければならないし、また、データの位置と表示位置との対応が崩れるので、
  | 様々の処理の効率も悪くなる。そもそも文字列だとか特殊な配置を持つタブだとかを使う機会は殆どないのだから、
  | その様な機能のために overhead を追加したくない。そう考えれば、文字列のマークなどのデータは別に管理したい。
  | 結局、現在は文字列のデータとして開始点と終了点のペアを管理しているが、
  | それを直接更新する事によって状態の変化を追跡するのではなくて、
  | 単にマーカの位置と種類を保持する様なデータ構造を追加するというので良いような気がする。
  | もし座標の対応関係などを取得したくなったら、それらのマーカの情報を用いて計算を行うか、
  | 或いはその都度開始点と終了点のペアのリストの構造を構築してそれを元にして計算を行う様にすれば良い。
  |
  | -- タブ揃えなどの配置の実現方法 --
  |
  | もう一つ考えて置かなければならないのは変なタブ配置が設定されている時の表示の方法である。
  | a 一つの手はデータ部では文字の重なりなどは全く気にしないという事である。
  |   データ部の内容を元にして描画する時に全て処理するという風に考える。
  |   しかし、問題は普通の端末ではそもそもそういう変な揃えタブに対応していないという事である。
  |   受信側の端末では表示がそれっぽくならなくても仕方がないという風に捉えるのであれば、
  |   そのままデータ部の内容を転送するようにすれば良い。
  | b しかし、受信側の端末が様々の機能に対応していなくても、
  |   それっぽい表示にするようにしたいというのであれば、色々と考えなければならない。
  | 思うに、データ構造としてはデータ部の中にマーカとして保持するだけで十分である。
  | これらの問題はデータ部の中に保持している時の問題ではなくて、描画する時の問題である。
  | つまりレンダラの都合でそれらの機能に対応したり対応しなかったりという風にして良いのではないか。
  | そして他の端末に内容を転送する場合には
  | a 変な揃えタブの機能は無視して出力するか
  | b 変な揃えタブの機能を STAB, SDS や SRS を埋め込んで出力するか
  | c contra 側で配置を行った後の結果を転送するか
  | という風にして良い気がする。
  |
  | 但し、描画する時に正しくカーソル位置を動かせる様にする為には
  | やはり描画した時にどの位置にどの文字が表示されるのかという情報を計算できる必要がある。
  | うーん…。本当に必要だろうか。特に問題になるのは上下移動を行おうとした時だろうが、
  | 見た目にカーソル位置がずれても別に問題ないのではないだろうか。
  | むしろ複雑なカーソル位置判定を行うとアプリケーションの側で
  | それに応じた動きをするのが難しくなるのではないかという懸念がある。
  | まあ、これはどちらでも良い気がする。
  |
  | いや、しかしレンダリング先が複数ある場合には困る。
  | 或る表示処理系ではある配置をされて、別の表示処理系では別の配置をされて、
  | という風になっていると表示部での移動というのをどの様に取り扱うべきかというのは難しくなる。
  | また、フォントだとか字間だとかそういうのの取り扱いも入ってくるとより難しくなるだろう。
  | その様に考えれば、実際の所表示部での移動というのは内部的なデータ構造から計算できる範囲に留めておいて、
  | 表示する時の様々な配置に関しては追随しないという様な実装が無難である様に思う。
  |
  | 上記の様に "文字列" などの構造は (規格にある通りに) 所詮は始まりと終わりを扱うマーカであり、
  | そのマーカは制御機能に依って明示的に挿入される物で、自動的に範囲を考慮して辻褄が合う様に
  | 生成されたりするものではないのだという立場にたてば実装が大分すっきりする。
  | そもそも、端末の場合文字を受け取る度に端末の状態が更新されるわけで、その様な場合に
  | 途中の中途半端な "文字列" の状態が何であるのかというのを色々定義しようとするのは無理がある。
  | それならば単にデータ部に埋め込まれたマーカであると考えた方が楽であるし、自然な定義になる。

  [現在の結論]

  1 先ず方向付き文字列などのデータはマーカの配列 (1) として表現する
  2 場合に応じて一時的なデータとして文字列の開始点と終端点のペアを保持する配列を
    (1) から生成して使っても良い。
  3 TATE などによるタブ揃えの処理とデータ部を完全に分離する。
    つまり contra::board 上では表示部における細かい配置については関知しない。
    ただ、属性値として保持するだけに留める。
    "表示部に置けるカーソル移動" の制御機能は方向付き文字列による文字位置の入れ替えのみに対応する。
  4 端末を出力先とするレンダリングにおいては、
    タブ揃えなどの配置について関知せずにそのまま出力する物と、
    内部的に配置をしてからそれを出力する物の二種類を考える事ができる。
    特に後者については実装方法について考える必要がある。


  | -- 配置をしてから端末に出力する場合の実装方法 --
  |
  | この実装をする時に注意しなければならないのは、できるだけ出力するデータを少なくしたいという事である。
  | 例えば配置をし直す度に全データを出力するなどという実装にしていると環境によっては遅くて仕方がない。
  | 従って、できるだけ出力先の端末の持っている機能を用いて簡潔な出力になる様にしたい。
  |
  | ところで、実際の仕様では TATE だとか SDS だとかを使う機会は殆どないと思われるので、
  | そういう物が使われない限りは普通に動作して、そういうのが使われる場合に限っては
  | 遅くても仕方がないという考え方でも良い様に思う。
  |
  | さて、次の問題はいざ使われたという時に一体どの様なデータ構造に依って現在の表示状態を表現するのかという事である。
  | 一番簡単な方法は、何のデータ構造も使わず、行を更新する必要が生じる度に完全に一から表示内容を構築するという方法である。
  | そして差分のある部分だけを出力する様にする。もう少しちゃんと考えるのであれば、ウィンドウシステムの様にしてしまうという手もある。
  | つまり、表示する領域毎にオブジェクトを定義し、
  | 各オブジェクトの重なりなどを計算して一番上にあるオブジェクトの内容が表示されているという様に処理する。
  | そして或るオブジェクトの内容に更新があったとすればそのオブジェクトの表示されている領域について再表示を行い、
  | またそのオブジェクトの位置やサイズが変わったとすればそのオブジェクトが新しく占拠する領域、または、
  | そのオブジェクトが退去した領域について再度どのオブジェクトが一番上に来ているのかという事を計算し直す。
  | ここで難しいのは実際のデータ部におけるデータの更新はオブジェクトに対する操作という形になっている訳ではないという事である。
  | ちょっとした操作によってオブジェクトが完全に組み変わったりする。
  | そもそも "或るオブジェクトの位置が変わる" とか "大きさが変わる" とかそういう風な更新ではなかったりする。
  | 面倒なので取り敢えずは非自明な行に関しては行の内容を毎回完全に生成するという形にする事にする。
  | 後で必要性が生じればもっと効率のよい方法を模索する事にすれば良い。

  [現在の結論] (端末を出力先とするレイアウトエンジンについて)

  1 非自明な設定のない行に関しては単純に出力を行う。
  2 非自明な行に関しては毎回行内容を全て構築して出力するという形態をとって良い。
  3 余裕があれば、先ず方向付き文字列の部分についてだけは対応を行う。
  4 更に余裕があればウィンドウシステム的にオブジェクトの入れ子構造を構築・管理して、
    効率の良い更新ができないか模索を行っても良い。

  という訳で現在のデータ構造を変更する事になる。
  現在のデータ構造を変更した時の影響範囲はどれくらいになるだろうか。
  調べた所、外部から使っている箇所は現在はテストコードだけという事がわかった。
  皆 to_data_position/to_presentation_position 経由で情報を使っている。
  この二つの関数さえ修正すれば自由に変更できる状態にある。

  | 取り敢えずデータ構造は確定した。
  | 次に実装するべきは to_data_position/to_presentation_position である。
  | これを実装する時にどの様な戦略が考えられるかについて一度考察したほうが良い。
  | また、その前に文字列の始まりと終わりの対応が取れない場合などに
  | 一体どの様に処理するかなどについても確定しておく必要がある気がする。
  |
  | a 一つの方法は始点と終点の対応を取って配列に格納してからそれを使うという方法である。
  |   これにすれば既存の to_data_position/to_presentation_position を流用できる。
  |
  |   しかし to_data_position/to_presentation_position を呼び出す度に配列を構築するコストがかかる。
  |   これについてはどうにかならないだろうか。
  |   例えば一つの方法は始点と終点のペアの配列をキャッシュする様にしておいて、
  |   前回から変更がなければ前回のデータを使うという風にすれば良い。
  |
  |   x しかし問題は marker の配列に変更がなかったとしても、
  |     行の内容の文字列の側に変更があると文字列の終端位置などに影響が出るという事である。
  |     つまり、前回から変更があったかどうかというのの判断は行内容も含めて実行しなければならない。
  |     これだと駄目である。なので、何とかこれを回避する方法はないだろうか。
  |
  |     例えば、特に行内容で影響を与えているのは "行終端" = "行の内容が存在している一番右端の位置" だけの気がする。
  |     だとすれば、行終端を表す特別な値 -1 などを使ってキャッシュすれば良い気がする。
  |     しかし、本当にデータ部における行内容が影響を与えるのは行終端だけなのだろうか。
  |     例えば行内容で一番初めに文字がある位置というのは影響を与えない。
  |     何故なら文字列の始まりはかならず明示的に指定されるからである。
  |     問題なのは文字列の終端がまだ受信されていない "過渡的な文字列" なのである。
  |     また、当然行内容の文字が入れ替わっても何の影響もないだろう。
  |
  |     但し、文字挿入の際に或る marker を跨ぐような文字が設置されると困る。
  |     でも、その際にはそれによって marker の除去もしくは修正が行われなければならないから、
  |     結局それに依って marker 列に変更が生じるので変更検出については問題ない。
  |     しかし、この文字挿入時の marker 修正については留意しておく必要があるだろう。
  |     marker の位置をずらすのだとしたら後方にずらして、もしその他の marker と衝突するようであれば
  |     それらも広報にずらす様にする必要がある。その際に長さ 0 の文字列が発生すればそれは削除する。
  |     しかし aligned tabulation に関してはずらすというのは変なので削除する。
  |     削除する時には、対になる end marker が既に来ているのだとしたらちゃんとそれも削除しなければならない。
  |     そうしないとその他の文字列を一気に閉じる事になり望まない結果になる様な気がする。
  |
  |     結局そんな理由で行終端だけが文字列範囲の決定に影響を与えると思って良さそうである。
  |
  |   所で、どの様にしてその様な対応関係の配列を生成するのかというのは一つの問題である。
  |   効率的な方法があるかどうかについてはまた後で考える必要がある。
  |   うーん。結局 stack の様な構造を作って処理するしかないのだろうか。
  |   それだと結構コストがあるような気がするが。しかしだからといって
  |   再帰にするとスタックオーバーフローの危険性があるし、うーん。
  |
  | b 或いは、対応関係を配列に入れなくても処理する方法はあるだろうか。
  |   例えば始点が来た時に終点をその場で計算するという方法が考えられる。
  |   この方法を使えば新しくメモリを確保するなどの手間が省けて良い。
  |   しかしこの方法だと始点ごとに入れ子になっている部分について
  |   同じ計算を実行する事になり非効率的な気がする。
  |   結局処理の見通しの良さなどを考えてもこの方法は取りづらい。
  |
  | まあ a で実装するのが現実的な気がするので、それで行く。
  |
  | + SIMD で文字が逆方向に進んでいる時には一体どうするのか?
  |   - SDS 開始と終了を反転させた順序で認識しなければならないのだろうか。
  |     しかし思うにデータ部内の内容自体がデータストリームであって、
  |     SIMD で文字を逆方向に進めるというのはデータ部内の "データストリームに対する編集" の一つだと考えるならば、
  |     文字を挿入する時に逆方向に進んでいたとしても、
  |     最終的に解釈する時にはその時にデータ部に記録されている内容から SIMD に関係なく文字列などの構造を決定するべきである。
  |     従って SIMD がどうだとかそういうのによって marker の解釈を買える必要はない。
  |   - もう一つ考えて置かなければならないのは過渡的な状態についてである。
  |     データ部に逆方向にデータを格納できるとすると、例えば SDS 終端を先に記録して、
  |     その後で SRS 始端を書き込むという事が可能になる。その過渡的状態で何か問題になる事はないだろうか。
  |     先ずそもそも終端のマーカだけでは SDS の場合には、その文字列の方向を決定できない。
  |     なので SDS の場合には終端マーカだけで有効な文字列として解釈するというのは不可能である。
  |     従って、SDS 終端マーカしか存在しない場合にはそれは単に無視するという風に処理するのが無難に思われる。
  |     だとすれば SRS の終端マーカの場合にも同様に処理するしかないだろう。
  |     それに終端マーカだけ存在していた時に、例えばそれを行頭までの文字列と解釈しようとすると
  |     文字列入れ子状態キャッシュ配列の処理もより複雑になる。
  |     といっても "行頭" を表す特別な値 "-2" に対して処理を書くだけのような気もするが。
  |     何れにしても余り凝ったことをしても自然な振る舞いになる様に思われないので、
  |     終端マーカだけしか無い文字列に関しては単に無視するというので良いだろう。
  |
  | + 一つの行に設定できるマーカの個数に上限を設定する必要がある。
  |   もしくは複数のマーカを縮約する方法について取り決めれば論理的に上限の数があるかもしれない。
  |   例えば同じ位置で始まって同じ位置で終わる文字列というのはくっつける事ができるのではないかという事である。
  |   そして入れ子になっていなければならない (閉路がない) という事と、空の文字列はないという事を考えれば、
  |   文字列は最大でも (行の文字数) * 2 - 1 個しか作成できない。
  |   但し、過渡的な状態として開始マーカを大量に仕込むことが出来る。
  |   開始マーカの時点ではそれぞれのマーカの終端が同じになるかどうかについて何も分からないので、
  |   結局終端マーカが来るまでは縮約については保留しなければならない。
  |   だとすると結局縮約をするとしてもマーカの個数に上限を設定しなければならないという事だから、
  |   そもそも縮約などの面倒な事も考えなくて良さそうな気がしてくる。
  |   ただ、マーカの個数の上限は (行の文字数) * 4 以上でないと不都合が生じるケースが
  |   存在するという事は分かった。なのでマーカの個数の上限は十分大きくとっておくことにする。

  [結論] 記録したマーカの処理方法について

  - 文字挿入時の marker の修正。全角文字の挿入に依って marker 位置の上に文字を上書きするとき、
    a その marker が aligned tabulation による物である場合にはそれを削除する。
      もし対応する終端マーカ (通常の tabstop への HT) がある場合にはそれも削除する。
      但し、それよりも前に aligned tabulation marker がある場合には削除しない (フィールド連結になる)。
    b その marker が SRS/SDS 文字列である時には marker の位置を新しく挿入した文字の終端に移動する。
      この時、文字列長が 0 になった場合には (つまり文字列終端が挿入文字の終端にあったときは)、
      その文字列 (同じ位置にあるマーカのペア) は削除する。

  - 終端マーカだけの存在は許す。文字列としては解釈しない。
    これは SIMD(1) による data stream 構築の過渡的状態として考えられる。

  - 一つの行に設定できるマーカの個数に上限を設ける。
    それは、論理的に配置できる文字列の個数が 2 * (行の文字数) であることから、
    4 * (行の文字数) より十分大きな物にする必要がある。
    この制限は tty_player の側でかける事にする。

  という訳で取り敢えず実装するものについて整理する。
  > 1 マーカ配列 → 文字列配列 への変換。
  > 2 to_data_position/to_presentation_position の調整。
  > 3 SDS/SRS によるマーカの挿入。
  > 4 文字挿入時のマーカ修正。
  # 5 HT によるマーカの挿入 (これはタブ実装の後で)
  # 6 一頻り実装が終わった後で様々な動作テストを行うべきである。

  5,6 に関しては別に項目を立てる。

  | [過渡的状態の文字列(非終端文字列)の取り扱い]
  |
  | to_data_position/to_presentation_position で行の終端を意味する
  | nested_string::npos を処理する必要がある。
  | しかし、そのためには行の終端を取得しなければならない。
  | line 構造体自体は行の内容について関知しないから行の終端を取得するためには
  |
  | a line 構造体自体に行の終端を格納するフィールドを用意して、
  |   行内容の変更に応じて line 構造体の行終端位置も更新する様にする。
  |
  |   # この方法を採用すると行内容の編集と一緒に毎回行終端位置を更新しなければならない。
  |   # そのまま愚直な実装で実装するとコストが高いし、
  |   # 或いは更新の方法に応じて賢い方法を考えるとすると複雑になる。
  |   # やはり使いたい時にその場で計算する方が理に適っている様な気がする。
  |
  | b もしくは、to_data_position に引数として予め計算した行終端を渡す様にする。
  |
  |   # この方法を採用すると行終端を毎回必ず計算しなければならず非効率的である。
  |   # 関数オブジェクトでも渡す様にすれば必要になった時にだけ計算する様にできるが、
  |   # 何か設計を誤っている様な気がする。
  |
  | c 或いは board の側に data_position を移して実行する様にした方が良いか。
  |   現状では presentationDirection を引数に受け取っているが、
  |   その様な情報によって計算結果が左右されるという事はやはり
  |   to_data_position/to_presentation_position は論理的にも board の管轄下にあると考えるのが自然である。
  |
  |   と思って確認してみたが、presentationDirection が記録されているのは board ではなくて tty_state の方だった。
  |   だとすると to_data_position/to_presentation_position は tty_player に実装するべきなのだろうか。
  |   しかしそれは変だ。行毎に文字列を管理しているのだから board や line のレベルで to_data_presentation
  |   に対応していないとおかしい。tty_player に実装するとなると、これらの board や line に記憶されているデータは、
  |   tty_player で board を操作している時にしか有効でない外付けの様なデータになる。
  |   だとすれば、これらの文字列のデータは board ではなくて player の方に移すべきなのだろうか。
  |   そもそも board にどれだけの機能をつけて、また、どれだけの機能を player の方に任せるのかというのを考えないと行けない。
  |   確かに双方向サポートなどというのは ANSI ターミナルを実装するときにしか使いそうにない機能である。
  |   その様に考えれば tty_player の側に実装する物の様にも思われる。
  |   しかし、一方で tty_player で管理するべきなのは "画像の出力内容をどのようにするかという設定" だけで、
  |   "実際のどの様な画像が表示されているか" に関しては board に完全に情報を持たせるべきの様にも思われる。
  |   また、各行についての設定・データを tty_player の側で管理するというのはやはり違う気がする。
  |   その様な情報はやはり飽くまで画面に付随している属性に思われる。
  |
  | どうも腑に落ちない。いろいろ考えている内に眠くなってきたので晩ごはんを食べに行く。
  |
  | 歩いていて思ったのだが、そもそも presentationDirection が tty_state の上にあるのがおかしいのだ。
  | これは board 上でどの様にデータが表現されているかという board の情報であって、
  | tty_player の振る舞いを規定するような情報ではない。それが tty_player の上にあるのがいけないのだ。
  | そもそもの方向付き文字列なども board 自体の presentationDirection を与えないと一意に定まらない。
  | さて、presentationDirection を board 上に移動するとなれば話はずっとすっきりする。
  | という訳で presentationDirection の移動を実施する。→移動した。意外と簡単に移動できた。
  |
  | 後は to_data_position/to_presentation_position の実装を board_line から board に移動するだけの筈である。
  | →これも無事にできた。

  | [文字列挿入時のマーカの上書き]
  |
  |
  | 文字列挿入時のマーカの修正方法について改めて考える必要がある気がする。
  | 実装している途中でよくわからなくなったので。
  | できるだけ様々な場合で整合的に動作する様にしたい。
  | つまり微妙な違いで振る舞いがぜんぜん違うというのは良くない気がする。
  |
  | 1 先ず初めにマーカの或る位置に文字を書き込んだ時の動作について。
  |   特に HT を行った時に設定される aligned string について。
  |   実際に実装する前には上書きする場合には消去し、
  |   隣接する場合には消去しないという風に考えていた。
  |   しかし、それだと全角で文字を出力していって丁度マーカを踏み潰す形になった場合には
  |   前のフィールドと次のフィールドが連結されるという様な形になるが、
  |   一方で、半角で出力していった場合や丁度全角文字がフィールドに収まる場合には、
  |   途中で書き込む先のフィールドが変わるという動作になる。
  |   出力位置の微妙な違いでこれらの大きな動作の違いがあるのは何か変だ。
  |
  |   そもそも、次のフィールドに移動する時に HT をするという前提で考えると、
  |   フィールドの末端ギリギリまで文字を出力するわけには行かない。
  |   そうすると、その文字を出力した直後に既に次のフィールドの位置に移動していて、
  |   その場所で次のフィールドに移動しようと思って HT を出力すると更に次のフィールドに移動してしまうからである。
  |   だとすればぎりぎりまで出力した場合には、上書きする時と同様にマーカを削除してしまって良い気がする。
  |   その次の瞬間にカーソルがそこを跨ぐから削除するという風に考えても良い。
  |
  |   改めて書くと、境界 a から境界 b に亘る文字を配置した時、a < m <= b なる位置 m にあるマーカは削除する。
  |   ではこの動作にした時に不明瞭は点は他にないだろうか。
  |   aligned string のマーカには三種類ある。純粋な終了点を表すマーカと、開始点を表すマーカ、
  |   それから開始点を表すマーカはそれより前に開始点を表すマーカがあった場合に終了点をも兼ねる。
  |   - 先ず状況の簡単そうな終了点のマーカを削除する事について考える。
  |     終了点のマーカが其処にあるという事は普通の状況では、
  |     現在出力している場所は前の開始点マーカで指定される文字列の途中という風に思われる。
  |     その時に其処に終了点が現れたらどうするか。
  |     もし、その行に対する出力が初めてであった場合には其処には何も終了点マーカなどはなかった筈で、
  |     過渡的な状態においては終了点が存在しないフィールドという物が許される。
  |     その様に考えればその様な終了点マーカは単純に削除してしまって良いと考える。
  |   - 次に純粋な開始点の場合にはどの様に処理すればよいだろうか。
  |     純粋な開始点を削除するというのは一体どういう事だろうか。
  |     先ずそれより前の部分は algned string ではないという事。
  |     なので、それより前の aligned string の整合性などについては考えなくて良い。
  |     一方で、対応する終了点について気になる。それは削除した方が良いのではないか。
  |     しかし、よく考えてみれば対応する終了点が孤立して残されたとしても何か問題が起こるという訳でもない。
  |     処理の上では単純に無視される。それならば局所的な変更になる様にしておいた方が後々様々な所での動作が自然になるのではあるまいか。
  |     しかし、これは data stream という観点から考えるとどうだろう。終了点マーカというのは HT によって次のフィールドに移った時や、
  |     NEL によってその行を終了したとき等に自動的に設置される。明示的に其処に埋め込むという物ではない。
  |     そう考えると開始点が消滅しているのに終了点だけ其処に残留するというのも変な話である。
  |     例えば、カーソル移動で適当に移動して文字を挿入したりタブを設置したりしようとすると変な事になる。
  |     従って、やはり終了点も対で削除した方が良い様に思われる。
  |   - では開始点と終了点の両方を兼ねているマーカの場合にはどの様に処理すればよいか。
  |     基本的には純粋な終了点と純粋な開始点の両方の処理をすれば良い気がする。
  |     純粋な開始点の様に前方に終了点マーカが存在すればそれと一緒に削除を行う。
  |     後は単純に削除を実施する。
  |
  |   結局動作についてまとめると、それが開始点マーカであるならば、
  |   次のマーカを探してそのマーカが終了点であればその終了点マーカを削除する。
  |   そしてそのマーカを (終了点マーカ・開始点マーカかに限らず) 削除する。
  |   また、マーカの範囲に関しては SIMD でない時には a < m <= b であり、
  |   SIMD である場合には a <= m < b にする。
  |
  |   ※実装前の考えではその点が終了点マーカである場合には、
  |   終了点をずらして今までのフィールドの長さを縮める様にしていた。
  |   しかし、この動作はやはりおかしい気がする。
  |   それだと例えばその行に既に内容が出力されているという事を知らずに、
  |   通常通りに出力を行った時に意図しないフィールド分割になってしまうという事になる。
  |   何も知らずに上書きしていっても副作用が出ない様に設計するのが良いのだ。
  |
  | 2 SDS/SRS で挿入される文字列についてはもう少し慎重になりたい。
  |   不用意に上書きをすると左右が突然反転したりして何か良くわからない事になる。
  |   上書きされる文字の部分は消えてしまうとしても、
  |   残った部分の方向性については保持する様にしたい。
  |
  |   もし、挿入文字がマーカ直前に隣接するという場合には何もしない。
  |   というのもマーカ直前に文字を挿入したとしても
  |   SDS/SRS 文字列の内容はそこに変わらず残るからである。
  |   直前に文字を書いただけで内容が破壊されるというのは変である。
  |   しかしそうするとその次に文字が書き込まれるのは文字列の内部という事になる。
  |   しかし、文字列先頭の位置はデータ部ではマーカの直後になるが、
  |   表示部で見るとその文字列の方向性に従った位置に表示されている。
  |   その様に考えると次の文字が挿入されるのはやはり方向性を考慮して計算された位置であるべきで、
  |   つまり、SDS/SRS 文字列の内部に文字が追加されるという事になる。
  |
  |   ※この動作は先の algned string の時と違う。
  |   aligned string の時には最終的な状態が空の行に出力した時と同じになる様に考えたが、
  |   今回の SDS/SRS 文字列の内部に侵入可能という様な実装では、
  |   既に其処に文字列が存在している状態で行を出力すると変な出力になってしまう。
  |   うーん。これについては後でもう少し考えたほうが良いような気もする。
  |   例えば現在の出力位置にどの様にして移動してきたのかという事や、
  |   マーカがいつ設置されたものなのかという情報を考慮に入れて文字挿入の動作を変化させるなど。
  |   しかし、それはそれで変な気もする。
  |
  |   また、挿入文字がマーカを上書きするという場合にはマーカを後ろにずらす。
  |   SIMD の場合には前にずらす様にするのが良いだろう。
  |   一つの懸念はマーカをずらす時にマーカの順序が変化してしまわないかという事である。
  |   終了マーカは開始マーカの直後になければならずその順序が変わってしまってはならない。
  |   m_markers 配列の中では勿論登録されている順序は変化しないが、
  |   しかし、位置を補正する事によって m_markers の内容がソートされているという条件が破れるのが心配だ。
  |   しかし、SDS/SRS マーカを全て同列に扱っている限りは開始マーカが後ろにずらされる事によって
  |   終了マーカの位置を追い越したとしても終了マーカも同様に後ろにずらされる筈であるから、
  |   問題は起こらない筈である。
  |   所で、ずらす事によって長さ 0 の文字列ができる事があるこれについては残しておいても良いような気もするが、
  |   やはり削除してしまったほうが自然な動作と思われる。従って、これについてチェックして削除を行う。
  |   これは終了マーカを移動した時にチェックを行えば良いであろう。
  |
  |   ? しかし SIMD の時に前方にマーカをずらすとするとちょっと微妙である。
  |     終了マーカが移動した時に文字列が潰れるかどうかの判定はどの様に行えば良いだろう。
  |     と思ったが、終了マーカも前方に移動するのでその時にやはり文字列が潰れているか
  |     どうか見極めて削除を行えば良い気がしてきた。
  |     実のところ開始マーカで判定をしても終了マーカで判定をしても良いけれども、
  |     両方移動した後に判定を実行しなければならない。
  |     そんな訳で順方向にループを回すのであれば終了マーカ移動時に文字列が潰れたかチェックし、
  |     逆方向にループを回すのであれば開始マーカ移動時に文字列が潰れたかチェックを行うという事になるのだろう。
  |     今回は順方向にループを回す実装しか考えてないので SIMD に拘らず終端マーカで空文字列判定を行えば良い。
  |
  |     うーん SIMD の時に前方にずらしたとしてその時に何か別の物を跨いだりして変な事にはならないだろうか。
  |     今のところの実装としては最終的な状態では挿入文字の内部にマーカが残る様な事はない。
  |     従って、SIMD の時に前方にずらしたとして追い越すとしたら元々文字内部または文字の境界にあったマーカだけである。
  |     うーん。SIMD で前方にずれるマーカというのは文字内部のマーカである。それが追い越すとしたら
  |     文字内部のマーカしか無い。文字内部のマーカの内 SDS/SRS マーカは同様に移動するので追い越す事はない。
  |     aligned string マーカに関しては削除されるので、これも追い越すという事はない。
  |     従って、SIMD で前方にずらしたとしても SDS/SRS/alignd string markes の何れも追い越さない筈である。
  |
  |   ? もう一つの問題は終了マーカで削除判定を行うとすると開始マーカと削除マーカの二つを削除する事になり、
  |     マーカに対するループの番号を補正しなければならない。
  |     と思ったが、よく考えてみればこれは aligned string の時も同様である。
  |     削除が発生した場合には次に検索するマーカは前回と同じ i であるべきなので、i-- するか、
  |     i++ しないようにするかの対策が必要である。
  |     同様に文字列が潰れた事の判定に依ってマーカの対を削除するのだとしたら単に i -= 2 などとすれば良い。
  |
  |   ? さて、しかし SDS/SRS 文字列が終端する条件は一つではない。
  |     SDS/SRS による明示的な終端だけではなく、次に aligned string マーカが存在するというパターンも有る。
  |     aligned string マーカの際に直前にある文字列が潰れていないか判定するのは面倒である。
  |     その様に考えると実は開始マーカの移動の際に一緒に終了点マーカの移動先も計算して、
  |     その上で文字列が潰れるかどうかを判定するという手のほうが良いのかもしれない?
  |     しかしそれだと入れ子になっている文字列が潰れた時に削除できない。
  |     終端マーカで削除判定を行う事の利点は、空文字列の終端マーカに到達した時には、
  |     必ず内部に入れ子になった文字列 (すべからく空文字列である) のマーカは既に全部除去されているという事である。
  |     つまり、直前の要素を見れば必ず開始点マーカに対応する物が存在するはずという事である。
  |
  |     もし直前の要素がない場合や、aligned string マーカである場合には
  |     そもそも開始点が存在しないという事になるので、
  |     そのマーカは単に削除すれば良いだろう。
  |
  |     結局、終了点マーカもしくは aligned string マーカが現れた時には空文字列判定を行うという事になる。
  |     SDS/SRS 終了点マーカの場合には移動後に空文字列判定を実施する。
  |     aligned string マーカの場合には先に空文字列判定を行って、その後で aligned string マーカの処理を行う。
  |
  |     →実装している時に気づいたが。
  |     現在の実装では aligned string マーカが現れたらその直前にある SDS/SRS を削除するという方針にしていた。
  |     しかし、この方法だと既にあってシフトの対象となった SDS/SRS だけではなくて、
  |     新しく追加した SDS/SRS マーカまでも削除してしまう事になる。
  |     つまり、alined string マーカの直前で SDS/SRS を設置してもそれが削除されてしまうという事態になる。
  |     本当に処理しなければならないのは何かというと、暗黙上書きによってシフトされた SDS/SRS に関して、
  |     直後に aligned string が存在していた時に空文字列として削除を行うという物である。
  |     元々の懸念は入れ子文字列の場合に正しく削除できないのではないかということだったが、
  |     仕方がないので可能性のあるマーカは全て確認して aligned string が一つでもあったら
  |     空文字列になると判定して削除するという具合にする。

  | [SDS/SRS によるマーカ挿入]
  |
  | 通常時は現在の文字位置の左側に挿入し、SIMD 時は現在の文字位置の右側に挿入する。
  | (そもそもその様にしないと次に全角文字が来た時に潰されてしまう。)
  | 左側に挿入する時は append で右側に挿入する時は prepend にするべきだろう。


* [2016-10-05] TAB 関連の機能 [#D0023]

  | Mode TSM
  | VT VTS
  | TAC TALE TATE TBC TCC TSR
  | STAB (ISO 8613-6) HTJ HT HTS CHT CBT CTC CVT
  |
  | 影響のあるもの: DAQ(7) DCH ICH DL IL RIS
  |
  | RLogin は HTS, DECHTS, VTS, DECVTS を認識するが、
  | 何も設定しない状態で HT を呼び出すと何が起こるのだろうか。
  | 確認する必要がある。
  | 因みに VT に関しては次の行に単に進むだけの様に見える。
  | VTS を設定してる状態で VT を実行するとどうなるだろうか?
  |
  | 1 HTS の設定に関する確認。
  |   $ printf $'\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |   xterm, screen, RLogin, mintty, Poderosa の何れも TSM(MULTIPLE) で、
  |   予め 8 の倍数の位置にタブが設定された状態で始まる。
  |   HTS を呼び出すと予め設定されているタブに加えて新しいタブを設定する。
  |
  |   TSM 対応に関して
  |
  |     $ printf $'\ec\e[5W\e[18h\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |
  |     RLogin のマニュアルを見ると TSM を ISM という名前で対応している。
  |     しかし "マルチ" と "シングル" の名前が間違っている。逆である。
  |     動作自体は逆にはなっておらず正しい。
  |     CTC(5) の仕様が異なるのは気になるが、何れにしても TSM(SINGLE) にすると、
  |     TSM の変更前に全体に共通のタブを色々設定していたとしても、
  |     各行で 8 の倍数にタブが設定された状態になる様だ。
  |     つまり、TSM の変更前のタブは引き継がれない。
  |
  |     xterm のマニュアルには何も書かれていない。実際に試しても対応していない。
  |     mintty, screen, Poderosa も試してみたが対応していない。
  |
  |   CTC in RLogin
  |
  |     RLogin の CTC(5) と CTC(6) の記述が ECMA-48 の記述と異なる。何故か?
  |     ECMA-48 側が変化したのかもしれないと思って確かめたが
  |     2nd edition から 5th edition まで記述は同じである。
  |     vt510 及び xterm にはそもそも CTC が存在しない。
  |     all-escapes.txt の内容は ECMA-48 の内容と全く同じだ。
  |
  | 2 TAC, TALE, TATE の取り扱い方法?
  |
  |   ECMA-48 に含まれるこれらの機能によって設置されたタブは特別な意味を持つ。
  |   タブ位置の前後にある文字列の配置に影響を与えるとある。
  |   しかし、実際のどの様に実装する物なのかよく分からない。
  |   まず例えばデータ部での配置に影響を与える物なのかどうか、
  |   表示部での上下左右の移動に影響を与えるのかといったことである。
  |
  |   恐らくデータ部での配置には影響を与えないつもりなのだろう。
  |   これらは飽くまで実際に表示する時にどう表示するかというのを指定するためにある。
  |   表示部での取り扱いをどの様にするべきかという事を考える前に、
  |   そもそもこれらのタブが具体的にどの様に処理されるかについて考えなければならない。
  |
  |   % 恐らく前後の文字列というのはフィールドと考えて良いだろう。
  |   % "文字列" と言えば方向付きの文字列という物が ECMA-48 の中で定義されているが、
  |   % それだと、それらが丁度タブの前後で分かたれているとは限らないのでよく分からない。
  |
  |   改めて規格の文面を見ると前後の文字列という訳ではなくて、
  |   何らかの text string があってそれが TAC などによるタブで揃えられる時には、
  |   その文字列の先端もしくは後端の位置によって左右位置の調整が行われるものと見える。
  |   また text string というのは恐らく双方向対応で出て来る strings とは別の物であろう。
  |   よくわからない点が色々ある。先ず、"tabstop by TAC で揃えられる text string" という物を
  |   どの様に指定するのかという事である。"これこれここの範囲はタブによって揃える text string ですよ"
  |   という様な感じに明示的にそれを指定する制御機能はないように思う。
  |   しかしだからといって、タブに従って揃えられますという様な表示規則も元々あるという訳ではなさそうだ。
  |   もし何かあるとすればフィールドだが、これについて何か説明が見つかるかもしれないので
  |   また改めて規格の内容をフィールドに関連して観察してみる。ECMA-48/6.7 を見る。
  |   うーん。分からない。とここで STAB の説明を改めて読むとそこに、
  |   以降の文字列を引数に依って指定されるタブ位置とその性質に従って align されると書かれている。
  |   実は TAC, TALE, TATE, TCC はこの制御機能ありきの機能なのではないだろうか。
  |   しかし、この制御機能は ISO 8613-6 に詳細を投げている。そちらも参照する必要があるだろう。
  |   ISO 8613-6 というか T.416 を見ると TAC, TALE, TATE, TCC は存在しない。やはり関係ないのか。
  |   T.416 STAB に関して見てみると、[T.416/9.1.13] のデータ構造 Line layout table を参照している。
  |   このデータ構造を見ると丁度 TAC, TALE, TATE, TCC などに対応する状態を持っている。
  |   というか、このデータ構造をそのまま採用すれば良い気がしてきた…。
  |
  |   更に、HT の説明に、もし次のタブ位置が TATE, TALE, TAC, TCC による物だとしたら、
  |   次に HT または改行が来るまでは文字列の内容はそのタブに関連付けられた文字列とすると書かれている。
  |   しかもそれは表示部で定義される物ではなくてデータ部の data stream 内で記録されるという。
  |
  | 3 RLogin で垂直タブの設定などをいろいろ試してみたがどうもうまく動かない。
  |   いつでも VT や DECSVT などは一行下に移動するという意味になる様に見える。
  |   xterm でやって見ると DECSVT は効果を持たない (対応していない?)。
  |
  |   縦タブを全てクリアしてから縦タブを設置する様にしてみたり色々したがうまくいかなかった。
  |   でもマニュアルにはちゃんと縦タブについて系統的に対応している様に見える。
  |
  |   - 一つの可能性は初期状態として全ての行に縦タブが設定されていて、
  |     更に縦タブをクリアする機能が効いていないという物である。
  |     縦タブをクリアする機能は CTC と TBC, DECAVT しかない。何れも試したが駄目だった。
  |
  |     $ printf '\e[H\e4\e[6W\e[4g\e[91m\e[10HX\eJ\e[20HY\e3\e[Hhello\vworld\e[1Ytest\e[m\n'
  |
  |     \e4 \e[6W \e[4g のどれを使っても縦タブが解除されていないという事になる。
  |
  |   - もう一つの可能性は何処かにモードがあって縦タブによる移動と
  |     単に一行下に移動するのを切り替えられる様になっているという物である。
  |     しかし説明を見ても VT もしくは縦タブに関連したその様なモードはない様に見える。
  |
  |   - 更に可能性として縦タブの設置に失敗しているという可能性がある。
  |     縦タブが存在しない場合は一つしたの行に移動するという実装になっているのかもしれない。
  |     しかし VTS も DECVTS も駄目だった。
  |
  |   - 或いは VT は常にひとつ下の行に移動するだけで、
  |     実際に縦タブするには CVT を使わないと行けない可能性もある。
  |     しかし CVT で試してみてもやはり状況は変わらない。
  |
  |   - 縦タブは1つずつ解除しなければならないのかもしれないと思って以下も試したが駄目だった。
  |
  |     $ printf '\e[H'; for a in {0..20}; do printf '\e[1g\e[3W'$a'\e[B'; done; printf '\eJ\e3\e[Hhello\vworld\e[Ytest\n'
  |
  |   うーん。RLogin は本当に縦タブに対応しているのだろうか。


  [実装方針]

  1 早々に実装方針を決定したい。
    基本的には ISO 8613-6 (というか T.416) にある様なデータ構造で保持したい。
    タブ構造は各行で保持する。但し、全体で共通のタブ構造を管理している場合には、
    共通のタブ構造と一致する限りに於いて実際にタブ配列を複製するのを避ける。
  2 TSM(MULTIPLE) のとき同じページの全ての行に適用する。
    新規行の文字タブ設定は頁毎に保持する。
  3 タブの位置は常に表示部で定義される。
    と思ったがタブと方向付き文字列の実装に関連して考察した結果、
    方向付き文字列の内部でタブは設定しないという風に考え、

2016-10-12

* Poderosa bug [#D0022]

  | Poderosa で RI を試そうとして以下を入力していたら無限ループになって死ぬ。
  |
  | $ printf 'hello\e[H\eMworld\n'
  |
  | ble.sh をロードした状態で上ボタンで履歴を表示してそれからこれを実行するとなる。
  | 具体的にどの様なエスケープシーケンスを受け取って死ぬのかは調べないと分からない。
  | 面倒だ。どの様にすれば確認できるだろう? contra で escape sequence を全て出力する?
  | 新しく escape sequence を全て出力するクラスを作った: sequence_dump
  | 関係のありそうなものだけを抽出する。DECSET(25), SGR, OSC, SI は関係ないだろう。
  |
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   CR LF
  |   unrecognized control sequence: CSI 1 L
  |   l o a d i n g   h i s t o r y . . .
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 1 1 C
  |   CR LF
  |   unrecognized control sequence: CSI 1 M
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 2 9 C
  |   p r i n t f
  |
  |   '
  |   h e l l o \ e [ H \ e M w o r l d \ n
  |   '
  |   unrecognized control sequence: CSI K
  |   CR LF h e l l o
  |   unrecognized control sequence: CSI H
  |   RI w o r l d CR LF
  |   unrecognized escape sequence: ESC 7
  |   [ b l e :   E O F ]
  |   unrecognized escape sequence: ESC 8
  |   unrecognized control sequence: CSI 2 0 7 C
  |       CR
  |   unrecognized control sequence: CSI K
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   [ b l e :   e x i t ]
  |   CR LF e x i t CR LF
  |
  |   くっつけて見る。
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\e[13D\n\e[1M\e[1A\e[5Cprintf\e[K\nhello\e[H\eMworld\n\e7EOF\e8'
  |
  |   ちょっとここまでで Poderosa に食わせてみる。何も起こらない…。もう一回実行してみる。再現した。
  |   何だろう。ただ単に printf 'hello\e[H\eMworld\n' を繰り返すだけでは起こらない様だ。
  |   もう一度やってみる事にする。起こらない。どうやら境界が下の方にできて、その境界の直後で実行するとなる様だ?
  |
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK
  |   printf '\e[H\n\e[1L\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK 再現性あり
  |   printf '\e[H\n\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\n\e[H\eM' OK

  まとめ: 以下の手順で Poderosa が死ぬ。
  (1) Poderosa で新しいウィンドウを開く
  (2) printf '\e[2H\e[L\e[M\n\e[H\eM' と入力して実行する

* escape sequence の処理の段階で NUL や DEL は無視しなければならないのではないか。 [#D0021]
  恐らくシーケンスの途中に NUL や DEL が含まれていても単に無視して取り扱うべき。

2016-10-11

* bidi サポート追記 [#D0020]

  規格を読んでも active data position と active presentation position の関係が分からないと考えていたが、
  ECMA-48/6.3/4 に書かれている。この段落はとても重要な段落である。

  > The graphic image output is constructed in the presentation component from the data stream stored in the
  > data component, and according to the line orientation and line progression of the presentation component.
  > The presentation of characters along a line in the presentation component is dependent on the character
  > path, the character progression and the direction associated with the string.
  >
  > 訳: 記憶部に記録されたデータストリームから、表示部の行送りの方向と行の向きに従って、
  > 表示部に画像出力が構築される。行内の文字の表示は文字進路・文字進行・文字列の方向に依る。

  acative data/presentation position の関係について全てがこの段落に含まれている。
  他の部分の記述や ECMA-TR/53 の記述を組み合わせて解釈したのと整合しているので、
  実装について変更を行う必要はないという事が分かった。つまり現在の実装を変更する必要はない。
  そのことが分かっただけでも大きな成果である。

* 全角文字の取り扱い in ECMA-48 [#D0019]

  ECMA-48/6.3/3 に行は predetermined number of character positions からなると書かれている一方で、
  ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている。
  つまり、全角文字などは複数の character position を専有するという扱いではなくて、character position 自体の
  大きさが大きくなるという解釈なのだろうか。だとすると一行に収める事のできる文字の数は全角・半角に関係なく、
  ただ表示する時に全角文字で構成された行はサイズが大きいという風な扱いということなのだろうか。
  これは実際の端末の実装とは一致しないし、何より変だ。しかし、異なっても良いし固定でも良いと書かれている
  (may be fixed or may be depend)。文字に依って専有する character position が複数でも良いという風に何処かに書かれていれば
  それが実際の実装と一致した物と考える事ができる。でも 6.1.6/2 には implicit movement によって
  the active data position is moved to the following character position と書かれている。the とついているので、
  やはりこれは一つ次の character position に移動するという事である。

  ECMA-48 的には
  - 行に全角文字が含まれていても行に入れる事のできる "文字数" は同じで、
  - 例えば SLH SLL で設定される文字番号は幅ではなく "文字数" でカウントされ、
  - CUF や CUB では半角幅毎ではなくて文字毎に移動するべきなのか…。

  これは実際の端末の実装と乖離しているし、それに実装として不自然である。
  また全角幅の文字は普通に使われる機能なので、今ここで ECMA-48 に厳密な実装にすると色々な問題が実用上生じる。
  どう考えても、実際の端末の実装の方が自然で現実的な実装であるので、ここでは ECMA-48 を無視する。
  これについて Note を残しておく事にする。

2016-10-05

* SPH/SPL [#D0018]

  page_home_position -> page_home, page_limit
  取り敢えず値を設定できる様にする。

* sequence_decoder, sequence: support ESC sequence [#D0017]
* escape sequences の解釈 [#D0016]

2016-10-04

* SCP SPD に対応する。 [#D0015]
* CR ... SCP SPD の向きが逆の場合に対応する。 [#D0014]

* data position と presentation position の変換方法について。 [#D0013]

  SCP による character path の方向は基本的な計算部分に影響を与えない。
  何故ならば character path は presentation position の番号と、
  実際に表示される位置の対応関係を規定する物であって、
  data position と presentation position の間の関係には影響ないからだ。
  但し、directed string の ltor と rtol は、
  character path によって意味が入れ替わるので注意する。

  従って、計算の上で気にしなければならないのは directed_string だけである。
  directed_string によって向きが反転している範囲の中にあれば反転するという事をしなければならない。


  presentation position -> data position の実装は比較的簡単である。
  1 先ず presentation position を x とする。
  2 directed_string のリストから x を含む
    一番大きい directed_string を拾って str とする。
    もし x を含む directed_string がもうなければ処理は終了する。
    ここで x は記憶部で最終的に必ず str の範囲に含まれる事に注意する。
  3 もし str の向きが外側の向きと一致していなければ x の位置を反転させる:
    x = str.end - 1 - (x - str.begin);
  4 以降は str 及び、その中に含まれる directed_string のみを考えれば良い。
    従って、str に含まれる directed_string のリストについて 2 に戻って繰り返す。

  data position -> presentation position については少々厄介である。
  presentation position -> data position の逆の処理をすれば良いかと考えたが、
  外側と較べて反転しているかどうかを知るためには外側から順に辿って
  一旦何処で反転が起こるのかを記録しなければならない。
  もっと賢い方法はないだろうか。
  反転は線形の関数である事を思えば、shift の量だけを記録すれば行ける気がする。
  反転が起こる度に、

    x = -x + (str.end + str.begin - 1)

  という事になる。i 回目での shift 量を

    shift[i] = str[i].end - 1 + str[i].begin

  とすれば、最終的な結果は、

    x[i] = -x[i-1] + shift[i],
    (-1)^i x[i] = (-1)^{i-1} x[i-1] + (-1)^i shift[i],
    (-1)^n x[n] = (-1)^0 x[0] + ∑[i = 1 .. n] (-1)^i shift[i],
    x[n] = (-1)^n x[0] + ∑[i = 1 .. n] (-1)^{n-i} shift[i]

  で求められるという事になる。但し、i の小さな shift の方が、
  より小さな範囲の directed_string に対応している。
  今、番号付けを変更して k = n - i とすれば、
  一番大きな単位の directed_string が k = 0 に対応する様になる。

    x[n] = (-1)^n x[0] + ∑[k = 0 .. n - 1] (-1)^k shift[n-k].

  これで行く。自身がないので様々な例に対してテストを実行して確認する。

    x[n] = (-1)^n (x[0] + ∑[i = 1 .. n] (-1)^i shift[i])

* tty_player (SGR): ANSI font [#D0012]

* bidi サポート [2016-10-02] [#D0011]

  具体的にどの様に実装するべきかについて。
  これは ECMA TR/53 の Appendix にある動作例が参考になる。

  思っていたのと似たような動作を考えている様だが、実際にはもっと複雑である。
  具体的には nested strings という仕組みが問題である。
  行の中に配置を反転して表示するべき領域を埋め込むという構造は想定していた。
  しかしその様な文字列を幾らでも入れ子にする事ができる様なのである。

  問題点が二つある。

  1 先ずその様な入れ子構造を表現するのに適したデータ構造は一体なんであろうか。

    勿論、愚直にそのまま実装すれば実装できない事はないが、
    パフォーマンスなどへの影響が気になる。
    特にこの様な、実際に使う人が本当に存在するのかどうか不明な謎機能のために、
    フラットな配列の構造を諦めて何らかのリストの様な構造にするのは受け入れがたい。
    つまり、基本的には配列の構造にデータを記録しておいて、
    この様な埋め込み文字列の様な物を表現したい場合に特別な取り扱いをするというのが良い。
    その時にできるだけシンプルに最小限のデータサイズで記録する方法があれば良い。
    特に、入れ子構造を表現する為の固定長のデータ表現が存在しうるかという事である。

    例えば各セルにネストレベルを記録したらどうだろうか。
    そうしておけば同じ位置でネストレベルが複数段階変化する場合に対応できる。
    (ab[[cde]fgh]ijk の様な感じの入れ子構造が存在しうる。)
    しかしそれだと各ネストレベルでどの方向性を持っていたかという情報を保持できない。
    或いは完全に別のデータ構造として構造を保持するという手の方が現実的なのかもしれない。

  2 もう一つは後から編集が起こって別の文字を上書きした時に、
    どの様に更新範囲を検出するのかという事である。
    更に関連して編集の順序を記録しないでもちゃんと一意的に座標の対応を取る事ができるのかというのも気になる。
    また SHP や SLL を変更した時に既に出力した内容について
    どのような表示を行うべきかについても考える必要がある。

  うーん。その前にもっと詳しく動作について考えておく必要がある。

  文字列をどの様に記録するかについては 2016-10-04 に議論を残した。
  具体的に文字列の挿入を行う時にどの様に動作するべきかについては後で考える事にして、
  取り敢えずはデータ構造を確定する事にする。

  →データ構造は Memo 2016-10-04 にある通りに、
    方向付き文字列のリストとして表現する事にした。
    後で問題が起こればその時にまた変更すれば良い。


* SLL/SLH と DCSM の関係 [#D0010]

  | DCSM(PRESENTATION) の時 DCSM(DATA) の時で動作が異なる。
  | ここで問題になるのが実際に効くのは、
  | SLL/SLH を設定した時の DCSM なのか、
  | それとも実際に CR などを実行する瞬間の DCSM なのかという事である。
  |
  | もう一つ気になるのは、SLL/SLH を設定した時の DCSM が効くという場合に、
  | それを data component における座標に対応させる事は可能なのかという事である。
  | (つまり単に data component における座標を記憶しておくだけで良いのか、
  | 或いは、SLL/SLH を設定した瞬間の DCSM の状態も
  | 一緒に記録して置かなければならないのかという事である。)
  |
  | これを決定する為には、CR の動作を詳しく調べて、
  | それに整合する様に決めなければならない。
  | 例えば DCSM(PRESENTATION) で CR/LF を実行した時に、
  | LF によってカーソルが丁度下に移動する様にしたい。
  | もしくは DCSM(DATA) の時に CR/LF して、
  | LF によってカーソルが data component 内部で丁度下に移動する様にしたい。
  |
  | CR について調べた。CR 自体の動作が DCSM, SIMD によって、
  | SLL の値を使ったり SLH の値を使ったりという風になっている様だ。
  | そして SLL/SLH が設定された時の DCSM がどうたらという様な記述は全くない。
  |
  | a つまり、SLL/SLH の側では特に DCSM の値によって記録方法を変えたり
  |   という事はしなくて良い様に思う。
  |   それに、その方が自然である。つまり、DCSM や SIMD によらない
  |   一定の範囲が存在して、CR の方がモードによって変化するという事である。
  |   範囲自体が DCSM や SIMD を切り替える度に変化するというのは変である。
  |   一方で DCSM(PRESENTATION) DCSM(DATA) の切り替えによって、
  |   見た目の範囲が変わってしまう。
  |
  | b (他の例) DCSM(PRESENTATION) か DCSM(DATA) かに拘らず表示部での表示位置で
  |   記録するという様な実装も考えられたが、DCSM(DATA) の状態で
  |   SLL/SLH した行で表示部・記憶部で複雑な座標の対応になっている場合、
  |   記憶部での値で指定した列を表示部での座標に変換して記録する事になる。
  |   どの様に動作するかを予期するのが難しく、しかも使い所が分からない。
  |   うーん、訳が分からない。
  |
  | やはり自然なのは a である。
  | ECMA-48 の説明には SLL/SLH の項目で矢鱈説明がされていて、
  | SLL/SLH した瞬間に複雑な処理をしなければならない様に錯覚するが、
  | これらの説明は単に CR や他の制御機能にどう影響を与えるかを説明しているだけと思われる。
  | というか、CR や他の制御機能の説明の所に書かれている動作をそのまま再度説明しているだけで、
  | ECMA-48 SLL/SLH の部分に書かれている説明は冗長である。
  | 丁寧という事なのかもしれないが規格書らしくないし、却って混乱を招いている。
  | ここは単に "CR/IL/DL/NEL で参照される、行内の使用範囲の先頭列を設定する" とか書いておけば良いのだ。

  [結論]

  - SLL/SLH によって記録される情報は単に一つの列番号であり、
    DCSM の状態に応じて変化する様な物ではない。
  - 機能 CR/IL/DL/NEL を実行する際に、
    それぞれの機能が DCSM の値に応じて SLH または SLL の値を参照する。

* 双方向テキストに対応する際の動作について [2016-10-02] [#D0009]

  | ★例えば nested strings の中で行末に達して、折り返し処理をしなければならない場合にはどうすれば良いのか。
  |
  |   例えば [one [two [three] four] five] の各箇所で改行が起こった場合にどの様になるべきだろうか。
  |   但し一番外側の括弧で括られた部分は左から右で、その内側の括弧で右から左になり、更に内側で左から右になっているとする。
  |   折り返しがない場合には、[one [ruof [three] owt] five] という具合に表示される。
  |
  |   1 もう少し単純化する。[one [two] five] の場合はどうだろう。[one [owt] five] と表示される。
  |     これで tw の直後で改行が起こったとする。こうか?
  |
  |       [one [wt
  |       o] five]
  |
  |     或いは、
  |
  |       [one [ow
  |       t] five]
  |
  |     元の言語の文章に於いて改行を考えるとすれば前者の様な気がする。
  |     しかし改行の後に一番左に配置されるというのは元の言語の文章ではないことだし、
  |     また、これはその言語の文章というよりも外側の言語に埋め込まれた物だと思うと、
  |     埋め込まれた部分の内部で内側の言語の改行ルールによる改行が行われるというのも変である。
  |     つまり、改行というのは一番外側のレベルで行われる物なので、
  |     一番外側の言語の規則で行われるべきものなのではないかという気がするのである。
  |     だとすると後者のほうが正しいという事になる。
  |
  |   2 具体的な例で考えてみないと感覚がよくわからない。
  |
  |     日本語は古くは右から左であったが、しかし、
  |     これは、基本的に縦書きで高さが狭い場合には右から左になるという事であって、
  |     本当に右から左なのかというと微妙だし、更にそこで改行を入れることがあるのかというともっと微妙である。
  |     それに普段使っている訳ではないので実際にこれで例を作ってみた所で感覚はよく分からない。
  |
  |     どちらの方が自然だろうか。これは縦書きの日本語の文章に含まれた英文でも同様の事が言えるだろう。
  |     英単語を右に 90 度傾けて印刷する場合には問題は起こらない。英語も日本語も上から下に流れるからだ。
  |     しかし、もし仮に英単語を左に 90 度傾けて印刷する事になった場合にはどうだろう。
  |     英語は下から上に読まなければならない。そしてその途中に改行が入った場合に、
  |     英単語をどの様に並べるべきだろうか。考えて見るにどちらでもありの様な気がする。
  |
  |     取り敢えず、埋め込まれている部分が短い場合には外側の言語のルールで改行し、
  |     内側の言語については一旦行内に全て配置してから見た目で改行を実行するのが自然そうだ。
  |     つまり、1 の例で言えば後者である。
  |     しかし、ある程度の長さの文章(複数行に跨る)が埋め込まれている場合には、
  |     1 の例で言えば前者の様にした方が自然な気がする。
  |     でもやはり総じて後者の方が良いような気がする。
  |
  |   3 ここで TR/53 の例で参考になる物はないか改めて調べてみる事にする。
  |
  |     うーん。途中で改行したりという事はしていない様だ。
  |
  |     % というかそもそもの SRS の動作がよくわからない。
  |     % →と思ったら勘違いだった。data component を見ていた。
  |
  |
  | ★一番初めに各 SRS や SDS の動作について確認しておくべきだ。
  |
  |   SRS 元々確立されている方向性とは逆方向の文字列の開始・終了を定義する。
  |
  |     [ECMA-48] における記述は以下の通りである。
  |
  |     但し、character progression (data component 内の文字の記録順序) は影響を受けない。
  |     つまり、data component の中で見ている限りには SRS はあってもなくても変わらない。
  |     ただ、presentation component における位置との対応を考える為には、
  |     SRS が何処で始まって何処で終わっているのかといった情報を記録する必要があるだろう。
  |
  |     また、"文字列" 中で CVT HT SCP SPD VT によって引き起こされる効果については定義されない。
  |     また are に関係する機能 DAQ, EPA, ESA, SPA, SSA は文字列の中では用いてはならない。
  |
  |   SCP
  |     これは表示の際の方向を指定する。
  |
  |     途中で改行したりした時に一体どういう扱いにするつもりなのかと考えて改めて ECMA-48 を参照してみると、
  |     この制御機能は "現在の行" 及び "それ以降の行 (subsequent lines)" に対して適用される物のようである。
  |
  |     では、既に確立した行に対してはどうなのだろう。例えばカーソルを移動してそこに何か書き込んだ時はどうなるか、
  |     これは TR/53 の動作を見るに、後で SCP してからその行に戻って其処に文字を書き込んだとしてもその行の
  |     characater path は変わらないという様に見える。それでは一旦カーソルを上に戻して、その場所で SCP したら
  |     一体どうなるのだろうか。もし subsequent lines というのが行番号が現在いる行よりも大きい全ての行、
  |     という意味であるのだとすれば既に表示している内容に影響を与えるという事になる。
  |     一方で、もし subsequent lines というのが新しく作成される行なのだとしたら、
  |     既に出力されている行については影響を受けないという事になる。
  |
  |     うーん。説明を読むと、現在の位置に既に書かれている内容をどの様に処理するかについては書かれているが、
  |     subsequent lines の内容をどの様に処理するかについては何も書かれていないので、
  |     新しく生成される行に対してのみこの character path が適用されると考える方が自然だろう。
  |
  |     然し、一方で subsequent lines in presentation component という表現もされれているので、
  |     見た目で現在行よりも下に表示されている全ての行に対して適用するという意味なのかもしれないが、
  |     もしそうだったとすると規格の文章にはミスがあるという事になる。
  |     既に表示されている内容についてどの様に処理するかは active line については記述があるが、
  |     subsequent lines については記述がない。しかし、"subsequent lines にも同様に適用する"
  |     だとかいう感じに簡単に一文付け加えるだけで済むはずなので、この記述がないという事は、
  |     そもそも subsequent lines は空の新しい行であるか、
  |     或いは規格を記述・確認した人たちがうっかりしていて思い至らなくて書き忘れたかのどちらかである。
  |     しかし、規格を記述するにあたって実現不可能な変な記述がないように参照実装ぐらいは行って、
  |     規格に問題がないかというのを確認するのが普通だと思われるし、
  |     特に記述がないという事は subsequent lines というのは新しく生成される行という事で問題ないだろう。
  |     →この解釈については escseq.html に記述する事にした。
  |
  |   TR/53 の二つ目の例を見る限り、文字列の中で新しく文字の挿入を行った場合は、
  |     入れ子のレベルはその部分におけるレベルに埋め込まれる形で文字が挿入される様だ。
  |     つまり、その場所に移動した時点でそこにある入れ子レベルに従う事になる。
  |
  |   結局、一通り ECMA-48, ECMA-TR/53 の内容を gh-pages/escseq.html にまとめた。
  |   結局不明な事は不明なままであるが、何が不明で何が分かっているかが多少すっきりした様に思う。
  |
  |   * 自動的な折り返しに際してどの様に振る舞うかについては記述はない。
  |   * 文字列の中で制御機能を用いて移動を行った場合にどの様に振る舞うかについても記述はない。
  |   * 文字列中での active data position は定義されていない。
  |     しかし TR/53 Annex A で何かしらの方法が与えられている様にも見える。
  |   % * "文字列" の中に後から文字を挿入して追加することができる。
  |   %   これはとても厄介である。
  |
  | ★文字列の入れ子構造は記録部に記録されるのか? そして後で挿入を実行できるのか?
  |
  |   % "文字列" の中に後で内容を追加する事はできるのかできないのか。
  |
  |   TR/53 の Example 2 を見ると、一度出力して確定した "文字列" の入れ子構造の内部に
  |   後から文字を挿入する事によって、入れ子構造を変化させる事ができるという様にも見えた。
  |   しかし、落ち着いて考えてみると実はそうではないのかもしれない。というのも、
  |
  |   1 先ず、規格を参照して見るに strings だとか nested strings の概念があるのは、
  |     data stream だけであって、data component や presentation component に関しては、
  |     string がどうのこうのという記述はない様に思われる。
  |     従って後になって入れ子構造がどうのこうのというのは変なのではないか。
  |
  |   2 また、別に入れ子構造を保持していなかったとしても、
  |     data component と presentation component でそれぞれ独立に文字の挿入を行って、
  |     同時に data position と presentation position の対応関係をセル毎に記録したとする。
  |     その様な動作をしている限りにおいては Example に出ているのと同様の効果が得られるであろう。
  |
  |     しかし何れにしても対応関係をセルごとに記録するとしても、
  |     文字が新しく来る度にその対応関係を大幅に更新しなければならない。
  |     少なくとも文字列が閉じるまでは入れ子構造を保持しておく必要がある。
  |     但し、文字列が閉じた後は内部の並び替えは起こらない物と思って、
  |     入れ構造を記録したデータについては削除しても良い。
  |
  |     然しながら、data/presentation positions の対応表を保持するぐらいであれば、
  |     実のところ元になった入れ子構造を記録しておいても良い気がする。
  |
  |
  |   さて、これを区別するためには TR/53 の Example 2 で挿入する文字列について、
  |   "方向を明示せずに挿入する"、もしくは "SRS 文字列を挿入する" という例があれば良い。
  |   文字列の入れ構造に挿入されるのだとしたら、"方向を明示せずに挿入" した結果、
  |   挿入点の方向に影響されて文字列が表示されることになる。
  |   一方で、単に指定した位置に data/presentation component 上で文字列を挿入するというだけであれば、
  |   "方向を明示せずに挿入" した結果として普通の文字列の向きで文字が表示されることになる。
  |   しかし、残念ながら "方向を明示せずに挿入する" 例も "SRS 文字列を挿入する" 例も載っていない。
  |   説明文には "Character insertion is always performed according to the presentation directions
  |   and the nesting level which are established by the data stream." としか書かれていない。
  |   data stream によって確立した nesting level が何処で記録されるかによって解釈が異なる。
  |   もし data/presentation component の各行・文字の位置で記録されるのだとしたら、
  |   入れ子構造を後から変更できるという事になるし、もし nesting level というのは
  |   実際にデータを受け取って書き込む時に保持するものなのだとしたら、
  |   後から文字列を挿入するのは単に data/presentation component 上の配列を見て挿入するだけという事になる。
  |
  |   と思ったが改めて SRS の説明を見ると "SRS is used to establish in the data component
  |   the beginning and the end of a string of characters as well as the direction of the string."
  |   と書かれている。つまり、SRS は data component 内部に入れ子構造を構築するという事になる。
  |
  |   それに data/presentation component の間の座標の対応を一つずつ覚えておく方法だと、
  |   結局どのように表示されているのかということが人にとって良く分からない物になる気がする。
  |
  |   [結論]
  |
  |   文字列の入れ子構造は記録部に記録する。
  |   そして文字の挿入は入れ子構造の内部で行われる。
  |
  |   但し、方向が異なる場合には新しく入れ子文字列を作って挿入するのが良いだろう。
  |   挿入点の方向について意識しなくても安全に挿入ができる様にするためである。
  |   というのはアラビア語など言語自体が方向性を持っている場合、
  |   明示的に SRS/SDS を指定しなくても反転文字列が設定されうる。
  |   その時に或る任意の場所に新しく文字列を書き込もうとした時に、
  |   挿入位置の方向に従って勝手に文字列が反転されてしまっては困るからである。
  |
  |
  | ★途中で折り返しや改行があった場合の処理方法としてどの様な物が考えられるか。
  |   先ず初めに、明示的な改行があった場合にはそのまま其処で改行してしまって良い。
  |   改行前の文字列の内容は前の行に表示し、改行後の文字列の内容は次の行に表示する。
  |   折り返しによって反転部分に改行が挿入された時の動作は微妙である。
  |
  |   a data [he][llo] presentation [eh/oll] (/ が折り返し改行挿入位置)
  |     (行毎に文字列の構造を管理し、表示内容は行分割してから方向を適用したものにする。)
  |
  |     行に入る部分までを一つの文字列の単位として切り、改行を挿入する。
  |     続きの部分はまた新しい文字列として開始する。
  |     この方法が一番単純であり実装に曖昧さが残らない。
  |     これだと外側の文字列に埋め込まれた部分文字列だという風に思うと不自然な結果になる。
  |
  |   b data [hello] presentation [ol/leh]
  |     (複数の行に跨って構造を管理し、表示内容は方向を適用してから行分割したものにする。)
  |
  |     外側の文字列に埋め込まれた形で行を構築して、その後で行を分断したという感じになる。
  |     しかし right-to-left の人にとって見れば読みにくい文章になるかもしれない。
  |     この方法だと改行に跨った領域に "文字列" が存在するという事を管理しなければならない。
  |     特に、後になって行を挿入したり行を削除したりした時に一体どの様に管理するのか謎である。
  |
  |     例えば文字列を構成するセルを一つずつ全て記録してリストにして保持するとする。
  |     - その時、最終的な結果を別の端末に転送する場合にはどうしたら良いのか。
  |       正しく転送する為には文字列を構成するセルの順序に従って端末内を
  |       色々に飛び回る様なシーケンスを生成する必要が出る。
  |     - ※例え文字列の内部で制御機能を呼び出す事が禁止されていたとしても、
  |       後になって行を追加削除したり文字を追加削除したり出来る様になっている以上は、
  |       "文字列" が連続になっている事は保証できないのではないかという気がする。
  |       或いは、挿入される行や文字は全て "文字列" の内部に追加されるという風に考えるのだろうか。
  |     - 然し、何れにしてもその様な実装は極めて不自然である。
  |       その様な動作を期待してそれに整合する様なプログラムを書くのは難しい。
  |       結局、多少動作が人間にとって不自然に思われても、
  |       曖昧さを含まない単純な規則で動作する様に実装しないと、
  |       アプリケーションプログラムを書くのが難しくなる。
  |       人間的に自然かどうかだとかそういった事に対して柔軟に対処するためには、
  |       そういったものは装置の側で対応するのではなくてアプリケーションプログラムの側で対応するべきである。
  |
  |     従って、この方法にするとしても開始点と終了点だけを保持して、
  |     それ以降に内部に行が挿入されたり削除されたりという事は気にしない様にするという手もある。
  |     つまり、開始点と終了点だけを素直に記録して、
  |     間に文字や行が挿入される場合には開始点と終了点も同じだけずらすという様な具合にしたらどうだろう。
  |     - しかし、色々と問題がある。例えば開始点と終了店の間で SCP をした時に行内容の位置がずらされるが、
  |       その時に、元々の文字列の内容があった領域は分断される事になる。
  |       間に新しく入った空白も反転の対象だと解釈すると表示が滅茶苦茶になり、
  |       SCP がどうのといった機能が効かなくなってしまうのでそれはない。
  |
  |   c data [hello] presentation [eh/oll]
  |     (複数の行に跨って構造を管理し、表示内容は行分割してから方向を適用した物にする。)

  色々に考えた結果、一定の結論を得た。
  この結論は 2016-10-04 の memo にまとめる。

  以上の事から "文字列" を管理するデータを行毎に管理する事にする。
  特に文字列を使用する事はそんなに多くない事から、実装の見通しが立ちやすい様なデータ構造を採用する。
  (開始点, 終了点, 方向) の三組を配列に格納し、未だ閉じていない文字列に関しては終了点に -1 でも代入しておく。
  implicit movement をしている限りは終了点の更新は行わない。


2016-09-27

* ECMA-48/9 の記述についてどうするか。 [#D0008]

  Control sequences や Control strings の中にある文字 (0xA0-0xFE) は、
  0x20-0x7E と同じに解釈しろと書かれている。しかし、これに愚直に従うと、
  Control strings で日本語などの文字列を送ることができなくなる。

  | というか、何故この様な仕様になっているかというと、
  | ECMA-35 (ISO 2022) に従って 7bit から 8bit に変換した時に、
  | GL に何を呼び出しているかに応じて変換後に 0x20-0x7E が 0xA0-0xFE に
  | map されてしまうという問題があるからなのだと思われる。
  | つまり escape sequences の内、CSI sequences や control strings は処理せずに、
  | ISO 2022 の sequences だけを実行してしまうことに問題がある。
  |
  | 例えばUTF-8 前提でやっている場合にはこの問題は起こらない。
  | あるいは ISO 2022 の sequences と CSI sequences
  | を同時に処理する場合にも問題は起こらない。
  | 然し、何処かに変な filter が入っていたりすると問題になる。
  |
  | 普通は端末とプログラムの間に文字コード変換が入ったりする事はない。
  | 問題になるとすればエスケープシーケンスを出力するプログラムの内部の問題である。
  |
  | | % 通常はエスケープシーケンスを出力する部分と、
  | | % 文字コードを変換する部分は分離されて設計されている。
  | | % 特にエスケープシーケンスを含む文字列を生成して、
  | | % それからそれをエンコードすると思われる。
  | | % UTF-8 にエンコードするという場合はどうなるだろう。
  | | % 多分受信側で先に UTF-8 をデコードするという仕組みにしている限りは何も起こらない。
  | | % では、ISO 2022 にする場合はどうなるだろう。
  | | % 先ず、制御文字の表現は決まっているので変な混乱は起こらない。
  | | % 一方で、0x20-0x7E が ISO 2022 を通した結果としてどの様に変換されるかは謎である。
  | | % もしかすると GR に割り当てられた上で 0xA0-0xFE というバイトで送られてくるかもしれない。
  | | % しかし、この場合は先に ISO 2022 から UTF-32 に戻してしまえば、
  | | % 結局元々の数値に戻るのでやはり問題は起こらない。
  | |
  | | つまり「送信側(アプリケーション)はエスケープシーケンスを生成してからそれをエンコードする。
  | | 受信側はUTF-32にデコードしてからエスケープシーケンスを解釈する」
  | | という取り決めにしている限りは途中の文字コードが ISO 2022 であろうと UTF-8 であろうと平気である。
  | |
  | | しかし送信側(アプリケーション)が通常文字列はエンコードしてから出力するが、
  | | エスケープシーケンスは直接書き込んでしまう、などという設計になっていると面倒だ。
  | | 受信側ではエスケープシーケンスと ISO 2022 のシーケンスを同時に処理する必要がある。
  | | その様にしておけば一応問題は起こらないのだろうと思われる。
  | | また UTF-8 だと 8bit C1 と UTF-8 を構成するバイトの区別ができないので死ぬ。
  | | ただ出力するエスケープシーケンスを 7bit C1 文字に徹していれば問題は起こらない。
  | |
  | | - gettext を使って国際化している場合などにはこれに該当すると思われる。
  | |   ただ、gettext で ISO 2022 を出力する際に毎回 GL を元の状態に戻すと思われるので、
  | |   先にデコードを実行してからでも問題は起こらない?
  | |   (そうでないと gettext を通さない英語のメッセージなどが文字化けしてしまう。)
  | |   UTF-8 の場合には 7bit エスケープシーケンスだけ出力する様に設計されていれば、
  | |   先にデコードして問題ない。8bit C1 を使っている場合にはそもそも論理的に
  | |   一意な切り出しが不可能なのでアプリケーションが壊れていることになる。
  | |   なのでそんなアプリケーションの事は気にしなくても良い。
  | |
  | | - gettext などは使わずに自前で文字列をエンコードしながら、
  | |   それでいてエンコード結果にエスケープシーケンスを挿入している場合は、
  | |   やはり問題が起こる。この場合は確かにエスケープシーケンスとデコードを同時にしなければならない。
  | |   しかし、そもそも stateful なエンコード形式を採用していながら、
  | |   そのエンコード結果を切り貼りする様なプログラムは壊れているとしか言いようがない。
  |
  | 以上の考察からまともな実装になっているアプリケーションの出力は、
  | 普通にデコードしてからその後で制御シーケンスの処理を行っても問題は起こらない筈である。
  |
  | もう一つの可能性は伝送路の途中に文字コード変換が挟まっている場合である。
  | この場合でもまともな設計のアプリケーションの出力する制御シーケンスならば、
  | 制御シーケンスは壊されずにちゃんと文字コード変換される筈である。
  | なのでこれも問題ないのではないかという気がする。
  |
  | さて、一方で気になる事もある。この ANSI (ECMA-48) が制定されたきっかけは、
  | 文字コードによってアルファベットなどの実際の数値が異なるので、
  | bit combinatinos (column/row) を用いて規格を記述する、という事である。
  | つまり、文字コードの変換をする前の生のバイト列に対して処理することを考えている。
  |
  | - うーん。プログラムを書く上では 'a' などと書くとそれがどの様にエンコードされるか (execution charset)
  |   が保証できないので危険で、だからこそ 0x61 などの様にして表現するわけだが、
  |   でもよく考えたら U'a' とか書いておけば済む話の様な気もする。
  |
  | これらの整合性については ISO/IEC 10646 に記述があるという事だった様に思うが
  | 一体どのようにしているのか実際に確かめてみる必要がある様に思う。
  |
  | http://kikakurui.com/x0/X0221-2007-01.html
  | [JIS X 0221/D.2.Note3] によると C1 の文字は U+0080 - U+009F を UTF-8 に変換した表現を持つとしている。
  | つまり、エスケープシーケンスを含んだ文字列を char32_t の列で作っておいて、
  | それをまるごとエンコードするという方式になっている。
  | [JIS X 0221/15] UTF-32, UTF-16 の時も同様のようである。

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそうしろと書かれている。
  それ以外の実装は駄目な実装なので気にしなくても良い様に思う。

  | しかし、ECMA-48/9 にある事を考えて、駄目なアプリケーションの為に
  | 途中で GL と GR が入れ替わったりする可能性を考慮に入れて、
  | CSI sequences だけは 0xA0-0xFE を受け入れても良い?
  | と思ったが例えばその後 UTF-8 に変換されたりすると、
  | 最早 iso 2022 でどの様な構成バイトを持っていたかの情報も失われてしまうので、
  | 下手に対応しないのが良い様に思う。
  |
  | うーん。改めて ECMA-48/9 を読んで見る。
  | 結局のところ iso 2022 の state に依らず同じ representation を
  | 制御機能に持たせたいが、その様にすると 7/8 bit 変換でぶれができるという事に見える。
  | そして実は iso 2022 の範囲内で扱っている限りに於いては 7/8 bit 変換のぶれは
  | 必ず GL/GR の入れ替わりしかないということが保証されているのだろう。
  | しかしそこに Unicode が入ってくると混乱が生じる。
  | Unicode から iso 2022 への変換は一意でない。
  | 同じ文字が複数の言語に含まれているかもしれないからだ。
  | だとすると GL/GR の文字化けは一旦 unicode にすると復元不可能という事になる。
  | というか文字化けとかそういうのに限らず、
  | "iso 2022 の state に依らず同じ representation になっている制御シーケンス" を
  | そのまま unicode に変換した時点で単射性が失われるので復元不可能である。

  ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、ECMA-48/9 の内容に対応する必要はない。

2016-09-24

* 取り敢えず 00/08-00/13 は実装しようと思ったが、ECMA-48 にある FF の説明が分からない。 [#D0007]

  screen では FF は単に無視される様だ。一方で ECMA-48/8.3.51 には FF は、
  列はそのままで、presentation component の中の次の form/page の
  page home position がある行に移動するという事になっている。

  然し、form だとか page とか page home position だとかは一体何なのか。
  仕方がないので ECMA-48 の初めの方の説明も見てみる事にする。
  presentation component だとか device (装置) について書かれているのは 6.1 である。

  | [ECMA-48/6.1.1, 6.1.3] presentation/data component とはそれぞれ行の集まりであり、
  | 行は文字を表示する位置の集まりである。
  | [ECMA-48/6.1.5] presentation が実際に表示される座標に関連する物であって、
  | data は内部的な座標に関連する物と考えれば良い。双方向 (bidi) の文字列表示に対応する為にある。
  | [ECMA-48/6.1.2, 6.2.4] presentation/data component はそれぞれカーソル (active position) を持つ。
  | active line/field/area/page はそれぞれカーソルが存在しているそれを指す。
  | [ECMA-48/6.1.5, 6.1.8] 両者のカーソルの位置は連動 (indirect movement) する。
  | [ECMA-48/6.1.6] 文字の挿入によるカーソルの移動は data component に作用する (implicit movement)。
  | [ECMA-48/6.1.7] 制御機能によるカーソルの移動は data copomponent もしくは
  | presentation component に作用する (explicit movement)。
  | 何れのカーソル移動の場合にも存在しない場所に移動しようとしたときの動作は処理系依存である。

  この説明の中で既に field/area/page などと言った定義の不明な語句が出てくる。
  もっと遡って調べる必要があるのか。最初の語句定義に色々載っていることに気付く。
  [4.2.7] Area: 範囲。連続する文字描画位置の集まり (必ずしも1つの行に含まれているとは限らない)
  [4.2.40] Field: ある tabstop から次の tabstop までの area (範囲)。
    但し、次の tabstop はその field には含まない。
  [4.2.56] Page: 連続する行の集合。
  [4.2.57] Page home position: presentation/data component の中でカーソルがそれ以上前へ動かせない位置。

  結局良くわからない。特に page が一体何なのかというのが分からない。
  というか出力のデバイスとして display または printer を想定するという事が書かれていたので、
  printer の場合には page というのはそのまま物理的な紙の事だと思って良いだろうか。
  だとすると、display を考える時には page という物を想定しなくても良いという事だろうか。

  改めて SPH/FF の説明を読んで見る。物理的な page だと思うとこの説明も納得が行く。
  page home position は紙を1枚送った後に何処にヘッドを置くのかという事に対応するのだろう。
  だとすれば display での自然な実装は、clear screen してから
  SPH の設定した位置を含む行に移動するという事だろうか。

  - ところで screen で試してみたが SPH にも対応はしていない様だ。
  - 次に xterm で試してみた所 FF は VT と同じ役割を持つ様に設計されている様だ。
  - mintty は xterm と同じ動作だ。
    沢山の機能を実装している RLogin はどうだろう→RLogin も xterm と同じく VT で実装している。
    SPH 等には対応しているのだろうか→対応していない様だ。
  - 更に RLogin の説明を読むと LF/VT/FF は全て同じ動作をする様だ。
    また LF で CR LF の動作になっている様に見えたのは仮想端末が LF を CR LF に翻訳しているからの様だ。
    基本的には全て VT の動作を行う。そして Mode 20 LNM でその動作を変更する事ができて、CR LF と同じ効果にできる。
  - これについて xterm でも確認を行ってみたが、やはり同様に LNM で VT/FF/LF の全てが影響を受ける様だ。
    また、何れも SPH 及び FF のそれっぽい実装には対応していない様だ。
    様々な端末における動作がよく分からなかったので包括的に調べる事にした。

  | 調査方法
  |
  | $ stty nl; printf '\e[20hhello\nworld\n\e[20lhello\nworld'
  | $ stty nl; printf '\e[20hhello\vworld\n\e[20lhello\vworld'
  | $ stty nl; printf '\e[20hhello\fworld\n\e[20lhello\fworld'
  |
  | - 仮想端末が勝手に \n を \n\r に変換しない様に設定する必要がある。
  | - Mode 20 LNM が設定されているかどうかで振る舞いが変わる。
  | - 更に現在位置が最終行かどうかで振る舞いが変わりうる。
  |   次の行を追加するかどうかで実装にぶれがある様だ。

  結果は gh-pages branch の escseq.html にまとめた。

* これから本格的に端末の機能を実装していこうと考えている。 [#D0006]
  しかし、多少プログラムが長くなってきたので再度構造を考えてからにする。

  window 自体はできるだけ plain な構造体にしたい。
  端末自体は window とは独立に "window を書き換える者" として実装したい。
  また window の描画先は "window の中身を写す者" として実装したい。
  つまり受動的なオブジェクトとして描画先を定義するのではなくて、
  能動的に window の中身を見て描画を行うのである。

  window を書き換える者の名前は何にしようか。案としては
  controller, painter, writer, layouter, application,...
  writer や application は一般的すぎる気がする。
  layouter は何か違う気がする。painter にすると、
  window を実際に描画する者の方は一体何になるのかという問題がある。
  controller も少々一般的というか余りしっくりと来ない。
  window を碁盤か何かと考えれば player と observer がいい。
  或いは window も board か何かに改名するか。
  (しかし、"player" はまた別の意味にも取れるかもしれない。)
  →取り敢えず各クラスの名前を変更する。

  出力に関しては現在は全体を出力する様になっているが、
  これは勿論効率が悪い。dirty section を管理する様にしなければならない。
  しかし一つの window に複数の observer がくっついている場合には、
  全ての observer で同じタイミングに同じ範囲を反映する様にするか、
  もしくは各 observer 側で dirty section を管理しなければならない。
  一つの window の履歴から各 observer の中で dirty section を再現するのは困難である。
  各セルについて version 番号を保持するという手もあるが効率的ではない。
  また、行の移動なども追跡したい。
  という訳で、やはり実際に window を変更するのと同時に dirty section を更新するしか無い。
  従って、実際の実装では (dirty section 情報を書き出すオブジェクト) を用意して、
  observer が自分の中に保持しているそれを、window の内部にあるリストに登録し、
  window は自分の状態が変更される度にそのリストにある dirty section オブジェクトの更新を行う、
  という仕組みにするのが良いのではないかと思う。

  何れにしても、出力部分を後で処理する事にする。
  それよりは先に実装するべきは player の方である。
  受け取ったバイトに応じて制御機能を呼び出すのである。
  また同時に UTF-8 のデコードも行いたい。
  一番初めに実装するべきは何か。UTF-8 のデコーダか。
  何でも良いから早く動くようにしたいという意味では、
  普通にバイトを受け取ってそれを書き出すという風にすれば良い。
  現在の put_char 関数を拡張する形で良いのではないだろうか。
  取り敢えず出力部分に関しては別のファイルに分離するか。

* is_ideogram_exclusive が使われていない -> fixed [#D0005]
* 49 が無駄に出力されている? -> fixed [#D0004]

2016-09-23

* 仮想端末の作り方については確か POSIX にサンプルコードが載っていたはず。 [#D0003]

  [[posix_openpt>http://pubs.opengroup.org/onlinepubs/9699919799//functions/posix_openpt.html#]] これ。

  ポーリングは O_NONBLOCK にするのが楽?
  [[ファイル入出力の基本 (IO モデル) を勉強する - フリーフォーム フリークアウト>http://d.hatena.ne.jp/cou929_la/20121103/1351950688]]

  あと exit とか _exit とか _Exit とか色々あるけれど何だったか。
  [[_Exit>http://pubs.opengroup.org/onlinepubs/9699919799/functions/_exit.html]]
  [[fork - Wikipedia>https://ja.wikipedia.org/wiki/Fork]] たぶん _exit でよい。

  一応何か起動した。
  bash: cannot set terminal process group (2692): Inappropriate ioctl for device
  と出るので子プロセスで setsid() しなければならない。

  さて、次に仮想端末の設定が変だ。どうも親プロセス側の仮想端末の設定がいけない様だ。
  (というか bash 側は bash 側でなんとかしているはずだ。)
  と、色々試行錯誤した後で以下の親切なページを見つけた。

  [[PTY を使ってシェルの入出力を好きなようにする - Hika Hibariya>http://note.hibariya.org/articles/20150628/pty.html]]

  簡単にできた。色々調べたりしながら分かった setsid や dup2 のことも全て書かれていた。
  初めから此処を見ていれば余り悩むこともなかった (然し理解が浅いままだったかもしれない)。
  あと、終了時に念のため子プロセスを kill しておくようだ。
  と思ったらこれらの事は詳細UNIXプログラミングという本に書かれている様だ。

2016-09-20

* バッファのデータ構造 [2016-09-19] [#D0002]

  行の管理

    行の管理はB木が良い様に思われたが、世の中にはスキップリストというデータ構造もある様だ。
    平衡を保つ仕組みは複雑になりがちだがそれから開放されるというのが売りの様である。然し実際の所どうなのだろう。
    Wikipedia によるとやはりリスト構造であるが故に遅いという様なことが書かれている。
    もっと調べると、M分木にすればB木だと logN/logM になるが、
    スキップリストだと M logN/ logM になるとある。考えてみれば確かにそうだ。
    連続添字の配列として使う場合は、赤黒木よりは良いけれど B 木には及ばないという所ではないか。
    しかしながらスキップリストには、アルゴリズムが簡単なお陰で並列処理・非同期処理などで分がある様だ。
    しかし、もし一旦画面の外に出た部分で内容の更新が起こらないのだとすれば、
    わざわざB木にしなくても単なる配列(or linked array)で良い。
    表示領域の高さは精々数百行なので挿入などは大したことない。

  文字の管理

    % 文字の管理はどうするのか悩ましい。
    % 一つの方法は列数と同じ要素数の配列を用意して、
    % その文字が表示される位置に文字を書き込むというものである。
    % しかしそれだと grapheme clusters に対応するのが苦しい。
    % 外字的な取り扱いにして新しい種類の clusters が来る度に登録を行うという手がある。
    % メモリリークを防ぐためには参照カウンタ方式にでもするか。
    % 遅そうではあるが、普通の文字を扱っている分には overhead がないというのは良い。
    % 一方で、proportional な font を許すような terminal を考えるとこの方法は苦しい。
    % (そもそもそんな物があるのか分からないし、あったとしても各文字の幅や
    % kerning などをどの様に取り決めておくのかという大きな問題がある。
    % 取り決めをしておかないと表示が乱れることになる。)
    %
    % 或いは、初めから可変長な文字の存在を受け入れて、
    % 要素が可変長な配列みたいな構造にしてしまうという手もある。
    % メモリ的にはこれが最もコンパクトである。UTF-8 を使うことにすれば
    % 通常のアルファベットを扱っている限りは各文字 1B しか消費しない。
    % 但し文字幅などの補助情報を持たせるとすると結局 2B になるか。
    % この時の問題はその様なデータ構造は前代未聞なので効率良い実装が可能なのかという事である。
    % 特に index を指定した時に対応する cluster を特定するのに必要な補助情報と計算時間である。
    % 補助情報が一切ないと先頭から順に文字を区切って行かなければならず不毛である。
    % 一応 B 木の各節で、下にぶらさがっている cluster の数を保持しておけば大分ましになる。
    % 問題は B 木の葉である。一つの方法は 1 cluster 1 byte の配列 (A) と、
    % 実際の文字の羅列を記録した配列 (B) の両方を保持して、
    % (A) に (B) 内での index を記録する方法である。
    % 然し、この方法だと単一の grapheme cluster の合計サイズに制限がかかってしまう。
    % また、その葉に含まれる全データサイズにも制限がかかる。
    % しかし、B木の容量を要素数ベースではなくデータ量ベースにするという手もある。
    % 更に一つの cluster が複数の葉に跨る事も許すことにすれば良い。
    % しかし効率の面から言ってこの方法は本当に得策なのか。
    % そもそも端末画面の横幅というのは上限がある。
    % 1行の文字数に制限のないエディタを作るのでないかぎりはB木にする必要もない。
    % また、端末での操作は基本的に挿入ではなくて上書きである。
    % なので各配列要素が各列に対応する様な設計の方が自然である。
    % やはりその様な側面から考えてもB木にするのは大げさである。
    %
    % やはり struct { char32_t ch; int32_t flags; } の配列のような構造にするのが無難だろうか。
    % しかし大抵の場合アルファベットの plain な配列だという事を考えるとこの表現はやはり無駄が大きいように感じられる。
    % この構造をベースに考えて、より効率化するという方向で考えられないだろうか。。
    % 例えば普段は char 配列で考える事にして、unicode 文字等の場合には何らかの特別な文字を使う。
    % そして unicode 文字本体の情報は別の所に格納する。
    % しかし何処に格納するのか? 格納位置を直接表現しようと思えば sizeof(void*) のデータが必要であり、
    % これだとそもそも char32_t と同じ大きさになってしまう。
    % だからと言って char の 128-255 の値を index に使おうと考えれば 128 文字しか unicode 文字を扱えない。
    % 或いは、128文字ごとに buffer を切り替えるというのも手なのかもしれない。うーん。
    % 然しそれだと初めから char32_t*128 の領域を確保しておくのと較べて得しているのかどうか怪しい。
    % 何より大量の文字が流れている場合、結局最終的に char32_t*画面の広さ 分だけの領域を確保する事にもなりそうである。
    % その場合には、初めから char32_t で全部領域を確保しておけば良かったという結論になりそうである。
    % 計算してみると、例えば sizeof(char32_t)*210*80 = 67.2 KB である。
    % 全部 char で済んだとしても 1/4 になるだけである。何かどうでも良い気がしてきた。
    % 実際に動いているプロセスを見ると普通に MB 食っている。
    % 16bit マシンならば 64KB もしくは 32KB に収めないといけないのかもしれないが、
    % 実のところその様なマシンで動かそうと思ったらプログラム自体をコンパクトにせねばならずそちらの方が問題だ。

    結局、char32_t ch の単純な配列で管理するのが良さそうだ。
    余計にメモリの確保解放を繰り返さない為には、初めから領域と同じ大きさの配列にしてしまう。

    Grapheme cluster は上限の大きさを決めておかないと攻撃が可能になってしまう。

  属性の管理

    さて次に考えるべきは属性をどの様に管理するのかという事である。
    実際の使用される状況を考えると、以下のことが言える。
    - 多くの場合は属性は設定されない。特に大量のデータを出力する場合。
    - 属性が設定されているとしても各文字ごとに設定されることは少なくて、
      連続する文字は完全に同じ属性を持っている可能性が高い。
    - colorful な実装にするにしても xterm 256color までが普通で、
      24bit color 等を出力する様なプログラムは稀である。
    勿論、これに反する様ないじわるなプログラムも作ることはできるが、
    上記の様な状況に対して効率の良いような実装にしてしまっても問題ないと思う。

    どのようにするのが良いか様々な実装について考えてみる。
    一番単純な方法は文字のデータと一緒に管理するという物である。
    しかし、実際に描画する時には一文字ずつ属性に応じて描画するというのは効率が悪い。
    普通は同じ属性の物をまとめて描画するという様にする筈である。
    実際に描画を行う場合には属性が連続しているかどうかを確認して出力を行うことになるだろう。

    もう一つの方法は Poderosa で使われている方法である。属性オブジェクトへのポインタを各セルに保持しておいて、
    描画する際の同じ属性の連続かどうかの判断はポインタが一致するかどうかで判定するという方法である。
    しかし、これが本当に効率的なのかどうかは怪しい。先ず、単に文字を描画すると言っても、
    複数の段階がある。まず初めに背景画像を描画し背景色があればそれを描画する。その後で文字を描く。
    各ステップで使用される属性が異なるので同じ属性が連続しているかどうかの判定も、
    属性オブジェクトをひとまとめにして行うのではなくて、
    関連のある属性のみに絞って連続しているかどうか判定した方が良さそうな物である。
    また、属性オブジェクトの確保・解放などの操作にもコストがかかる様な気がする。
    基本的な属性に関して言えば十分 32bit におさまるので
    32bit/64bit のポインタで属性オブジェクトを参照する方が余程メモリを食う。
    Poderosa の方法だと拡張性が高いのは良いが効率面で余り良くないだろう。

    あるいは Poderosa の様に属性オブジェクトを作るまでではないが、
    属性に変更があるという意味のフラグを char32_t の内部に置いて
    (unicode はどうせ 10FFFF までなのでフラグを幾つか設置する自由はある)、
    別の箇所に属性データを記録するという風にすることも可能だろう。
    しかし、その場合属性データはどの様に保持するべきだろう。
    属性に変更があったかどうかのフラグだけでは属性データに対する参照にならない。
    一つの方法は配列にして適用対象の文字と同じ位置に属性データを格納する事である。
    しかしこの方法だと初めから文字と一緒に属性データを記録するのとメモリ効率的に変わらない。
    逆にメモリの管理や参照が複雑になるだけで意味がない。
    もう一つの方法はハッシュテーブルや平衡木などを用いて sparse な map にするという物である。
    これならばメモリを節約できる。しかし、そこまでする程の事なのかという疑問が残る。
    特に高が属性を参照するのに一々毎回複雑なデータ構造を辿るというのは非効率的に思われる。

    結局、基本的な属性の範囲であれば文字のデータと一緒に固定長で管理をし、
    特別な種類の属性を含む場合にはそれを示すフラグと拡張属性データの index を埋め込む。
    拡張属性データは別の一つの配列に入れておいて管理すれば良い。
    同じ属性が連続して続く場合を考えれば拡張属性データは複数の文字から参照できる様にして、
    また参照カウントを用いて管理するのが良いだろう。

    基本的には各セル struct { char32_t ch; uint32_t flags; }; を保持する。
    基本的な属性に関しては flags に格納する事にして、
    特殊な属性を含む場合には或るフラグを立てておく事にする。
    そのフラグが立っている場合には、別に持っている拡張属性データ用配列にデータの格納を行う事にする。
    拡張属性データの配列要素は、参照カウントと基本属性と更に拡張属性データへのポインタを持つ。
    char32_t ch に収まらない様な unicode grapheme clusters についても同様に処理を行う。


  他に必要なデータはあるか

    他の実装も確認してみる。

    yaft.h を見ると、先ず気づくのは文字データは一つのオブジェクトとして生成し、
    セルはそこへのポインタを保持する。更にセルは uint8_t fg, bg と、
    enum char_attr attribute と、それから width まで保持する。
    加えて sixel support としてセル内部に bitmap データまで持つ
    (これはセルのサイズが固定だからできる事であろう)。
    yaft の目的上、メモリ使用量の上限が分からない動的なメモリ確保ではなくて、
    使用メモリ量の計算がしやすい固定的な割当になっているという事だろうか。
    また、glyph に関してはビットマップに結びついているので、
    予め用意された文字しか扱えない。当然、grapheme clusters に対応しているとは思われない。

    struct cell_t {
        const struct glyph_t *glyphp;
        struct color_pair_t color_pair;
        enum char_attr attribute;
        enum glyph_width_t width;
        bool has_bitmap;
        uint8_t bitmap[BYTES_PER_PIXEL * CELL_WIDTH * CELL_HEIGHT];
    };

    sixel もしくは端末の特定の領域に設置される挿入オブジェクトを管理できる様にしたい。
    当初は属性データに持たせる事を考えたが、属性データは複数の文字で共有されるという性質があり、
    しかし一方で挿入されるオブジェクトは或る位置セルに紐付けて管理した方が良い気がする。
    あるいは領域に属する全てのセルで共有しても良いが、何れにしても属性と同列の物ではない気がする。
    だとすれば flags とは別に更に拡張可能なオブジェクトを設定するべきか。
    もしくは grapheme clusters の別種として管理するべきか。それが良い気がする。
    例えば sixel オブジェクトと文字を両方保持しなければならないという事はなさそうに思われるし。

    tmux.h を見るとどうやら文字データは UTF-8 で保持している様だ。
    5 bytes で属性・フラグ・色・幅・UTF-8の長さを持つ様だ。
    不思議なのはこの実装も "幅" を保持している事である。
    幅なんていう物は右のセルに続いているかどうかだけ見れば良い気がするのだが。
    文字のデータには 9 bytes 使っている。そんなに使う文字は存在していただろうか。謎である。
    特定の grapheme clusters だけは扱える様にしているのかもしれない。

    #define UTF8_SIZE 9

    struct grid_cell {
            u_char  attr;
            u_char  flags;
            u_char  fg;
            u_char  bg;

            u_char  xstate; /* top 4 bits width, bottom 4 bits size */
            u_char  xdata[UTF8_SIZE];
    } __packed;

    screen については何処に定義があるのだろう?? image.h の struct mchar, mline?
    どうも screen がどういう処理方法になっているのか色々見ても見えてこないが、
    取り敢えずそれっぽいものはこれしかない。
    文字に関しては恐らく image と mbcs に分割して格納されている。
    ASCII の範囲内であれば image で、そうでなければ mbcs に続きが格納されるという事だろうか。
    他に色と属性とフォント(?)がある。./configure --help を見たがフォントが何か分からなかった。
    面倒なのでこれ以上は深追いしない。しかし前から思っていたがやはり screen のソースコードは汚い。

    struct mchar {
             unsigned char image;
             unsigned char attr;
    IFFONT(  unsigned char font; )
    IFCOLOR( unsigned char color; )
    IFCOLORX(unsigned char colorx; )
    IFDWCHAR(unsigned char mbcs; )
    };

    struct mline {
             unsigned char *image;
             unsigned char *attr;
    IFFONT(  unsigned char *font; )
    IFCOLOR( unsigned char *color; )
    IFCOLORX(unsigned char *colorx; )
    };

    mintty は term.h に一連の定義がある。
    mintty の構造は他のプログラムに較べてよく考えられた構造になっている。
    綺麗だ。他のプログラムが俄然ごみの様に思われてくる。詳しく見てみる事にする。
    - 気付く事は、色は初めから true color 前提で書かれている。
      256色前提の場合パレットを変更した時に既に表示した文字の色も変わってしまうので、
      理想的にはパレットの変更に追随させておけば背景黒と背景白の切り替えなどをしても見にくくならない、
      等の利点があると考えられるが実際にはそううまくは行かない。
      複雑な出力や様々な色を表示するプログラムの場合、パレット変更は普通は想定しない。
      パレットが変更されたときのことまで考えて設計するのは困難な為である。
      それを考えると true color 前提で書いた方が本当は良いのかもしれない。
    - もう一つ気になるのは grapheme clusters の取扱である。
      複数の文字が一つのセルに含まれる場合には、
      各文字毎に 文字&属性&cc_next(=リスト用) を保持する様になっていて、
      更に、同じセル内の次の文字 cc_next は相対位置で表現している。
      配列中で未だ使用されていない文字は termline::cc_free を先頭として、リストで管理している。
      よく考えられた設計である。気になるのは combining characters が沢山来て、
      行内の文字数が SHRT_MAX を超えた場合に何が起こるのかという事である。
      ちょっと見た所、何も対策がなされていない気がするがいいのか?
      後、相対位置にする意味があるのかというのも可也謎である。
      というか相対位置にしていると行内の文字を削除して
      切り詰める時に余分な操作が必要になってしまう気がする。
      もう一つは文字を格納する領域を行単位で管理している事である。
      これだと部分スクロールなどをする場合に文字の移動と一緒にリストを再構築しなければならない。
      一方で利点もある。行の生成・削除が簡単だという事である。
    - また sixel に関しては特殊な文字コード 0xFFFC で表現している。
      恐らく文字がこれになっている場合には其処には文字ではなくて画像が入るという事なのだろう。
      これの意味する所は端末の文字サイズ拡大縮小に際して
      埋め込み画像のサイズは一緒に大きくなったり小さくなったりするという事である。
      しかし下手に埋め込み画像をピクセル単位にしてレイアウトが変わったりするよりは、
      出力したときの領域をそのままに画像も一緒に大きくなったり小さくなったりするのが自然である。
      また U+FFFC は OBJECT REPLACEMENT CHARACTER で place holder の役割のある Unicode 文字の様だ。
      画像本体はどの様に管理しているのかと思ったら struct term の中に保持している様だ。
      恐らくこの中に画像の表示位置などの情報も含まれているのだろう。
    - 属性も様々な属性がある。
      bold dim underline italic reverse invisible blink
      doubleunderline overline protected wide/narrow/expand
    - temp_strage_t は temp_storage_t のつづり間違いではないだろうか。

    typedef struct {
      unsigned long long attr;
      uint truefg;
      uint truebg;
    } cattr;

    typedef struct {
      short cc_next;
      wchar chr;
      cattr attr;
    } termchar;


  結論

    エディタとデータ構造を共有する (エディタにも転用可能にする) のであれば、
    巨大なファイルに対して行の挿入などがスムーズにできる様に B 木にする。
    また、proportional なフォントに対応するために列と配列要素を対応させる構造は使えない。
    ファイルへの書き出しが楽になる様にするためには、
    ファイルに書き出すデータをそのまま保持するようなデータ構造の方が良いかもしれない。

    しかし terminal 専用に設計するのであればより簡単な実装になる。
    流れたデータは単に末尾に追加可能な配列に溜めれば良いし、
    行のデータも長さ決め打ちで良い。
    端末の領域と同じサイズの単一のメモリ領域でも allocate すれば良い。
    効率を考えれば terminal 専用に設計して、特殊な機能に関しては例外的な方法で処理するのが断然良い。

* 名称 [2016-09-18] [#D0001]

  [議論]

  名称を決めよう、と思うが良い名前は何だろう。
  変に凝った様な名前は嫌なので短いのが良い。でも他とは被りたくない。
  混同しやすいようなものや検索しにくいものも万一のため避けたい。

  暫定的に tty1 (単に tty の初めての実装ぐらいの意味) としたが、
  これは既に /dev/tty1 と被っていてよくない。それに version 番号をつけにくい。

  端末の名前といえば、*term *tty などが多い。
  この系統にするとしたら一文字入れるのが良い。
  然し未だ使われていないものが良い。
  - xterm は言うまでもない。
  - iTerm は Mac 用の物。
  - aterm はルータの製品名に使われている。
  - atty は isatty を思い出す。isatty は何の略だろう。"is a tty" ということか?
  - stty は仮想端末の設定を行うコマンドである。
  - RTTY とはアマチュア無線×TTYのこと??
  - VTTY というのも既にあるようだ。

  関連して pseudo-terminal を pty としたりする様だが、
  それだと pseudo-typewriter にならないか?
  それに、近くにあるコンソール tty に tele という語句が入って、
  遠くにあるリモートに繋がっている pty で tele が抜けていることになり妙だ。話がそれた。
  何れにしても ty だけを取るというのも手なのである。
  - mty とか vty とか…? 三文字だと流石に既存のコマンドなどと被るだろうか。

  screen 系列で行くと
  - 例えば tmux がある。これは terminal multiplexer の略である。
  - また、byobu というのもある (単なる設定集の様な物だが)。
    これは screen の言い換えだ。

  contra

    ふと昔書きかけたプログラムの事を思い出した。contra という名前だった。
    エスケープシーケンスを翻訳して TERM に応じた出力に変換する為の物である。
    もしくは Windows のコンソールに対して出力を行ったりもできる様にするという目的だった。
    これと合流するのが良い考えである様に思う。
    名称も contra に変更する。

    というのも今回のプログラムの構想としては、

    1 端末の内部状態と描画部分を分離する
    2 描画部分は "他の端末に対する制御シーケンス" だったり、
      あるいは "GUI ウィンドウに対する描画" だったり、
      容易に切り替えられる様にする。
    3 端末の内部状態に対する操作は、
      "プログラムから直接操作" したり、
      "制御シーケンスを解釈して操作" したり
      色々切り替えられる様にする。

    ということであったが、一方で contra は制御シーケンスの解析
    と制御シーケンスの解釈部分を分離して、
    制御シーケンスの適用先をまた別の端末にしたり、
    或いは Windows のコンソールやその他の GUI Window にしたりという事だった。

    これらは容易に統合してより機能を綺麗に整理する事ができる。

    - icontrol_function_processor

      制御シーケンスからデコードされた制御機能の呼び出しを処理する。

      実装として二通り考えられる。内部端末に対する操作を行うもの。
      それから他の端末に対する制御シーケンスを生成するもの。

      - tty_writer: icontrol_function_processor を実装

      - window_writer: icontrol_function_processor を実装

    - tty_reader

      制御シーケンスを解釈して icontrol_function_processor を操作する。

    - iwindow_target

      window の内容を表示・出力するための物。様々な実装が考えられる。

      - tty_target

        m_proc = icontrol_function_processor に対する操作として実装する。
        特に m_proc が tty_writer の場合には端末に対する出力になるし、
        或いは window_writer の場合には window の簡易複製になる。

      - x_target
      - gdi_target
      - console_target

        様々な GUI interface やコンソールに対する描画として実装しうる。

    以上を組み合わせれば様々なプログラムを容易に実装できる。

    - 例えば、tty_reader -> tty_writer を組み合わせれば、
      制御シーケンスの翻訳として動作する。

    - 或いは、tty_reader -> window_writer -> tty_target を組み合わせれば、
      screen の様なことができる筈である。

    - もしくは tty_reader -> window_writer -> x_target とすれば、
      新しい terminal emulator を実装できる。
      特に、様々の target を実装するだけで様々な環境に移植できる。

    さて、ここまで考えたのはプログラム→端末のデータの流れについてであるが、
    逆に端末→プログラムのデータの流れ (主にユーザの入力操作) についても
    同様に綺麗に扱うことができる。

    - キーシーケンスの解釈部: キーシーケンスを操作のイベントの列にする。
    - イベントの列を処理する部分:

      例えば、直接ここにプログラムを実装してしまっても良いだろう。
      或いは、また TERM に応じたキーシーケンスに翻訳しても良い。

  [結論]

  contra にする。更に、元々 contra という名前で書いていたコードと順次統合する。
