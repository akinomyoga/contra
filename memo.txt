# contra dev note


------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

2018-02-19

* データの表現方法

  行内の文字ではなくて行内の各文字位置(半角)に対して board_cell を保持する。
  board_cell は二つのメンバを持つ。

  - character_t character (32bit)
  - attribute_t attribute (32bit)

  character は character_flags と文字コードのビット和になる。
  character_flags として何も指定されていない時、値は Unicode である。
  character_flags として is_wide_extension が指定されている時、
  その領域は半角よりも大きな幅を持つ文字の余白である。

  is_wide_extension は一定の大きさの文字を格納する時に
  各セルに対応して board_cell がある。


2016-10-11

* 全角文字の取り扱い

  - ECMA-48/6.1.6/2 暗黙的移動 (文字挿入に伴って起こる) によって現在記憶位置は一つ次の文字位置に移動する
  - ECMA-48/6.3/3 行は予め決められた数の文字位置からなる
  - ECMA-48/6.3/5 文字位置の大きさは其処にある文字に依存しても良い

  これらの記述を総合するに、ECMA-48 では全角文字は複数の文字位置を専有するとして実装されるのではなく、
  文字位置自体の幅が大きくなって実装されるという想定の様である。しかし、この仕様は現実の実装と異なる。
  更に、行に含まれる全角文字の数に応じて各行の大きさが異なるという事になるし、
  また、CUU CUD CUB CUF などの制御機能でどの様にカーソルが移動するかを計算するのが困難になる。
  contra では ECMA-48 に従った実装は行わず、現実の端末と同様の方法で全角文字を取り扱う。

2016-10-04

* 方向付き文字列 (SRS/SDS string) の取り扱い

  0 文字列の定義によって記憶部上の文字の配列に影響は出ない様にする。

    # これは双方向に対応していないアプリケーションでアラビア語や
    # 双方向制御を含む Unicode 文字列を取り扱っても問題が生じない様にする為に必要である。
    # それに記憶部ではできるだけデータの受信順序を保ちたい。

  1 記憶部で文字列の開始終了の情報を記録・管理し、
    これらの情報から一意的に表示部での配列を再現できる様にする。

  2 行にまたがる文字列構造は管理しない。
    受信したデータの中に改行が含まれている場合や、折り返し処理によって行が分割される場合、
    一旦文字列を全て閉じて改行してから再び文字列を開いたかの様に動作する。

    # 理由は複数ある。
    #
    # + [明示的な改行との取り扱いの一貫性]
    #   明示的な改行が含まれている場合は改行前の文字列は前の行に、
    #   改行後の文字列は次の行に表示する。
    #   行折り返しによる暗黙的な改行も同様に取り扱うべきである。
    #   そうしないと暗黙的な改行が挿入された後に、
    #   再度その内容を別の装置に転送する時に、
    #   文章の順序が保たれなくなってしまうからである。
    #
    #   ※暗黙的な改行を区別して記録すれば良いという意見もあるかもしれない。
    #     しかし、様々な制御機能を経た後にそれが意味論的に
    #     まだ暗黙的改行として扱ってよいかなどを決める規則は難しい問題である。
    #     それに暗黙的な改行を区別する為のデータ表現も色々考えると難しい。
    #
    # + [行毎にSCPした時の取り扱い]
    #   行毎に SCP で character path を切り替える事ができる。
    #   例えば SRS 文字列が複数の異なる character path を持つ行に跨っていた場合に、
    #   どの様にその文字列の "範囲" を表現するのかや、
    #   それをどの様に整合的に表示するのかなどに曖昧な点が生じる。
    #
    #   例えば、文字列の各行に含まれる部分を切り出して一つの文字列としたのと
    #   同様に表示するという取り扱いにするのが自然だろう。しかし、
    #   その様に取り扱うのであれば、初めから各行毎に文字列を分割して管理したほうが良い。
    #
    # + [SCP による複数行表示との一貫性]
    #   例えば単に複数行のアラビア語を表示するとして、
    #   SCP を使用して出力する場合と、出力文字列全体を SRS で囲む場合を考える。
    #   前者では次の行は前の行の下に表示される。
    #   後者でも次の行は前の行の下に表示された方が動作として一貫している
    #   (それに読みやすさの観点から言ってもその方が良い)。
    #
    # + [行内での完結]
    #   表示する際に文字の並び替えは行内で完結していたほうが取り扱いやすい。
    #   ある所に表示する内容が別の行に含まれるというのは始末が悪い。
    #   それに座標の計算をする際に考慮に入れるべき範囲の長さに上限がなくなるので、
    #   そういう意味でも複数行に亘る文字列というのは都合が悪い。

2016-09-27

* ECMA-48/9 には対応しない。

  [2016-09-27 の考察の結果を抜粋する]

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそういう前提の内容がかかれている (15 および D.4.Note3)。
  それ以外の実装は駄目な実装なので気にしなくても良い。

  もともと ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである (ECMA-48/1)。
  意図的に 10/00 - 15/14 を使って制御シーケンスを記述するための物ではない。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、そもそもの前提が崩れるので、
  ECMA-48/9 の内容に対応する必要はない。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2019-04-29

2019-04-28

* trace_line_scroll は DECSLRM,DECSTBM に対応している端末では
  表示幅が全体でなくてもこれらを使って対応できる筈。

  また、is_terminal_bottom での処理に関しても、
  DECSTBM が設定できるのであれば敢えて挿入する必要はない筈である。

* vttest: ESC ( B, ESC ) B, ESC ( 0 等を出してくる。
  文字コード関連も整備した方が良いのだろうか。

* 画面サイズが変更された時に端末に通知していない気がする…。
  tty_observer でちゃんとサイズ変更を検知して、
  更に出力しなければならない。

  というか変更された瞬間に実行するべきなのか、
  或いは表示する瞬間に実行するべきなのか。
  これは恐らく変更された瞬間に実行するべきである…。
  もし変更を指示したのがそのアプリケーション自体であった場合、
  アプリケーションは画面サイズの変更通知を待たずに、
  そのサイズを前提とした処理を実行してくるはずだからである。

* カーソル形状等に関しては表示の瞬間に前回と変更がないかを見て変更すれば良い。
  また decscnm (背景・前景反転) に関しても。描画の瞬間にチェックすれば良い。

2019-04-27

* [保留] なめらかなスクロール (mode_decsclm)

* tty_observer: Mode ?8 の変更を外側に伝達

* 他にも外に伝達するべき mode 変更について考える必要がある

  実は Mode ?5 の変更に際しても term から tty_observer に伝達があると良い。
  或いは tty_observer 側で前回の状態を記録しておいて丁寧に差分を取るか。
  しかし、volatile に変更を外に伝達したい場合もあるのではないかという気がする。
  (具体的には今は思い浮かばないので volatile な伝達は必要になってから考えれば良い。)

* 入出力の順序等に関して

  * 現在の実装で yes を実行したらどうなるのか確認した
    ちゃんとすぐに C-c が通じて yes を終了する事ができる。
    そう。本来そうでなければいけないはずなのである。

    一方で、他の端末はどうなのだろう。実は Poderosa が駄目なだけなのでは。

    - と思って試してみると xterm も RLogin も C-c
      を押してからだいぶ経ってから yes が終了する。

    - mintty に関してはそもそも yes を終了することもできず、mintty 自体がフリーズしてしまう。
      CPU 100% になっている訳でもなくデッドロック状態になっている様に見える。

    - 後、今気づいたのだが文字を入力していると Poderosa は結構 CPU を食っている。
      これはどうやら Google IME が CPU を食っているという事の様である。
      日本語の入力をしている時には 10% ぐらいになるが、
      英語の入力をしている時には上に上がってこない。

2019-04-23

* 縦スクロールの外側端末に対する描画に関して

  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)
  terminal multiplexer で縦スクロールをどの様に外部に伝達するのかについては
  確かに面倒であるという事が議論されている。

  a 例えば縦スクロールの直前に画面を全て更新して
    縦スクロールのシーケンスを送信するという手がある。
    しかし、そうすると縦スクロールを全て送信しなければならなくなる。
    大量の出力の末にスクロールしきった一番最後の状態を表示するというのができない。

  b 特に、画面が隠れていた時に行われた縦スクロールはどの様に処理するのか…。
    と思ったが、実はそれは気にしなくて良い気がする。画面が現れた時に、
    何れにしてもその時の状態は全描画しなければならないので、
    それまでに実行された縦スクロールなどは気にしなくて良い。

  c うーん。縦スクロールは DECSLRM に従って実行されると仮定すれば、
    実は DECSLRM で切って差分などを取る事によって移動を検出すれば良いのではないだろうか。
    DECSLRM が解除した後であっても最後にスクロールを実行した時の lrmargin を記録しておくという手もある。
    現在スクロールは do_vertical_scroll で実行しているので大域的な変更は必要ない。

    実際にスクロールと言うか内容の移動が検出できたとしてどの様に移動を実施するのか。
    例えば DECSTBM DECSLRM が対応できていたとして SU, SD で移動すれば良いのだろうか。
    IL, DL を使った実装は xterm で期待通りに動かない。xterm では DECSLRM を無視して
    本当に行を挿入したり削除したりするからである。一方で、SU SD で本当に期待通りに動くのか
    については確認していないのでわからない。

  というか実際にそれを実装するとしても DECSTBM, DECSLRM を外側の端末が対応している
  という事を確定できなければ使うことができないのである。
  これの実装に関しては後で余裕があれば考える事にする。

  或いは DECCRA に関しても最後に実行した時の座標を記録しておくというので十分の気がする。
  複数回実行した時に関しては考えない事にする。

2019-04-21

* 資料

  DECCRA もしくは DECSLRM について
  [端末で縦分割時のスクロールが遅い - Togetter](https://togetter.com/li/516002)

  SCOSC と DECSLRM のシーケンスの区別について
  [LeoNerd's programming thoughts: ANSI vs DEC, arbitrary scrolling in terminals](http://leonerds-code.blogspot.com/2012/03/ansi-vs-dec-arbitrary-scrolling-in.html)

  端末判定について
  [端末エミュレータマニアから見たMinEdの実装のヤバさ - Togetter](https://togetter.com/li/380509)

* sixel の振る舞いについて少し調べてみた。

  - RLogin では文字として表示されている気がする。
    ICH などでずれるし、上書きすればそのマス目だけが潰される。
    色々と画像の継ぎ接ぎができる。

  - 一方で、過去の twitter の議論を観察すると、
    実機では ICH などでずれない様だ? 直接 VRAM 上に置かれているという説だそうだ。

  - mintty の実装は何か変である。

    | mintty の場合には ICH ではずれない。
    | 描画範囲はずれない。というか色々微妙な動作をする。
    | 
    | - ICH(3) すると何も変化は見えない。DCH(3) すると画像の末尾が欠ける。
    | - DCH(3)ICH(3) も ICH(3)DCH(3) も変化は齎さない。
    | - DL(2) すると画像範囲が小さくなるだけで画像の一部が削られたりとかはない。
    | - IL(2) してもやはり画像の表示領域が消えるだけで画像が二つに分かれるとかではない。
    | 
    | ここから推測するに、mintty は sixel のマス目かどうかの情報を文字と同じ様に保持しているが、
    | 一方で、そのマス目に表示する内容は相対座標か何かで決定している。
    | ICH 等によってマス目が画像の範囲外に移動した時には何も表示しない。
    | 元画像への参照と元画像の原点 (?) の位置を保持している。
    | 然し、原点を保持するにしてもスクロールして画面の外に出てしまった場合に
    | どの様に処理しているのか不思議である。
    | 
    | - DECSTBM して sixel を表示してみて分かったが、
    |   mintty では単にスクロールした回数を記録しているだけの気がする。
    |   スクロール範囲外の sixel 画像も一緒にスクロールしてしまうのが観察された。
    | 然し、mintty は画面上から流れて出ていった画像を見る為にスクロールすると
    | 何か描画が変である。画像が残ったり残らなかったりしている。

    まとめると、mintty では文字と同様にそれが sixel の升目かどうかを保持している。
    元の sixel 画像がどれかだけを参照していて、元の画像のどの部分かの情報は保持していない。
    一方で sixel 画像の側に現在の表示位置を保持している。
    sixel 画像の位置はスクロールを実行する度に更新される。
    SU は sixel 画像の位置を更新するが、RI や SD は更新しない。
    何故この様な中途半端な実装になっているのか分からない。

    実機を真似ているという事なのだろうか。。

  - xterm は RLogin と同様の実装になっている気がする。
    DL(3) や IL(3) も試してみたがやはり行と一緒に画像が切り貼りされる感じだ。

  どれが良いのかは分からないがデザインとして納得できるのは RLogin/xterm の方式である。
  従って、もし対応するのであれば RLogin/xterm の方式で考える事にする。
  但し、現在の実装では文字以外の物体を置く仕組みを整備していないので後で考える。

  文字以外の物体を置くとしてどの様に置くのが良いだろうか。つまり参照方法。

  a 例えば object id を以て参照するというのは以前のアイディアである。
    うーん。結局 object id を以て参照するというので良い気がしてきた。
    但し、各升目に対して object を配するのはコストが高い気もする。
  b 或いは、ポインタを保持するという手もある。
    ポインタをデータメンバとして追加すると更にメモリを食うようになる。
    フラグが立っている場合にはポインタを保持して、
    フラグが立っていない時には属性を保持するという様にする、
    という事も考えられるが実装が複雑になる。
  
  更に、メモリ管理はどの様にするのかが問題になる。

  a 以前は手動で inc/dec して管理していたがとても面倒だし、
    直ぐにミスしてメモリリークしそうである。
  b かと言って ctor/dtor/copy 等でカウントするのは
    それはそれでコストが高い様に思われる。
  c 或いは参照カウントは諦めて毎回メモリをコピーする事にするか。
    これはメモリ確保解放が増えるので重くなる。
    更に、それが必要かどうかを判定する必要があるので、
    結局参照カウント方式と比べて何か楽になる訳でもない。
  d もう一つの可能性は行ごとにリソースを管理して、
    行が消滅する時に一気に開放するという物である。
    これは単一行でずっと処理を繰り返した場合に
    どんどんメモリ使用量が増えてしまうという問題がある。
  e 或いは GC の様に時々 mark/sweep を実施するというのでも良いかもしれない。
    mark/sweep のタイミングは n 回メモリ確保をした時点で実施する、などにする。
    この時に root オブジェクトは何処にあるだろうか。
    各ページ・スクロールバッファ・代替画面などにある。
    他にスタックの上などに置いてあったりはしないだろうか…。
    まあ、そんなには難しくないような気がする。
    この方法は一つの手であると思われる。

2019-04-20

* ansi (get_cells_in_presentation): prop の場合の動作
  prop の場合にちゃんと動作するかどうにかについてテストしていない。

* ansi (get_cells_in_presentation): 振り仮名・sixelなどの埋め込まれたオブジェクト
  振り仮名だとかの marker は適切に開始・終了等の並び替えを実行する必要があるのではないか。

* observer: 描画中は一時的にカーソルを隠す
  これについては現在の端末のカーソルの状態と term_t のカーソルの状態を
  管理できる様にしてから実装する事にする。

* DA2 に対する応答_
  https://qiita.com/kefir_/items/0bda5e55f43392420d66

  現在の impl2 ではただ単に画面の内容を追跡しているだけで、
  画面を自前で描画している訳ではないので、
  DA2 に応答しても仕方がない。
  然し、今後の実装としてはちゃんと自前で描画できる様にしたい。
  その時にはちゃんと DA2 に対する応答を書き込まなければならない。
  書き込み先を設定できる様にする必要がある。

* 描画に関して

  後、描画に関してはどの様にするのが良いだろうか。
  以前の構想だと端末の内部状態の管理とは別に、
  observer を用意してそこから端末の内部状態の変化を調べて表示するという話だった。
  然し、本当にそれで大丈夫だろうか。内部状態の変化をどの様に検出するのかとか、
  或いは、効率的な内部状態変化の適用方法などがあったとしてそれを如何に実行するのか。

  出力先が端末かそれとも GUI かによっても色々取り扱いが異なってくるだろう。
  例えばスクロールだとかに関しては出力先がどちらであっても、
  できるだけスクロールとして実装したい様に思う。
  例えば、その為には行IDの様な物を保持しておいて、それを元に行を追跡する。

  在る範囲の属性の変更等に関しては GUI が出力先の場合には何れにしても全て再描画である。
  一方で、出力先が端末の場合には実は

  a "属性の変更" という操作を送信した方が早いのではないか。
    x 大量の出力があった時に描画を省略したい場合には、
      却って属性の変更という操作を送信する様にするのは、
      全てを出力することを要求する事になるので避けた方が良いのではないか。

  b 実際に画面が有限の大きさである事を考えると、全部再描画しても問題ない様な気もする。

  c "属性を変更した" というイベントを何処かに記録しておいてそれを使って何とか操作を送信するか。

  d term で属性を変更する直前に画面状態を更新しておいて、その上で属性を変更しつつ
    属性を変更する操作を observer にも送るという手もある。

  うーん。画面の大きさが有限である事などを考えると、まあ行内容の更新は、
  変化のあった部分について全て再描画というので問題ない気がする。
  念の為、文字の部分一致についても調べてできるだけ短いシーケンスになる様には努める。
  (然し、それでも速度の遅い端末では問題になる気がする。)

  しかしできるだけ短いシーケンスというのはどの様に決定したら良いのだろうか。
  つまり、文字をシフトした方が短いのか或いは普通に出力した方が早いのか。
  a これはシフト対象について連続する文字の数にもよるだろう。
    更に、潰される文字に関しては連続していると解釈しても良さそうだし、うーん。
  b 或いは、もう単純な場合にだけ短くなる様に工夫して、
    ある程度以上複雑な更新が必要になったら、フルに描画してしまう事にするか。
  c もっと細かく考えたら何か動的計画か何かで最短になるシーケンスを算出できるのだろうか。
    確かに競技プログラミングの問題に出てきそうではある。

* DECSTBM の影響範囲
  MC, DECMC は DECSTBM, DECPEX の影響を受けるそうだ。
  DECOM についてもちゃんと DECSTBM に対応する様にする必要がある。

2019-04-14

* ansi: うーん。ECMA-48 を見て思う事は、実は ECMA-48 及び ANSI は端末の規格というよりも、
  ワープロの様な物の規格の様に思われてくるという事である。
  フルに様々なオブジェクトを埋め込める様なそういうデータ形式が想定されている様な気がする。
  JFY (text-justification) だとか PTX (ふりがな) だとかを考えると、
  端末の機能として実装するのはかなり難しい様な気がしてくる。
  実際の所はどうなのだろうか…。

  思うに完全に実装しようとすると遅くなってしまうので現在の mono/prop の様に、
  更に上の段階として full 的な物を用意して、
  そのデータ形式に於いて様々な入れ子の構造などにも対応するという形が良いのかもしれない。

  | うーん。というか PTX 等で振り仮名を振っている時にも中でフルに
  | 文字列を作成したりフィールドを作成したり領域を作成したりする事は可能なのだろうか。
  | 或いはそういった機能は未定義という事なのだろうか。
  | 改めて規格を確認してみたが何も書かれていない。細かい Note は書かれているが、
  | どの様に表示されると考えられるかという例について説明されているに過ぎない。
  |
  | 改めてデータ部と表示部の説明を確認してみる。
  | 何処にもどの文字位置も同じ大きさを持つとは書かれていない。
  | 更に一行に含まれる文字の数についても触れられていない。
  | 行の高さが同じであるとも書かれていない。
  | そういう事を総合して考えると、これは端末の規格というよりは、
  | やはりワープロソフトもどきの装置の規格の様である。
  | 或いは、もう実際にその様に実装してしまうというのも手かもしれない。
  |
  | prop から full に昇格した時の整合性はあるのだろうか。
  | 例えば prop で処理している時には先に文字列の終端を挿入して
  | 後で文字列の開始を挿入したとしてもその瞬間のデータ部における
  | マーカの関係を考慮に入れて入れ子の状態を認識する様になっている。
  | つまり、prop では HTML のソースを弄る様な形で処理が行われる。
  |
  | 一方で、full に昇格して現在どの入れ子の中にいるのかという
  | 入れ子構造の木の中で挿入を行う仕組みにしてしまうと、
  | 先に文字列の終端を挿入してから後で文字列の開始を挿入する
  | と言った操作が困難になる。というか、文字列の開始を挿入した時点で
  | 木の構造を再構築しなければならなくなってしまう。
  |
  | 現在求められているのはどちらであろうか。
  | "データストリームの編集" と考えれば HTML のソースを弄る様に、
  | 一次元的なデータを編集する様にして、
  | その瞬間瞬間での解釈を用いて表示を行う事になる。
  | やはりそちらの方が自然である様に思われてきた。

  [結論] データ部では HTML を編集する様にしてデータストリームを編集すると解釈する。
  また、その時に文字の幅などは特別に解釈して右での折返しを実装できれば望ましい。

  さて、問題は、PTX の様な物の幅をどのように取り扱うかである。
  うーん。PTX が含まれる場合には計算する時の x 位置の幅を
  リセットするとかそういう事になるのだろうか。

  - その場合には実は _prop_glb, _prop_lub の定義を弄るだけで
    対応できてしまったりはしないだろうか。

  - 双方向文字列はどの様に処理すればよいだろうか。
    双方向文字列に関しては振り仮名の中はスキップする様にするのが良さそう。
    これは双方向文字列を処理するルーチンの修正が必要になる。
    しかし、それさえ修正してしまえば実は終わりなのでは?

    と安易に考えてはいるが実際に対応しようと考えると、様々な考察やテストが必要になる。
    或いは、もっと安全なデータ構造を考えた方が良いかもしれない。

* ansi (_bdsm_shift_cells): ECH/ERM
  現在の実装では ERM で protected な部分に関しては、
  方向文字列などの状態は復元せずに、そのままデータ部で
  保持する様に実装しているがこの実装は適切だろうか。

  ユーザからすると変な振る舞いに見えるのではないだろうか。
  然し一方で、境界上に protected/unprotected な物が混ざっていると、
  方向文字列などの復元をどの様にしたら良いのかが非自明となる。
  或いは、方向文字列に関連する marker だけは unprotected であっても残す様にするのか。
  そしてそれ以外の unprotected 零幅文字は削除するという仕様にするか。

2019-04-13

* DAQ に対応する。
  protected/guarded の属性に関しては描画属性で対応する事にする。
  然し、input だとか HT の設定だとかに関しては描画属性で対応する物かどうかは微妙である。
  実際の所、始まりと終わりの marker を保持しておいてその間を領域と解釈するべきなのではないか。

  然し、SPA EPA 等と混ざっていた時に EA などが認識する "領域" はどの様に解釈すれば良いだろうか。
  また、SPA, EPA 等は全ての行に亘って検索するべき気もする。うーん。

  結局、DAQ は SPA, EPA 等で終了するという様に決めておかないと駄目な気がする。
  その様に考えると属性も DAQ と SPA で共通にして良いのでは。とも思うが、
  まあ、両者が混在した場合などを考えるとやはり区別したほうが良いか。。

  思うに EA が認識する "領域" と、DAQ 及び SPA-EPA がそれぞれ自分で把握している "領域" は
  独立であっても良いのではないかという事。

* line (_bdsm_shift_cells): erase unprotected cells におけるテスト項目
  境界上の大きな文字に対する補正として、
  その大きな文字が特に3文字以上ある時に
  境界から左端・右端への距離が分からない。
  現在の実装では両方試す実装になっているが、
  実のところ3文字以上の大きな文字に未だ対応していないのでテストしていない。
  3文字以上の文字が現れた時にテストを追加するべきである。

2019-04-10

* どの段階で term.initialize_line(line) が適用されるべきか不明瞭である。
  一番最初に何らかの編集が行われる時?
  それとも一番最初にカーソルが移動した時?
  或いは一番最初に画面に現れた時?
  或いは初めてタブなどが実行されて情報が必要になった時かもしれない? うーん。

  cur.y に値を代入している箇所はそんなにないので
  そのタイミングで実行するので良い気がする。
  その行に移動しなくても何か編集作業が起こる事があるだろうか。
  そしてその様な時には initialize_line を実行するべきだろうか。

  また移動せずに編集作業が起こったとしてもその瞬間に適用する必要はないのかもしれない。
  そもそも SLL SLH は暗黙移動に関する物で HT もカーソルの移動に関する物である。
  従って、カーソルがその行に始めて移動した時に処理するというので良い気がしてきた。

* TSM for DL IL

* ERM for EA, ED, EF, EL
  - done: ECH については完了した。
  - done: 取り敢えず ED と EL についても対応した。動作確認はしていない。
  - EA, EF についてはそもそも現時点で実装されていない。

* SEE for DCH DL ICH IL

* DECSTBM は現在のページだけに影響を与えるのだろうか。
  それとも全てのページに対して影響を与えるのだろうか。
  これはページに対応する時に改めて調べる事にする。

* sequence: 制御列などは最大長さを設定しておくべきでは
* sequence: 中に規格外の文字列が入っても許容する設定があっても良いのでは

2019-04-08

* ansi: 思ったのだが marker と通常の文字を区別する意味はあるのだろうか。
  表示する時に出力されるかどうか?
  文字幅が0かどうかの違いしか無い様な気がする…。
  例えば bidi の制御文字に関して考えると、
  正しくレンダリングされる為にはやはり制御文字も一緒に表示する必要がある。
  という事などを考えるとやはり通常の文字として埋め込んでしまう方が良いのでは…。

* ansi: 結合文字について
  やはり screen と Poderosa で振る舞いが異なる。
  というか UTF-8 ではない文字列が送られてくる様になる。

* attribute だとか character の拡張機能はどの様に処理するべきか。

  * 拡張オブジェクトの寿命管理はどの様にするのが良いか

    | attribute や character のコピーコンストラクタ等に処理を追加してしまう事にするか。
    | そうすると書き込みや読み込みなどの際に毎回チェックが入る事になり重い気がする。
    | 勿論、殆どの場合には拡張はないので if でフラグを検査するだけではある。
    |
    | 或いは、cell の側にオブジェクトなどを保持する為のポインタを設置するべきか。
    | 特に文字に関してはそちらの方が良い様な気もする。
    | "文字" というスカラー値でオブジェクトを運搬できる様にする必要性など実はないのである。
    | 然し、そういったオブジェクトの寿命は誰が管理するのだろうか。
    | 特に複数のセルで使い回されている時にどうするのか。
    |
    | 様々の事を考えると実は character に持たせるのではなくて
    | セル側に持たせるほうが自然に思われてくる。
    | 然し、一方で巨大な attribute をコピーする理由は何だろう。
    | attribute はそう頻繁に変更する物でもないし、
    | コピーして持ち回るほうが普通なのではないか。
    | Poderosa の場合には GC があるので自由にコピーして良かった。
    | C++ で実装する時にはどうするのが良いか。
    | よく考えたら C# で GC に頼っているのであれば、
    | C++ でも同様に実装しても良いのではないか。
    | つまり、"時々" 全体をスキャンして使われていなない属性を破棄するという事。
    | しかし、時々というのはどのタイミングだろうか。
    | 更に sixel 等の巨大なオブジェクトの場合には時々ではなくて、
    | やはり消滅する時にちゃんと始末しておきたい所である。
    | うーん。何とか全体をスキャンするコストを抑えつつ、
    | 参照カウントの更新の様な煩わしさを避けつつ、
    | という様にする事はできないだろうか。
    |
    | 例えば、画面の見える領域に関しては全体をスキャンする事にして、
    | そしてそれ以外の領域に関しては参照カウントで対処する等。
    | うーん。それが良いような気がする。
    | 画面の見える領域に関しては root オブジェクトとして取り扱う。
    | 画面から出ていった領域に関しては行を登録する時と、
    |
    | 行を削除する時に参照カウントを更新する事にする。
    | 以前の取り扱いよりも更に複雑になった気がしないでもないが、
    | まあ、この様にする位が高速で良いのだろうという気がする。

    画面の見える領域については参照カウントはしない。
    GC をする時に全体をスキャンして使われているかどうかを判定する。
    画面から出ていった部分については参照カウントを実行する。
    つまり、画面外 buffer に行を移動する時に inc して、
    画面外 buffer から行を削除する時に dec する。
    基本的に画面外 buffer に含まれる行は二度と編集が起きないという事は仮定する。

    ページ等に関しては退避する時に参照カウントを inc して、
    また復帰する時に dec する事にすれば良い。
    GC は一定の回数 attribute を生成する毎に実行する。
    大きなオブジェクトに関してはその都度チェックを実施すれば良い。

  * attribute に拡張属性を使用するか

    | 今 attribute は 4 bytes である。
    | extended attributes は 16 bytes ある。
    | 実はそんなにけちる程の物でもないかもしれないが、
    | 将来的に拡張する事なども考えるとやはり拡張性を持たせる?
    | 16 bytes あっても普通は使わないのである。と思ったが、
    | 最近では full color 対応なども出てきた。
    | そう考えると full color の為の 8 bytes はやはりあった方が良いのだろうか。
    | xattr に関してはそんなに使う頻度が高いとは思われないが、
    | しかし contra が広まるなどして拡張属性が広まれば
    | やはり使われる様になるかもしれない。
    | 文字を書き込む度に 16 bytes のコピーを何度も実施するのは微妙な気もするが、
    | しかし、うーん。現状で既に文字を書き込む度に物凄く色々な処理をしている。
    | 文字幅のテーブルを引いて、それから踏み潰される全角文字がないか確認して、
    | その上で書き込みを実施するのである。16 bytes のコピーをけちる所ではない。
    | 或いは、ASCII のみしか存在していない状況で最適化した実装をする事ができるだろうか。
    | 何れにしても 16 bytes (4 fields) のコピー程度は何の事はないだろう。

    16 bytes は文字の書き込み時に行っている処理の複雑さを考えれば
    大した手間とはならない (それを言い出すと拡張フラグのチェックも大した手間ではないが)。
    データサイズ的にはそんなに大きな物ではない。
    例えば 200字x10000行x16bytes = 32MB である。うーん。結構ある…。
    char 4B width 4B attr 16B だと 48MB であり、
    char 4B width 4B attr 4B だと 24MB である。2倍位の差になる。

    c 或いは画面から流れた内容を何らかの方法で圧縮して
      保持する方法などあるだろうか…。ANSI seq に変換して記録する等。
      然し、それはそれで複雑な行内容だった場合に困難が生じるし、
      複雑なオブジェクトがある場合には何れにしても困る。

    d 画面から流れた内容はファイルに書き出してしまっても良いのかもしれない。
      と思ったが、その時には拡張属性等はどう管理したら良いだろうか…。
      ファイルの中に領域を作るのも変だし、拡張属性・拡張オブジェクトだけ
      メモリ上に保持するというのも片手落ちな気がする。
      更にファイルに記録するとすると、そのファイルのインデックス等も
      管理しなければならない。ファイル内のどの位置が何行目に対応しているかという。

      然し、ECMA 48 の書き方を考えると画面から出て行った内容に対して、
      この様にファイルに書き出す機能という物があっても良い様には思う。
      それを画像として出力するのか、テキストファイルとして出力するのか、
      或いは、ASCII seq を含んだファイルとして出力するのかは色々。
      HTML にして出力してしまうという手もあるのではないか。
      sixel 部分に関しては適当に画像に変換してセルごとに保存してしまう。
      うーん。オブジェクトは確かに画面の外に出た瞬間に
      画像として残すだけで良い気がしてきた。

      一方で、昨今の Web インターフェイスの様な物を考えると、
      実は端末上でも領域に id でもつけて対話的な事ができるようにしても良いのでは、
      そしてスクロールして色々な情報を見られる様にして良いのではないか、
      等と考えないでもないが、まあその様な機能を実装したとして広まらないし、
      やはりやっても余り意味が無いような気がするので考えても仕方がない。

      本気でなにか広めるのだとしたら新しい OS でも作って、
      標準のターミナルでそういう面白い機能をふんだんに使った
      アプリケーションを提供する等しなければならない。
      しかし、余り複雑だとそれに追随するソフトウェアが現れないし難しい所である。
      精々ボタンを設置して、そのボタンが押された時に受信されるシーケンスを設定する位である。
      或いは terminfo に代わる様なライブラリを提供するか。

* [暫定実装] ansi: c2w の実装は中途半端な物である。
  結合文字などの文字幅 0 の文字の事を考慮に入れていない。
* [暫定実装] ansi: utf8_decode の実装も中途半端である。
  これは別の encoding の場合も考慮に入れて
  インターフェイスを考えておく必要がある。
  使う側もそれに合わせて実装する必要がある。

2019-04-05

* bidi: 情報を収集していたら余計によく分からなくなった。

  Unicode には bidi 関連の機能を制御する文字がある。
  それだけでなく文字の種類によって自然な文字の方向というのが存在して、
  アラビア文字等の場合には特に制御をしなくても勝手に文字の方向が決まる。

  contra の内部実装ではデータ部での論理配置を軸にして、
  表示上の移動などにも対応する事になる。
  表示部での操作を実装する為には、対応するデータ部での配置に変換できなければならない。
  その変換を実行するために必要なデータ構造は何だろうか。
  また、データ部・表示部における様々な操作に対してそのデータ構造を更新する必要がある。

  アラビア文字を挿入する度に周囲のアラビア文字との結合を考えるのは面倒である。
  従って、データ部・表示部の変換を実行する度に、
  行内にどの様な種類の文字が存在してどの様な配置になるのかという事を計算するのか。
  或いは、文字配置に関連するデータをキャッシュしても良い。
  或いは、やはり文字を挿入する度にそう言ったデータを管理する様にするのか。

  そしてマーカはやはり文字列としてデータ部の中に埋め込む形にするのが良いだろうか。
  その場合にはデータ部における明示的移動でマーカをどの様に設置することにするのか。
  文字を新しく挿入するとその右にあるマーカは削除する事になる。
  現在の実装のアイディアはこれに基づいている気がする。

  - 属性化領域(DAQ)・選択領域(SSA, ESA)・保護領域(SPA, EPA)
    これらはデータ部・表示部の変換に影響しない。
    従って独立に管理するのが良いのではないだろうか。
    また ECMA-48 に従うと表示部に対する範囲指定だが、
    用途を考えるとデータ部に対する範囲指定と考える方が良いのではないか。

    ECMAによると SDS, SRS の内部でこれらを設定する事はできない。
    然し、実際の端末ではそういった入力を受け取る可能性を排除できない。
    これらはその位置における SDS, SRS を解除すると見做す事にする。
    然し、その様に解釈すると DAQ, SSA, ESA 等のマーカーも全て
    記録しなければならないのではないだろうか…。

  - 方向付き文字列(SDS)・反転文字列(SRS)
    これらはマーカとして埋め込む。対応はその場その場で構築する。
    変なマーカの配置の仕方をしていてもちゃんとそれっぽく解釈する。
    折返しが起こる場合には一旦方向付き文字列を閉じて、
    改行してから再び同じ入れ子状態に復元する。

  - タブ(HT)
    これは事前に設定されているタブストップの位置と、
    実際にタブによって移動した時に起こるタブの確立を区別するべき。
    そして実際にタブで動いた時に起こるタブはまた内部に記録される。
    実際に発生したタブについて実は TCC を考えると
    文字も記録しなければならないのではないだろうか。
    うーん。従って現在の形式はやはり何か限界があるという気がする。

  うーん。簡単なプロトタイプ実装でも作って考えてみる事にする。
  UAX #9 を確認してみる。思いの外複雑である。
  というか先に UAX#9 を実装してから考えるのが良さそう。
  UAX#9 の為に一から作り直しになるのは面倒である。

  UAX#9 の要点をまとめつつ読んでいく。X1 の規則が滅茶苦茶長い。
  うーん。然し…これに従って並び替えた後に
  表示部での消去を実装するとどう振る舞うべきなのだろうか…。
  この様な複雑な処理を経ると最終的にどの様に切断したら
  見た目を変化させずに消去する事ができるのかという事を判定できない…。
  或いは表示部で範囲を決定するだけで、実際の消去はデータ部で実行して良いのだろうか。

  % UAX#9 の UBA の overflow_isolate_count と
  % overflow_embedding_count の取扱はこれで良いのか。
  % 例えば max_depth = 124 の時 LRI に失敗してその後に RLE に成功する事がある。
  % この時 oic = 1, oec = 0 になる。PDF が来るとそのまま処理される。
  % PDI が来ると oic-- して oec はそのままである。
  % 或いは max_depth = 124 の時 LRE に失敗してその後に LRI に成功したとする。
  % この時 vic = 1, oic = 0, oec = 1 になる。
  % PDI が来ると、vic=0,oic=0,oec=0 になってしまう。
  % そして PDF が来ると駄目になる気がする。
  →と思ったが、よく文章を読んでみると oic || oec の時必ず失敗する事になっている。
    従って失敗した後それが pop されるまでは成功する事はあり得ない。

  取り敢えず UAX#9 の実装を試みる事にする。

2016-10-19

* 方向付き文字列の対応
  - HT によるマーカの挿入
  - 各種テストの実装
  - マーカ個数の最大数を設定

2016-10-10

* ページについて。

  ページ関連の機能については一体どの様に実装するのが良いのかと悩んでいたが、
  RLogin のエスケープシーケンスを眺めていた所 RLogin はページに対応している事に気づいた。
  (もしかして xterm なんかも実装しているのだろうかと思って試してみたが実装していない様だ。
  mintty, screen, Poderosa も実装していない。)

  # 特に気になっていたのは画面の上端から流れて出ていった内容をある一定の長さで区切ってページとするべきなのか、
  # 或いはそれどころか画面内である一定の行数毎に区切ってページとするべきなのかという事であった。
  # それよりは画面内はやはりずっと同じページだし、
  # 上端から流れて出ていった内容もやはり同じページにあると考えた方が自然な気もした。
  # しかしそれだと他のページの内容を確認しにくいし、
  # SPH で設定した行は画面内の行ではなくて流れていった内容に含まれる行なのかなど色々わからない。

  RLogin の実装を見てみた所、ページは恐らく見えている範囲が 1 ページになっていて、
  各ページは altscreen と同様に差し替えられるという仕組みになっている様だ。
  上端から流れていった内容は別にページの一部とは考えれていない。
  ページの視点からは上端から流れて出ていった内容は飽くまで失われた内容という事である。

  結局、既存の実装があるのだからこれに従うのが良さそうだし、
  何よりなんとなくこの実装がそれ自体設計として良さそうに思われる。
  が、保険のためもう少しこの実装の声質について考えてみる。

  | なるほど確かに考えてみれば display で見えている範囲というのが丁度カーソルによって移動できる範囲であり、
  | それがプリンタに於ける一枚の紙とみなすのは自然である。そして上端から流れていった内容は、
  | 単に端末の追加機能として記録している物に過ぎず、端末の制御下にあるものではないと考える。
  |
  | と思ったがロール紙 (?) の様なのに印刷している場合はどうなんだろう。その場合には上端から流れていった内容も
  | やはり移動の対象としても良いような気がする。何よりページの移動というのは実際の印刷機では
  | 一体どのような動作に対応するのだろうというのが気になる。特にページを戻るというのは何だろう。
  | 普通のプリンタでは一度出力した紙はトレーに落ちて機械的に自動的に戻したりする事はできない。
  | そういう事を考えると一連の長いロール紙にページという単位の区切りを用意して前にスクロールしたり、
  | 後ろにスクロールしたりする事でページを移動するという風にデザインする事も可能である。
  |
  | そして規格の意図していることとは独立に、アプリケーションから見た時の、
  | 端末機能としての利便性という観点からも考えたほうが良いかもしれない。
  | そういう観点だとページの機能というのは、複数ある画面を切り替えるものとして実装するととても便利そうである。
  | 一つの画面の中に勝手にページ区切りができたりという風な設計だと使いにくいし、
  | また、手動でページ区切りを挿入するのだとしても別に便利だとは思われない。
  | そんなのはアプリケーション内で独自に別の管理の仕方をした方が楽に決まっている。
  | そういう意味で実装して意味のある機能か、という観点から言っても RLogin の実装は合理的である。
  |
  | また上端から出ていった内容に関しては、データの管理の観点から言って
  | 其処にカーソルを戻す事ができる様な設計になっているのは面倒である。
  | というか現在の実装を大きく書き換えなければならなくなり面倒である。
  | もしそれに対応するのだとしたら上端から流れていった内容に関しても、
  | ディスプレイの続きとして同じ配列の中で管理しなければならなくなるし、
  | そうするとメモリ効率などの点から行っても余り嬉しくない。
  | そもそも上端から流れて出ていった内容を確認する頻度というのは、
  | 画面内に文字を出力する頻度と比べれば小さい物だし、
  | どこかに掃き溜めの様に集めておくだけで良いのである。
  |
  | 一つの懸念は FF である。FF は規格どおりに実装するのだとしたら
  | 次のページに移動して SPH に移動するという物である。
  | (page or form と書かれているから頁ではなくフォームでも良いのかもしれない。
  | しかし form とは何だろう。実質 page と同じに扱って良い気がする。)
  | この実装だと、誤って FF を出力した場合に混乱を来す事になる。
  | 次のページに進むことによって今まで表示されていた内容が見えなくなるからである。
  | しかし混乱を来すとは言っても再描画すれば済むことだしそんなに致命的でない気もする。
  | 誤ってではなく意図的に FF を出力する様なプログラムも、LF や VT がある事を考えれば、ないだろう。
  | そう考えれば FF は本当に次の頁に移ってしまうという実装で良い気がする。
  | 一応 FF で LF と同じ動作になる様にできるオプションも付けておくのが良いだろう。
  | # 所で、複数のページがある時に現在のページ番号を表示する様にしても良い。
  |
  | もう一つの懸念は幾らでもページを追加できる様にするのかという事である。
  | 例えば FF だとか PPR を延々と吐き出すプログラムを作った時に
  | 端末はどの様に応答するべきかという事である。
  | 上端から流れていった内容に関しては通常は最大の行数を指定する事ができて、
  | それより沢山の行を出力する場合には順次ローテーとして古い行から消えていく。
  | しかしページの場合には PPA を用いてページ番号を明示的に指定して移動する事ができるので、
  | 古い物から順に消していくという作戦も使えない。或いは、その様に実装して
  | 消えたページに戻った時には空の内容を表示するという風にしたとしても、
  | 実際にいざ移動した時に新しく確保したメモリは配列にどの様に格納するのかという問題が生じる。
  | 勿論スパースな配列を実装して其処に記録するというのでも良いのかもしれないが、
  | それもまた変な実装である。何より使う側からすると謎の挙動に見えて分かりづらいだろう。
  | だとすると予めページ数に上限を加えるというのが現実的な解になるだろう。
  | とここまで考えて RLogin の実装はどうなっているのかというのを確認してみる事にする。
  | もし上限があれば何処かで止まるか、あるいはエラーになるかするし、
  | 上限がないのだとしたらメモリがどんどん増えていくというのを観察できるはずだ。
  |
  | $ for f in {0..10000}; do printf $'\e[ Qhello'$f'\n'; done
  |
  | 結果 RLogin の最大ページ数は 100 という事が分かった。最大ページ番号まで行くと、
  | それより次に行こうとしても何も起こらなくなる (※カーソル位置も動かない)。
  | もしかして設定項目に最大ページ数があるのかもしれないと思って確認してみたが、
  | [スクロールバックできるヒストリー行数] は設定できてもページ数は設定できない様だ。
  | しかし、[通信ログ] の項目に PAGE が云々と書かれているのでやはりページを意識した設計になっている。
  |
  | 更に RLogin のページを見ていると DECRQDE DECCRA DECRQCRA でページについて言及がある。
  | つまり、VT系列の端末ではページに対応していたと考えられ、
  | だとすると RLogin のページに関する動作は VT互換な物であると期待できる。
  | 従って、やはり RLogin の真似をして実装するしか無いだろう。
  |
  | 他に NP PP という機能がある。ECMA に従うと n-th following/preceding page to be displlayed
  | と書かれている。表示されるだけというのはどういう事だろう。
  | また active presentation position の変化は定義されないと書かれている。
  | 一方で RLogin の実装では上端から流れた内容を一時的に表示する
  | (というかスクロールバーの位置を変更する) 様になっている。
  | 現在位置は変化せず、次に最新の内容に変化があった時にはまたもとの画面に戻る。
  | つまり、PPA PPR PPB で操作される "page" と、NP PP で操作される "page" は異なるという事になる。
  |
  | ECMA-48 にも色々書かれている事が分かった。
  | - ED が ECMA では ERASE IN PAGE になっている事から、
  |   やはり page は ED の対象の範囲と同一であるべきで、
  |   だとすれば現在の page というのは現在表示されている範囲の事だと思うべきである。
  |   (ただ、これだけだと現在のページ以外のページがどういう形態を持つのか、つまり、
  |   上端から流れたデータをも含むのか、それとも別のバッファとして記録するのかは不明である)。
  | - 更に QUAD JFY に関する補足が ECMA-48 の付録にあって其処では、
  |   a display device with a multiple-page buffer では云々と書かれている。
  |   つまり page を扱える為にはそれ専用の特別のバッファを持っていると想定できる。
  |   ただ単に上端から流れていく情報を溜めておく装置は multiple-page buffer とは言い難いし、
  |   上端から流れていく情報を一定の行数毎に区切って移動できる様にしただけの物に
  |   新しく multiple-page buffer と名前をつけてそれを display device の特徴の一つとして挙げるのも変である。
  |   そういう事を考えれば、やはり規格的にも page というのは RLogin が実装している様に、
  |   それ専用の buffer に割り当てられる領域とするのが自然であろう。
  | - もっと ECMA-48 を見てみるとちゃんと [ECMA-48/6.3/3] に page について書かれている。
  |   また、[ECMA-48/6/2] にも書かれている。所で気になるのは、行は predetermined number of character positions
  |   からなると書かれている一方で、ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている事である。
  |   これについてはまた別に項目を立てて考察を行う事にする。

  [まとめ]

  - アプリケーションから見た時の利便性の観点からも RLogin と同様の実装が支持される。
  - DECRQDE DECCRA DECRQCRA などの存在から VT 端末も RLogin と同じ動作だろうと期待できる。
  - ECMA-48 的にも ED や Annex C の記述から、page 専用の buffer を持つディスプレイ装置が想定される。
  - NP PP は ECMA-48 的には一時的に他のページを表示するもの (?) の様だが、RLogin は上端から流れた内容を表示する。

  - PPA PPR PPB NP PP に関しては全面的に RLogin と同様に実装する。
  - FF はオプションで LF と同じか次のページに行くかを選べる様にする。
  - 頁数の上限を設定できる様にする。


  関連する制御機能を整理しておく。

  SPH SPL FF PFS
  PPA PPR PPB NP PP
  他にも未だあったような気がする…→ SEF だ。

  | * [2016-10-05] SPH/SPL の効果について
  |
  |   FF 及び implicit movement それから
  |   active presentation position does not normally go
  |   beyond the page limit position というのを実装する。
  |
  |   しかし、そもそも頁の概念を端末上でどの様に実装するべきかが明確でない。
  |   その他の頁を制御する制御機能の説明を調べて、
  |   その上で適切な頁の概念の再現方法を考える事にしたい。
  |
  |   また SLH/SLL と同様に頁毎に home/limit
  |   の値を設定する事ができるかどうか考察する。

  これに関しては行の属性と同様に、
  各ページに SPH, SPL を保持する様にする。
  同時に "現在の既定の SPH, SPL" も保持する。

2016-10-08

* emacs だとかのアプリケーションを動作させるだけであれば、
  terminfo のエントリにある物だけ対応しておけば実は十分という事に気付く。
  一々起動してどの様なシーケンスを送ってくるかを調べる必要はないのだ。

  infocmp xterm を見てみると意外と沢山ある。
  しかしキーシーケンスも多いのでどれが制御機能かぱっと見て分からない。
  後で terminfo の entries についても纏める必要があるだろう。

  序で infocmp ansi を見ると大分すっきりしている。
  というかキーシーケンスが全然ない。考えてみれば当然だ。
  ANSI 規格は制御機能しか定義していなくてキーボードは定義していないからだ。
  また、気になるのは ANSI 規格で処理系定義とされている機能についてだ。
  例えば xenl は infocmp ansi では書かれていないが、
  別に xenl でもそうでなくても ANSI 規格準拠の筈だ。
  後、altcharset (acsc) に普通に非 7 bit 文字が記述されているが、
  これらを utf-8 の環境で使うと何が起こるのか気になる。
  (ncursesw はちゃんと encode してから送信するのだろうか?)

* DECDWL, DECDHL の動作に関して。

  DECDWL, DECDHL, DECSWL は VT510 のページに記述がある。
  これらは行に対する属性として動作する。
  しかしこれらの属性を持つ行に関してカーソルの移動はどの様に働くのだろう。

  xterm, RLogin, mintty が対応していたので動作を観察してみる。

  - VT510 の DECDWL の説明によると元から行に存在していた
    内容の右半分は失われると書かれている。

  - xterm は DECDWL を設定した行であっても表示が二倍の幅になっているだけで、
    一行に収める事のできる文字の数は変化しない様である。
    つまり、画面の右端に行ってもその場では折り返されず、
    行の右半分だけが表示されないという動作になる。
    そして画面の右端に行って隠れた文字列はちゃんと記録されていて、
    \e#5 で行の文字の幅を元に戻すと画面の右端に行って隠れた文字列が戻ってくる。

    また、カーソル移動に関しては \e[C もしくは \e[D で移動すると、
    二倍の距離移動する様になる。つまり、文字数で移動する。
    (因みにカーソルの下に全角文字がある場合に \e[D しても半角分しか移動しない。)

    DECDWL の行で 4 文字目 (つまり7列目) にカーソルがある場合、
    \e[A で上に移動すると他の行の 4 文字目 (4列目) にカーソルが移動する。
    見た目に合わせて 7 列目にカーソルを移動する等という動作はしない様である。
    (ECMA-48 は presentation component での見たままの上下左右の移動に拘っている様なので、
    ECMA-48 を標準化している様な人からすれば \e[A は見た目の通りに 7 列目にするべきと考えるだろう。)

    DECDWL した瞬間にカーソルの位置が変わるかどうかも興味深い。
    xterm の実装では DECDWL した瞬間にカーソル位置は表示上右に2倍の位置に移動する。
    文字データの観点から言うと、DECDWL する前と後で指している文字は変わらない。

    結局のところ xterm の DECDWL, DECDHL の対応はただ単に "表示する時に横幅を二倍にしているだけ" であって、
    実際の端末の処理としては全然幅を認識していないという事になる。

  - mintty は xterm の動作を模倣している。

  - RLogin の場合には画面の見た目で行折り返しが起こる。
    つまり、DECDWL の行では半分しか文字を出力できない。
    然しながら、一旦行内を埋めてから DECDWL してそれから DECSWL をすると、
    また内容が戻ってくる。つまり、SLL を一時的に半分の位置に設定しているだけで、
    実際の内部的な表現としてはやはり一文字一セルで記録している物と思われる。

    面白い振る舞いとしては一旦行内を半分以上埋めて DECDWL をしてカーソルが画面外に出た状態で
    何か文字を出力すると、1文字目は何処にも出力されず、2文字目は行折り返しが起こって
    次の行に表示されるという事である。
    思うに RLogin は現在のカーソル位置が範囲外にあるかどうかをカーソルが移動した時に
    判定して記録しているのだろう。なので、カーソルが移動した後に設定が変わってカーソル位置がはみ出ても
    それを認識せずに文字を置こうとして失敗して、その後でカーソルを移動した時にようやく
    現在位置が範囲外であったという事に気づいて行折り返しを行うというそういう動作になっているのだろうと思う。

    カーソル移動については xterm と全く同じである。\e[C \e[D は2列ずつ移動するし、
    また \e[A \e[B すると前後の行の同じ列ではなく同じ文字番号の場所に移動する。

    所で DECDWL/DECDHL と sixel を組み合わせるとどうなるかを見てみた所、
    sixel の絵も横に二倍に引き伸ばされて表示される様である。
    序に DCH や DL も試してみたがちゃんと画像の一部が削除される様だ。
    これらの動作についてはまた後で様々の実装の間で比較する必要がありそうだ。

  結局、これらの実装が本当に VT の実機と同様なのかは怪しい。
  何れの実装でも行の右半分のデータを保持している。
  一方で、わざわざ VT の説明に行の右半分のデータは discard すると書かれている。
  これは、VT の実装では単に表示を二倍にしているのではなくて、
  丁度表示位置に対応するセルにデータを記録しているという事の気がする。
  だとするとカーソル移動は見た目での列に従って起こるべきだし、
  また行の内容が保持されたり折り返しがなかなか起こらなかったりという事もないのではないか。

2016-10-05

* RIS

  xterm ,screen, mintty はちゃんと表示内容も消去する。
  RLogin は RIS をしても表示内容を消去しない。
  Poderosa はそもそも RIS に対応していない。

* 基本的な移動機能その他

  > CUU CUD CUB CUF (現在位置・上下左右)
  > HPA HPB HPR VPA VPB VPR (記憶位置・行列)
  > CHA CNL CPL (行列)
  CPR
  DCH ICH ECH DL IL EL ED

* RI は一度消えた行ではなくて新しい行を挿入している @ screen
  RI IND

* Poderosa IL bug
  →バグ特定については 2016-10-12 を参照。

* http://invisible-island.net/vttest/

2016-10-04

* 本当に行毎に SLL/SLH の値を保持するべきなのか。

  subsequent lines と書かれているが、
  CUU 等で戻ってから上書きする場合には適用されないのか。
  また ED で erased state にされた行に設定されていた home/limit は消去するべきなのか。

  他に "以降の行" に適用される様な状態はあっただろうか。
  それらの機能の自然な動作も考慮に入れて考える。
  例えば SCP が以降の行に対して適用される物である。
  SCP の説明では現在行の内容の更新方法については述べているが、
  以降の行についての更新方法については述べていない。
  - 既に出力された行に再度移動して其処に新しく何かを書き込んだ時に、
    突然表示方法が変化するというのも変である。
    或いは、既に出力された行に移動した瞬間に変化するというのも変である。
    だとすれば、SCP が適用されるのは本当に新しく作った行に対してのみであるべきである。
    或いは LF もしくは NEL によって移動した時にのみ SCP を更新するというのも考えられるかもしれないが、
    しかしそれでも LF を単なる移動に使うという場合も考えられるし、やはり表示方法が突然変化するというのは変である。
  - ED によって空にした行については SCP はどう働くべきだろうか。
    ED によって空にした行についてはそれが新しい行であるかのように動作して欲しい。
    以前其処にあった方向性が残っているというのはおかしいからである。
    例えば中身が全て erased になっている行に限っては SCP の方向性が新しく適用されるというのはどうだろうか。
    しかし、それも不自然な気がする。周りの行が新しい SCP に影響されていないのに、間にある行だけ影響を受けるというのも変である。
    という事は、行自体に "この行は新しい行である" かどうかを保持するデータをつけておくべきだろうか。
    そして新しい行であった時に限って、現在の SCP をその行に適用し、"新しい行ではない" という様に書き換える。
  - では書き換えるタイミングは何であろう。例えば、一番初めに文字を書き込んだときであるべきか。
    それともカーソルを移動させた瞬間であるべきか。
    カーソルを一気に動かした場合にはどうするべきか。
    カーソルを一気に動かした場合にはスキップされた間の行にまで値が適用されるのは変な気がする。
    という事はカーソルを一気に動かした場合にはあいだの行には SCP は適用しないとする。
    そして、カーソルを一気に動かした場合と一歩ずつ動かした場合で同じ動作になって欲しいという事を考えると、
    結局カーソルの移動だけでは新しい行に属性を適用するには至らないという風にした方が良い気がする。
    つまり、行に対して具体的に何らかの変更が適用される時に初めて行の属性を適用するという風にする。

  さて SCP がこの様な動作をしている時に SLL/SLH はどの様に動作するべきか。
  カーソルを移動して前の場所に戻った時に、現在の SLL/SLH を用いて動作する方が良いか、
  それとも行が生成された時の SLL/SLH を用いて動作する方が良いか。

  % 普通に考えると現在の SLL/SLH を用いて動作したい所だが、
  % 一方で SCP での "以降の行" というのは新しく生成した行に対してのみ適用する事に決めた。
  % この時 SLL/SLH での "以降の行" を別の意味に解釈するのも変である。
  % もう少し考えてみる。SLL/SLH は行を生成した時の値を用いるという動作の方が自然に思われる様な例があるかもしれない。
  %
  % % 例えば、SCP で character path が反転している様な場合はどうだろう。
  % % DCSM(PRESENTATION) の場合には見た目によって位置が決まる。
  % % →しかし、よく考えてみたら SCP は表示部での character path つまり文字位置の番号自体を反転させるのであって、
  % %   記憶部と表示部の列番号の対応関係に影響を与える物ではない。
  % %   そして SCP の異なる行を跨った場合には、例え DCSM(PRESENTATION) であっても、
  % %   見た目に左右が反転している事を考慮に入れて表示部での列番号を移動するのではなく、
  % %   飽くまで表示部での列番号は保持したままで実際の位置は左右反転するという事になる気がする。
  %
  % うーん。でもやはり SCP での "以降の行 (subsequent lines)" との整合性から考えて、
  % SLL/SLH で設定される境界についても各行で保持して、
  % 新しい行に対してのみ現在の設定を適用するという様にするべきな気がする。

  →改めて規格を見てみると SCP の "以降の行 (subsequent lines)" は SCP の説明にしか出てこない。
    一方で、SLL/SLH の "以降の行 (lines of subsequnet line)" は TAB の設定などで複数回出てくる。
    さて、もし SLL/SLH を SCP と同様に各行で定義するとすると、
    整合性から考えて tab stop 等も全て行毎に管理しなければならなくなる。
    それは面倒であるし効率が悪そうな気がする。
    だとすれば、やはり SLL/SLH については共通の設定を一つ何処かに持っておいて、
    行毎には記録しないように変更するべきか。

  [結論]

  - 行には新しい行かそうではないかを識別するための属性をつける。
  - 新しい行に初めて文字などの書き込みを実行する時に、属性を適用する。
    また LF や NEL を実行した際にも属性を適用する。
    後 CR の直前にも実行しなければならない。というか LF の代わりに CR で実行するべき?
  - ED 等の消去関数を用いた場合には空になった行は新しい行としてマークする。

  これらについてはタブ関連の機能について調べてからで良いだろう。
  タブ関連の機能を見て、行毎に tab stop を管理しなければならなそうであれば、
  SLL/SLH も含めて行毎に管理をする様にする。
  もしタブは全ての行について共有なのだとすれば SLL/SLH もその様にする。
  →どうもタブ関連の機能は TSM で動作を切り替えられる様である。
    しかし TSM に影響されずに動作する DAQ(7) 等の機能も存在する。
    つまり基本的に character tab stop は行毎に管理して、
    但し、TSM = MULTIPLE の場合には特定の制御機能は
    全ての既存の行に対して作用するという事らしい。
    全体で共通の tab stop を管理するという様な事ではない様だ。

2016-09-25

* 各機能のテストコードを書く必要がある。

* BEL/HT/VT の正しい実装

* cell で毎回セルのアドレスを計算して取得するのではなくて、
  window.cur に現在のセル、もしくは現在の行へのポインタを保持した方が
  効率が良いのではないか。

2016-09-24

* planned programs

  - terminal multiplexer
  - terminal with graphical user interface
  - screen の様に複雑なことをする物が最終目的の一つだが、
    一方で、cygterm の様に他のプログラムとの仲介を行う物もあった方が良い。
    何かの折にそのようなシンプルな物が欲しくなることがあるだろうからである。

* ポーリングを O_NONBLOCK でやって sleep するのはやはり良くない?

  とはいいつつ入力と出力の両方を監視しなければならないので結局
  timeout を設定して交互に確認することになるので結局同じかもしれない。
  いや、然し同時に複数のオブジェクトを待つという種類の同期の方法が
  提供されていても良いはずだ。

  これについては今の所は致命的な問題になっていないので対処しない。
  後で余裕が出てきた時に正しい方法を模索する事にすれば良い。

2016-09-23

* PLD/PLU/SGR 10-19 の出力を実装する

* SGR 60-69 の実装方法について決める

  同時に複数の属性を on にできるのかそうでないのか。
  或いは出力先のターミナルに応じて処理を変えるべきか否か。

2016-09-22

* ルビ?

  ANSI や Unicode にルビの機能があるようである。面倒である。

  - ANSI に PTX という物がある。これはルビのための制御機能に見える。
    「CSI 1 \ 漢字 CSI 3 \ かんじ CSI 5 \」などの様にして使うものと思われる。
    行内に無理やり押し込めるのではなくて、隣の行に表示することを意図している様だ。

  - 更に Unicode にもそれ専用の文字がある。
    U+FFF9 .. U+FFFB  Interlinear annotation characters
    「<U+FFF9>漢字<U+FFFA>かんじ<U+FFFB>」などの様にして使う。

    <a href="http://unicode.org/reports/tr20/tr20-1.html">UTR #20: The Use of Unicode with Markup Languages</a>
    <a href="http://www.slideshare.net/xkawabata/2014-1109-texruby">TeXユーザの集い2014　発表資料（W3C Ruby）</a>
    <a href="https://en.wikipedia.org/wiki/Ruby_character">Ruby character - Wikipedia</a>
    <a href="http://www.wdic.org/w/CUL/%E3%83%AB%E3%83%93">ルビ ‐ 通信用語の基礎知識</a>

    U+FFF9 - U+FFFB にはそれぞれ IAA IAS IAT という略称が与えられている様だ。

    しかし Unicode も一体何を目指しているのか謎だ。変な制御機能を追加してドキュメントの構造を定義するのであれば、
    SGR だとかに対応する様な機能をつけて加えても良いような気がしてくる。勿論、論理的な意味構造に対応する物しか
    追加したくないという主張なのだろうが、誰が使うのか分からない妙な制御機能を付け加えるならばより明確な機能である
    描画属性ぐらい対応しても良い気がする。毒も喰らわば皿までという事である。

  * PTX と SRS, SDS の interaction についての問題

    | PTX は ECMA-48 を読む限り "普通は隣の行に表示する" などと書かれているが、
    | SRS や SDS など双方向テキストが混ざっている場合にどうするのかというのが謎である。
    | 逆方向の文字列に文字を追加するとその度に既に出力した文字列の位置はずれる。
    | そこに PTX が含まれていると "隣の行" の内容をふりがなで塗りつぶす事になるのではないか?
    | 更に、隣の行の上での双方向の構造がどのようになるのかも謎である。
    |
    | 改めて PTX の説明を読んでみると、PTX is used to delimit strings of graphic characters that are communicated
    | one after another in **the data stream** but that are intended **to be presented** in parallel with one another,
    | usually in adjacent lines. と書かれている。6.3/4 によると data stream はデータ部の中にあるデータの事と思われ、
    | だとすればデータ部の中ではルビは単に付加情報として取り扱われ隣の行には影響を与えない。
    | 実際に表示部に表示されるときにだけ隣の行に上書きして表示するものと考えるという事になりそうだ。
    | しかし、そうすると隣のセルに既に内容がある場合にどちらを優先して表示するのかといった問題が生じる。
    | 例えば、
    | a 常にルビを優先するか、
    | b 或いは常に本来のセル内容を優先するか
    | c もしくは後に描画したものの方を優先して表示するとか
    | a' 次の行の内容を優先するか
    | b' 前の行の内容を優先するという可能性がある。
    | d 或いは重ねて表示してしまうか。
    |   考えて見るに Unicode を完全に処理するとしたら行からはみでて表示される文字も表示したいし、
    |   そう考えてみると重ねて表示してしまうというのが現実的な解になるのだろう。
    |   また実際に其処にあるのに表示されない文字というのも変なので、両方表示したい。

    [結論]

    - データ部ではルビは付加情報として埋め込み、隣の行には影響を与えない。
    - 表示の際に具体的にどうするかは実装に任せる。
      一般的な実装としては表示の際に隣の行に表示する。
      隣の行に既に内容がある場合は重ねて表示してしまうのが良い。

    ※はみ出る文字があると再描画領域の計算などが難しくなるが、
      HTML レンダリングエンジンではそれをやっているのだし、
      何れにしてもふりがなだとかよりも先に実装することになるだろう。

* ANSI の記述によるとエスケープシーケンスは全て "文字" ではなくて "数" で指定されている。
  つまり、変な文字コードを使っていたとしても、エスケープシーケンスに含まれる
  '[' や ';' や '0' は ASCII における値を使わなければならない。
  従って、ソースコード中ではこれらは数字で表現するべきである。

2016-09-20

* original contra のコードの取り込み

  更にもっと古い ConsoleEscapeSequenceHandler についても統合を行いたい。

* gh-pages

2016-09-18

* 端末を作って遊ぶ。

* 端末の要素

  制御シーケンス・文字コードの解釈

    文字コードの枠組み iso2022 は制御シーケンスと渾然一体になっているので、
    どの様に取り扱うかは微妙である。既存のライブラリを部分的に使うかそれとも全部自前で処理するか。
    取り敢えず UTF-8 だけに対応してみるというのであれば大分楽である。というか自明である。

    制御シーケンスの最大の長さというものは決めておかなくても良いだろうか。
    幾らでも巨大なシーケンスを許容すると、超巨大なシーケンスを送りつけてメモリ不足にさせる、
    という攻撃が可能になってしまう。例えば、巨大なシーケンスはファイルに書き出すなどとしても、
    ディスク容量に依存してしまう。そういう訳で制御シーケンスの長さに制限を与えるのが現実的である。
    しかし現代に於いては巨大なデータを送りつける用途もある。
    シーケンスの種類に応じて適応的に処理するべきな気がする。

  バッファの管理

    内部的なデータの表現方法が鍵になる。この定義によって性能が規定される。

    そもそも何が必要か。行、文字、文字幅、属性の管理が必要だ。
    更に unicode grapheme clusters を考えると、結局文字はどう頑張っても可変長になる。
    属性については種類を限定せずに幾らでも拡張可能な様に設計するのが無難だ。
    また、画像だとかのインライン要素も管理しなければならない。

    同時にメモリ効率や変な脆弱性が入らない様にしたい。

  bidi

    既存の各 terminal が bidi をどの様に処理しているのかは確認しておく必要がある。
    特に行折り返しの時にはどうしたら良いのだろう。
    http://unix.stackexchange.com/questions/100811/are-there-terminal-emulators-that-support-bi-directional-text

    うーん。ある場所に hoge (表示 egoh) と出力して、その後にカーソルを色々移動した後に
    hoge の末端に移動して fuga (表示 aguf) と出力したとする。この時にこの二つの文字列が結合して、
    agufegoh という表示になるとそれは変だ。という事は bidi に対応する場合には、
    どの部分が連続して出力されたものなのかという情報を保持する必要がある。

    例えば属性を用いてこれを表現するなどはどうだろう。或る属性がついている文字は、
    次の文字と結合して bidi になる。最後の文字には bidi 属性は設定しない。次の文字とくっつかない為に。
    但し、最後の文字を削除する場合には前の文字から bidi を削除しないと勝手に次の文字とくっついてしまうので注意する。

    →ECMA-48 を読んでいたらわざわざ bidi の為に presentation component
    と data component という物が用意されている様だ。[ECMA-4.8/6.1]

  描画部

    この部分はただ愚直に実装すれば良い。何も問題はない。
    但し、更に別の端末に対して出力を行う場合には terminfo 等を参照せねばなるまい。

  キーシーケンスその他

    逆にユーザ側からアプリケーションに向かって送信されるデータ。
    これについても愚直に実装すれば良いだけである様に思う。
    但し、別の端末から受け取ったデータは翻訳する必要がある。
    これはやはり terminfo 等を参照する事にする。



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2019-04-29

* vttest(2) の origin mode test が駄目 [#D0090]
  一番下に表示されると言っている行が一番上に表示されている。
  動作を調べる事にする。

  \e[23;24r\r\n の直後に "この行は一番下" と出力し始めている。
  これが意味する所は、 DECSTBM で原点に移動するという事である。

2019-04-28

* bug: vttest で抜けてから ls すると背景色が適用されていない領域ができる [#D0089]
  どうも前回と内容が同じ時に起こるスキップの様である。
  然し、IL や DL で消滅した行に関しては old_content は clear() されている筈である。
  trace_line_scroll の中で不整合が起こっているという事だろうか。

  動作をもう少し詳しく見てみることにしてみた。
  問題が起こっている時には DL で 23 行消して IL で 0 行挿入している。
  (そもそも削除しっぱなしで良いのか、同じ行数だけ挿入する必要はないのか
  という話もあるがまあ後で考える事にする。)

  一方で、screen_buffer の方でどれだけ clear しているのか、
  というのを観察してみると 1 行しかクリアしていない。
  うーん。これは実際に移動した1行についてだけクリアしているという事。
  その他の行についてもクリアしないといけないのである。
  修正した。ちゃんと動く様になった。

  * done: 画面が一番下にない限りは削除するだけでなくて
    同じ行数だけ挿入しなければならないのではないか?
    これもその様に修正した。

    取り敢えず一番下にいるかどうかを is_terminal_bottom という変数を参照して決める事にした。
    現在は is_terminal_bottom は定数だが、今後実際に使う場合にはその時の状況に応じて
    設定する変数とする。

* 変だ xenl の時に \b をすると2文字戻ると思っていたが、 [#D0088]
  xterm の上で試してみると1文字しか戻っていない様に見える。
  何かそういう設定が存在するという事なのだろうか。

  RLogin で試すとちゃんと2文字戻る。
  xterm は何か特別な条件で戻ったり戻らなかったりするのだろう。
  よく分からないのでこれはそのままで良いという事にする。

  * ok: xterm の行末での全角文字を潰す時の振る舞いについて:
    % 後、xterm は行末で あ\e7\e8\ba 等とすると
    % "あ" の左半分だけを表示できる。
    % つまり、全角文字の途中で半角文字を踏み潰しても OK になる。
    % 例えば "え\ba" 等としても全角文字が消去される。
    % 行末以外で "え\e7\e8\ba" としても全角文字は消去される。
    % 行末で "あ\ba" とすると全角文字は消去されない。
    xterm は行末で "あ\ba" とすると全角文字の左半分だけが残る。
    これはバグだろう。この振る舞いに関しては再現しなくて良い。

* うーん。実行していて気づいたのだが、実は DECSLRM が設定されている時に [#D0087]
  右境界の右側にいる時に文字を出力すると改行せずにそのまま出力される。
  更に、同じ位置に居ても実は xenl として其処に留まっているのかどうかが
  ちゃんと記録されている様である…。つまり…。
  カーソル移動を大幅に修正しなければならない。

  更にカーソル移動によって実際のところカーソルが動かなかった場合、
  というのも存在すると思われるがその場合には xenl 状態をクリアするべきなのか、
  クリアしなくても良いのか…。

  これは大きな変更になりそうなので独立した項目で処理する事にする。

  [実装]

  * done: 先ず初めに cur に xenl を記録できる様にする。
    振る舞いを見るに実は xenl が設定されている時には、
    本当は最後の文字ににカーソルがあるけれども、
    色々の制御機能において行末にある振りをしているという事の気がする。

    然し、insert_graph だとかの実装の都合を考えると、
    やはり行末の位置にカーソルを置いて置いた方が便利な気がする。
    一方で行移動などが起こった時に行の最後の位置に
    移動するという振る舞いをどの様に再現するか。

    振る舞いに関して SU,SD 等は xenl を保持する。
    CUU,CUD,VPB,VPR や VPA 等は xenl を保持しない。
    DECSC, DECRC は xenl を保持する。
    VT は xenl を保持しない。

    取り敢えず実装した。今の所は問題なく動いている気がする。

  * do_sm_decawm は範囲外にいる時に範囲内に強制して良いのか?
    xterm の振る舞いを調べてみると、xenl が
    設定されている時に 1 文字戻しているだけの様に見える。
    取り敢えず b.cur.adjust_xenl() だけ呼び出す事にした。

  * done: insert_graph の調整
    うーん。取り敢えず範囲外にいたら範囲を広げて考える様に修正した。
    また SIMD の時には xenl は考えない事にした。
    直ぐに次の行に移動する事にする。

  * done: do_bs の調整

    うーん。xterm の振る舞いがよく分からない。
    vttest を実行している時には BS の前に xenl で後退している様に見える。
    然し、手動で行末に行って其処で \b を出力しても 1 文字しか戻らない。
    一方で RLogin は手動で行末に行って其処で \b を出力すると2文字戻る。
    また DECSLRM の右境界に行っても \b でちゃんと2文字戻る。
    よくわからないので、取り敢えずは RLogin の振る舞いを真似る事にする。
    xterm については何か発動条件の様な物が存在するのだろう。

    SIMD の時の振る舞いがどうなるべきかはよく分からないが、
    取り敢えずそれっぽい振る舞いで実装する事にした。

* 2019-04-23 DECSLRM の時の動作テスト: SU,SD,LF,IL,DL のそれぞれについて [#D0086]

  どうやってテストを作るのが良いのだろうか。
  実はシェルスクリプトでも作った方が良いのかもしれない。

  DECSLRM を実行したらコアダンプしてしまった。
  エラーメッセージは出力されていない。
  compose_segments の line_segment_transfer の時のバグだった。修正した。
  取り敢えず do_vertical_scroll は動いている様だ。
  SU,SD,SL,SR は do_vertical_scroll を使って実装されている。
  IL,DL も do_vertical_scroll で実装されている。
  LF も do_generic_ff -> do_vertical_scroll という具合に実装されている。
  その様に考えれば現状で do_vertical_scroll が動いていたのでまあ大丈夫だろう。

  但し、m_prop_enabled = true の時については誰もテストしていない。。
  取り敢えず m_prop_enabled = true の場合でも動いてはいるようである。

* vttest が decmode 3 4 5 8 40 45 を要求している [#D0085]
  2019-04-28 残っているのは ?45 だけである。
  ?45 は何だったかというと、"行頭BSによる上行右端移動" と書かれている。
  xtBSBackLine という名前を与えて実装する事にした。

* [自然解消] ansi: clear screen で DECSTBM の原点に移動する? [#D0084]
  そもそも clear screen はどの様なシーケンスで実施されているのだったか。
  $ TERM=xterm infocmp | grep 2J を見ると \e[H\e[2J の様である。
  つまり原点に移動している。しかし、原点と言っても \e[H である。
  つまり DECOM の影響を受けて移動先の位置は変わるのだと思われる。

  clear screen という機能はそもそもない。terminfo のシーケンスで自動的に原点に移動する。
  DECOM にも対応しているので、恐らく他の端末で実行した時と同じ振る舞いになっている筈。

* DECALN の実装 [#D0083]
  これで恐らく vttest 1 はちゃんと通る様になった筈。

* DECLRMM の説明を読むと [#D0082]
  DECLRMM が有効の時にしか DECSLRM は margin を設定できないとなっている。
  つまりいつでも DECSLRM が設定できるが DECLRMM がないと効果が発揮されない、
  という事ではなくて DECLRMM が有効でないと margin を設定できないだけで、
  既存の margin は有効であるという解釈なのだろうか。

  xterm で試す。
  - % xterm で DECLRMM 及び DECSLRM を設定して試そうとしているが発動しない。
    % もしかして、未だ実装されていないとかそういうことだったりするのだろうか。
    % 或いは、無効になっているとか。。
    → -ti 340 で起動すると無効になる様だ…。
  - 改めて xterm-344 で起動してみると…。
    ?69l した瞬間に margin の設定をクリアする様である。
    うーん。面倒なので、xterm の振る舞いには追随しない事にする。

  RLogin で試してみる。
  - % やはり ?69 は現在設定されている margin が有効か
    % 無効かだけを制御していて、DECSLRM が margin を設定できるかどうかとは
    % 関係ない動作をしている様に見える。
  - ?69 を設定して margin を設定して、
    ?69 を解除して設定しても margin は有効であった。
    ここから分かる事は ?69 を解除しても margin がその場でクリアされる訳ではないという事。
  - ?69 を設定して margin 10;25 を設定し、
    ?69 を解除して margin 10;50 を設定し、
    ?69 を設定すると、どうやら 10;25 になっている様子だ。
    つまり、?69 が設定されている時にのみ DECSLRM は margin の設定を変更する。

  これについては端末によって振る舞いが異なるので
  取り敢えず contra では RLogin の振る舞いにする。

* vttest: test 2 を実行してから test 1 を実行すると着色が反転する [#D0081]
  調べてみると test 2 は反転状態で最後に DECSC (ESC 7) を実行している。
  そして test 1 は何故か最初に DECRC (ESC 8) を呼び出している。
  然し、xterm や RLogin は影響を受けていない。
  何か途中で実行している物が影響を与えて DECSC された内容をクリアしているのかとも思ったが、
  調べてみてもよく分からない。ESC 0 と ESC B は試してみたがクリアしてはいない。
  CSI J 及び CSI 2 J も当然関係なかった。CSI ? 3 l も関係なかった。

  不思議だ…。実際に impl3 が見ているシーケンスを出力するスクリプトを書いてみた。
  そのスクリプトを xterm に食わせてみたら反転するのが再現する。
  という事は xterm が見ている内容と impl3 が見ている内容が異なるという事。

  infocmp を確認しても \eB や \e0 が含まれる様な項目は見当たらない。
  うーん。DA2 で 67;0 という変な物を返しているのが悪いのかと思って、
  それを 61 や 67 に変えてみても症状は変わらない。

  a うーん。という事は受信する時点で何かを間違えている可能性?
    何らかのシーケンスが消滅しているという可能性はあるのだろうか。

    うーん。やはり変だ。やはり受信する時点で何か内容が変化している気がする。
    例えば E で囲むというのが実行されていない…。E で囲むというのは何に依って引き起こされるかというと。
    ESC#8 によって引き起こされる…。あれ、もしかして ESC#8 が ESC 8 に翻訳されている?
    何と、そうだった。手で \e#8 を出力すると \e8 が記録されている。
    これが意味する所は escape sequence の中間バイトが記録されていないという事。

  b screen でもやはり \e7\e8\e8 で反転状態になってしまう。
    detach して attach してもやはり反転状態はそのままなのでそうなのだろう。
    一方で、screen から vttest を実行した時には、
    一瞬だけ反転する様子が見えるがその後に通常の表示に戻るのが見える。うーん。

  原因は a だった。遡っていくと、そもそも # が受信されていない疑惑…。
  分かった。sequence で ESC を受け取った瞬間には has pending ESC の状態になって、
  その次に文字を受け取った時に初めて ESC # のペアでエスケープシーケンスを開始する。
  それなのに ESC だけしかシーケンスに記録されないというバグだった。

* vttest (2): 三行の****が現れる筈の所4行現れている [#D0080]
  出力されているシーケンスを確認すると **** を2行分ずつ出力しているが、
  decawm SM(?7) が入っている時と入っていない時で試している。
  もしかして decawm というのは xenl 等の機能ではなくて、
  新しい文字が来てもずっと其処に留まるという動作の物なのだろうか。。

  うーん。振る舞いを色々と調べると現在の実装は微妙だ。
  xenl と decawm の両方を参照して処理を分ける必要がある。

* bce というのが erase の時に使われる着色を制御している気がする [#D0079]
  対応した。mode_bce を見て erase に使う属性を変更する。

  と思って色々と動かしていたらどうも bce というのは背景色だけを適用するのであって、
  その他の属性は適用しない様に思われる。例えば反転を適用すると前景色と
  背景色を入れ替える事になるが xterm 及び RLogin の振る舞いを見ると、
  背景色がそのまま表示されている。

* 行内容の更新は先頭一致部分と末端一致部分だけ活かす様にする [#D0078]
  #D0077 の様な方法を考えるととても複雑になって、
  色々と新しいデータ構造をメモリ確保しなければならなくなって微妙な気がするので、
  取り敢えず先頭一致部分と末端一致部分だけを使って処理する事にする。

  (それでも末端一致部分は DCH 等すると一致しなくなってしまうので、
  結局先頭一致部分しか一致させない場合になってしまう事も多いが、
  これに関しては取り敢えずは気にしない事にする。)

* [棄却] 動的計画で最短の出力で行内容を更新する方法? [#D0077]
  現在の実装では行の追跡は行っているが、行の更新は全て再描画している。

  これは結構考察が必要な気がする。
  基本的には diff のアルゴリズムと同様で、
  しかし、スキップなどがあったりした時のコストが異なる。
  diff の場合にはスキップのコストが一定だったので何とかなったが、
  今回の場合にはそう簡単ではない。何しろ二次元の表であるマス目に来たとしても、
  其処に来るまでの経路で描画属性が異なるはずで、それも考慮に入れないと
  実際にどれだけの出力が行われるかはわからないからである。

  よく考えてみたら proportional の場合にはもっと複雑になる。
  →余りに複雑になるし本当にそれで効率的になるのか分からないので取り敢えず棄却する。

2019-04-27

* vttest: DECCOLM 後のカーソル位置 [#D0076]
  うーん。未だ表示位置が変である。調べると DECCOLM を unset している。
  この瞬間にカーソルを原点に移動するべきという事か。
  然し、やはり駄目である。と思って再度実行したら動く様になった。

* vttest で気づいたのだが BS は行末にいる時に一文字戻ってから作用する。 [#D0075]
  これを修正したら何だか良い感じになったが…。

* vttest で全然駄目だと思ったらどうやら DECOM を使っている様だ。 [#D0074]
  RLogin を確認すると DECOM で変化するのは
  HPA HPR VPA VPR HVP CHA CUP なのだそうだ。
  然し、HPR, VPR がどう影響を受けるのかというのは謎である。
  →RLogin で試してみた所 HPR, VPR は DECOM が有効の時に
    範囲内に confine される様になる様だ。

  * do_cux の lrmargin の制限はちゃんと行方向の反転を意識しているのだろうか…。
  * 更に、RLogin では RS,GS 等の移動も影響を受けるのだろうか。試すと影響は受けない様だ…。

* mode ?4,?5,?8 [#D0073]

  4 はスクロールに関する話。これに対応すると滅茶苦茶遅いので対応したくない。
  というか現在の機構だと対応が困難である。一行変更する度に画面更新をかけるのだろうか。

  5 は背景色の設定だが…。よく考えてみれば現在の実装だと、
  背景色は外側の端末の設定をそのまま使う前提である。
  そういう意味において内部で背景色を設定できる様にしても良いのではないかという気がする。
  うーん。然し、背景色を設定したとして…面倒だ…。

  8 はキーボードを実際に持っている端末でないと意味がない。
  これに関しては外側の端末に伝達しなければならない。

  取り敢えず背景色が設定されている時の output について実装する事にする。
  幾つかの実装方法を考える事ができる。

  a sgrcap の方で設定を弄って既定の前景色・背景色を設定する時に
    前景色・背景色を設定する様に書き換える様にする。
    この方法の問題点は設定を term の中で書き換えるのが難しいという事である。
    また、やはり出力先の端末の性質と中の端末の設定は独立にしたい。

  b もう一つの方法は attribute_t を描画時に渡す時にそれを修正して渡すという事。
    前景色・背景色の設定は何処に保持するのが良いだろうか。
    tty_state の中に保持するか、或いは、sgrcap の中に保持するか。
    うーん。実際に term に対して背景色を問い合わせたりするという事があるという事も考慮に入れると、
    やはり term の中に現在の前景色・背景色について設定できるようにするのが良い気がする。

  c 或いは board_t の中で既に背景色や前景色を設定した状態で記録する。
    これは微妙な気がする。やはり独立にしたいという気がする。

  apply_attr する時に既定の前景色・背景色があればそれを上書きする事にする。

  * reject: screen_buffer に格納する前に既定の前景色・背景色を適用してしまう?
    うーん。差分を取って行を更新している事などを考えると、
    背景色の変更に関してはキャッシュに記録した方が良い気がする。
    後、背景色の変更があった時には全体を更新しなければならない。
    うーん。逆に全体を更新しなければならないのであればキャッシュをクリアすれば良い訳で。
    という事を考えると、やはり既定色についてはその場で設定するというので良い気がする。

  * done: とにかく。先ずは既定の前景色・背景色を attribute に適用するコードについて考える。
    結局最後まで実装した。動いている。まあ、これで良いだろう。

  * done: 次に mode ?5 で既定の前景色・背景色を弄る様にする。
    改めて説明などを読むと、これは明るいか暗いかというよりは反転しているかどうか、
    という話の様なので実は既定の前景色・背景色の設定の話ではない気がしてきた…。
    うーん。これは結局、反転として処理する事にした。

  x fixed: 反転として実装したら妙な感じになった。
    自分で指定して着色している物まで反転していて良いのか。
    その様に考えると実はやはり前景色・背景色の既定色の
    入れ替えとして考えるべきなのではないか。

    xterm で試してみると実際に既定色のみの入れ替えになっていた。
    また、DECSCNM の説明に反して明暗は固定ではなくて、
    その端末の既定の背景色・前景色に依存して変わる。

    →その様にして実装する事にした。
    前景色・背景色が設定されていない時には分からないのでそのまま。

* BUG: ansi: 何故か知らないが空白が入力される様になってしまった… [#D0072]

  うーん。ble.sh 側の問題ではない筈。というのも、他の端末では症状が出ていないので。
  respond() を消すと問題がなくなる。という事は DA2 のシーケンスを構築しているところが悪い。
  うーん。見てもよく分からない。或いは DA2 のシーケンスの中身によって何か変な事が
  ble.sh 側で起こっている可能性もなくはない。
  うーん。respond() だけ呼び出しても変な物が出力されている。
  respond() を2回呼び出しても1回しかスペースは入力されない。

  もしかして初めから変な物が入っている可能性がある?
  と思って初期化の所を見てみた所、サイズを指定するつもりで 32 が指定されていた。
  これがサイズではなくて要素の初期化であると見なされて空白が挿入されていたのである。
  更に、よく考えてみれば初期化の時に指定するのはサイズではなくて、
  capacity の方である筈なのでここで指定しても仕方がない。
  コンストラクタの中で reserve を呼び出す事にした。

* ansi: 端末サイズ変更関連に対応する [#D0071]

  * done: 端末のサイズを変更した時に行内容を truncate する。
    そうしないと全角文字などが化けて出たり座標計算がおかしくなったりする。

  さて、vttest でどの様に動作するのが正しいのか確かめる為に実行してみると、
  そもそも screen では何やら変な動作をする。
  Poderosa に下って実行してみようとしたら Poderosa が固まってしまった。
  結局まともに動作する端末は余りないという事なのだろうか。

* というより DSR に応答する様にしなければならない [#D0070]
  現在は何も応答していない。というか、そもそも制御機能の登録もしていなかった。
  不思議だ ble.sh が DSR(6) を発してはいなかったか。。
  或いは ambiguous width を emacs にしているから飛んできていないだけか。

  何れにしても vttest を実行する上で DA1 だか DA2 には応答したい。
  応答する為には応答の書き込み先を用意しなければならない。

  * done: 適当に DA1 には応答する様にした。
    然し、今度は vttest が DECRQSS を要求している。
    うーん。実装していない。

  * done: DA2 についてはうーん。取り敢えず適当に CSI > 6 7 ; 0 c を返す事にする (67 は 'C')。
    中で ble.sh が DA2 を要求しているので ble.sh が受信した内容を確認する。

      $ echo $_ble_term_DA2R
      67;0

    OK. ちゃんと返答できている。

  * done: というか返答に使う CSI は S7C1T 等の設定に応じて切り替えるべきでは。
    更に "\x1b[...c" 等ではなくて ascii code で出力するべきである。

  * done: vttest を実行してみると DECRQSS を送ってくる。
    DECRPSS を返信する様にした。

* bug: vttest を実行しようとしたら表示が滅茶苦茶に乱れる、と思ったら tab を使うとなる様だ [#D0069]
  tab は全て nul か sp に変換しているつもりだったのにそのまま挿入されているという事になる。
  うーん。調べる。やっぱりカーソル移動しか実行していない気がする。
  或いはカーソル移動するともう駄目なのだろうか。
  →そうだった。カーソル移動だけで座標計算が駄目になる。
  と思ったら pus_spaces の中身を展開した時に変数を書き換えていたのが駄目だった。

* というか sequence で ^@ や ^? を読み飛ばしているつもりだったが読み飛ばせていない。 [#D0068]
  うーん。不思議だ確認してみると ascii_nul または del は無視している筈…。
  そもそも graphic character としても挿入されない。全く処理されない筈なのである。

  * fixed: うーん。そもそもエラーメッセージに ^@ という文字が含まれているのがおかしい。
    と思って確認したらちゃんと変換するのを忘れている。直した。NUL と表示される様になった。
  * fixed: うーん。もしかすると中途半端に終了してしまったシーケンスを処理しようとしている?
    調べてみるとそうだった。process_invalid_sequence を呼び出す前に set_final で
    問題の文字を設定してしまう事にした。

    そして実際にシーケンスの途中に改行だとかタブだとかを混ぜて来ている…。
    この時にどう振る舞うべきなのか…。改めて ECMA-48 を確認してみたが何も書かれていない。
    screen はちゃんと対処して vttest を通っている。という事は何か期待される動作があるという事。
    a もしかするとその改行だとかタブだとかを改めて制御機能として処理するという事なのだろうか。
      現在の contra の実装では単に捨ててしまっている。
      と思って改めて処理する様にしてみたが全然駄目だった。
    b 或いは単に途中に C0 が含まれていても無視する様になっている??
      試しに無視する様にしてみたら駄目だった。
    c 或いは途中に現れた C0 は独立に処理してしまう?
      その様にしたら通る様になった。

    vttest は CR HT VT に対してしかこの振る舞いを要求していない。
    他の制御文字に関してはどうなっているだろうか。
    RLogin で試すと (1) FF も埋め込める。(2) 流石に他のエスケープシーケンスは埋め込めない。
    (3) 制御シーケンスの中に ESC が来た時、その ESC は次のエスケープシーケンスの先頭として使われる。
    つまり、ESC も一緒に廃棄されるという訳ではない。(4) LF も埋め込める。(5) 8bit NEL は埋め込めない。
    恐らく UTF-8 デコード前にもう駄目になっているのではないかという気がする。(6) 実は C1 は全て認識している。
    FS, GS, RS, US による移動も認識している。

2019-04-23

* cat memo.txt すると右端にごみが残ってしまう [#D0067]
  これは何だろう。描画ルーチンで m_width + 1 だけ ECH すると消える。

  | 何処かで一文字消滅しているのだろうか。或いは screen が文字幅を勘違いしている?
  | というか、impl3 の方で文字幅を勘違いしているのかもしれない…。
  | と思ったが、screen で観察する限りはちゃんと最後のごみは 80 桁目に収まっている。
  | と思ったら screen を detach/attach すると消える。
  | という事はこれは contra 側の問題でもなく screen 側の問題でもなく、
  | Poderosa の問題という事になるだろうか。
  | 直接 Poderosa から ./impl3 を実行しても問題は発生しなかった。
  | という事はこれは screen が Poderosa に出力する時に起こる何らかの不整合だろう。

  結論: screen の Poderosa に対する描画が何か変である。contra ./impl3 は関係ない。

* 行の追跡と再描画の省略 [#D0066]
  次に実装するべきは何だろうか。

  恐らく行毎に変更があったかなかったかを検出する事と、
  行事体の移動を追跡する事である。
  その為には前回の行の内容 (というかその瞬間に端末に表示されているであろう内容) と、
  行番号と version 番号などなどである。
  行番号と version が一致していれば更新の必要はない。
  一致していなければ行内容を照らし合わせて変更のあった部分以降について更新を行う。

  行番号の追跡に関しては全画面の時には実施するが、
  他の内容も表示されている時には DECCRA もしくは DECSLRM がないと難しい。
  逆に DECCRA 及び DECSLRM が使えるのであればそれを使ってスクロールする様にしても良い。

  * done: 取り敢えず各行に固有の id が割り振られる様にする。
    set_id をする場所は何処だろうか。board_t の中で新しい行を入れている所で割り当てる。

    ? 後 term.cpp で clear_content を呼び出している箇所はどうだろうか。
      clear_content を呼び出しているのは EL(2) 及び ED である。
      これらに関してはまあ新しい行と認めなくても良い気がする。
      全削除をしている事によって追跡の必要はなくなるという事の気がするけれども、
      然し、概念としては実際には削除していない。結局どちらでも良い気がするが…。
      id を描画の目的だけで用いるのだとしたら新しい id を割り当ててしまって良い気がする。
      一方で id を別の目的で将来使用したくなる可能性まで考えると
      新しい id は割り当てない方が良い気がする。
    →結論: EL(2) 及び ED では新しい id は割り当てない事にする。

  * done: id 及び version が変化した行だけを再描画する。
    これは直ぐに実装する事ができた。そんなに大変な事はなかった。

  * done: id を用いた行の追跡を実行する。
    これは scroll が有効な場合とそうでない場合があるので on/off できる様にする。

    というか、これは先ず始めに差分のアルゴリズムで最長の一致を求める必要があるのではないか?
    と思ったが、よく考えてみると端末のシーケンスには行を挿入したり削除したりするコマンドはあるけれども、
    行の順序が交換される様な操作は存在しない。従って、最長の一致は共通の id を持つ行を特定するだけで良い筈。
    もし順序が交換される様な場合もあるとしても、さしあたっては簡単なアルゴリズムで十分であろう。

    取り敢えず決めなくてはならないのは共通部分をどの様に決定するのかという事である。
    これは実は前の表示内容の各行がどれだけ移動したかという情報で良いのではないか。

    行の移動の最適な方法は何だろうか。
    先ず始めに各位置で削除と挿入をそれぞれどれだけ行うかを決定する。
    挿入を実行した時に内容がはみ出てしまうと問題に鳴るので削除は先に実行する。
    その後で挿入を実行すれば良い。

    では screen_buffer の方の更新はどの様に行うのか。
    screen_buffer は配列なので削除と挿入を毎回行っていると効率が悪い。
    実際には各範囲毎に移動量が決まるはずで、それに従って移動を実施すれば良い。
    若い番号に移動する場合には何も考えなくて良い。
    大きな番号に移動する時にはふみつぶさない様に保留する。
    最初に踏み潰されない要素が見つかった時にその要素から順に移動すれば良い。
    その様に考えると移動量ではなくて移動先で管理した方が良い様な気もしないでもない。

    うーん。結局、削除・挿入・screen_buffer の更新は独立に実施するのが良さそう。
    実装した。本当にこんな実装で大丈夫なのか確認はしていないが、まあ取り敢えず動いているには動いている。

* 2019-04-21 DECSLRM が設定されている時 SU, SR, 及び暗黙移動による rotate で内容を切り貼りする [#D0065]
  内容を切り貼りする為にはある行の内容を切り出して、
  別の行に貼り付けるという事をしなければならない。

  更に mono の場合と prop の場合が混在していた時にどうするかについて考えなければならない。
  表示部での切り貼りとデータ部での切り貼りの二種類の可能性についても考える必要があるだろうか。
  ECMA-48 によると SU, SD, SL, SR は表示部におけるスクロールであった。
  従って、表示部に於いて複雑な切り貼りを実行する必要があるのではないだろうか。
  うーん。DCSM を感知する様にしても良いのではないかという気がする。
  表示部で切り貼りされたらアプリケーション側では現在の状態の追跡が困難になるのではないか。

  然し、将来的な対応だとか実装の自然さなどを考えるとデータ部における切り貼りも一応対応したいと思う。
  後、この様な機能を使う頻度を考えると多少効率の悪い実装になっても構わないという気がする。

  compose_segments に渡す line_segment_t に親の行を指定する事ができるようにすれば良い気がしてきた。
  後でまた観察する。一方で mono_compose_segments についてはどうだろうか。
  これもそんなに悩まずに実装する事ができそうだが、一方で、
  呼び出し元で処理すればより効率的な実装ができそうな気もしないでもない。

  * done: 取り敢えず、SU,SD,IL,DL 迄は対応した。

  x fixed: うーん。試しに動かしてみたらスクロールが動かなくなっている…。
    そして動かなくなったのは一つ前のコミットの様である。
    diff を見てみたが何が行けないのかすぐには分からない。
    取り敢えず insert_graph を確認してみる。

    何と折返しが起こっていない、と思ったがよく見るとそもそも
    画面の右端に達していないので折返しが起こっていないというだけだった。
    という事は do_nel が怪しい。特に do_generic_ff が怪しい。

    * fixed: 調べるとそもそもスクロールする所まで進んでいない…。
      というか spl の値が何故か 80 になっている。直した。

    と思ったら直っていない。動作を調べていくと一応 rotate(1) までは呼び出されている。
    うーん。不思議である。ちゃんと呼び出されている。

    うーん。確かに rotate をする時としない時で振る舞いは異なるが変である。
    後、initialize_cells の効果も変である。別に負の shift が起こっている訳でもない。

    うーん。IL DL の方の問題の気がしてきた…。でも変だ。コメントアウトしても何も変わらない。
    IL と DL を即座に抜ける様に修正しても画面の内容が消えたりスクロールしない問題はそのまま。
    やはり rotate が変なんだろうか…。rotate を全くしない様に変更すると、
    出力した内容の1行目だけが表示される様になる。
    最終行だけが表示されると期待するのに何故1行目だけなのだろう…。
    或いは、別の行に何か表示しているのだろうか…。

    1. うーん。先ず prompt で enter を押しても rotate が起こっていない様子である。
      bash --norc で起動するとちゃんと rotate が起こっている。
      これが意味する所は IND もしくは IL, DL による行挿入が動作していないという事。
      また、bash --norc で起動したとしても次々に行内容が消滅する。

      うーん。もしかして書き込み位置がおかしくなっている?

    * fixed: 今気づいたが spl の値が変だ。1 多い。これは修正した。
      然し、振る舞いが微妙に変化しただけで依然として何かが変だ。
      因みに implcit_spl を呼び出している所はこの箇所だけである。

    未だ治らないと思ったらテストの為にコメントアウトしたコードを修正したら直った。OK

  * 次に暗黙的移動で起こる shift_lines についても DECSLRM の影響を受ける様に修正する。
    もう他には shift_lines を呼び出している箇所はない。

2019-04-21

* ICH と DCH についても DECSLRM に対応した [#D0064]
  ECH については RLogin も xterm も DECSLRM の影響を受けていないので保留する。

* SLH,SLL と DECSLRM は同一視しても良いのだろうか [#D0063]
  例えば、ECMA-48 を参照すると SLH, SLL が SU や SD の範囲に影響を与えるとは書かれていない。
  然し、DECSLRM は SU や SD の範囲に影響を与えるという前提の様である。
  少なくとも Tw 上の議論ではその様な前提で行われている様に見える。
  うーん。やはり ECMA-48 を見ても SLH, SLL でスクロール範囲が制限されるとは読めない。

  しかし暗黙移動に対する影響は両者とも同じ様に見える。
  どの様に実装するのが良いだろうか。
  例えば暗黙移動に関する関数に関しては両方を参照する様にして、
  スクロールに関する機能からは DECSLRM だけを参照する様にするなど。
  また、SLH, SLL は subsequent lines という話なのだから、
  行毎に情報を保持する事にする。
  DECSLRM は全体で一つの値を保持するという事にする。

  その様に実装を修正する事にする。

  * done: というか DECSLRM を実装する事にする。
    実装は殆ど DECSTBM と同様で大丈夫。
    調べて分かった事は DECLRMM モードにも依存するという事。

  * fixed: xterm の振る舞いを観察すると変な引数を与えて
    DECSTBM が効かない時には原点に移動する動作も行わない様である。
    今までの実装だと変な引数を与えた時でも原点に移動していたので修正した。

  * done: DECLRMM 用意した。

  * done: 範囲を取得する関数。関数名を考える必要がある。

    うーん。現状で slh sll で取得するのは line_home, line_limit としているが、
    似たような関数名だとどれがどれか分からなくなってしまうので、
    それぞれが何を取得するのか分かりやすい方が良いのではないだろうか。
    例えば slh, sll で設定するのは暗黙的移動による範囲であると考えて良い。
    一方で decslrm で設定するのは暗黙的移動による範囲に加えて、
    スクロールの範囲やカーソル移動の範囲も制限する。

    うーん。slh, sll による設定は implicit_{left,right}_boundary と言った感じである。
    一方で decslrm は完全に範囲を制限している。scroll_left, scroll_right なのか、
    という感じである。うーん。違う。スクロールに関しては decslrm の設定だけ参照する。
    CUF, CUB に関しても decslrm の設定だけ参照する。
    implicit_left と implicit_right に関しては両方の設定を参照する。

    実装した。DECLRMM を参照しつつ決定する。

  * done: implicit_home,limit は引数に line_t const& を受け取る様にしたい。

  * done: board_t::line_home,limit は廃したい。

  * done: RLogin では CUF CUB が影響を受ける。HPB, HPR は影響を受けないのだろうか。
    これについては後で調べる事にする。→調べてみた所 HPB, HPR は影響を受けない様だ。
    従って、取り敢えず CUF, CUB だけ修正する事にする。

  * done: FF の類は SPH, SPL と DECSTBM の両方を参照する様に変更する。

* bug: less で上にスクロールした時に何も表示されなくなる [#D0062]
  何故だろうと思って出力されているシーケンスを観察すると、
  表示されている文字列と表示されていない文字列の出力の間に RI が呼び出されている。
  つまり、RI を呼び出した瞬間に画面がクリアされているという事だろうか…。

* bug: emacs 上で括弧の対応の強調が起動されると描画位置がずれる [#D0061]
  出力されているシーケンスを観察すると何と CR HT HT BS という列で移動を行っている…。
  一体どういう移動方法だ…。ESC [ 1 5 ` か ESC [ 1 5 G で良いのでは?
  と思ったが、確かに 1 byte 少なくて済む…。terminfo か何かの移動テクニックなのだろうか。。

  それと同時に CR HT HT BS に対して現在の実装はどの様に反応するだろうか。

  x fixed: というか、現在の実装では HT に対して 0 埋めを実行しているが、
    実は HT は移動だけしか行わない?→どうやらそのようである。
    現在の実装では 0 で埋めているので修正が必要になる。修正した。

  x fixed: しかしこの修正だけだと未だ振る舞いが変である…。
    →うーん。分かった tab で進む位置の計算を間違えていた。
    現在の位置が丁度タブの位置になっている時に移動しない様になっていた。

  o 実は右端に行った時の振る舞いが変なのでは…。
    と思ったが、改めて見た所、ちゃんと std::min で抑えてあるので大丈夫。
    本来はこれについても line_limit か何かで制限するべきではある。

  何れにしてもずれは発生しなくなったのでよしとする。

2019-04-20

* ansi: rotate を DECSTBM に対応する [#D0060]
  今の実装だと改行などで範囲の外に出てしまう。

  x fixed: さて、対応したつもりだがそれでも何故か文字列を入力して行って
    改行を実行すると範囲の外に出てしまう。
    と思ったが改行で一番下にいるかどうかの
    判定を修正していない気がする。→修正した。

  x fixed: 動かなくなった…と思ったが、
    これは rotate の呼び出し方を反転していたのが問題だった。修正した。

* altscreen が動いていない気がする… [#D0059]
  調べるとどうも set_mode(true) しか受信されていない様である。
  と思ったら get_mode(mode_altscreen) に対応していなくて
  常に false が返る様になっていた。つまり、false に設定しようとしても、
  常に既に false になっているから特別の処置は不要であると判定されていたという事。
  修正した。altscreen は無事に動作する様になった。

* impl3: 取り敢えず端末画面の内容を出力する様にしてみた [#D0058]

  先ずは簡単で良いので画面内容を出力し続ける様にする。

  * fixed: TIOCSWINSIZE の問題
    % できたと思ったが内容がおかしい。どうも出力がおかしいのではなくて
    % 実際に端末画面の内容がおかしいようである。調べてみると、
    % LINES, COLUMNS の内容がおかしい。
    % slavefd に対して TIOCSWINSIZE を実行しても反映されない。
    % masterfd に対して TIOCSWINSIZE を実行しても反映されない。
    % ループの中で何度も masterfd に対して TIOCSWINSIZE を実行すると反映される様だ。
    % しかし、それだといかにも非効率的というか変な事がおきないか心配である。
    % 更に、不自然である。ちゃんと正しい方法が存在する筈である。
    % 思うに bash が起動した瞬間からちゃんと winsize を設定していないといけないのでは。
    % と思って create_session の内部で一番始めに設定する winsize の時点で
    % ちゃんと目的の幅・高さに設定する様にしたら解決した。
    →仮想端末を開いた時の初めの TIOCSWINSIZE の時点で最終的な値を設定する必要があった。

  * fixed: mode_vem の既定値が true になっていた問題
    bash だと内容が正しいが ble.sh だと内容がおかしい。
    これは IL, DL の実装が変だからの様な気がしてきた。
    画面内容が少しずつずれていくからである。
    というか IL, DL を実行するにしても上にずれていくのは変である。
    bash で問題になっていないのだから改行などによって起こる
    スクロールが問題になっている訳ではない様に思う。
    と思ったら mode_vem の既定値が true になっていた。修正した。

  * fixed: 日本語を正しく出力できていない。
    然し、どうも print_screen では正しく出力できている様だ。
    つまり、端末内容は問題がないが出力に問題があるという事だろうか。
    或いはバイト値で格納されている?
    うーん。そちらの様な気がしてきた。
    つまり、入力時に UTF-8 ではない変な解釈になっている。

    tty_player_device を見ると term_t::write を呼び出している。
    調べると term_t::printt はちゃんと encoding に対応しているが、
    term_t::write は encoding に対応していない様である。

  * done: 後、着色もちゃんと反映する様にしたいのである。

    取り敢えず先ずは着色を反映される様にする。
    と思ったが現在の実装だと並び替えなどを実施した際に、
    属性を取得する事ができない。属性も取得する様に拡張するのは面倒である。

    a 或いは、line の側で並び替えを実行した時のセルの配列を取得する関数を用意するか。
      処理に時間がかかる様になってしまうのではないかと思ったが、
      よく考えてみると現在の暫定実装について考えると、
      文字列の入れ子を何度も走査するので一括で取得した方が明らかに速い筈である。

    b メモリが無駄になるなどの事を思うならばセルに対するポインタの配列でも良いかもしれない。
      と思ったが、現状でセルは 16B でポインタは 8B なので対して節約になっていない。
      寧ろポインタ経由でアクセスする為に遅くなってしまうのではないか。
      その様に考えるとポインタの配列にするぐらいならば直接セルの配列にする。

    文字列の情報を用いて反転を実施する事にする。
    所で update_strings で得られる文字列で記録しているのは、
    文字列の座標範囲であって、cell のインデックスではない。
    という事はこれを使って実装する事はできない。
    update_strings でインデックス情報も取得する様にするか、
    或いは一からループを書き直してその場で反転を実施する様にするか。

    取り敢えず今の所は他の箇所でインデックス情報を参照するかどうかも分からないので、
    表示に於ける並びを取得する関数で新しくループを記述する事にする。
    然し面倒なのは cluster 等は元の順番を保持する様に反転しなければならないという事。
    cluster の部分だけ予め反転させて置いて、最終的に正しい向きになるように調整しなければならない。

    取り敢えず適当に実装を初めて見る事にする。

    取り敢えず実装は完了した。実は文字列がある場合にはテストはしていないのだけれども、
    それについては追々テストを追加して行く事にする。

  * [自然解消] うーん。並び替えも含めてどの様に処理するか考え直す必要があるかもしれない。
    取り敢えずの所は get_cells_in_presentation で実装する事にした。

  * 保留: うーん。emacs みたいに描画中にカーソルを
    一時的に隠すというのは有効かもしれない。

    所でちらつくのは単に fflush が足りていないだけではないかと思ったが、
    実際に試してみると、ある程度は現在の位置にカーソルが表示される様にはなるが、
    やはり fflush しても余りちらつきは変わらない。

    \x1b[?25l で隠す様にしてみたが対して変わらない様だ…。
    というか \x1b[?25l 等を実行してしまうと現在の端末の状態に応じたカーソルを破壊してしまうので、
    もし使うとしても現在のカーソル状態をちゃんと管理する様にしてからでなければならない。
    何れにしても余り効果が無いようなのでこれについては今の所は off にしておく。

  * done: 次は更新があった時にだけ画面内容を出力する様に書き換えたい。
    後、変更があったかどうかについては version を参照する様にしたい。
    また、行に id を割り当てて追跡する様にしたい。
    然し、これらの実装は恐らく複雑になるので別項目で処理したい。

* 2019-04-14 RLogin では FS/GS/RS/US に対して ADM-3 互換と称してカーソル移動を割り当てている [#D0057]
  一方で xterm, mintty ではその様な機能は存在しない様である。
  FS-US は単に何もしない機能という事になっているからこれに対応しても良いかもしれない。
  しかし、この様なシーケンスを用いたプログラムが書かれる事があるのだろうか、
  という事を考えるとやはり対応しても仕方がないのではないかという気もする。
  まあ、RLogin に倣って対応するというので良い気がする。

* ansi: bug: 画面内容が全く保存されていない。何処かでクリアされている? [#D0056]
  改行が効いていないのかもしれないと思ったが今までのテストでちゃんと動いていた筈である。
  実際に何か別のコマンドを呼び出してみるとちゃんと複数行になっている。
  という事は何らかのシーケンスが画面をクリアしていると考えるのが自然である。

  どうやら調べてみると IL で全てが消滅している様である。
  shift_cells の引数が負の時に移動方向が反転してしまっているバグがあった。修正した。

* DECSTBM と IL DL 等の関係を調べる [#D0055]

  DECSTBM の影響範囲に関しては RLogin のエスケープシーケンスのページが詳しい。
  http://nanno.dip.jp/softlib/man/rlogin/ctrlcode.html#SGR
  CUU CUD CNL CPL IL DL SU SD
  後 MC, DECMC というのも DECSTBM, DECPEX の影響を受ける。

  取り敢えず勘で実装してしまった。RLogin で振る舞いを確認した方が良さそう。
  先ず初めに DECSTBM に変な引数を与えた時にどの様に振る舞うかに関して。

  - %%先ず初めに DECSTBM の第二引数は最終行ではなくて、最終行の次の行である。%%
    →どうやらこれは勘違いの気がする。単に ble.sh のステータス行を数え忘れていただけだった。
  - fixed: 巨大な値を指定すると最終行までと見なされる。
  - fixed: 範囲が潰れる様な指定の仕方をするとスクロール範囲に対する変更は実行されない。
  - fixed: 引数 0 もしくは空欄は既定値を意味する。開始の既定値は画面の一番上で、
    終端の既定値は画面の一番下である。

  更に、IL 及び DL がどう振る舞うかについて。まあ、これは確認してなくても良いだろう。
  また、同時に SU SD SL SR についても実装をしておきたい。
  それから CUU, CUD 等も影響を受けるそうだ…。

  * done: DECSTBM の振る舞いについて確認して gh に記述した。
  * done: SU, SD, SL, SR の振る舞いについても確認を行った。
  * done: SU, SD, SL, SR の実装。
  * done: CUU, CUD, CUF, CUB, CPL, CNL の修正。

* ansi: DECSTBM の対応 [#D0054]
  emacs を起動してみると凄い勢いで
  DECSTBM (set scrolling region) を実行している。
  つまり DECSTBM に対応した方が良いのでは。という事。

2019-04-17

* ansi: Alternate Screen Buffer には対応しないと行けない [#D0053]

  仕様について確認を行う。

  ?47 と ?1047 でバッファは共有の様である。
  ?1047 は ?47 を設定して更に代替画面をクリアするという事の様だ。
  また、?1047 の値と ?47 の値は DECRQM で確認すると連動している。
  ?1049 も連動している様子である。双方向に変更が伝わる。

  実は alternate screen buffer は VT の機能ではない様だ。なんで名前はついていない。
  誰が一番始めに実装したのだろうか。xterm には xterm と書かれている。

  関連して ?1048 の設定・解除は実は \e7 \e8 と等価になっている。
  現在の状態は記録されていない。
  取り敢えず表面上だけでも実装する事にした。

  うーん。後は altscreen の board を用意するだけで良い気がする。
  或いは board ではなくて lines だけでも良いのかもしれない?
  presentation_direction だとかも保存されるのだろうか…。
  然し、SPD 等で変換する場合なども考えると、
  altscreen の SPD と本体の SPD は独立が良い気がする。

* ansi: やはりモードの登録方法を考える必要がある気がする… [#D0052]
  一覧表から自動生成する事にしようか。

  * 一覧表を作るところから始める事にする。
    何が必要だろうか。

    1. 名称
    2. type = flags, accessor
    3. flags 内のインデックスは自動生成すれば良い
    4. mode_type = ansi, dec, contra, etc.
    5. mode_param = 番号
    6. 既定値

    $1--$4 に上記の 2. 1. 4.5. 6. を入れて一覧表を作った。

  * さてどの様に実装しようか。
    実用性を考えると実は今と同じで良いのではないか?

    と思ったが ansi1 だとか dec2004 だとかの情報は
    mode_spec に埋め込まなくても良い。どうせ辞書から引かないと行けない。
    そして辞書から引くのだとしたら辞書に登録する時に必要になるだけで、
    別に mode_spec に埋め込んでおくのは冗長である。
    今までその様にしていたのは表を作るのが面倒だったからである。

    そうすると flags か accessor かという情報と
    それぞれに対応した index だけ記録しておけば問題ないという事になる。

    a 先ず値に関して。
      accessor_flags = 0x10000 として
      後は flags, accessor それぞれに対して順に 0...n まで生成すれば良い。
    b 規定値の設定部分も生成する。
    c 辞書に登録する部分も生成する。

    実装した。動いている。異常もない。

2019-04-15

* emacs が SM(34) と SM(?25) を送ってくる [#D0051]
  SM(?25) は DECTCEM である。カーソルの表示・非表示である。
  他にもカーソル関係はある。SM(?12) はカーソルの点滅を制御する。

  * 次に SM(34) について。

    | 調べてもそういったものは無いようだ。
    |
    | もしかして terminfo から拾っているだろうかと思って
    | 調べてみると TERM=screen-256color であって、screen のマニュアルには
    | "normal cursor visibility" と書かれている。infocmp を見ると、
    | cnorm=\E[34h\E[?25h と書かれている。cnorm はカーソルを表示するという奴である。
    | うーん。よく見てみると cvvis=\E[34l になっている。cvvis は very visible
    | つまりカーソルをよく見える様にする、という事である。
    | という事はやはりカーソル形状をブロックにするという物と思って良さそう。
    |
    | all-escapes.txt によると 34 33 は WYSTCURM, WYULCURM という名前の様である。
    | それぞれ "カーソルの形は下線" と "カーソルは点滅しない" である。
    | 調べているとカーソルの形状・点滅・表示に関しては錯綜している。
    | まあ現時点では contra は GUI を持たないので適当に空実装という事にしておく。

    まとめると
    Mode 32, 33, ?12, ?13, ?14 は Wyse 及び xterm でカーソルの点滅のon/offに使われている。
    Mode 34 は Wyse 及び screen でカーソルの形状の変更に使われている。

  * mode についての getter/setter?

    | 後、これらに関しては重複する設定の様な気がするので、連動させる為に
    | getter, setter を設定できる様にしたい。
    | また、後で observer から設定変更を検出する為にも getter, setter の仕組みは
    | 何れにしても必要になるのではないかという気がする。
    | と思ったが、getter, setter と onchange は違う気もする。
    |
    | board に追加しようとして思ったのは、端末の状態は board に含まれていない。
    | つまり tty_observer は実は term に対しても observe を実行する必要がある。
    | まあ、それはそういう構造でも良いという気がする。
    | getter というよりも setter だけが必要?
    | と思ったけれども実際に記録されない様なフラグや他のフィールドから算出される様な
    | フラグに関しては getter も特別な物に差し替えるのが良い。
    | そして、それは term.cpp の側で処理するというよりも、
    | tty_state の側で処理する方が適切である様に思われる。

    →取り敢えずのところはその場に switch で書き込む事にした。
    もっとちゃんとした感じの実装にするのは増えてきてからという事にする。

  * 他にカーソル関係で形状と点滅を同時に制御する制御機能があった筈。
    これとの相互作用は一体どうなっているだろうか。
    うーん。& で良い様な気がする。つまり、片方が点滅を抑制していれば点滅は抑制される。
    と思ったが…うーん。片方が点滅を指定していれば点滅するという考え方も存在する。
    因みに既定値は点滅である。という事を思えば点滅が既定であって、
    どちらか一方で点滅を抑制する指定があったら点滅しないという設定で良い気がする。

    | xterm の動きを観察する。うーん。よく分からない。
    | 分かった事は menu の Blinking Cursor は反転として働いているという事である。
    | というか DECRQM を実行してしまえば良いのでは。。
    | 実際に実行してみると ?13 は認識していない。?14 も認識していない。
    | うーん。xterm の説明書に書かれているのは手元の xterm の振る舞いと違うという事なのか。
    | 最新の xterm で追加された機能なのかもしれない。
    | とにかく menu 項目の設定 (説明書によると ?13 らしい) は反転させる効果という事。
    | 更に DECSCUSR の値を変えても ?12 の値は常に 2 (RM) のままである。
    | 本当に ?12 はカーソルなのだろうか…。更に、SM(?12) にしても RM(?12) にしても
    | DECRQM(?12) の結果は変化しない。これが意味する所は…。
    | 実は一度でも DECSCUSR を使うと ?12 は inactive になるのだろうか。
    | RIS SM(?12) DECRQM(?12) を試してみたがそれでも状況は変化しない。
    |
    | うーん。つまり実は xterm は対応していないという事?
    | Cygwin の xterm の version は 330 と書かれている。
    | 最新版の xterm (344) をダウンロードしてコンパイルして実行してみた所、
    | ?13 も ?14 もちゃんと有効になっている。?12 も設定に応じて変化する。
    | これで改めて設定を確認してみる事にするのである。
    | ?12 は SM/RM で変化する。?13 は RM のままで SM/RM では変化しない。
    | ?14 は permanently set という状態を返す様である。
    |
    | % DECSCUSR は説明と比べると反転した状態になっている。
    | % そして、メニューが表示されていないので分からないが、
    | % メニューに於いて Enable Blinking Cursor の
    |
    | DECSCUSR は ?12 と連動するという所まで確認できた。
    | メニューとどう連動するかは良く分からない。
    |
    | man xterm に詳しく書かれていた。cursorBlinkXOR が設定されていない時は、
    | どちらか一方でも blink になっていれば blink する様である。つまり or。
    | うーん。メニューを設定する方法は不明だが、
    | % うーん。-bc で起動すると反転していない。+bc で起動すると反転している。
    | % DECSCUSR の仕様の方を勘違いしているだろうか…。
    | 勘違いだった。ちゃんと期待した通りの動作になっている。
    |
    | 因みに #330 はどれだけ古いのかと思ったが、
    | 調べると 2017/06/20 なので特に古くもない。

    まとめると。
    1. xterm が ?12 ?13 ?14 に真面目に対応したのは割合最近の話である。
    2. ?12 の設定は DECSCUSR による設定と連動している。
    3. ?13 の設定は cursorBlink resource の値を反映する。
      SM/RM では変更する事ができない。
      因みに cursorBlink resource は false true always never の4種の値を本当は取る。
    4. ?14 は常に set という事になっている。
      set の時は片方だけ set (blinking) の時に、blink する。
      reset の時は一方でも set ならば blink する。

2019-04-14

* BDSM の実装。これは DCSM の有効・無効の判定部分に影響を与える [#D0050]

* 2019-04-13 選択範囲や属性化領域はどの様に処理するのが良いのだろうか [#D0049]

  | ? 例えば選択範囲は入れ子にすることができるのだろうか。
  |   他の領域と overlap がある場合にはどの様に取り扱うべきか。
  |   領域は或いは他方が一方を必ず包含する様になっているのだろうか。
  |
  |   うーん。用途を考えると入れ子にしても仕方がない気がする。
  |   なので on/off で解釈してしまっても良い気がする。
  |   因みに属性化領域の説明には選択領域で終了するなどは書かれていないので、
  |   互いに overlap する事が可能である様な気がする。
  |
  |   つまり、属性化領域・保護領域・選択領域は互いに overlap 可能の様に思われる。
  |
  | ? 属性化領域も入れ子にすることができるのだろうか。
  |   と思ったが DAQ の解説によると次の DAQ が現れたらもう其処で終わるとの事。
  |   なので入れ子はないと解釈して良い。
  |
  | ? 他の実装はどうやっているのだろうか。
  |   例えば DECSCA の様に描画属性に紛れ込ませていたりはしないか。
  |
  |   例えば VT510 は対応しているのだろうか。調べてみると SSA-ESA も SPA-EPA も DAQ も対応していない。
  |
  |   RLogin を見ると文字消去ガード開始・終了、としていて SPA-EPA と同じ取り扱いという事になっている。
  |   具体的にはどういう実装になっているだろうか…。ERM も機能として実装している様だから試してみる。
  |   printf '\e[41mabcdefghijklmnopqrs\ra\eVBC\e[20Cx\t\td\eWefg\e[m\e[2K\n'
  |
  |   - どうも試してみると SPA-EPA はやはり描画属性の如くに処理されている気がする。
  |     というのも物理的に SPA と EPA の間の文字列が保護される訳ではなくて、
  |     時間的に SPA と EPA の間に入力された文字が保護されている様子だからである。
  |   - 更に EPA をした後に上書きした部分に関しては削除されない様子である。
  |   - また HT による移動では1文字目だけに属性が適用されて、
  |     それ以降のスキップには属性は設定されていない。
  |
  |   printf '\e[41mA\eVBC\eW\e[10P\e[m\e[2K\n'
  |   これだと行末に描画属性が適用される事になるが、
  |   実は其処には保護は適用されていない。うーん。
  |   つまり、描画属性とは別に管理されているという事になるのか。
  |   実は文字を書き込む時に設定されるという事だろうか。
  |   だとすると ht で一文字だけ適用されるとも理解できるかもしれない。
  |   或いはできないかもしれない。
  |
  |   xterm も実は対応している様子だ。xterm の場合には HT では属性は保存されない。
  |   HT でスキップした範囲は保護の対象ではない。EL や DCH 等で挿入された空白は保護の対象ではない。
  |   などなど。
  |
  |   これらの事を考慮に入れて "領域" はどの様に定義されるだろうか。
  |   - 例えば HT でスキップした場合に同じ "領域" と見做して良いのだろうか。
  |     それとも別の領域と思うべきなのか。或いは、保護を実行する時に何回目の保護領域なのか
  |     というのを覚えておくとかそういう手もあるかもしれない。然し、実装が面倒だし、
  |     振る舞いとしても分かりやすい物であるとは言えない。
  |   - 或いは保護領域の範囲と実際に保護される文字は別でも良いのかもしれない。
  |     例えば SPA を実行した位置と EPA を実行した位置を覚えておいて、
  |     その間を保護領域であると解釈する等。
  |
  | ? また、表示部での範囲を指定するのだろうか。
  |   それともデータ部での範囲を指定するのだろうか。
  |
  |   DAQ の内部で文字列を使用した時の動作は未定義という事になっていた。
  |   これを考えるに DAQ は属性として処理してしまって良い気がする。
  |   更に、未定義というのはデータ部で範囲を抽出しても良いし、
  |   表示部でデータを抽出しても良いという意味に取れるのではないだろうか。

  contra の実装では以下の様にする。SPA, SSA, DAQ は何れも描画属性の一部として記録する事にする。
  これらの属性がカーソルに設定されている間に入力された文字についてだけ属性を適用する事にする。

  領域はどの様に定義するのかは微妙である…HT によるスキップには現在属性は設定していない。
  他の実装でもそうなっている気がする。但し、RLogin に関しては1文字目だけに属性を設定している。
  うーん。取り敢えず NUL は跳ばす事にして同じ属性になっている範囲を領域という事にする?

  * protected guarded などについて意味を確認しておく。
    protected は削除されないし変更されないという事。
    guarded はデータストリームとして転送されない・補助装置との間で転送されないという事。

  * ERM に同時に対応したい気がするが面倒である…。
    全て消去するのならばともかくとして protected だけ残して消す。
    mono の場合には簡単である prop の場合にも簡単である。
    問題は prop&presentation の場合である。

    というか ERM が影響を受けるのはどれだったか…EA, ECH, ED, EF, EL である。
    うーん。shift_cells のフラグとして erm を追加するのは良しとして、
    どの様に対応するべきだろうか…。

    現在の実装は compose_segments に依っているが、
    実はこれは表示位置から計算されたデータ位置を使って抽出を行っていて、
    各セルのインデックスで抽出を行っている訳ではない。
    つまり、marker によって protected, unprotected が混ざっているかもしれないが、
    そういった物は全く関係なく全て切り出す様になっている。
    erase なので unprotected な marker は削除したい。
    或いは、単に protected なセルだけ残して他を全て削除するという処理方法でも良いのだろうか。
    うーん。取り敢えずそういう方針で実装する事を考えてみる事にする。
    それによって見た目が変な事になっても知らない、という事で。

    取り敢えず少しずつ実装する事にした。
    mono, prop&data については実装した。

    prop&presentation については compose_segments で実装されている。
    考慮に入れなければならない事が色々ある。

    - done: というか、そもそも protected な文字が含まれている行というのは
      余りない。みんなそんな機能は使っていない筈である。
      という事を考えると、実は、事前に protected があるかどうかだけ
      チェックして、含まれていなければ普通の処理方法で良いという事。

      含まれている場合には多少重い処理になっても気にしないという事にする。

    - done: 先ず初めに境界上に protected な全角文字が存在する時、
      現在の compose_segments の実装だとうまくできない。
      これは compose_segments の呼び出し元で範囲を調整する様にしたら良いだろうか。

      % 但し、どちらの方向に調整するのか等も含めてよく分からない…。
      % 然し、境界上に全角文字が存在する場合、
      % 必ずそれは表示範囲の端にある筈だから、
      % どちらの方向にずらしたら良いのかは自明なのでは。
      % つまり、範囲を広げる方向にずらせば良いのである。
      % 従ってこれは気にしなくても大丈夫。

      やはり全角文字がある場合にはどちらの方向に調整したら良いのかわからない…。
      特に全角文字の幅が 3 以上あって、境界の右側と左側で幅が異なる場合に。
      幅が同じ場合には適当に幅を拡張すれば良いだけなのである。

      然し、異なる場合には先ず初めに現在の文字の方向性を取得して、
      それに基づいて修正する量を決定する必要がある。
      或いは、二種類試してより良い方向を選べば良いのだろうか。
      二種類の xL, xR を pL, pR に変換して試すというのをやってみたが、
      よく考えると xL, xR でも文字列マーカの左右で結果が異なる筈である。
      なので xL, xR -> pL, pR の方向の変換は信用できない。
      一方で、pA, pB -> xA, xB の方向の変換は多分大丈夫である。
      うーん。本当だろうか。依然として曖昧さが残る気がするが、
      まあ、"その位置の右にある有限幅の文字の位置" になっていた筈で、
      その場合にはちゃんと変換される筈なのである。

      取り敢えず実装した。

    - done: 次に考えなければならないのは…。
      零幅文字を含むのか含まないのかという事である。
      うーん。境界上の零幅文字については元々削除しない方針なので、
      残す必要はない、というか残してはならない。
      その他の零幅文字については残すべきである。
      では何処が端の境界に対応していたのか、という情報は得られるだろうか。
      現在の実装だと難しい。

      これも無理矢理に実装した。本当に動作するのだろうか…。

  x fixed: うーん。テストケースを作っていたらアルゴリズムに不備が判明した。
    やっぱり真面目に反転しているかどうかを判断しなければならないという事なのか。

    * done: うーん。向きまで考えるのは面倒だけれども、convert_position を境界の左側について
      計算する関数があれば向きも自然に分かるのでは? という様に思われる。
      その様な関数を作るのは簡単だろうか。思うに、range.begin 及び range.end を +epsilon
      したアルゴリズムを作れば良いのではないかという気がする。
      そうすれば現在の位置が相対的に境界よりも左側にいるという事になる。
      と思って convert_position の実装を観察してみるが…うーん。
      +epsilon しても動作に変化はない。というか寧ろ -epsilon しないと動作が変化しない。変だ。
      というより反転部分の処理の方が効いている? end-1 - (x-begin) としている。
      これは文字の位置を意識した処理になっている。境界について処理をしているのだとしたら、
      end - (x-begin) とするべきなのである。
      文字の位置を意識した時は xL+0.5 = end - (xL+0.5-begin) より
      自然に xL = end-1 - (xL-begin) が導ける。

      では、文字の右端と左端の変換で違いはどうなるだろうか。
      うーん。+epsilon 作戦で実装してみたが全然駄目だった。真面目に考える事にする。
      と思ったが、単に +epsilon した時に条件式がどう変化するかを逆に考えていた。
      a < b → a < b + epsilon ⇔ a <= b という事だった

      と思ったが、それでも駄目だった…。"境界の左側" にあるのは元々の状態の時であって、
      一回反転が起こった時には "境界の右側" になっている…。
      実装した。従来の convert_position の実装に組み込んだ。

      然し、よく考えてみたら逆方向の変換の事を考えていなかった…。
      うーん。やっぱり分からない。反転回数によって結果が変わるのである…。
      というか現在文字の位置の変換は問題なく行えているのだから、
      それと反転回数を元に結果を修正すれば良いだけでは?
      というわけでその様に実装し直したら簡単に動作する様になった。

    convert_positions を拡張したのでそれを使って計算する事にする。
    と思ったがどうやって計算したら良いのかよく分からなくなった。

    取り敢えず boundary の位置がどうなるかを判定すれば良い筈である。
    その時に境界の右隣の位置を追跡するべきか、或いは左隣の位置を追跡するべきか。
    実は、これはどちらでも良い。全角文字が跨っている時には、
    どちらで計算しても同じ筈である。全角文字の途中で文字列が切れている事はないので。
    また、丁度境界の上に乗っていた時にはちゃんと _prob_glb で一致している位置が返ってくる筈で
    その時には何も処置しなくて良いという事が直ちに分かるのでやはり問題ない。
    その様に修正した。うーん。取り敢えず動いているから良いという事にする。

2019-04-13

* 2019-04-12 ansi: 行末ECH後のカーソルの位置は? [#D0048]

  (これは調べたやはり端末によって色々である。contra-gh に追記した。)

  以下に於いて B が行末に表示されれば最後の文字に移動している。
  B が行頭に移動していれば ECH,DCH,ICH に於いて行末に留まる。
  printf '\e[100CA\e[@B\n'
  printf '\e[100CA\e[PB\n'
  printf '\e[100CA\e[XB\n'

  RLogin で試すと最後の文字に移動する。xterm でも同様である。
  Poderosa と screen は行末に留まる。mintty は行末に留まる。

* 2019-04-11 どうも to_presentation_position の仕様を前と変えてしまった [#D0047]
  presentation position は文字進路の方向にするべきだった。
  今は左から右という事になっている…。

  各実装でちゃんと結果がどうなるか確認する必要がある。
  - convert_position
    これは既に修正した。と思ったが、to_data_position 側を修正していない。
  - curpos_t line_t::_prop_to_presentation_position(curpos_t x, curpos_t width, bool line_r2l) const;
  - void line_t::calculate_data_ranges_from_presentation_range(slice_ranges_t& ret, curpos_t x1, curpos_t x2, curpos_t width, bool line_r2l) const;
  - というか line_r2l が関わってくる関数は全てこれが問題になる気がする。

  取り敢えず機械的に書き換えてみたが本当に大丈夫なのかは不明である。
  一通りテストを書いておく必要がある気がする。
  特に data における ECH, ICH, DCH は確認しておきたい。

  実際にテストを少しずつ追加していたらバグが出た。
  DCSM(PRESENTATION) に於いて正しく抽出できていない?
  と思ったが、調べてみると ECH の後の様子は問題ない。
  SDS(1) がちゃんと動作していない様である。

2019-04-12

* ansi: EL について DCSM(PRESENTATION) でも !m_prop_enabled の時は簡単に実装 [#D0046]
  というか ECH ICH DCH に関しても実装が term.cpp と line.cpp に分散しているが、
  基本部分だけを line.cpp に移動して、
  細かい動作については term.cpp で指定する様にできないだろうか。

  a 例えば、insert delete 等の操作を仮想的に行う事によって
    compose_segements の引数を構築する等…。
    つまり {{0, 10, insert_fill}, {10, 20, delete}} 等の引数を渡す。
    これをデータ部で実行するか或いは表示部で実行するかは line 側に任せる、など。

    うーん。ICH の実装を見て思ったが delete して insert したり、
    insert して delete したりするのは無駄である。
    データを移動してそれから消去すれば良いだけの筈なのである。
    insert, delete を分けるという事は2回も移動を行っているという事になる。

    そう言った移動を体系的に操作として記述する事は可能だろうか。
    そしてそれに基づいて !m_prop_enabled の場合、
    data && m_prop_enabled の場合、表示部 && m_prop_enabled の場合に分けて
    適切に効果的な処理方法を算出する事が可能だろうか。

    例えば !m_prop_enabled の場合を考えてみると、
    1. move {a..a+delta} to {0..delta}
    2. erase {delta..a+delta}
    の様に記述する事ができる。表示部 && m_prop_enabled の場合に対応する為には、
    先ず初めに、[0..width] という状態があって、(1) の操作によって
    [a..a+delta][delta..a+delta][a+delta..width] という領域に分かれる。
    更に (2) の操作によって真ん中の区間が消去されるという具合になる。
    こう言った区間の演算はどの様にして実行するのが良いのだろうか。
    場合分けして真面目に実装するのだろうか。
    しかし、どの程度複雑なケースまで考慮に入れるのかというのも気になる。

  b 「実は重複がない・順序が保たれる」という条件の下では、
    現在の compose_segments の形式の方が便利なのではないだろうか。
    各範囲について移動が必要かどうかも含めて判定する事ができる気がする。
    然し、動かす順番に気をつけないと何処かの範囲が移動している内に
    別の範囲が塗りつぶされるという事故が起こる可能性もある。
    というか本当にどの範囲も一回だけの移動で移動できる様になるだろうか。。

    少なくともどの範囲も最終的な移動量は確定している。
    その時に他の範囲を踏み潰す様な事があれば移動を延期しなければならない。
    例えばある範囲の移動について考えることにする。
    その範囲が左に動くとする。その時に左側にある範囲を踏み潰す様であれば、
    その左側にある範囲は先に動かさなければならない。その範囲は必ず左側に動く筈である。
    という事を繰り返し考えていけば必ずすぐに移動できる範囲に達する筈である。

    つまり、最初の範囲から順番に見て行って、
    右側に動かす場合には踏み潰される範囲がないかを確認して、
    一番最初に踏み潰されない範囲があればそれを移動する事にすれば良い。

  試しに実装してみる事にしようか。。
  取り敢えず compose_segments をどの様な場合でも動く様に修正した。

  * 実装してみて思った事はこの様な複雑な処理をするぐらいであれば、
    普通に移動を2回するぐらいの方が速い気がするという事である。
    更に _prop で同様の物を実装する為には余計に複雑な処理になってしまう。
    とにかく潰した全角文字を変換した後のスペースを何処かに記録する必要がある。
    そしてそれを記録していると余計にメモリの確保・解放の回数が増える。

    しかくよく考えてみたら今回実装を統一したのは
    効率をよくする為ではなくて今後の実装をすっきりした物にする為である。
    あらゆる制御機能を実装する度に同じコードを何度も書くのは不毛である。
    従って、統一的で一般的なインターフェイスを用意して、
    今後はそれを使って処理を行う様にしようというのが目的だった。

    insert/delete をくっつけて要素の移動を少なくする事ができる
    という話は副次的な利点であったのである。
    なので、この実装によって速度が遅くなったとしても、
    まあ実装する意味がなかったという事にはならない。

  * もっと効率の良い実装の方法はないだろうか。
    現状だと全角文字を潰した事によって発生する空白を
    どの様に記録したらよいかが分からない。
    これを記録する為には新しいメモリ領域を準備する必要がある気がするが、
    それで新しいメモリ領域を準備するぐらいであれば、
    実は既存の compose_segments と同様に処理するのと大差ない。

    或いは、実装を一般的にしすぎという事なのかもしれない。
    例えば segments の数は最大でも 2 か 3 という具合に
    制限して実装しても良いのかもしれない。
    左右の不変部分と、真ん中の消去・削除・移動部分という具合に。

    ECH の場合には真ん中を削除して代わりに何かを挿入する。
    DCH の場合には左端を固定して、真ん中を左に移動するという操作である。
    ICH は実は DCH と逆の動作になっている。
    SR や SL も似た様な実装になっている。
    EA 等については実は ECH を使って実装できてしまう。
    なので余り気にしなくても良いのである。

    然し、SEE を考慮して DCH 等をするとまた具合が異なる気がする。
    左右の不変部分があって、それとは別に内部に移動する文字列がある。
    この場合最大四箇所で全角文字の処理をしなければならない。

    うーん。これは結局何を意味しているのだろうか。
    実は一般的なインターフェイスは、もっと簡単にできるのではないか。

    beg, end, xL, xR, fillL, fillR で指定する事ができるという事だろうか。
    つまり最終的に [0..beg] [fillL] [xL..xR] [fillR] [end..width]
    という形になる様な編集である。
    或いはもっと簡単にする事はできないだろうか。
    beg, end, xL, xR, shift でも大丈夫の気がする。
    それどころか beg, end, m, bool LR で行ける気がする。
    LR=0 の時 [0..beg][m..end][fill][end..width] になる。
    LR=1 の時 [0..beg][fill][beg..m][end..width] になる。
    或いは beg, end, shift で大丈夫の気がしてきた。
    ECH は [beg..end] 以上に shift が起こる場合と捉える事ができる。

    所で見た目は同じかもしれないが DCH ICH ECH で
    境界上の零幅文字の処理の仕方が異なるのではないかという気がする。
    これは引数で制御する様にすれば良いのだろうか。
    うーん。それが良い気がする。

  * 何やら振る舞いがおかしいと思ったら
    to_presentation_position が負の値を出している。
    convert_position の実装を眺める。何だかよく分からない。
    どうしてこのコードで to_presentation_position が計算できるのだろう…。

    q = 0 に初期化して、
    x を含む反転範囲があると、q = end - 1 - (q - beg)
    を実施する、という具合にしている。
    そして最後に p = x - q という様にしている。
    うーん。p = x - q についての漸化式に書き換えたら分かるだろうか。

      p = x - q = x - (end - 1 - (x-p -beg))
        = x - ((end-1)+p-(x-beg))
        = 2x - p -(end-1+beg)

    何だか分かりそうで分からない。
    結局反転によってどれだけずれるかを積算していると考えたら良いのだろうか。

      xold - beg == end-1 - xnew という事を思えば
      xnew = end-1 - (xold-beg) という式を得る。
      xnew+xold = end-1 - beg と言っても良い。

    結局分からないけれども最後の反転の条件がおかしいことだけは確かな気がする。
    従って最後の反転の条件を書き換えた。一応直った気がする。
    しかし、今度は CUF が変な気がする。to_presentation_position は、
    lr になる様に修正を行う物である。一方で CUF は rl の時は、
    方向が反転している物と思って移動を行っている。

  まだテストが通っていないが presentation position の定義に誤りがあったので
  改めて全体的に手を入れる必要が出てきた。従って、一旦ここで commit する事にする。

2019-04-11

* ansi: ICH ECH DCH で挿入される空白の属性 [#D0045]

  どうも ICH ECH DCH で新しく現れる空白領域には現在の属性が適用されるらしい。
  例えば DCH した時に行末に補填される空白にもちゃんと現在の背景色が適用される。
  これは RLogin 及び xterm, mintty で確認した。
  Poderosa でもそうなっているが多少バグがある。
  screen の場合には属性は解除される。
  大勢に倣って現在の属性を適用する様に変更する事にした。

  * done: また全角文字を踏み潰す場合には
    其処に適用する属性は元の文字の属性という事にする。
    - write_cells を確認する
      _mono_generic_replace_cells に関しては元から属性は全て設定されているのでOK。
      _prop_generic_replace_cells に関しても lfill, rfill でちゃんと属性を読んでいる。
    - _prop_reverse は特に踏み潰す様な操作はしていない。
    - copose_segments を確認する。これは其処にある文字の属性を使う様に修正した。

  * done: HT についても現在の属性を適用する?
    と思ったが、これはどの端末でも現在の属性は適用されていなかった。
    contra では寧ろ現在の属性を適用していたので、適用しない様に変更した。

  * done: ICH ECH DCH で挿入される空白について。
    これは外部から属性を指定する必要がある。
    伴って ech や ich や dch についても属性を指定する。
    面倒な事になっているが仕方がない…。
    また、dch に関しては右端をクリアしていたが、
    右端に属性を適用する為にちゃんと余白を fill する様に変更する必要があった。

    compose_segments を使わない時の実装についても同様に
    fill_attr を指定して dch に関しては余白を明示的に insert する必要があった。

  * done: EL と ED に関しても修正する。
    何と EJ や ED で埋められる領域についても現在の属性が適用される様である…。
    clear_content 等と言っている場合ではない…。

  * 実は IL (CSI L) や DL (CSI M) によって挿入される行についても?
    少なくとも RLogin は現在の属性を使っている。xterm, mintty もである。
    Poderosa と screen は違う。空の行を生成する様である。

    というか IND や RI についてはどうなのだろう…。
    やはり属性が適用されている。と思ったら実は LF ですらそうである。
    つまり、新しい行があれば必ず全体に色が適用されるという事である。
    それならその様に実装すれば良いのである。

    これで IND も RI も LF も IL や DL も全部属性が適用される様になったはず。

* DECSCA ... これは描画属性に含めてしまって良い気がする [#D0044]
  DECSC,DECRC で一緒に復元されるとの事なのでそういう実装なのだろう。

* ansi: DECSC, DECRC に対応する [#D0043]

  DECAWM DECOM の状態と属性とカーソル位置を保存する。

* ansi: DECSET, DECRST に対応したい [#D0042]
  SM, RM と同時に対応した。
  然し、結局認識していないモードが受信された時にメッセージを表示しておきたいので、、
  煩い認識できない〇〇のメッセージが表示されるのは変わらない。
  というか、覚えておいて二回目以降は表示されない様にするというのも手かもしれない。
  とも思ったが、そういうのは出力した後に処理するべきである。
  どの様なシーケンスがどのくらいの頻度で呼び出されているかが気になる事もあるかもしれない。

* ansi: ESC k や OSC(0) によるタイトル設定に対応した [#D0041]
  プロンプトからこれが出力されて画面に表示されるのがうるさいので。

2019-04-10

* ansi: VEM for DL IL →DL IL の対応と同時に対応した [#D0040]

* ansi: SLH for ICH DL IL → これは対応した。mode_home_il というモードを作った [#D0039]

* [完了] 2019-04-05 ansi: 新しい端末の定義として ansi_term というのを作る事にした。 [#D0038]

  取り敢えず動く物から作る事にする。

* [完了] 2019-04-05 行のデータ構造の変更の可能性 [#D0037]

  | Unicode 対応等を考えると現在の形式は色々微妙である。
  | 先ず結合文字などが入ってくると特別にメモリ領域を作らなければならない。
  | (但し、これは特別なオブジェクトを保持する時には
  | やはり特別にメモリ領域を作らなければならないので同じ事かもしれない。
  | 然し、そういったオブジェクトは数が限られている一方で、
  | 結合文字などは余りにも簡単に出力する事ができてしまう。)
  | Grapheme cluster も考えて実装するとなると、
  | もう少し柔軟なデータ構造の方が望ましいのではないかと思われる。
  |
  | 結局どのような事を考えているかというと、
  | 行は幅などを考えずに文字の列で表現し、
  | その中に bidi を制御する文字なども含めるという事にする。
  | 座標からデータ内部の位置への変換をスムーズにする為に、
  | B木で各節に合計を保持する?
  | 或いは、行内の文字数がそんなにないと思えば直列に文字を保持しても良い気がする。
  |
  | Proportional なフォントなどを使う場合も考慮に入れて文字の幅は自由にする。
  | 全角2半角1でも良いし、或いはもっと細かい単位でも良いという事にする。
  | 元々の端末の考え方だと全て1だが、今や全角文字のためにその取り扱いは崩れている。
  | 従って、最早2だろうが何だろうが全部真面目に処理するしかないのである。

  行は単にデータ位置とは独立に文字の列として保持する。

    Unicode の bidi や SRS, SDS 等の文字列や、属性化領域・フィールド
    等の情報を保持する為には任意のゼロ幅の文字も保持できなければならない。

  Q. データ位置は行内の文字の番号なのか、仮想的な座標なのか。

    | というかそもそもECMA-48におけるデータ位置とは何だったのかが分からなくなってきた。
    | データ位置には埋め込まれたマーカーはカウントされるのだろうか。
    | 今までカウントされないと考えていたが本当だろうか。
    |
    | 文字が受信された時の事を考えると、受信した文字は次の"マーカー"を上書きするのではなくて、
    | 次の"文字位置"を上書きするのである。という事を考えるとデータ位置というのは
    | bidi の並び替えを実行する前の座標と考えるのが自然である。

    A. データ部における仮想的な座標であるべき。

    何故ならば (1) 文字を受信した時その "座標位置" にある文字を上書きするのであって、
    行内のN番目の文字を置き換えるという訳ではない。(2) データ位置は全角文字の途中にも
    移動する事ができる。

  Q. grapheme cluster で保持するか文字で保持するか

    | そうすると再度文字の表現方法から再考が必要になるのではあるまいか。
    | 今、行を Unicode 文字列で表現する事にしたので、
    | 実は grapheme cluster をそのまま複数の文字として行内に埋め込む事ができる。
    | 或いは今までどおりに特殊文字として毎回登録して使うという様にもできる。
    | どちらの方が良いのだろうか。
    |
    | UAX#9 等を考えると、並び替えの時に面倒なので grapheme cluster の単位で保持したい気もする。
    | 一方でメモリの確保・開放などの効率を考えると grapheme cluster は展開して埋め込みたい気もする。
    | そうすると並び替えなどの操作が色々面倒になってしまう。
    |
    | うーん。考えて見るに通常の使用方法における速度を保証する為には、
    | 内部に grapheme cluster だとか marker だとか R 文字だとか変な物が含まれていない、
    | というフラグを用意しておいて、そのフラグが立っている時は高速な処理にして、
    | そのフラグが立っていない時には低速な処理に切り替えるという手がある。
    |
    | 高速な処理にしている時には wide_extension を有効にしておいて、
    | 低速な処理にしている時には wide_extension を無視するという具合にする?
    | 実は wide_extension は結合文字や grapheme cluster の二番目以降の文字を格納するのに使えるのでは。

    wide_extension 文字を復活させる。
    grapheme cluster は wide_extension と同様の取り扱いにする。
    更に grapheme cluster, marker, R/AL 文字の有無で処理を切り替える。
    これらがない時にはデータ位置と文字インデックスは一致する。

* [消滅] 2016-10-31 bidi: ICH, DCH, ECH に際してどの様に設置されている文字列を更新するかが問題になる。 [#D0036]

  % つまり、文字列の更新とはマーカの位置をどの様に更新するのか、
  % 或いは削除するのかという問題に帰着する。
  %
  % | 先ずは方向付き文字列しかない場合について考える (つまり TATE などの設置されていない場合)。
  % | ICH に関してマーカに隣接していない場合には単純にそれより後ろにあるマーカを移動すれば良い。
  % | また、DCH に関しても削除領域がマーカに隣接していない場合にはやはり後ろにあるマーカを移動すれば良い。
  % | しかしマーカに隣接している場合の取扱は微妙である。
  % |
  % | 先ず ICH に関しては比較的簡単に処理できそうな気がする。
  % | 挿入位置に丁度マーカが設定されている場合にはどの様に処理するべきか。
  % | 挿入位置のマーカは動かさなくて良い。
  % | では現在位置とその左側の位置に挿入を行おうとしている場合にはどうすれば良いか。
  % | (これは HEM で逆向きに設定されている場合のことを言っている)。
  % | どの様な場合にこの HEM を使うのかよくわからないが例えば SIMD と一緒に使うのだろうか。
  % | だとすると HEM が設定されている場合には現在位置に存在しているマーカも一緒に動かす必要がある。
  % | # しかしこの動作で丁度よい気がする。マーカが現在位置以前にあるものと現在位置より右にあるもの
  % | # の二つに分類されて、HEM に応じて片方のグループがまとめて動くという形になっている?
  % | # →ちょっとこの考え方は説得力に欠ける。
  % | 一方で、ICH において反対側で消去される部分のマーカをどうするのかという問題が残る。
  % |
  % | ECH, DCH, ICHシフトによって失われる領域のマーカの取り扱いに関しては、
  % | insert character 時の文字が置かれる場所の掃除を行う時の手法をそのまま使うのが自然に思われる。
  % | なので、insert character 時の処理がどの様になっているのかを改めて確認し、
  % | どれだけ再利用できるか、どれだけ書き直さなければならないかについて考える。
  % | 望ましいのは insert character で用いているコードを拡張して、
  % | 引数などのオプションに依って動作を切り替えて様々な消去の場合に対応できる様にする事である。
  % | (insert character の実装では任意の文字幅に対応できる様になっていた筈なので、
  % | 自然に拡張できれば嬉しいが…。)
  % |
  % | insert character 時の消去についてまとめる。
  % | 実装は board.cpp の board_line::update_markers_on_overwrite にある。
  % | 既に結構複雑な処理になっている様である。
  % | 先ず引数は curpos_t beg, end 文字の左端と右端を指定する。
  % | つまり、消去する領域の右端と左端と考えて良いだろう。
  % | そして beg <= p < end にあるマーカについてのループを考える。
  % | a bidi string の場合には
  % |   内部に存在するマーカは simd に従ってマーカを右端か左端に移動する。
  % |   その移動によって文字列が潰れる場合には始端・終端マーカを一緒に除去する。
  % |   更に、終端マーカの場合には直前に開始マーカまたはフィールド開始がある場合に除去する。
  % | b aligned string の場合には
  % |   基本的に削除を実行する。但し、simd に応じて左端または右端に存在するマーカは削除しない。
  % |   これは自然なデータの流れによって aligned string が開始して初めの文字が挿入される時に
  % |   直前に設置した aligned string マーカが削除されないという条件と同じであり、
  % |   それが自然な動作に丁度なっている。
  % |   更に、直後の aligned string marker が aligned string 終端の場合にはそれも一緒に削除する。
  % |
  % | 問題はこの動作は ECH や DCH ICH においても自然なのかどうかという事である。
  % | 実は余り自然ではないのではないかという予感がしている。
  % | 様々なケースを想定して考える必要があるだろう。
  % |
  % | 先ずは ECH について考える事にする。
  % | a bidi string 開始が ECH 消去領域の内部に存在する場合の動作は何か。
  % |   もし対応する終端がやはり ECH 内部にあるのだとしたら
  % |   その終端と一緒に削除するのが自然である。
  % |   また、もし対応する終端が ECH 外部にまで及んでいるのだとしたら、
  % |   その bidi string 開始は ECH 消去領域の終端に移動するべきである。
  % |   さて、その時 SIMD が逆になっている場合に ECH 消去領域の開始に移動するという事はありえるか?
  % |   →その動作は変な気がする。
  % |
  % |   ではそもそも何故文字挿入時にはその様な動作になっていたのだろうか。
  % |   例えば全角文字を挿入する時には [直前][現在] という様になっている升目を上書きする。
  % |   内部に存在している bidi string 開始マーカは左端に移動するのが自然と思われるというのも、
  % |   文字を挿入する前のカーソルの位置は確かに現在位置より前にあるのだからその時点で文字を挿入すれば、
  % |   その文字に押し出されて左端に移動するというのは自然だからである。一方で SIMD が設定されていない時には、
  % |   [現在][直後] というセルの並びになっているのだから、文字の挿入に依って現在位置から後方に向かって
  % |   マーカが押し出されるのだという風に解釈する事ができる。
  % |
  % |   さて、ECH を実行する際にも似たような解釈をする事は可能だろうか。
  % |   ECH で後方に向かって削除をする時には単純にマーカを終端に設置すれば良い。
  % |   では、現在位置から前方に向かって削除をする時にマーカを前方に移動するのは自然だろうか。
  % |   - 例えば、それが直後にそこに SIMD を用いて文字を書き込んでいくという事を想定しているとする。
  % |     うーん。もし現在位置が文字列の内部に存在していて現在位置の文脈を以て領域を拡大しようと
  % |     考えるのだとしたら ECH によって左側にマーカがずれるというのは自然である。
  % |     しかし ECH で消去をしようとしているのに bidi string の領域が増えるというのも変である。
  % |     また、ECH というのはやはり文字を挿入するという訳ではないのだから bidi string は長くならなくて良い気がする。
  % |     →やはり ECH で現在の階層の領域が拡大されるというのは無理がある様な気がする。
  % |   - そもそも update_markers_on_overwite では "文字を挿入した後" のマーカの位置を想定して設計された物である。
  % |     従って、削除した瞬間のマーカの配置を表す物ではない。つまり、"削除してから挿入する" という様な形にはなっていないのである。
  % |     つまり、マーカの移動は文字の挿入に固有のものであって、領域の確保によって起こる物ではない。
  % |     その様に考えるのだとしたら、別に ECH によってマーカを移動させたりしなくても良いような気もする。
  % |     しかしやはり ECH というからには其処に設置されている諸々のマーカが除去されてほしくもある。
  % |     →うーん。やはり ECH された領域の中ではマーカは存在してほしくない。
  % |   - しかし完全に階層構造を消去領域の中で解いて除去してしまうというのも変である。
  % |     というのも ICH や DCH を用いる場合には、現在のカーソルの位置に於ける階層構造の上で削除や挿入を行うのが自然であり、
  % |     それと整合性を取る為には ECH も同じように現在位置における階層で消去を行いたいからである。
  % |   - そうすると消去領域の内部に一部でも含んでいる階層については、消去領域の端まで移動を行い、
  % |     消去領域を完全に含む階層に関しては何も変更しないというふうにするのが現実的である。
  % |     しかし、その様な動作を実際に行った時にそれは自然な動作になるのかというのも考えておく必要がある。
  % |     例えば abc[defg]hijk という風になっていて現在位置が f にあるとする。
  % |     前方に向かって 1-3 文字消去する時には abc[   g]hijk という様になる。
  % |     更に前方に向かって 4 文字消去すると ab    [g]hijk という形になる。
  % |     また、初めに 3 文字消してそれから 4 文字目を消去すると ab [  g]hijk という形になる。
  % |     この様な不連続性は実際に行った時に気にならないだろうか。
  % |
  % |   | というかそもそも DCSM が表示部になっている時には一体どのように処理したら良いのか謎である。
  % |   | 一つ一番簡単な実装方法は一文字ずつ消去した時とまとめて消去した時の結果が同じになる様に設計して、
  % |   | それから消去対象の位置について一つずつ消去を実施していくという物である。
  % |   | 一文字ずつ消去しても動作が変わらない様にするというと、消去位置で完全に階層構造を解除するという物が考えられる。
  % |   | - その様な実装だと ICH をどの様に処理するのかが疑問として残る。ICH でも完全に階層構造を解除するのか、
  % |   |   或いは ICH に関してはその時の階層構造を尊重して挿入を行うのか。
  % |   |   特に DCSM で表示部になっている場合にはどの様に考えるのが良いのだろう。
  % |   |   特に ICH に伴うシフトをどの様に行うのかというのも問題である。
  % |   |   もし完全に階層構造を解除するのだとしたら、(1) 先ずは見た目に従って文字列を完全に分割する
  % |   |   (2) その後でシフトを実行するという様にできる。注意するべきは (1) でも字の並び替えが必要になるという事である。
  % |   |   ただ (1) さえ実装してしまえば後は簡単である。
  % |   |
  % |   |   また DCH について考えてみると…もし階層構造を完全に解除してからシフトなどを行うという事にしていると、
  % |   |   ある階層構造の中の或る文字を削除した時に、その文字があった箇所の前後で bidi string が分かたれてしまい、
  % |   |   見えない "切れ目" ができてしまう事になる。
  % |   |   その後の文字の書き込みなどで正しく bidi が処理されなくなるという問題が生じる。
  % |   |   そもそも DCH 等の非自明な操作を行ったときでも bidi が保たれる様に要求するべきかという話もあるが、
  % |   |   できるならば自然でありなおかつ予想可能な振る舞いをするのが良いように思う。
  % |   |
  % |   | - うーん。思うに DCSM で表示部だったとしても文字列の範囲をどの様に縮めるか、
  % |   |   もしくは拡大するか、文字列を削除するかといった様な論理はデータ部の時と同じである。
  % |   |   違うのはデータの表現方法との間に複雑な変換が必要になってしまうという事のみである。
  % |   |   従って、余りデータの変換方法などについては考えない様にして、
  % |   |   先に見た目での文字列の処理方法を与えるほうがよい。
  % |   |   編集が実際にデータ部にたいしてどの様になされるかの変換については後で考える事にすれば良い。
  % |   |
  % |   | さて DCSM に対して作用する事も考え合わせれば update_markers_on_overwrite は恐らく使えそうにない。
  % |   | この既存関数とは別に新しく考えるのが良いような気がする。
  % |
  % |   [結論]
  % |
  % |   - DCSM(PRESENTATION) に関しては先に見た目での文字列の消去・短縮を決定してから、
  % |     それを実現する様にデータ部に対して加工を行うという様に考える。
  % |     恐らく複雑な文字のシフトを伴う変換が起こるがそれについては後で考える。
  % |   - update_markers_on_overwrite については忘れる。
  % |
  % | うーん。やはり ECH においては其処にある bidi string は全て除去するのが自然な気がする。
  % | 一方で DCH は現在の階層において削除を実行する。
  % | ICH は現在の階層において挿入を実行する。端から出ていった物に関しては ECH と同様に消去を行う。
  % | それを元にして再度ルールを決め直すのが良い気がする。
  % |
  % | 次に問題になるのは aligned string のマーカの移動に関してである。
  % | ECH に於いては消去範囲の中に aligned string マーカが存在する場合に削除を行う。
  % | 隣接している場合には削除は行わなくて良い。
  % | 問題は DCH や ICH を行う際に移動範囲に ECH が含まれていたとしてそれを一緒に移動するかどうかである。
  % | 一緒に移動しないと文字だけがずれるので変な事になる。
  % | 一方で一緒に移動すると全て解除するというのも変な気がする。
  % | 或いは、aligned string の内部にある文字列は移動しないという風にする可能性もあるかもしれないと思ったが、
  % | やはりそれは ICH してから何かを上書きするという様な使い方などを考えるに、文字列を動かさないのは駄目である。
  % | 結局、一緒に移動せざるを得ないという風に考えるのが良いだろう。
  % | では、中に設置してある tab stop についてはどうするか。一緒に動かすかそのままかという選択肢がある。
  % | MULTI の場合には DCH でずれる様になっていると全体で共通のタブという状態が崩れてしまう。
  % | その事を考えればずれないという実装にするのが自然である様に思う。
  % | つまり、後になってまた HT 等で移動を行った時は DCH をする前の位置にまた上書きをするという形になる。
  %
  % [結論]
  %
  % - ECH は階層構造も全て消去する。内部の aligned string marker は削除する。
  % - ICH, DCH は現在の階層構造において実行する。DCH において内部の aligned string marker は削除する。
  %   ICH においてシフトで押し出される内容はその階層で削除する。つまり、DCH で削除する。
  %   (実は ICH と DCH は全く同じ実装で行けるのではないかという気がする。)
  % - 何れにしても隣接する aligned string marker はそのままである。
  % - SIMD の影響は受けない。代わりに HEM の影響を受けても良い。
  % - DCSM(PRESENTATION) の場合には表示部における消去・挿入・削除をデータ部にどの様に反映させるかについて考える必要がある。
  %   単純に表示部の範囲をデータ部の範囲に写像して消去を行うと駄目である。階層構造がばらばらになってしまう。
  %   上の階層にある文字列から順に適用していって分割統治で行くような感じに実装したい。これは後で考える。
  %
  % ----------
  %
  % 次に考えなくてはならないのは DCSM(PRESENTATION) の時にどの様に表示部での編集をデータ部での編集に変換するかである。
  % それを考える為には先ずどの様に問題を分割して、そして個々の場合についてどの様に場合分けをするかが重要になる。
  %
  % 取り敢えずは aligned string については考えない事にする…というか、aligned string に関しては
  % データ部と表示部での差異については考えないという実装だったはずだ。
  % つまり、aligned string に関しては特別の変換は必要ないという事になる。
  % また方向付き文字列の内部に aligned string が含まれているという事も設計上無いはずだから、
  % 結局 aligned string の削除についてはデータ部と表示部での差はないという事になる。
  %
  % 問題は方向付き文字列が存在する時の処理についてである。先ず初めに ECH について考える。
  % ECH の領域と方向付き文字列がどの様な関係になるのかというのには幾つかのパターンが考えられる。
  % 1 先ずは ECH の領域が方向付き文字列に完全に含まれている場合である。
  %   今 ECH の領域が eb <= x < ee として方向付き文字列が sb <= x < se であるとする。
  %   sb <= eb && ee <= se の時 ECH 領域が方向付き文字列に含まれていると判断する。
  %   この場合には方向付き文字列内部の座標で ECH を実行する様にすれば良い。
  % 2 次の場合は ECH の領域が方向付き文字列を完全に含んでいる場合である。
  %   これは eb <= sb && se <= ee という条件で表される。
  %   この場合には単純に方向付き文字列諸共削除してしまえば良いだけの話である。
  %   1 かつ 2 の場合には 2 の取り扱いで良いだろう。
  % 3 次のパターンは eb < sb && ee < se という様な場合である。
  %   この場合には消去領域は二つに分割される。
  %   先ずは eb <= x < sb に当たる部分に関しては現在の階層で消去を行う。
  %   そして sb <= x < ee に当たる部分に関しては更にその方向付き文字列の内部で消去を行う。
  % 4 逆に sb < eb && se < ee という場合もあるが、これは 3 と同様に処理すれば良い。
  % 結局以上のことを文字列の入れ子階層に従って実行すれば良いという事である。
  % ここで注意しなければならないのは 3, 4 において ECH は階層構造を消去するという事である。
  %
  % ----------
  %
  % | この時方向付き文字列の中身をシフトしなければならない。
  % | どのタイミングでシフトを行うか・どの様にしてシフトを行うかについてはまた考える必要がある。
  % | というか 1 の場合にも分かたれた２つの部分それぞれについてシフトを実行しなければならない気がする。
  % | 更にどんどん文字列が入れ子になっている場合には単純なシフトでは済まないだろう。
  % | 一体どの様に処理すれば良いだろうか…。一つの方法は一旦表示部に内容を転写して、
  % | 消去を行った後で再びデータ部に転写する方法である。この方法は簡単で安全であるが、余りスマートでない様にも思う。
  % | もしもっと簡単に位置関係・シフトなどを表す表式があればそれを採用したい。それについて考える。
  % |
  % | 一回数式にしてみようとも考えたが複雑になりそうである。
  % | 数式を見ても簡単な形に単純化することができるとは思われない。
  % | 一旦簡単な場合で考えてそれから入れ子がある場合を考えていくという様にしたい。
  % | 入れ子のない一番単純な場合で反転領域の内部を消去する場合は、
  % | 右の端に残ったデータと左の端に残ったデータを交換しなくてはならない。
  % | つまりシフトもしくは swap の様な物が必要になる。
  % |
  % | とここで思ったのだが入れ子が複雑になっている場合はシフトもしくは swap の組み合わせで対処できるようには思われない。
  % | というのも、原理上入れ子を組み合わせる事によって任意の置換を表現する事ができるはずで、
  % | 表示部での単純なシフトでさえデータ部では複雑な置換になりうるからである。
  % | 置換は循環の組み合わせで書くことが出来るが独立な swap で組み合わせて書くことはできない。
  % | つまり、何れにしても原理上は swap やシフトを複数回実行しなければならない訳である。
  % | なので、シフトを複数回ではなくて一回で実行するという事に拘る事はできないし、しなくても良い。
  % | 結局、シフトの組み合わせで実装するという事を受け入れて良い気がする。
  % |
  % | 入れ子の構造がある場合の問題は、交換する領域 (右端のデータと左端のデータ) の境界が
  % | 更に内側の文字列の内部にあるという場合である。しかし、これに関しては
  % | 内側にある文字列から順番に交換・消去を実行していけば良い。
  % | 先に内側から交換すれば、外側の文字列で交換を実行する時には
  % | 丁度内側の文字列の境界が交換領域の境界に一致する様になっている。
  %
  % [まとめ]
  %
  % DCSM(PRESENTATION) の時は ECH は見た目が変わらないようにデータ部で文字の並び替えを実行しなければならない。
  % 特に反転文字列内部で消去部分の右側にある部分と左側にある部分の内容を交換する必要がある。
  % 表示部・データ部の変換および文字の並び替えに関しては、内容交換を階層ごとに実行する事によって行う。
  % 入れ子階層の一番深いものから順に消去・分割・内容交換を実行していけば良い。
  %
  % ----------
  %
  % 次に考慮しなければならないのは文字列を切断した時にどのようにマーカを更新するのかという事である。
  % 交換に際してマーカも一緒に交換しなければならない。そのまま愚直にその様にするのが良さそうである。
  % "交換を全て実行した後の位置" というのを計算するのは面倒そうである。
  % (或いはオフセットを計算できるだろうか?)
  %
  % - うーん。というか文字列を分割する時の表現はどの様にするのが良いか。
  %   マーカにするべきかそれとも文字列の配列にするべきか。
  %   マーカで交換をそのまま実施するのは困難を極める。というのも、
  %   マーカが必ず開始と終端のペアになっているとは限らないからだ。
  %   という訳でマーカで移動を行うとしても正規化などの操作が必要になるだろう。
  %   更に正規化したとしても一つの文字列が "開始" と "終端" という複数の (離れた) 要素からなるため、
  %   移動・交換などの処理が面倒である。但し、"文字列" の配列であったとしても
  %   入れ子になっている子孫も一緒に移動しなければならない事を考えると大した違いはないかもしれない。
  %   何れにしても正規化という手順を踏む必要性がある事を考えれば、
  %   マーカでの処理は諦めて普通に "文字列" で並び替えを実行して、
  %   その後でそれをマーカに逆変換する方が自然である。
  %
  % ----------
  %
  % 2018-02-19 暫く時間を置いたので現状でどこまで実装したのかが何だか良くわからない状態になっている。
  %
  % ToDo: 後シフトの際に中途半端に全角文字の半分だけシフトするという事がない様にする。
  %   消去される領域が中途半端に被っている場合にはその全角文字全体を削除する必要がある。
  %   また、そもそもマーカが全角文字の中途半端な位置に挿入されない様に設計しておく事も必要である。
  %   (ただ、それでも何かの拍子にマーカが全角文字の途中に置かれる事も考えられなくはないので、
  %   その様な中途半端な事が起こっても大丈夫な様に設計したい。)
  %
  % ToDo: ICH, DCH についても場合分けを考える必要がある。
  %
  % 2019-04-04 ECH について時間を費やし過ぎである。
  % うーん。紙に書くなどして簡単に実装することはできないのか。
  % そもそもどの様に方向付き文字列を表現していたかを確認する必要がある。
  %
  % board_line に std::vector<line_marker> m_markers; というメンバがある。
  % line_marker は curpos_t position と nested_string_type stype というメンバを持つ。
  % nested_string_type には方向付き文字列、反転文字列、
  % 横位置合わせ文字列 (string_aligned) の三種類がある。
  % というか string_aligned とは何だったか…。
  % 確認すると TATE TALE TAC TCC 等である。
  % これらは次の string_aligned が現れると其処で範囲が終わると見なされる。
  %
  % * update_markers_on_overwrite の実装を見ると、
  %   1. aligned string は次の aligned marker が現れる迄の範囲を表す。
  %   2. aligned string の終わりは方向付き・逆転文字列の終わりを表す。
  %     これは workaround というよりも実際にそういう表現を正当な物として許す。
  %
  %   というより update_markers_on_overwrite の実装が変な気がする。
  %   これに対応するテストという物は存在するのだろうか…。
  %   うーん。明らかにテストは実装されていない。
  %   勝手に実装し直す事にする。
  %
  % うーん。そもそも現在の表現方法自体がおかしい気がするが…。
  % まあ、これで実装を続けるとするとどうなるだろうか…。
  % とも思ったが、やはり微妙である。
  % ICH だとか DCH だとか色々実装しなければならない物は沢山ある。
  % その時にも毎回この様に複雑な事を考える必要があるのだろうか。
  % もっとすっきりした表現で簡単に実装する事はできないのだろうか。
  %
  % 例えば ECH を実装する際には、文字列の開始位置・終了位置を
  % 削除範囲の両端に寄せれば良いのでは。
  % その上で空の文字列を削除する様にする。
  % TATE 等で設置した aligned 文字列は単に削除する事にする。
  % と思ったが、途中で方向付き文字列の内部で消去が起こった時は微妙。
  % 方向付き文字列の内部のままという事にしておくと、
  % 後から其処に何かを記入した時に意図しない表示になってしまう。
  % 従って、現在の実装では方向付き文字列を分断して、
  % 其処には文字列が現れない様にするという様に実装している。
  % うーん。結局昔の考察の通りに ECH は階層構造も全て削除するという仕様にする。
  %
  % DCSM(PRESENTATION)の時の動作については。
  % というか DCSM(PRESENTATION) はどの様に実装しているのだったか。
  % 恐らくカーソル位置はデータ部での位置になっている。
  % それを表示部での位置に変換して更に其処から右にN文字進んだ場所までを削除領域とする。
  % それをデータ部での消去に変換する必要がある。
  %
  % 最終的な結果は完全に階層構造を取り除いた状態というのは DCSM(DATA) の時と同じ。
  % うーん。競技プログラミング勢だとあっという間に実装してしまうのだろうか…。
  % 取り敢えず、データ構造は考えない事にして、構造とアルゴリズムについて考える事にする。
  %
  % (1) 表示部における範囲を決定する。
  % (2) トップレベルの反転文字列から再帰的に処理を行う。
  %
  % うーん。どうも滅茶苦茶構造が汚い。全く駄目だ。実装し直したい。
  % そもそも marker で文字列を表現しようとしたのは何故だったか。
  % 1. 実際の文字の配列と別個に管理したかった。
  % 2. 受信するのは開始マーカと終了マーカである。
  % という事だった。従って、marker で管理するのが自然であるとの考えであった。
  % 然し、marker による表現は実際の構造を反映しているとは言い難いので、
  % 具体的な操作を実装しようとすると対応するマーカを探し出すという事を
  % 毎回実行しなければならない。従って、色々と面倒な事になってしまう。
  %
  % 実は文字列に関しては真面目に木構造で保持した方が良いのではないだろうか。
  % うーん。

  これはデータ形式を変更して実装し直した。

* ansi: SPD の実装 [#D0035]

  見た目を変えずに charpath が反転する為には
  データ部での反転を実行しなければならない。
  然し、strings などがあると複雑になってしまう。
  どの様に処理するのが正しいのか。

  因みに strings は終端していない場合は強制的に終端しても良い物だろうか。
  例えば反転文字列を書き込んでいる途中で SPD による反転が実施されたとする。
  この時反転文字列の続きを記入できる様にするべきだろうか。
  考えてみるにそうではない気がする。やはり反転が起こったらその時点で固定化する。
  つまり、strings は終端を明示的に挿入する様にするという事なのである。

  さて、どの様に実装したら良いだろうか。
  update_strings は実行する必要がある気がする。

  a 例えば以下の様に実装する。
    先ず update_strings で得られた結果を反転する。
    然し単純に逆転させれば良い訳ではない。
    開始点について昇順に元々並んでいるが、
    これは終端点について昇順であるとは限らない。
    そして、それに基づいてマーカーを挿入しながら
    文字を順番に登録していく。
    中に含まれていた文字列のマーカーは全て無視する。

    と思ったが色々問題がある。
    零幅文字と文字列開始・終端の順序が保たれない。
    それに update_strings を end について
    ソートし直さなければならないのは面倒。

  b 例えば、始めに文字列終端を設置していく。
    完全に設置して対応が取れている状態になって、
    その時に始めて反転を実施し始める。
    反転する時には予め update_strings で得られた
    情報を元に開始マーカーと終了マーカーを入れ替える。

    或いは update_strings のルーチンを改造して、
    その時にもう開始マーカーと終了マーカを入れ替えるべきだろうか。

  取り敢えず b で実装できた気がする。

* ansi: カーソル移動について。 [#D0034]
  これは色々調整が必要かと思っていたが
  実は表面的に書き換えたら簡単に動く様になってしまった。

* ansi: SGR 等。 [#D0033]

  取り敢えず鬼門だった ICH, DCH, ECH の類を実装できたので、
  SGR 等の機能について移植していく事にする。

  うーん。これらの属性は拡張フラグを使って実装されている。
  面倒なので attribute_t に沢山関数を生やして実装する事にする。
  後で拡張したくなっても大丈夫な様にする為に。

* ansi: ICH, DCH も同様に実装するべき? [#D0032]

  どの様に実装するべきだろうか。
  ICH に関しては現在の位置に文字を挿入する。

  SIMD の影響は受けない様である。HEM の影響を受ける。
  DCSM の影響も受ける。

* ansi: ECH 取り敢えず実装した。まあこんな物だろうか…。 [#D0031]

2019-04-08

* ansi: ECH (DCSM(PRESENTATION)) [#D0030]

  さて、問題の ECH である。これの実装をどの様に考えるか。
  思うに Unicode Bidi を考え始めると訳が分からなくなるし、
  もっと言うと Unicode Bidi を考慮に入れて端末にシーケンスを
  送ってくる様なアプリケーションが存在するとは思われない。
  強いて言えばユーザが画面を見た目で操作する為にその様な物を送るぐらいか。

  さて、今となっては NUL が segment separator の役割をしているので、
  DCSM(DATA) の時には単に ECH は NUL を書き込むだけで良い。
  NUL を書き込んだ場所より後の反転の効果は解除されるが、
  まあ、データ部は marker も含めた文字列の集合なのだと思えば、
  その様な振る舞いは自然なのである。

  DCSM(PRESENTATION) の時にはどの様に取り扱うのが良いのだろうか…。
  表示部に於ける各点に対応するマス目を消していけば良いのだろうか。
  然し、そうすると変な事になる気がする。更に境界上に乗っている
  marker をどの様に取り扱うのかが謎である。
  というか PRESENTATION というからには、やはり見た目を保持したい気もする。
  Unicode bidi を対応しないという決断をした今、実はその様な実装は可能の気がする。

  文字列 m_strings_cache の情報は使う前提である。
  結局、前半部分までの文字列と、後半部分までの文字列を生成して、
  それを接続するという事にすれば良いのではないだろうか…。

  前半部分までの文字列は内容を変更しない様に構築しようとするとどうなるか?

  * ゼロ幅の文字の取り扱い

    | 取り敢えずゼロ幅の文字をどの様に取り扱うのか決めておく必要がある?
    | ゼロ幅の文字も一緒に反転して表示する前提にした方が良いだろうか。
    |
    | 例えばデータ部で ...[A|B|C|D]... となっていて
    | 表示部で ...[D|C|B|A]... となっている時に、B 以降を削除するとする。
    | 得られる結果は表示部で ...[D|C|] という事で良いのだろうか。
    | というか ECH はできるだけゼロ幅を残す様に実装すると考えれば、
    | 実はあんまり考えなくてもゼロ幅文字をいつも残す様にしておけば良い気がする。

    →ゼロ幅の文字はできるだけ拾う様にする。

  うーん。取り敢えず…。前半部分の範囲を取得するコードを書く事にする。

  | 早速何がどうなっているのか分からなくなった…。
  | 結局何をしたいのだったか。
  | 持っているデータは何かというとデータ部で見た時の入れ子の構造である。
  |
  | 外から中に見て行った時に、反転を起こす。
  | 更に範囲で見ているので範囲が分断されたり色々する。
  | 分断された範囲をそれぞれどの様に取り扱うのか。
  |
  | 例えば [] で切り取り範囲を () で反転範囲を示すと、
  | 以下の様な場合には [>>>(<<<)>>>] 三分割される。
  |
  | 或いは [>>>(<<<]<<<) という様な場合には、
  | () に要求するのは後半の3文字である。
  | うーん。実は要求はデータ位置で行っておけば良いのではないか?
  | 何だかよく分からなくなってきた。データ位置というか、
  | その反転範囲に取ってのデータ位置というべきである?

  a うーん。ちゃんと木を作ってから処理すればできる気がするが、
    今のデータ構造の儘で単純に深さ優先で並列に処理する事は可能なのだろうか。
    そのノードの中に入る時に座標を変換して、そして出る時にまた変換を戻す。
    そんな風にして処理していけるのだろうか…。
    行ける筈だが何だか面倒な感じしかしない。
    先ず、ノードに入る・出るというのを検出しなければならない。

  b うーん。特にノードを出たというのを判定するのが難しいのではないか。
    と思ったが、それは parent を記録しておいて、それが減ったら抜けたと思えば良いのか?

    前回処理した i と現在の parent を比べる。現在のノードが前回処理したノードの
    子供ならば i - 1 == range.parent になる。現在のノードが前回の兄弟ならば、
    strings[i - 1].parent == range.parent になる。前回のノードが抜けたのであれば、
    strings[i - 1].parent > range.parent になる。
    そんな感じに先ずは抜けたとか入ったとかを検出できる様にしたい。

  取り敢えず b によって入ったり抜けたりするのは試験的に実装した。

  | この段階でどの様に実装したら良いのだろうか。
  | 少しずつ考える事にする。今見ているのは常にデータ部での範囲である。
  | 基本的には文字を削除するのと等価なのでデータ部での順序は保たれる。
  | 問題は切り取る範囲をどの様に動的に管理するのかという事である。
  | 実は簡単な気がしてきた…。
  |
  | と思ったがそうでもない。途中で範囲が二つに別れたりする…。
  |
  |   表示部   ----[--**]**--
  |   データ部 ----[**--]**--
  |
  | うーん。push する度に結局何処か別の場所に範囲を記録しなければならないのだろうか。
  | 更に入れ子が増えていくとどんどん分裂していく事になる。これに対処するのは難しい。
  | 結局スタックか何かを用意して処理していくしかないのだという気がする。
  | そして、現在の範囲は現在のノードの中でのみ有効と考える。
  | →残っている断片をスタックに記録して処理する事にした。実装できた。
  |   動作テストもしてみた。ちゃんと動いている。

  スタックに分断した断片を記録する事にして、範囲取得は実装してテストした。

  * ネスト状態の復元について

    うーん。然し、本当にこんな実装で良いのだろうか…?
    というか文字列の始まりと終わりについて記録しなくて良かったのだろうか?
    またネスト状態の追跡をしたいという要望もあるのである。
    もしネスト状態の追跡をしたとして、範囲で拾った物の前にネスト状態の復元を置いたとする。
    しかし、範囲で拾った物に既にネスト状態の更新が含まれていたらどうするのか?
    うーん。含まれていたり含まれていなかったりの気がする。
    という事を考えてみると実はネスト状態の復元に必要な点もリストに含めておく必要がある?

    本当だろうか。境界上の marker は全て拾う様になっているので、
    境界に至る直前のネスト状態を復元すれば良いという事になるのではないか。
    然し…境界上の marker を全て拾うというのはそれはそれで厄介である。
    重複して前後して拾ったりはしないのか? と思ったがデータ部の上でちゃんと
    順番に列挙する様になっているので境界が重複しているという事はない筈である。

  うーん。と思ったけれどやはり微妙な気がしてきた。
  必ずしも先頭ではないのである。少し動かしてみる。
  必要なのは丁度先頭に来た部分に対して状態を復元する事である。

  因みに削除直前の部分に関しては特に処理は必要ない。
  というのも NUL を置いた時点で其処で文字列が強制的に終了するからである。

  * 因みに NUL にした所に文字を書き込んで行くと、
    文字列が延長されて混ざり合ってしまう。
    この様な振る舞いをよしとするかどうかは微妙である。

    a まあ、再び同じ内容を書き込んだら復元できるという様に考えたらこれでも良い気がする。

      x と思ったが、表示部でそうなる様に文字を書き込むというのは困難がある。
        実際に書き込みが行われるのはデータ部であって、
        データ部に於けるデータの並び方に関しては既に並び替えられてしまっているので、
        再び復元する事は不可能である。

    b 或いは、何らかの文章を途中に書き込むのが目的と思えば、
      勝手に混ざり合ってしまうのは都合が悪いという考え方もある。

    その様に考えると実は、ちゃんと終端して置いた方が良い気がする。
    →終端する様に実装した。

  * テストが不十分な気がする。
    もっとちゃんとテストするにはどうしたら良いか。
    テストコードを書いた。幾らか試した。動いている気がする。

  * find_innermost_string についてもテストして置きたい。
    →テストを書いた。ちゃんと動いている。完璧な気がする。OK

* ansi: to_data_position [#D0029]

  これの実装はどうしたら良いのか…。

  [>>>>[<<<<x<<<<]>>>>]

  持っているのは presentation_position なので、
  反転範囲が終わるまで見ないと分からない気がする…。
  うーん。一旦、完全な string のリストを作ってしまう事にするか…。
  そして外側から順に中に入っていくという作戦。
  これが元々の contra の実装である。

  もっと簡単にする事は果たして可能なのだろうか。
  うーん。一旦、対応する終端までジャンプすれば可能なのだろうか。
  とも思ったが、其処から更に後退していく等の処理を考えると、
  やはり一旦完全な string のリストを作ってしまう方が楽の気がする。
  これは既存の実装を参考にするのである。

  実装した。動いている。

* ansi: to_presentation_position [#D0028]

  nested_state を追跡する事で計算できるだろうか。
  要するに目的のデータ点 x を含む nest について
  深さを以下の様に書いた時 (x を含まない nest は書かない)、

  [>>>>[<<<<x<<<<]>>>>]

  x より前にある >>> と x より後にある <<<< の数を集計すれば良い。
  また、都合上 x と同じ位置にあるマーカーは x の直前にあると見做す。
  先ずは x が現れるまでループを回す事を考える。
  その間に nest を開いたり閉じたりする事になる。
  x に出会った時にどの状態になっているかを調べる。

  nest を記録する時に何を記録するべきだろうか。
  始まりの位置? それから方向?
  stack の中にある逆方向の文字列の数も調べておくべき。
  途中で中断できる様にしたいので。

  contra::ansi における文字列の入れ子の解釈

  1. SDS(1) SDS(2) SRS(1) によって文字列を開始する
  2. SDS(0) によって対応する SDS に当たるまで全部閉じる。
    SRS(0) によって対応する SRS に当たるまで全部閉じる。
    対応する物がない場合には無視する。
    例えば SDS(1) aa SRS(1) bb SDS(0) cc SRS(0) は [aa[bb]]cc と解釈される。
  3. NUL に当たった時は全部閉じる。
    (但し、NUL は HT 等によってフィールドを移動した時に設置される。)

  取り敢えず実装した。幾つかテストケースを試してみて動いているからよしとする。

* ansi (line_t::proportional_glb): [#D0027]
  もっとまともなデータの保持の仕方はないだろうか…。

  a 例えば std::multiset で良いのではないか
    % …と一瞬思ったが、ICH や DCH をする度に位置を全て書き換えなければならず非効率的である。
    % と思ったが、実は ICH/DCH の頻度は低いし全て位置を書き換える方法の方が効率的なのでは。。

    x 然し、その場合には monospace の時とデータ構造を切り替える必要がある。
      o 何れにしても工夫をするのであればデータ構造を切り替える必要があるのは確実である。

  b 或いは最後に触った位置を記録しておけば良いのかもしれない。
    どうせ前から後ろに向かって書き込んでいく場合が殆どなのだから、
    実は最後に触った位置を記録しておけば問題は起こらない。

  →取り敢えず b の様にして最後の位置を記録する様にした。
    SIMD で逆方向に進んでいる時は毎回全て計算する事になるが、
    まあ気にしない事にする。

* ansi: wcwidth に相当する物を自分で実装する [#D0026]
  これは ble.sh にテーブルがあった筈なのでこれを流用する。
  →これは enc.c2w に実装した。contra::encoding::c2w である。
  取り敢えず現在の端末の c2w_width_emacs でテストを続ける事にする。

  monospace 側も non-monospace 側も正しく動作している様に見える。

2019-04-05

* [棄却] bidi: 文字列の構造はマーカではなくてちゃんとした構造に変更する [#D0025]
  そもそも文字列はそんなに頻繁には使われないので複雑な構造でも大丈夫の筈。
  但し、文字の記入などのあらゆる操作に対して文字列がある場合には色々と考察が必要になる。

  取り敢えず試験実装として現在の実装と並列にする事にする。
  試験実装の構造には prefix として xxx をつける事にする。
  リスト構造にしようか、或いは vector にしようか。
  そんなに要素が増えないと思えばリスト構造である。
  メモリを節約しようと思うとリスト構造になるだろうか。
  然し、最悪の使用方法の場合を考えると vector の方が効率も良い。
  実装は断然 vector の方が楽である。

  うーん。属性化領域だとか色々考え出すと余りにも複雑である。

2016-10-19

* [2016-10-14] "文字列" データ構造再考 [#D0024]

  | -- 方向付き文字列の表現について --
  |
  | タブなどの仕様について調べた結果、"文字列" の記録方法に変更を加えた方が良いような気がする。
  | タブの仕組みの内に TATE, TALE, TAC, TCC という物があって、これは
  | ある HT と次の HT または CR, NEL の間を一つの単位として
  | 表示する時の配置を指定する物である。
  |
  | SRS, SDS の文字列の内部で HT や VT を行った時の動作が未定義になっているのはそういう事だろう。
  | また、他にも文字列のある場所にカーソルを移動して其処に文字を挿入すると、
  | 文字列の内部に文字が挿入される形になるという仕様についても合理的な実現方法を考えなければならない。
  | 思うに、SRS, SDS は "data stream の中に文字列の開始を意味するマークを挿入する" という意味なのだから、
  | その通りにデータ部の中身を一つの stream と思って其処にマークを挿入するという風に処理するという手があるのではないか。
  | しかし、それをそのままやるとデータ形式を全く変えなければならないし、また、データの位置と表示位置との対応が崩れるので、
  | 様々の処理の効率も悪くなる。そもそも文字列だとか特殊な配置を持つタブだとかを使う機会は殆どないのだから、
  | その様な機能のために overhead を追加したくない。そう考えれば、文字列のマークなどのデータは別に管理したい。
  | 結局、現在は文字列のデータとして開始点と終了点のペアを管理しているが、
  | それを直接更新する事によって状態の変化を追跡するのではなくて、
  | 単にマーカの位置と種類を保持する様なデータ構造を追加するというので良いような気がする。
  | もし座標の対応関係などを取得したくなったら、それらのマーカの情報を用いて計算を行うか、
  | 或いはその都度開始点と終了点のペアのリストの構造を構築してそれを元にして計算を行う様にすれば良い。
  |
  | -- タブ揃えなどの配置の実現方法 --
  |
  | もう一つ考えて置かなければならないのは変なタブ配置が設定されている時の表示の方法である。
  | a 一つの手はデータ部では文字の重なりなどは全く気にしないという事である。
  |   データ部の内容を元にして描画する時に全て処理するという風に考える。
  |   しかし、問題は普通の端末ではそもそもそういう変な揃えタブに対応していないという事である。
  |   受信側の端末では表示がそれっぽくならなくても仕方がないという風に捉えるのであれば、
  |   そのままデータ部の内容を転送するようにすれば良い。
  | b しかし、受信側の端末が様々の機能に対応していなくても、
  |   それっぽい表示にするようにしたいというのであれば、色々と考えなければならない。
  | 思うに、データ構造としてはデータ部の中にマーカとして保持するだけで十分である。
  | これらの問題はデータ部の中に保持している時の問題ではなくて、描画する時の問題である。
  | つまりレンダラの都合でそれらの機能に対応したり対応しなかったりという風にして良いのではないか。
  | そして他の端末に内容を転送する場合には
  | a 変な揃えタブの機能は無視して出力するか
  | b 変な揃えタブの機能を STAB, SDS や SRS を埋め込んで出力するか
  | c contra 側で配置を行った後の結果を転送するか
  | という風にして良い気がする。
  |
  | 但し、描画する時に正しくカーソル位置を動かせる様にする為には
  | やはり描画した時にどの位置にどの文字が表示されるのかという情報を計算できる必要がある。
  | うーん…。本当に必要だろうか。特に問題になるのは上下移動を行おうとした時だろうが、
  | 見た目にカーソル位置がずれても別に問題ないのではないだろうか。
  | むしろ複雑なカーソル位置判定を行うとアプリケーションの側で
  | それに応じた動きをするのが難しくなるのではないかという懸念がある。
  | まあ、これはどちらでも良い気がする。
  |
  | いや、しかしレンダリング先が複数ある場合には困る。
  | 或る表示処理系ではある配置をされて、別の表示処理系では別の配置をされて、
  | という風になっていると表示部での移動というのをどの様に取り扱うべきかというのは難しくなる。
  | また、フォントだとか字間だとかそういうのの取り扱いも入ってくるとより難しくなるだろう。
  | その様に考えれば、実際の所表示部での移動というのは内部的なデータ構造から計算できる範囲に留めておいて、
  | 表示する時の様々な配置に関しては追随しないという様な実装が無難である様に思う。
  |
  | 上記の様に "文字列" などの構造は (規格にある通りに) 所詮は始まりと終わりを扱うマーカであり、
  | そのマーカは制御機能に依って明示的に挿入される物で、自動的に範囲を考慮して辻褄が合う様に
  | 生成されたりするものではないのだという立場にたてば実装が大分すっきりする。
  | そもそも、端末の場合文字を受け取る度に端末の状態が更新されるわけで、その様な場合に
  | 途中の中途半端な "文字列" の状態が何であるのかというのを色々定義しようとするのは無理がある。
  | それならば単にデータ部に埋め込まれたマーカであると考えた方が楽であるし、自然な定義になる。

  [現在の結論]

  1 先ず方向付き文字列などのデータはマーカの配列 (1) として表現する
  2 場合に応じて一時的なデータとして文字列の開始点と終端点のペアを保持する配列を
    (1) から生成して使っても良い。
  3 TATE などによるタブ揃えの処理とデータ部を完全に分離する。
    つまり contra::board 上では表示部における細かい配置については関知しない。
    ただ、属性値として保持するだけに留める。
    "表示部に置けるカーソル移動" の制御機能は方向付き文字列による文字位置の入れ替えのみに対応する。
  4 端末を出力先とするレンダリングにおいては、
    タブ揃えなどの配置について関知せずにそのまま出力する物と、
    内部的に配置をしてからそれを出力する物の二種類を考える事ができる。
    特に後者については実装方法について考える必要がある。


  | -- 配置をしてから端末に出力する場合の実装方法 --
  |
  | この実装をする時に注意しなければならないのは、できるだけ出力するデータを少なくしたいという事である。
  | 例えば配置をし直す度に全データを出力するなどという実装にしていると環境によっては遅くて仕方がない。
  | 従って、できるだけ出力先の端末の持っている機能を用いて簡潔な出力になる様にしたい。
  |
  | ところで、実際の仕様では TATE だとか SDS だとかを使う機会は殆どないと思われるので、
  | そういう物が使われない限りは普通に動作して、そういうのが使われる場合に限っては
  | 遅くても仕方がないという考え方でも良い様に思う。
  |
  | さて、次の問題はいざ使われたという時に一体どの様なデータ構造に依って現在の表示状態を表現するのかという事である。
  | 一番簡単な方法は、何のデータ構造も使わず、行を更新する必要が生じる度に完全に一から表示内容を構築するという方法である。
  | そして差分のある部分だけを出力する様にする。もう少しちゃんと考えるのであれば、ウィンドウシステムの様にしてしまうという手もある。
  | つまり、表示する領域毎にオブジェクトを定義し、
  | 各オブジェクトの重なりなどを計算して一番上にあるオブジェクトの内容が表示されているという様に処理する。
  | そして或るオブジェクトの内容に更新があったとすればそのオブジェクトの表示されている領域について再表示を行い、
  | またそのオブジェクトの位置やサイズが変わったとすればそのオブジェクトが新しく占拠する領域、または、
  | そのオブジェクトが退去した領域について再度どのオブジェクトが一番上に来ているのかという事を計算し直す。
  | ここで難しいのは実際のデータ部におけるデータの更新はオブジェクトに対する操作という形になっている訳ではないという事である。
  | ちょっとした操作によってオブジェクトが完全に組み変わったりする。
  | そもそも "或るオブジェクトの位置が変わる" とか "大きさが変わる" とかそういう風な更新ではなかったりする。
  | 面倒なので取り敢えずは非自明な行に関しては行の内容を毎回完全に生成するという形にする事にする。
  | 後で必要性が生じればもっと効率のよい方法を模索する事にすれば良い。

  [現在の結論] (端末を出力先とするレイアウトエンジンについて)

  1 非自明な設定のない行に関しては単純に出力を行う。
  2 非自明な行に関しては毎回行内容を全て構築して出力するという形態をとって良い。
  3 余裕があれば、先ず方向付き文字列の部分についてだけは対応を行う。
  4 更に余裕があればウィンドウシステム的にオブジェクトの入れ子構造を構築・管理して、
    効率の良い更新ができないか模索を行っても良い。

  という訳で現在のデータ構造を変更する事になる。
  現在のデータ構造を変更した時の影響範囲はどれくらいになるだろうか。
  調べた所、外部から使っている箇所は現在はテストコードだけという事がわかった。
  皆 to_data_position/to_presentation_position 経由で情報を使っている。
  この二つの関数さえ修正すれば自由に変更できる状態にある。

  | 取り敢えずデータ構造は確定した。
  | 次に実装するべきは to_data_position/to_presentation_position である。
  | これを実装する時にどの様な戦略が考えられるかについて一度考察したほうが良い。
  | また、その前に文字列の始まりと終わりの対応が取れない場合などに
  | 一体どの様に処理するかなどについても確定しておく必要がある気がする。
  |
  | a 一つの方法は始点と終点の対応を取って配列に格納してからそれを使うという方法である。
  |   これにすれば既存の to_data_position/to_presentation_position を流用できる。
  |
  |   しかし to_data_position/to_presentation_position を呼び出す度に配列を構築するコストがかかる。
  |   これについてはどうにかならないだろうか。
  |   例えば一つの方法は始点と終点のペアの配列をキャッシュする様にしておいて、
  |   前回から変更がなければ前回のデータを使うという風にすれば良い。
  |
  |   x しかし問題は marker の配列に変更がなかったとしても、
  |     行の内容の文字列の側に変更があると文字列の終端位置などに影響が出るという事である。
  |     つまり、前回から変更があったかどうかというのの判断は行内容も含めて実行しなければならない。
  |     これだと駄目である。なので、何とかこれを回避する方法はないだろうか。
  |
  |     例えば、特に行内容で影響を与えているのは "行終端" = "行の内容が存在している一番右端の位置" だけの気がする。
  |     だとすれば、行終端を表す特別な値 -1 などを使ってキャッシュすれば良い気がする。
  |     しかし、本当にデータ部における行内容が影響を与えるのは行終端だけなのだろうか。
  |     例えば行内容で一番初めに文字がある位置というのは影響を与えない。
  |     何故なら文字列の始まりはかならず明示的に指定されるからである。
  |     問題なのは文字列の終端がまだ受信されていない "過渡的な文字列" なのである。
  |     また、当然行内容の文字が入れ替わっても何の影響もないだろう。
  |
  |     但し、文字挿入の際に或る marker を跨ぐような文字が設置されると困る。
  |     でも、その際にはそれによって marker の除去もしくは修正が行われなければならないから、
  |     結局それに依って marker 列に変更が生じるので変更検出については問題ない。
  |     しかし、この文字挿入時の marker 修正については留意しておく必要があるだろう。
  |     marker の位置をずらすのだとしたら後方にずらして、もしその他の marker と衝突するようであれば
  |     それらも広報にずらす様にする必要がある。その際に長さ 0 の文字列が発生すればそれは削除する。
  |     しかし aligned tabulation に関してはずらすというのは変なので削除する。
  |     削除する時には、対になる end marker が既に来ているのだとしたらちゃんとそれも削除しなければならない。
  |     そうしないとその他の文字列を一気に閉じる事になり望まない結果になる様な気がする。
  |
  |     結局そんな理由で行終端だけが文字列範囲の決定に影響を与えると思って良さそうである。
  |
  |   所で、どの様にしてその様な対応関係の配列を生成するのかというのは一つの問題である。
  |   効率的な方法があるかどうかについてはまた後で考える必要がある。
  |   うーん。結局 stack の様な構造を作って処理するしかないのだろうか。
  |   それだと結構コストがあるような気がするが。しかしだからといって
  |   再帰にするとスタックオーバーフローの危険性があるし、うーん。
  |
  | b 或いは、対応関係を配列に入れなくても処理する方法はあるだろうか。
  |   例えば始点が来た時に終点をその場で計算するという方法が考えられる。
  |   この方法を使えば新しくメモリを確保するなどの手間が省けて良い。
  |   しかしこの方法だと始点ごとに入れ子になっている部分について
  |   同じ計算を実行する事になり非効率的な気がする。
  |   結局処理の見通しの良さなどを考えてもこの方法は取りづらい。
  |
  | まあ a で実装するのが現実的な気がするので、それで行く。
  |
  | + SIMD で文字が逆方向に進んでいる時には一体どうするのか?
  |   - SDS 開始と終了を反転させた順序で認識しなければならないのだろうか。
  |     しかし思うにデータ部内の内容自体がデータストリームであって、
  |     SIMD で文字を逆方向に進めるというのはデータ部内の "データストリームに対する編集" の一つだと考えるならば、
  |     文字を挿入する時に逆方向に進んでいたとしても、
  |     最終的に解釈する時にはその時にデータ部に記録されている内容から SIMD に関係なく文字列などの構造を決定するべきである。
  |     従って SIMD がどうだとかそういうのによって marker の解釈を買える必要はない。
  |   - もう一つ考えて置かなければならないのは過渡的な状態についてである。
  |     データ部に逆方向にデータを格納できるとすると、例えば SDS 終端を先に記録して、
  |     その後で SRS 始端を書き込むという事が可能になる。その過渡的状態で何か問題になる事はないだろうか。
  |     先ずそもそも終端のマーカだけでは SDS の場合には、その文字列の方向を決定できない。
  |     なので SDS の場合には終端マーカだけで有効な文字列として解釈するというのは不可能である。
  |     従って、SDS 終端マーカしか存在しない場合にはそれは単に無視するという風に処理するのが無難に思われる。
  |     だとすれば SRS の終端マーカの場合にも同様に処理するしかないだろう。
  |     それに終端マーカだけ存在していた時に、例えばそれを行頭までの文字列と解釈しようとすると
  |     文字列入れ子状態キャッシュ配列の処理もより複雑になる。
  |     といっても "行頭" を表す特別な値 "-2" に対して処理を書くだけのような気もするが。
  |     何れにしても余り凝ったことをしても自然な振る舞いになる様に思われないので、
  |     終端マーカだけしか無い文字列に関しては単に無視するというので良いだろう。
  |
  | + 一つの行に設定できるマーカの個数に上限を設定する必要がある。
  |   もしくは複数のマーカを縮約する方法について取り決めれば論理的に上限の数があるかもしれない。
  |   例えば同じ位置で始まって同じ位置で終わる文字列というのはくっつける事ができるのではないかという事である。
  |   そして入れ子になっていなければならない (閉路がない) という事と、空の文字列はないという事を考えれば、
  |   文字列は最大でも (行の文字数) * 2 - 1 個しか作成できない。
  |   但し、過渡的な状態として開始マーカを大量に仕込むことが出来る。
  |   開始マーカの時点ではそれぞれのマーカの終端が同じになるかどうかについて何も分からないので、
  |   結局終端マーカが来るまでは縮約については保留しなければならない。
  |   だとすると結局縮約をするとしてもマーカの個数に上限を設定しなければならないという事だから、
  |   そもそも縮約などの面倒な事も考えなくて良さそうな気がしてくる。
  |   ただ、マーカの個数の上限は (行の文字数) * 4 以上でないと不都合が生じるケースが
  |   存在するという事は分かった。なのでマーカの個数の上限は十分大きくとっておくことにする。

  [結論] 記録したマーカの処理方法について

  - 文字挿入時の marker の修正。全角文字の挿入に依って marker 位置の上に文字を上書きするとき、
    a その marker が aligned tabulation による物である場合にはそれを削除する。
      もし対応する終端マーカ (通常の tabstop への HT) がある場合にはそれも削除する。
      但し、それよりも前に aligned tabulation marker がある場合には削除しない (フィールド連結になる)。
    b その marker が SRS/SDS 文字列である時には marker の位置を新しく挿入した文字の終端に移動する。
      この時、文字列長が 0 になった場合には (つまり文字列終端が挿入文字の終端にあったときは)、
      その文字列 (同じ位置にあるマーカのペア) は削除する。

  - 終端マーカだけの存在は許す。文字列としては解釈しない。
    これは SIMD(1) による data stream 構築の過渡的状態として考えられる。

  - 一つの行に設定できるマーカの個数に上限を設ける。
    それは、論理的に配置できる文字列の個数が 2 * (行の文字数) であることから、
    4 * (行の文字数) より十分大きな物にする必要がある。
    この制限は tty_player の側でかける事にする。

  という訳で取り敢えず実装するものについて整理する。
  > 1 マーカ配列 → 文字列配列 への変換。
  > 2 to_data_position/to_presentation_position の調整。
  > 3 SDS/SRS によるマーカの挿入。
  > 4 文字挿入時のマーカ修正。
  # 5 HT によるマーカの挿入 (これはタブ実装の後で)
  # 6 一頻り実装が終わった後で様々な動作テストを行うべきである。

  5,6 に関しては別に項目を立てる。

  | [過渡的状態の文字列(非終端文字列)の取り扱い]
  |
  | to_data_position/to_presentation_position で行の終端を意味する
  | nested_string::npos を処理する必要がある。
  | しかし、そのためには行の終端を取得しなければならない。
  | line 構造体自体は行の内容について関知しないから行の終端を取得するためには
  |
  | a line 構造体自体に行の終端を格納するフィールドを用意して、
  |   行内容の変更に応じて line 構造体の行終端位置も更新する様にする。
  |
  |   # この方法を採用すると行内容の編集と一緒に毎回行終端位置を更新しなければならない。
  |   # そのまま愚直な実装で実装するとコストが高いし、
  |   # 或いは更新の方法に応じて賢い方法を考えるとすると複雑になる。
  |   # やはり使いたい時にその場で計算する方が理に適っている様な気がする。
  |
  | b もしくは、to_data_position に引数として予め計算した行終端を渡す様にする。
  |
  |   # この方法を採用すると行終端を毎回必ず計算しなければならず非効率的である。
  |   # 関数オブジェクトでも渡す様にすれば必要になった時にだけ計算する様にできるが、
  |   # 何か設計を誤っている様な気がする。
  |
  | c 或いは board の側に data_position を移して実行する様にした方が良いか。
  |   現状では presentationDirection を引数に受け取っているが、
  |   その様な情報によって計算結果が左右されるという事はやはり
  |   to_data_position/to_presentation_position は論理的にも board の管轄下にあると考えるのが自然である。
  |
  |   と思って確認してみたが、presentationDirection が記録されているのは board ではなくて tty_state の方だった。
  |   だとすると to_data_position/to_presentation_position は tty_player に実装するべきなのだろうか。
  |   しかしそれは変だ。行毎に文字列を管理しているのだから board や line のレベルで to_data_presentation
  |   に対応していないとおかしい。tty_player に実装するとなると、これらの board や line に記憶されているデータは、
  |   tty_player で board を操作している時にしか有効でない外付けの様なデータになる。
  |   だとすれば、これらの文字列のデータは board ではなくて player の方に移すべきなのだろうか。
  |   そもそも board にどれだけの機能をつけて、また、どれだけの機能を player の方に任せるのかというのを考えないと行けない。
  |   確かに双方向サポートなどというのは ANSI ターミナルを実装するときにしか使いそうにない機能である。
  |   その様に考えれば tty_player の側に実装する物の様にも思われる。
  |   しかし、一方で tty_player で管理するべきなのは "画像の出力内容をどのようにするかという設定" だけで、
  |   "実際のどの様な画像が表示されているか" に関しては board に完全に情報を持たせるべきの様にも思われる。
  |   また、各行についての設定・データを tty_player の側で管理するというのはやはり違う気がする。
  |   その様な情報はやはり飽くまで画面に付随している属性に思われる。
  |
  | どうも腑に落ちない。いろいろ考えている内に眠くなってきたので晩ごはんを食べに行く。
  |
  | 歩いていて思ったのだが、そもそも presentationDirection が tty_state の上にあるのがおかしいのだ。
  | これは board 上でどの様にデータが表現されているかという board の情報であって、
  | tty_player の振る舞いを規定するような情報ではない。それが tty_player の上にあるのがいけないのだ。
  | そもそもの方向付き文字列なども board 自体の presentationDirection を与えないと一意に定まらない。
  | さて、presentationDirection を board 上に移動するとなれば話はずっとすっきりする。
  | という訳で presentationDirection の移動を実施する。→移動した。意外と簡単に移動できた。
  |
  | 後は to_data_position/to_presentation_position の実装を board_line から board に移動するだけの筈である。
  | →これも無事にできた。

  | [文字列挿入時のマーカの上書き]
  |
  |
  | 文字列挿入時のマーカの修正方法について改めて考える必要がある気がする。
  | 実装している途中でよくわからなくなったので。
  | できるだけ様々な場合で整合的に動作する様にしたい。
  | つまり微妙な違いで振る舞いがぜんぜん違うというのは良くない気がする。
  |
  | 1 先ず初めにマーカの或る位置に文字を書き込んだ時の動作について。
  |   特に HT を行った時に設定される aligned string について。
  |   実際に実装する前には上書きする場合には消去し、
  |   隣接する場合には消去しないという風に考えていた。
  |   しかし、それだと全角で文字を出力していって丁度マーカを踏み潰す形になった場合には
  |   前のフィールドと次のフィールドが連結されるという様な形になるが、
  |   一方で、半角で出力していった場合や丁度全角文字がフィールドに収まる場合には、
  |   途中で書き込む先のフィールドが変わるという動作になる。
  |   出力位置の微妙な違いでこれらの大きな動作の違いがあるのは何か変だ。
  |
  |   そもそも、次のフィールドに移動する時に HT をするという前提で考えると、
  |   フィールドの末端ギリギリまで文字を出力するわけには行かない。
  |   そうすると、その文字を出力した直後に既に次のフィールドの位置に移動していて、
  |   その場所で次のフィールドに移動しようと思って HT を出力すると更に次のフィールドに移動してしまうからである。
  |   だとすればぎりぎりまで出力した場合には、上書きする時と同様にマーカを削除してしまって良い気がする。
  |   その次の瞬間にカーソルがそこを跨ぐから削除するという風に考えても良い。
  |
  |   改めて書くと、境界 a から境界 b に亘る文字を配置した時、a < m <= b なる位置 m にあるマーカは削除する。
  |   ではこの動作にした時に不明瞭は点は他にないだろうか。
  |   aligned string のマーカには三種類ある。純粋な終了点を表すマーカと、開始点を表すマーカ、
  |   それから開始点を表すマーカはそれより前に開始点を表すマーカがあった場合に終了点をも兼ねる。
  |   - 先ず状況の簡単そうな終了点のマーカを削除する事について考える。
  |     終了点のマーカが其処にあるという事は普通の状況では、
  |     現在出力している場所は前の開始点マーカで指定される文字列の途中という風に思われる。
  |     その時に其処に終了点が現れたらどうするか。
  |     もし、その行に対する出力が初めてであった場合には其処には何も終了点マーカなどはなかった筈で、
  |     過渡的な状態においては終了点が存在しないフィールドという物が許される。
  |     その様に考えればその様な終了点マーカは単純に削除してしまって良いと考える。
  |   - 次に純粋な開始点の場合にはどの様に処理すればよいだろうか。
  |     純粋な開始点を削除するというのは一体どういう事だろうか。
  |     先ずそれより前の部分は algned string ではないという事。
  |     なので、それより前の aligned string の整合性などについては考えなくて良い。
  |     一方で、対応する終了点について気になる。それは削除した方が良いのではないか。
  |     しかし、よく考えてみれば対応する終了点が孤立して残されたとしても何か問題が起こるという訳でもない。
  |     処理の上では単純に無視される。それならば局所的な変更になる様にしておいた方が後々様々な所での動作が自然になるのではあるまいか。
  |     しかし、これは data stream という観点から考えるとどうだろう。終了点マーカというのは HT によって次のフィールドに移った時や、
  |     NEL によってその行を終了したとき等に自動的に設置される。明示的に其処に埋め込むという物ではない。
  |     そう考えると開始点が消滅しているのに終了点だけ其処に残留するというのも変な話である。
  |     例えば、カーソル移動で適当に移動して文字を挿入したりタブを設置したりしようとすると変な事になる。
  |     従って、やはり終了点も対で削除した方が良い様に思われる。
  |   - では開始点と終了点の両方を兼ねているマーカの場合にはどの様に処理すればよいか。
  |     基本的には純粋な終了点と純粋な開始点の両方の処理をすれば良い気がする。
  |     純粋な開始点の様に前方に終了点マーカが存在すればそれと一緒に削除を行う。
  |     後は単純に削除を実施する。
  |
  |   結局動作についてまとめると、それが開始点マーカであるならば、
  |   次のマーカを探してそのマーカが終了点であればその終了点マーカを削除する。
  |   そしてそのマーカを (終了点マーカ・開始点マーカかに限らず) 削除する。
  |   また、マーカの範囲に関しては SIMD でない時には a < m <= b であり、
  |   SIMD である場合には a <= m < b にする。
  |
  |   ※実装前の考えではその点が終了点マーカである場合には、
  |   終了点をずらして今までのフィールドの長さを縮める様にしていた。
  |   しかし、この動作はやはりおかしい気がする。
  |   それだと例えばその行に既に内容が出力されているという事を知らずに、
  |   通常通りに出力を行った時に意図しないフィールド分割になってしまうという事になる。
  |   何も知らずに上書きしていっても副作用が出ない様に設計するのが良いのだ。
  |
  | 2 SDS/SRS で挿入される文字列についてはもう少し慎重になりたい。
  |   不用意に上書きをすると左右が突然反転したりして何か良くわからない事になる。
  |   上書きされる文字の部分は消えてしまうとしても、
  |   残った部分の方向性については保持する様にしたい。
  |
  |   もし、挿入文字がマーカ直前に隣接するという場合には何もしない。
  |   というのもマーカ直前に文字を挿入したとしても
  |   SDS/SRS 文字列の内容はそこに変わらず残るからである。
  |   直前に文字を書いただけで内容が破壊されるというのは変である。
  |   しかしそうするとその次に文字が書き込まれるのは文字列の内部という事になる。
  |   しかし、文字列先頭の位置はデータ部ではマーカの直後になるが、
  |   表示部で見るとその文字列の方向性に従った位置に表示されている。
  |   その様に考えると次の文字が挿入されるのはやはり方向性を考慮して計算された位置であるべきで、
  |   つまり、SDS/SRS 文字列の内部に文字が追加されるという事になる。
  |
  |   ※この動作は先の algned string の時と違う。
  |   aligned string の時には最終的な状態が空の行に出力した時と同じになる様に考えたが、
  |   今回の SDS/SRS 文字列の内部に侵入可能という様な実装では、
  |   既に其処に文字列が存在している状態で行を出力すると変な出力になってしまう。
  |   うーん。これについては後でもう少し考えたほうが良いような気もする。
  |   例えば現在の出力位置にどの様にして移動してきたのかという事や、
  |   マーカがいつ設置されたものなのかという情報を考慮に入れて文字挿入の動作を変化させるなど。
  |   しかし、それはそれで変な気もする。
  |
  |   また、挿入文字がマーカを上書きするという場合にはマーカを後ろにずらす。
  |   SIMD の場合には前にずらす様にするのが良いだろう。
  |   一つの懸念はマーカをずらす時にマーカの順序が変化してしまわないかという事である。
  |   終了マーカは開始マーカの直後になければならずその順序が変わってしまってはならない。
  |   m_markers 配列の中では勿論登録されている順序は変化しないが、
  |   しかし、位置を補正する事によって m_markers の内容がソートされているという条件が破れるのが心配だ。
  |   しかし、SDS/SRS マーカを全て同列に扱っている限りは開始マーカが後ろにずらされる事によって
  |   終了マーカの位置を追い越したとしても終了マーカも同様に後ろにずらされる筈であるから、
  |   問題は起こらない筈である。
  |   所で、ずらす事によって長さ 0 の文字列ができる事があるこれについては残しておいても良いような気もするが、
  |   やはり削除してしまったほうが自然な動作と思われる。従って、これについてチェックして削除を行う。
  |   これは終了マーカを移動した時にチェックを行えば良いであろう。
  |
  |   ? しかし SIMD の時に前方にマーカをずらすとするとちょっと微妙である。
  |     終了マーカが移動した時に文字列が潰れるかどうかの判定はどの様に行えば良いだろう。
  |     と思ったが、終了マーカも前方に移動するのでその時にやはり文字列が潰れているか
  |     どうか見極めて削除を行えば良い気がしてきた。
  |     実のところ開始マーカで判定をしても終了マーカで判定をしても良いけれども、
  |     両方移動した後に判定を実行しなければならない。
  |     そんな訳で順方向にループを回すのであれば終了マーカ移動時に文字列が潰れたかチェックし、
  |     逆方向にループを回すのであれば開始マーカ移動時に文字列が潰れたかチェックを行うという事になるのだろう。
  |     今回は順方向にループを回す実装しか考えてないので SIMD に拘らず終端マーカで空文字列判定を行えば良い。
  |
  |     うーん SIMD の時に前方にずらしたとしてその時に何か別の物を跨いだりして変な事にはならないだろうか。
  |     今のところの実装としては最終的な状態では挿入文字の内部にマーカが残る様な事はない。
  |     従って、SIMD の時に前方にずらしたとして追い越すとしたら元々文字内部または文字の境界にあったマーカだけである。
  |     うーん。SIMD で前方にずれるマーカというのは文字内部のマーカである。それが追い越すとしたら
  |     文字内部のマーカしか無い。文字内部のマーカの内 SDS/SRS マーカは同様に移動するので追い越す事はない。
  |     aligned string マーカに関しては削除されるので、これも追い越すという事はない。
  |     従って、SIMD で前方にずらしたとしても SDS/SRS/alignd string markes の何れも追い越さない筈である。
  |
  |   ? もう一つの問題は終了マーカで削除判定を行うとすると開始マーカと削除マーカの二つを削除する事になり、
  |     マーカに対するループの番号を補正しなければならない。
  |     と思ったが、よく考えてみればこれは aligned string の時も同様である。
  |     削除が発生した場合には次に検索するマーカは前回と同じ i であるべきなので、i-- するか、
  |     i++ しないようにするかの対策が必要である。
  |     同様に文字列が潰れた事の判定に依ってマーカの対を削除するのだとしたら単に i -= 2 などとすれば良い。
  |
  |   ? さて、しかし SDS/SRS 文字列が終端する条件は一つではない。
  |     SDS/SRS による明示的な終端だけではなく、次に aligned string マーカが存在するというパターンも有る。
  |     aligned string マーカの際に直前にある文字列が潰れていないか判定するのは面倒である。
  |     その様に考えると実は開始マーカの移動の際に一緒に終了点マーカの移動先も計算して、
  |     その上で文字列が潰れるかどうかを判定するという手のほうが良いのかもしれない?
  |     しかしそれだと入れ子になっている文字列が潰れた時に削除できない。
  |     終端マーカで削除判定を行う事の利点は、空文字列の終端マーカに到達した時には、
  |     必ず内部に入れ子になった文字列 (すべからく空文字列である) のマーカは既に全部除去されているという事である。
  |     つまり、直前の要素を見れば必ず開始点マーカに対応する物が存在するはずという事である。
  |
  |     もし直前の要素がない場合や、aligned string マーカである場合には
  |     そもそも開始点が存在しないという事になるので、
  |     そのマーカは単に削除すれば良いだろう。
  |
  |     結局、終了点マーカもしくは aligned string マーカが現れた時には空文字列判定を行うという事になる。
  |     SDS/SRS 終了点マーカの場合には移動後に空文字列判定を実施する。
  |     aligned string マーカの場合には先に空文字列判定を行って、その後で aligned string マーカの処理を行う。
  |
  |     →実装している時に気づいたが。
  |     現在の実装では aligned string マーカが現れたらその直前にある SDS/SRS を削除するという方針にしていた。
  |     しかし、この方法だと既にあってシフトの対象となった SDS/SRS だけではなくて、
  |     新しく追加した SDS/SRS マーカまでも削除してしまう事になる。
  |     つまり、alined string マーカの直前で SDS/SRS を設置してもそれが削除されてしまうという事態になる。
  |     本当に処理しなければならないのは何かというと、暗黙上書きによってシフトされた SDS/SRS に関して、
  |     直後に aligned string が存在していた時に空文字列として削除を行うという物である。
  |     元々の懸念は入れ子文字列の場合に正しく削除できないのではないかということだったが、
  |     仕方がないので可能性のあるマーカは全て確認して aligned string が一つでもあったら
  |     空文字列になると判定して削除するという具合にする。

  | [SDS/SRS によるマーカ挿入]
  |
  | 通常時は現在の文字位置の左側に挿入し、SIMD 時は現在の文字位置の右側に挿入する。
  | (そもそもその様にしないと次に全角文字が来た時に潰されてしまう。)
  | 左側に挿入する時は append で右側に挿入する時は prepend にするべきだろう。


* [2016-10-05] TAB 関連の機能 [#D0023]

  | Mode TSM
  | VT VTS
  | TAC TALE TATE TBC TCC TSR
  | STAB (ISO 8613-6) HTJ HT HTS CHT CBT CTC CVT
  |
  | 影響のあるもの: DAQ(7) DCH ICH DL IL RIS
  |
  | RLogin は HTS, DECHTS, VTS, DECVTS を認識するが、
  | 何も設定しない状態で HT を呼び出すと何が起こるのだろうか。
  | 確認する必要がある。
  | 因みに VT に関しては次の行に単に進むだけの様に見える。
  | VTS を設定してる状態で VT を実行するとどうなるだろうか?
  |
  | 1 HTS の設定に関する確認。
  |   $ printf $'\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |   xterm, screen, RLogin, mintty, Poderosa の何れも TSM(MULTIPLE) で、
  |   予め 8 の倍数の位置にタブが設定された状態で始まる。
  |   HTS を呼び出すと予め設定されているタブに加えて新しいタブを設定する。
  |
  |   TSM 対応に関して
  |
  |     $ printf $'\ec\e[5W\e[18h\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |
  |     RLogin のマニュアルを見ると TSM を ISM という名前で対応している。
  |     しかし "マルチ" と "シングル" の名前が間違っている。逆である。
  |     動作自体は逆にはなっておらず正しい。
  |     CTC(5) の仕様が異なるのは気になるが、何れにしても TSM(SINGLE) にすると、
  |     TSM の変更前に全体に共通のタブを色々設定していたとしても、
  |     各行で 8 の倍数にタブが設定された状態になる様だ。
  |     つまり、TSM の変更前のタブは引き継がれない。
  |
  |     xterm のマニュアルには何も書かれていない。実際に試しても対応していない。
  |     mintty, screen, Poderosa も試してみたが対応していない。
  |
  |   CTC in RLogin
  |
  |     RLogin の CTC(5) と CTC(6) の記述が ECMA-48 の記述と異なる。何故か?
  |     ECMA-48 側が変化したのかもしれないと思って確かめたが
  |     2nd edition から 5th edition まで記述は同じである。
  |     vt510 及び xterm にはそもそも CTC が存在しない。
  |     all-escapes.txt の内容は ECMA-48 の内容と全く同じだ。
  |
  | 2 TAC, TALE, TATE の取り扱い方法?
  |
  |   ECMA-48 に含まれるこれらの機能によって設置されたタブは特別な意味を持つ。
  |   タブ位置の前後にある文字列の配置に影響を与えるとある。
  |   しかし、実際のどの様に実装する物なのかよく分からない。
  |   まず例えばデータ部での配置に影響を与える物なのかどうか、
  |   表示部での上下左右の移動に影響を与えるのかといったことである。
  |
  |   恐らくデータ部での配置には影響を与えないつもりなのだろう。
  |   これらは飽くまで実際に表示する時にどう表示するかというのを指定するためにある。
  |   表示部での取り扱いをどの様にするべきかという事を考える前に、
  |   そもそもこれらのタブが具体的にどの様に処理されるかについて考えなければならない。
  |
  |   % 恐らく前後の文字列というのはフィールドと考えて良いだろう。
  |   % "文字列" と言えば方向付きの文字列という物が ECMA-48 の中で定義されているが、
  |   % それだと、それらが丁度タブの前後で分かたれているとは限らないのでよく分からない。
  |
  |   改めて規格の文面を見ると前後の文字列という訳ではなくて、
  |   何らかの text string があってそれが TAC などによるタブで揃えられる時には、
  |   その文字列の先端もしくは後端の位置によって左右位置の調整が行われるものと見える。
  |   また text string というのは恐らく双方向対応で出て来る strings とは別の物であろう。
  |   よくわからない点が色々ある。先ず、"tabstop by TAC で揃えられる text string" という物を
  |   どの様に指定するのかという事である。"これこれここの範囲はタブによって揃える text string ですよ"
  |   という様な感じに明示的にそれを指定する制御機能はないように思う。
  |   しかしだからといって、タブに従って揃えられますという様な表示規則も元々あるという訳ではなさそうだ。
  |   もし何かあるとすればフィールドだが、これについて何か説明が見つかるかもしれないので
  |   また改めて規格の内容をフィールドに関連して観察してみる。ECMA-48/6.7 を見る。
  |   うーん。分からない。とここで STAB の説明を改めて読むとそこに、
  |   以降の文字列を引数に依って指定されるタブ位置とその性質に従って align されると書かれている。
  |   実は TAC, TALE, TATE, TCC はこの制御機能ありきの機能なのではないだろうか。
  |   しかし、この制御機能は ISO 8613-6 に詳細を投げている。そちらも参照する必要があるだろう。
  |   ISO 8613-6 というか T.416 を見ると TAC, TALE, TATE, TCC は存在しない。やはり関係ないのか。
  |   T.416 STAB に関して見てみると、[T.416/9.1.13] のデータ構造 Line layout table を参照している。
  |   このデータ構造を見ると丁度 TAC, TALE, TATE, TCC などに対応する状態を持っている。
  |   というか、このデータ構造をそのまま採用すれば良い気がしてきた…。
  |
  |   更に、HT の説明に、もし次のタブ位置が TATE, TALE, TAC, TCC による物だとしたら、
  |   次に HT または改行が来るまでは文字列の内容はそのタブに関連付けられた文字列とすると書かれている。
  |   しかもそれは表示部で定義される物ではなくてデータ部の data stream 内で記録されるという。
  |
  | 3 RLogin で垂直タブの設定などをいろいろ試してみたがどうもうまく動かない。
  |   いつでも VT や DECSVT などは一行下に移動するという意味になる様に見える。
  |   xterm でやって見ると DECSVT は効果を持たない (対応していない?)。
  |
  |   縦タブを全てクリアしてから縦タブを設置する様にしてみたり色々したがうまくいかなかった。
  |   でもマニュアルにはちゃんと縦タブについて系統的に対応している様に見える。
  |
  |   - 一つの可能性は初期状態として全ての行に縦タブが設定されていて、
  |     更に縦タブをクリアする機能が効いていないという物である。
  |     縦タブをクリアする機能は CTC と TBC, DECAVT しかない。何れも試したが駄目だった。
  |
  |     $ printf '\e[H\e4\e[6W\e[4g\e[91m\e[10HX\eJ\e[20HY\e3\e[Hhello\vworld\e[1Ytest\e[m\n'
  |
  |     \e4 \e[6W \e[4g のどれを使っても縦タブが解除されていないという事になる。
  |
  |   - もう一つの可能性は何処かにモードがあって縦タブによる移動と
  |     単に一行下に移動するのを切り替えられる様になっているという物である。
  |     しかし説明を見ても VT もしくは縦タブに関連したその様なモードはない様に見える。
  |
  |   - 更に可能性として縦タブの設置に失敗しているという可能性がある。
  |     縦タブが存在しない場合は一つしたの行に移動するという実装になっているのかもしれない。
  |     しかし VTS も DECVTS も駄目だった。
  |
  |   - 或いは VT は常にひとつ下の行に移動するだけで、
  |     実際に縦タブするには CVT を使わないと行けない可能性もある。
  |     しかし CVT で試してみてもやはり状況は変わらない。
  |
  |   - 縦タブは1つずつ解除しなければならないのかもしれないと思って以下も試したが駄目だった。
  |
  |     $ printf '\e[H'; for a in {0..20}; do printf '\e[1g\e[3W'$a'\e[B'; done; printf '\eJ\e3\e[Hhello\vworld\e[Ytest\n'
  |
  |   うーん。RLogin は本当に縦タブに対応しているのだろうか。


  [実装方針]

  1 早々に実装方針を決定したい。
    基本的には ISO 8613-6 (というか T.416) にある様なデータ構造で保持したい。
    タブ構造は各行で保持する。但し、全体で共通のタブ構造を管理している場合には、
    共通のタブ構造と一致する限りに於いて実際にタブ配列を複製するのを避ける。
  2 TSM(MULTIPLE) のとき同じページの全ての行に適用する。
    新規行の文字タブ設定は頁毎に保持する。
  3 タブの位置は常に表示部で定義される。
    と思ったがタブと方向付き文字列の実装に関連して考察した結果、
    方向付き文字列の内部でタブは設定しないという風に考え、

2016-10-12

* Poderosa bug [#D0022]

  | Poderosa で RI を試そうとして以下を入力していたら無限ループになって死ぬ。
  |
  | $ printf 'hello\e[H\eMworld\n'
  |
  | ble.sh をロードした状態で上ボタンで履歴を表示してそれからこれを実行するとなる。
  | 具体的にどの様なエスケープシーケンスを受け取って死ぬのかは調べないと分からない。
  | 面倒だ。どの様にすれば確認できるだろう? contra で escape sequence を全て出力する?
  | 新しく escape sequence を全て出力するクラスを作った: sequence_dump
  | 関係のありそうなものだけを抽出する。DECSET(25), SGR, OSC, SI は関係ないだろう。
  |
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   CR LF
  |   unrecognized control sequence: CSI 1 L
  |   l o a d i n g   h i s t o r y . . .
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 1 1 C
  |   CR LF
  |   unrecognized control sequence: CSI 1 M
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 2 9 C
  |   p r i n t f
  |
  |   '
  |   h e l l o \ e [ H \ e M w o r l d \ n
  |   '
  |   unrecognized control sequence: CSI K
  |   CR LF h e l l o
  |   unrecognized control sequence: CSI H
  |   RI w o r l d CR LF
  |   unrecognized escape sequence: ESC 7
  |   [ b l e :   E O F ]
  |   unrecognized escape sequence: ESC 8
  |   unrecognized control sequence: CSI 2 0 7 C
  |       CR
  |   unrecognized control sequence: CSI K
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   [ b l e :   e x i t ]
  |   CR LF e x i t CR LF
  |
  |   くっつけて見る。
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\e[13D\n\e[1M\e[1A\e[5Cprintf\e[K\nhello\e[H\eMworld\n\e7EOF\e8'
  |
  |   ちょっとここまでで Poderosa に食わせてみる。何も起こらない…。もう一回実行してみる。再現した。
  |   何だろう。ただ単に printf 'hello\e[H\eMworld\n' を繰り返すだけでは起こらない様だ。
  |   もう一度やってみる事にする。起こらない。どうやら境界が下の方にできて、その境界の直後で実行するとなる様だ?
  |
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK
  |   printf '\e[H\n\e[1L\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK 再現性あり
  |   printf '\e[H\n\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\n\e[H\eM' OK

  まとめ: 以下の手順で Poderosa が死ぬ。
  (1) Poderosa で新しいウィンドウを開く
  (2) printf '\e[2H\e[L\e[M\n\e[H\eM' と入力して実行する

* escape sequence の処理の段階で NUL や DEL は無視しなければならないのではないか。 [#D0021]
  恐らくシーケンスの途中に NUL や DEL が含まれていても単に無視して取り扱うべき。

2016-10-11

* bidi サポート追記 [#D0020]

  規格を読んでも active data position と active presentation position の関係が分からないと考えていたが、
  ECMA-48/6.3/4 に書かれている。この段落はとても重要な段落である。

  > The graphic image output is constructed in the presentation component from the data stream stored in the
  > data component, and according to the line orientation and line progression of the presentation component.
  > The presentation of characters along a line in the presentation component is dependent on the character
  > path, the character progression and the direction associated with the string.
  >
  > 訳: 記憶部に記録されたデータストリームから、表示部の行送りの方向と行の向きに従って、
  > 表示部に画像出力が構築される。行内の文字の表示は文字進路・文字進行・文字列の方向に依る。

  acative data/presentation position の関係について全てがこの段落に含まれている。
  他の部分の記述や ECMA-TR/53 の記述を組み合わせて解釈したのと整合しているので、
  実装について変更を行う必要はないという事が分かった。つまり現在の実装を変更する必要はない。
  そのことが分かっただけでも大きな成果である。

* 全角文字の取り扱い in ECMA-48 [#D0019]

  ECMA-48/6.3/3 に行は predetermined number of character positions からなると書かれている一方で、
  ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている。
  つまり、全角文字などは複数の character position を専有するという扱いではなくて、character position 自体の
  大きさが大きくなるという解釈なのだろうか。だとすると一行に収める事のできる文字の数は全角・半角に関係なく、
  ただ表示する時に全角文字で構成された行はサイズが大きいという風な扱いということなのだろうか。
  これは実際の端末の実装とは一致しないし、何より変だ。しかし、異なっても良いし固定でも良いと書かれている
  (may be fixed or may be depend)。文字に依って専有する character position が複数でも良いという風に何処かに書かれていれば
  それが実際の実装と一致した物と考える事ができる。でも 6.1.6/2 には implicit movement によって
  the active data position is moved to the following character position と書かれている。the とついているので、
  やはりこれは一つ次の character position に移動するという事である。

  ECMA-48 的には
  - 行に全角文字が含まれていても行に入れる事のできる "文字数" は同じで、
  - 例えば SLH SLL で設定される文字番号は幅ではなく "文字数" でカウントされ、
  - CUF や CUB では半角幅毎ではなくて文字毎に移動するべきなのか…。

  これは実際の端末の実装と乖離しているし、それに実装として不自然である。
  また全角幅の文字は普通に使われる機能なので、今ここで ECMA-48 に厳密な実装にすると色々な問題が実用上生じる。
  どう考えても、実際の端末の実装の方が自然で現実的な実装であるので、ここでは ECMA-48 を無視する。
  これについて Note を残しておく事にする。

2016-10-05

* SPH/SPL [#D0018]

  page_home_position -> page_home, page_limit
  取り敢えず値を設定できる様にする。

* sequence_decoder, sequence: support ESC sequence [#D0017]
* escape sequences の解釈 [#D0016]

2016-10-04

* SCP SPD に対応する。 [#D0015]
* CR ... SCP SPD の向きが逆の場合に対応する。 [#D0014]

* data position と presentation position の変換方法について。 [#D0013]

  SCP による character path の方向は基本的な計算部分に影響を与えない。
  何故ならば character path は presentation position の番号と、
  実際に表示される位置の対応関係を規定する物であって、
  data position と presentation position の間の関係には影響ないからだ。
  但し、directed string の ltor と rtol は、
  character path によって意味が入れ替わるので注意する。

  従って、計算の上で気にしなければならないのは directed_string だけである。
  directed_string によって向きが反転している範囲の中にあれば反転するという事をしなければならない。


  presentation position -> data position の実装は比較的簡単である。
  1 先ず presentation position を x とする。
  2 directed_string のリストから x を含む
    一番大きい directed_string を拾って str とする。
    もし x を含む directed_string がもうなければ処理は終了する。
    ここで x は記憶部で最終的に必ず str の範囲に含まれる事に注意する。
  3 もし str の向きが外側の向きと一致していなければ x の位置を反転させる:
    x = str.end - 1 - (x - str.begin);
  4 以降は str 及び、その中に含まれる directed_string のみを考えれば良い。
    従って、str に含まれる directed_string のリストについて 2 に戻って繰り返す。

  data position -> presentation position については少々厄介である。
  presentation position -> data position の逆の処理をすれば良いかと考えたが、
  外側と較べて反転しているかどうかを知るためには外側から順に辿って
  一旦何処で反転が起こるのかを記録しなければならない。
  もっと賢い方法はないだろうか。
  反転は線形の関数である事を思えば、shift の量だけを記録すれば行ける気がする。
  反転が起こる度に、

    x = -x + (str.end + str.begin - 1)

  という事になる。i 回目での shift 量を

    shift[i] = str[i].end - 1 + str[i].begin

  とすれば、最終的な結果は、

    x[i] = -x[i-1] + shift[i],
    (-1)^i x[i] = (-1)^{i-1} x[i-1] + (-1)^i shift[i],
    (-1)^n x[n] = (-1)^0 x[0] + ∑[i = 1 .. n] (-1)^i shift[i],
    x[n] = (-1)^n x[0] + ∑[i = 1 .. n] (-1)^{n-i} shift[i]

  で求められるという事になる。但し、i の小さな shift の方が、
  より小さな範囲の directed_string に対応している。
  今、番号付けを変更して k = n - i とすれば、
  一番大きな単位の directed_string が k = 0 に対応する様になる。

    x[n] = (-1)^n x[0] + ∑[k = 0 .. n - 1] (-1)^k shift[n-k].

  これで行く。自身がないので様々な例に対してテストを実行して確認する。

    x[n] = (-1)^n (x[0] + ∑[i = 1 .. n] (-1)^i shift[i])

* tty_player (SGR): ANSI font [#D0012]

* bidi サポート [2016-10-02] [#D0011]

  具体的にどの様に実装するべきかについて。
  これは ECMA TR/53 の Appendix にある動作例が参考になる。

  思っていたのと似たような動作を考えている様だが、実際にはもっと複雑である。
  具体的には nested strings という仕組みが問題である。
  行の中に配置を反転して表示するべき領域を埋め込むという構造は想定していた。
  しかしその様な文字列を幾らでも入れ子にする事ができる様なのである。

  問題点が二つある。

  1 先ずその様な入れ子構造を表現するのに適したデータ構造は一体なんであろうか。

    勿論、愚直にそのまま実装すれば実装できない事はないが、
    パフォーマンスなどへの影響が気になる。
    特にこの様な、実際に使う人が本当に存在するのかどうか不明な謎機能のために、
    フラットな配列の構造を諦めて何らかのリストの様な構造にするのは受け入れがたい。
    つまり、基本的には配列の構造にデータを記録しておいて、
    この様な埋め込み文字列の様な物を表現したい場合に特別な取り扱いをするというのが良い。
    その時にできるだけシンプルに最小限のデータサイズで記録する方法があれば良い。
    特に、入れ子構造を表現する為の固定長のデータ表現が存在しうるかという事である。

    例えば各セルにネストレベルを記録したらどうだろうか。
    そうしておけば同じ位置でネストレベルが複数段階変化する場合に対応できる。
    (ab[[cde]fgh]ijk の様な感じの入れ子構造が存在しうる。)
    しかしそれだと各ネストレベルでどの方向性を持っていたかという情報を保持できない。
    或いは完全に別のデータ構造として構造を保持するという手の方が現実的なのかもしれない。

  2 もう一つは後から編集が起こって別の文字を上書きした時に、
    どの様に更新範囲を検出するのかという事である。
    更に関連して編集の順序を記録しないでもちゃんと一意的に座標の対応を取る事ができるのかというのも気になる。
    また SHP や SLL を変更した時に既に出力した内容について
    どのような表示を行うべきかについても考える必要がある。

  うーん。その前にもっと詳しく動作について考えておく必要がある。

  文字列をどの様に記録するかについては 2016-10-04 に議論を残した。
  具体的に文字列の挿入を行う時にどの様に動作するべきかについては後で考える事にして、
  取り敢えずはデータ構造を確定する事にする。

  →データ構造は Memo 2016-10-04 にある通りに、
    方向付き文字列のリストとして表現する事にした。
    後で問題が起こればその時にまた変更すれば良い。


* SLL/SLH と DCSM の関係 [#D0010]

  | DCSM(PRESENTATION) の時 DCSM(DATA) の時で動作が異なる。
  | ここで問題になるのが実際に効くのは、
  | SLL/SLH を設定した時の DCSM なのか、
  | それとも実際に CR などを実行する瞬間の DCSM なのかという事である。
  |
  | もう一つ気になるのは、SLL/SLH を設定した時の DCSM が効くという場合に、
  | それを data component における座標に対応させる事は可能なのかという事である。
  | (つまり単に data component における座標を記憶しておくだけで良いのか、
  | 或いは、SLL/SLH を設定した瞬間の DCSM の状態も
  | 一緒に記録して置かなければならないのかという事である。)
  |
  | これを決定する為には、CR の動作を詳しく調べて、
  | それに整合する様に決めなければならない。
  | 例えば DCSM(PRESENTATION) で CR/LF を実行した時に、
  | LF によってカーソルが丁度下に移動する様にしたい。
  | もしくは DCSM(DATA) の時に CR/LF して、
  | LF によってカーソルが data component 内部で丁度下に移動する様にしたい。
  |
  | CR について調べた。CR 自体の動作が DCSM, SIMD によって、
  | SLL の値を使ったり SLH の値を使ったりという風になっている様だ。
  | そして SLL/SLH が設定された時の DCSM がどうたらという様な記述は全くない。
  |
  | a つまり、SLL/SLH の側では特に DCSM の値によって記録方法を変えたり
  |   という事はしなくて良い様に思う。
  |   それに、その方が自然である。つまり、DCSM や SIMD によらない
  |   一定の範囲が存在して、CR の方がモードによって変化するという事である。
  |   範囲自体が DCSM や SIMD を切り替える度に変化するというのは変である。
  |   一方で DCSM(PRESENTATION) DCSM(DATA) の切り替えによって、
  |   見た目の範囲が変わってしまう。
  |
  | b (他の例) DCSM(PRESENTATION) か DCSM(DATA) かに拘らず表示部での表示位置で
  |   記録するという様な実装も考えられたが、DCSM(DATA) の状態で
  |   SLL/SLH した行で表示部・記憶部で複雑な座標の対応になっている場合、
  |   記憶部での値で指定した列を表示部での座標に変換して記録する事になる。
  |   どの様に動作するかを予期するのが難しく、しかも使い所が分からない。
  |   うーん、訳が分からない。
  |
  | やはり自然なのは a である。
  | ECMA-48 の説明には SLL/SLH の項目で矢鱈説明がされていて、
  | SLL/SLH した瞬間に複雑な処理をしなければならない様に錯覚するが、
  | これらの説明は単に CR や他の制御機能にどう影響を与えるかを説明しているだけと思われる。
  | というか、CR や他の制御機能の説明の所に書かれている動作をそのまま再度説明しているだけで、
  | ECMA-48 SLL/SLH の部分に書かれている説明は冗長である。
  | 丁寧という事なのかもしれないが規格書らしくないし、却って混乱を招いている。
  | ここは単に "CR/IL/DL/NEL で参照される、行内の使用範囲の先頭列を設定する" とか書いておけば良いのだ。

  [結論]

  - SLL/SLH によって記録される情報は単に一つの列番号であり、
    DCSM の状態に応じて変化する様な物ではない。
  - 機能 CR/IL/DL/NEL を実行する際に、
    それぞれの機能が DCSM の値に応じて SLH または SLL の値を参照する。

* 双方向テキストに対応する際の動作について [2016-10-02] [#D0009]

  | ★例えば nested strings の中で行末に達して、折り返し処理をしなければならない場合にはどうすれば良いのか。
  |
  |   例えば [one [two [three] four] five] の各箇所で改行が起こった場合にどの様になるべきだろうか。
  |   但し一番外側の括弧で括られた部分は左から右で、その内側の括弧で右から左になり、更に内側で左から右になっているとする。
  |   折り返しがない場合には、[one [ruof [three] owt] five] という具合に表示される。
  |
  |   1 もう少し単純化する。[one [two] five] の場合はどうだろう。[one [owt] five] と表示される。
  |     これで tw の直後で改行が起こったとする。こうか?
  |
  |       [one [wt
  |       o] five]
  |
  |     或いは、
  |
  |       [one [ow
  |       t] five]
  |
  |     元の言語の文章に於いて改行を考えるとすれば前者の様な気がする。
  |     しかし改行の後に一番左に配置されるというのは元の言語の文章ではないことだし、
  |     また、これはその言語の文章というよりも外側の言語に埋め込まれた物だと思うと、
  |     埋め込まれた部分の内部で内側の言語の改行ルールによる改行が行われるというのも変である。
  |     つまり、改行というのは一番外側のレベルで行われる物なので、
  |     一番外側の言語の規則で行われるべきものなのではないかという気がするのである。
  |     だとすると後者のほうが正しいという事になる。
  |
  |   2 具体的な例で考えてみないと感覚がよくわからない。
  |
  |     日本語は古くは右から左であったが、しかし、
  |     これは、基本的に縦書きで高さが狭い場合には右から左になるという事であって、
  |     本当に右から左なのかというと微妙だし、更にそこで改行を入れることがあるのかというともっと微妙である。
  |     それに普段使っている訳ではないので実際にこれで例を作ってみた所で感覚はよく分からない。
  |
  |     どちらの方が自然だろうか。これは縦書きの日本語の文章に含まれた英文でも同様の事が言えるだろう。
  |     英単語を右に 90 度傾けて印刷する場合には問題は起こらない。英語も日本語も上から下に流れるからだ。
  |     しかし、もし仮に英単語を左に 90 度傾けて印刷する事になった場合にはどうだろう。
  |     英語は下から上に読まなければならない。そしてその途中に改行が入った場合に、
  |     英単語をどの様に並べるべきだろうか。考えて見るにどちらでもありの様な気がする。
  |
  |     取り敢えず、埋め込まれている部分が短い場合には外側の言語のルールで改行し、
  |     内側の言語については一旦行内に全て配置してから見た目で改行を実行するのが自然そうだ。
  |     つまり、1 の例で言えば後者である。
  |     しかし、ある程度の長さの文章(複数行に跨る)が埋め込まれている場合には、
  |     1 の例で言えば前者の様にした方が自然な気がする。
  |     でもやはり総じて後者の方が良いような気がする。
  |
  |   3 ここで TR/53 の例で参考になる物はないか改めて調べてみる事にする。
  |
  |     うーん。途中で改行したりという事はしていない様だ。
  |
  |     % というかそもそもの SRS の動作がよくわからない。
  |     % →と思ったら勘違いだった。data component を見ていた。
  |
  |
  | ★一番初めに各 SRS や SDS の動作について確認しておくべきだ。
  |
  |   SRS 元々確立されている方向性とは逆方向の文字列の開始・終了を定義する。
  |
  |     [ECMA-48] における記述は以下の通りである。
  |
  |     但し、character progression (data component 内の文字の記録順序) は影響を受けない。
  |     つまり、data component の中で見ている限りには SRS はあってもなくても変わらない。
  |     ただ、presentation component における位置との対応を考える為には、
  |     SRS が何処で始まって何処で終わっているのかといった情報を記録する必要があるだろう。
  |
  |     また、"文字列" 中で CVT HT SCP SPD VT によって引き起こされる効果については定義されない。
  |     また are に関係する機能 DAQ, EPA, ESA, SPA, SSA は文字列の中では用いてはならない。
  |
  |   SCP
  |     これは表示の際の方向を指定する。
  |
  |     途中で改行したりした時に一体どういう扱いにするつもりなのかと考えて改めて ECMA-48 を参照してみると、
  |     この制御機能は "現在の行" 及び "それ以降の行 (subsequent lines)" に対して適用される物のようである。
  |
  |     では、既に確立した行に対してはどうなのだろう。例えばカーソルを移動してそこに何か書き込んだ時はどうなるか、
  |     これは TR/53 の動作を見るに、後で SCP してからその行に戻って其処に文字を書き込んだとしてもその行の
  |     characater path は変わらないという様に見える。それでは一旦カーソルを上に戻して、その場所で SCP したら
  |     一体どうなるのだろうか。もし subsequent lines というのが行番号が現在いる行よりも大きい全ての行、
  |     という意味であるのだとすれば既に表示している内容に影響を与えるという事になる。
  |     一方で、もし subsequent lines というのが新しく作成される行なのだとしたら、
  |     既に出力されている行については影響を受けないという事になる。
  |
  |     うーん。説明を読むと、現在の位置に既に書かれている内容をどの様に処理するかについては書かれているが、
  |     subsequent lines の内容をどの様に処理するかについては何も書かれていないので、
  |     新しく生成される行に対してのみこの character path が適用されると考える方が自然だろう。
  |
  |     然し、一方で subsequent lines in presentation component という表現もされれているので、
  |     見た目で現在行よりも下に表示されている全ての行に対して適用するという意味なのかもしれないが、
  |     もしそうだったとすると規格の文章にはミスがあるという事になる。
  |     既に表示されている内容についてどの様に処理するかは active line については記述があるが、
  |     subsequent lines については記述がない。しかし、"subsequent lines にも同様に適用する"
  |     だとかいう感じに簡単に一文付け加えるだけで済むはずなので、この記述がないという事は、
  |     そもそも subsequent lines は空の新しい行であるか、
  |     或いは規格を記述・確認した人たちがうっかりしていて思い至らなくて書き忘れたかのどちらかである。
  |     しかし、規格を記述するにあたって実現不可能な変な記述がないように参照実装ぐらいは行って、
  |     規格に問題がないかというのを確認するのが普通だと思われるし、
  |     特に記述がないという事は subsequent lines というのは新しく生成される行という事で問題ないだろう。
  |     →この解釈については escseq.html に記述する事にした。
  |
  |   TR/53 の二つ目の例を見る限り、文字列の中で新しく文字の挿入を行った場合は、
  |     入れ子のレベルはその部分におけるレベルに埋め込まれる形で文字が挿入される様だ。
  |     つまり、その場所に移動した時点でそこにある入れ子レベルに従う事になる。
  |
  |   結局、一通り ECMA-48, ECMA-TR/53 の内容を gh-pages/escseq.html にまとめた。
  |   結局不明な事は不明なままであるが、何が不明で何が分かっているかが多少すっきりした様に思う。
  |
  |   * 自動的な折り返しに際してどの様に振る舞うかについては記述はない。
  |   * 文字列の中で制御機能を用いて移動を行った場合にどの様に振る舞うかについても記述はない。
  |   * 文字列中での active data position は定義されていない。
  |     しかし TR/53 Annex A で何かしらの方法が与えられている様にも見える。
  |   % * "文字列" の中に後から文字を挿入して追加することができる。
  |   %   これはとても厄介である。
  |
  | ★文字列の入れ子構造は記録部に記録されるのか? そして後で挿入を実行できるのか?
  |
  |   % "文字列" の中に後で内容を追加する事はできるのかできないのか。
  |
  |   TR/53 の Example 2 を見ると、一度出力して確定した "文字列" の入れ子構造の内部に
  |   後から文字を挿入する事によって、入れ子構造を変化させる事ができるという様にも見えた。
  |   しかし、落ち着いて考えてみると実はそうではないのかもしれない。というのも、
  |
  |   1 先ず、規格を参照して見るに strings だとか nested strings の概念があるのは、
  |     data stream だけであって、data component や presentation component に関しては、
  |     string がどうのこうのという記述はない様に思われる。
  |     従って後になって入れ子構造がどうのこうのというのは変なのではないか。
  |
  |   2 また、別に入れ子構造を保持していなかったとしても、
  |     data component と presentation component でそれぞれ独立に文字の挿入を行って、
  |     同時に data position と presentation position の対応関係をセル毎に記録したとする。
  |     その様な動作をしている限りにおいては Example に出ているのと同様の効果が得られるであろう。
  |
  |     しかし何れにしても対応関係をセルごとに記録するとしても、
  |     文字が新しく来る度にその対応関係を大幅に更新しなければならない。
  |     少なくとも文字列が閉じるまでは入れ子構造を保持しておく必要がある。
  |     但し、文字列が閉じた後は内部の並び替えは起こらない物と思って、
  |     入れ構造を記録したデータについては削除しても良い。
  |
  |     然しながら、data/presentation positions の対応表を保持するぐらいであれば、
  |     実のところ元になった入れ子構造を記録しておいても良い気がする。
  |
  |
  |   さて、これを区別するためには TR/53 の Example 2 で挿入する文字列について、
  |   "方向を明示せずに挿入する"、もしくは "SRS 文字列を挿入する" という例があれば良い。
  |   文字列の入れ構造に挿入されるのだとしたら、"方向を明示せずに挿入" した結果、
  |   挿入点の方向に影響されて文字列が表示されることになる。
  |   一方で、単に指定した位置に data/presentation component 上で文字列を挿入するというだけであれば、
  |   "方向を明示せずに挿入" した結果として普通の文字列の向きで文字が表示されることになる。
  |   しかし、残念ながら "方向を明示せずに挿入する" 例も "SRS 文字列を挿入する" 例も載っていない。
  |   説明文には "Character insertion is always performed according to the presentation directions
  |   and the nesting level which are established by the data stream." としか書かれていない。
  |   data stream によって確立した nesting level が何処で記録されるかによって解釈が異なる。
  |   もし data/presentation component の各行・文字の位置で記録されるのだとしたら、
  |   入れ子構造を後から変更できるという事になるし、もし nesting level というのは
  |   実際にデータを受け取って書き込む時に保持するものなのだとしたら、
  |   後から文字列を挿入するのは単に data/presentation component 上の配列を見て挿入するだけという事になる。
  |
  |   と思ったが改めて SRS の説明を見ると "SRS is used to establish in the data component
  |   the beginning and the end of a string of characters as well as the direction of the string."
  |   と書かれている。つまり、SRS は data component 内部に入れ子構造を構築するという事になる。
  |
  |   それに data/presentation component の間の座標の対応を一つずつ覚えておく方法だと、
  |   結局どのように表示されているのかということが人にとって良く分からない物になる気がする。
  |
  |   [結論]
  |
  |   文字列の入れ子構造は記録部に記録する。
  |   そして文字の挿入は入れ子構造の内部で行われる。
  |
  |   但し、方向が異なる場合には新しく入れ子文字列を作って挿入するのが良いだろう。
  |   挿入点の方向について意識しなくても安全に挿入ができる様にするためである。
  |   というのはアラビア語など言語自体が方向性を持っている場合、
  |   明示的に SRS/SDS を指定しなくても反転文字列が設定されうる。
  |   その時に或る任意の場所に新しく文字列を書き込もうとした時に、
  |   挿入位置の方向に従って勝手に文字列が反転されてしまっては困るからである。
  |
  |
  | ★途中で折り返しや改行があった場合の処理方法としてどの様な物が考えられるか。
  |   先ず初めに、明示的な改行があった場合にはそのまま其処で改行してしまって良い。
  |   改行前の文字列の内容は前の行に表示し、改行後の文字列の内容は次の行に表示する。
  |   折り返しによって反転部分に改行が挿入された時の動作は微妙である。
  |
  |   a data [he][llo] presentation [eh/oll] (/ が折り返し改行挿入位置)
  |     (行毎に文字列の構造を管理し、表示内容は行分割してから方向を適用したものにする。)
  |
  |     行に入る部分までを一つの文字列の単位として切り、改行を挿入する。
  |     続きの部分はまた新しい文字列として開始する。
  |     この方法が一番単純であり実装に曖昧さが残らない。
  |     これだと外側の文字列に埋め込まれた部分文字列だという風に思うと不自然な結果になる。
  |
  |   b data [hello] presentation [ol/leh]
  |     (複数の行に跨って構造を管理し、表示内容は方向を適用してから行分割したものにする。)
  |
  |     外側の文字列に埋め込まれた形で行を構築して、その後で行を分断したという感じになる。
  |     しかし right-to-left の人にとって見れば読みにくい文章になるかもしれない。
  |     この方法だと改行に跨った領域に "文字列" が存在するという事を管理しなければならない。
  |     特に、後になって行を挿入したり行を削除したりした時に一体どの様に管理するのか謎である。
  |
  |     例えば文字列を構成するセルを一つずつ全て記録してリストにして保持するとする。
  |     - その時、最終的な結果を別の端末に転送する場合にはどうしたら良いのか。
  |       正しく転送する為には文字列を構成するセルの順序に従って端末内を
  |       色々に飛び回る様なシーケンスを生成する必要が出る。
  |     - ※例え文字列の内部で制御機能を呼び出す事が禁止されていたとしても、
  |       後になって行を追加削除したり文字を追加削除したり出来る様になっている以上は、
  |       "文字列" が連続になっている事は保証できないのではないかという気がする。
  |       或いは、挿入される行や文字は全て "文字列" の内部に追加されるという風に考えるのだろうか。
  |     - 然し、何れにしてもその様な実装は極めて不自然である。
  |       その様な動作を期待してそれに整合する様なプログラムを書くのは難しい。
  |       結局、多少動作が人間にとって不自然に思われても、
  |       曖昧さを含まない単純な規則で動作する様に実装しないと、
  |       アプリケーションプログラムを書くのが難しくなる。
  |       人間的に自然かどうかだとかそういった事に対して柔軟に対処するためには、
  |       そういったものは装置の側で対応するのではなくてアプリケーションプログラムの側で対応するべきである。
  |
  |     従って、この方法にするとしても開始点と終了点だけを保持して、
  |     それ以降に内部に行が挿入されたり削除されたりという事は気にしない様にするという手もある。
  |     つまり、開始点と終了点だけを素直に記録して、
  |     間に文字や行が挿入される場合には開始点と終了点も同じだけずらすという様な具合にしたらどうだろう。
  |     - しかし、色々と問題がある。例えば開始点と終了店の間で SCP をした時に行内容の位置がずらされるが、
  |       その時に、元々の文字列の内容があった領域は分断される事になる。
  |       間に新しく入った空白も反転の対象だと解釈すると表示が滅茶苦茶になり、
  |       SCP がどうのといった機能が効かなくなってしまうのでそれはない。
  |
  |   c data [hello] presentation [eh/oll]
  |     (複数の行に跨って構造を管理し、表示内容は行分割してから方向を適用した物にする。)

  色々に考えた結果、一定の結論を得た。
  この結論は 2016-10-04 の memo にまとめる。

  以上の事から "文字列" を管理するデータを行毎に管理する事にする。
  特に文字列を使用する事はそんなに多くない事から、実装の見通しが立ちやすい様なデータ構造を採用する。
  (開始点, 終了点, 方向) の三組を配列に格納し、未だ閉じていない文字列に関しては終了点に -1 でも代入しておく。
  implicit movement をしている限りは終了点の更新は行わない。


2016-09-27

* ECMA-48/9 の記述についてどうするか。 [#D0008]

  Control sequences や Control strings の中にある文字 (0xA0-0xFE) は、
  0x20-0x7E と同じに解釈しろと書かれている。しかし、これに愚直に従うと、
  Control strings で日本語などの文字列を送ることができなくなる。

  | というか、何故この様な仕様になっているかというと、
  | ECMA-35 (ISO 2022) に従って 7bit から 8bit に変換した時に、
  | GL に何を呼び出しているかに応じて変換後に 0x20-0x7E が 0xA0-0xFE に
  | map されてしまうという問題があるからなのだと思われる。
  | つまり escape sequences の内、CSI sequences や control strings は処理せずに、
  | ISO 2022 の sequences だけを実行してしまうことに問題がある。
  |
  | 例えばUTF-8 前提でやっている場合にはこの問題は起こらない。
  | あるいは ISO 2022 の sequences と CSI sequences
  | を同時に処理する場合にも問題は起こらない。
  | 然し、何処かに変な filter が入っていたりすると問題になる。
  |
  | 普通は端末とプログラムの間に文字コード変換が入ったりする事はない。
  | 問題になるとすればエスケープシーケンスを出力するプログラムの内部の問題である。
  |
  | | % 通常はエスケープシーケンスを出力する部分と、
  | | % 文字コードを変換する部分は分離されて設計されている。
  | | % 特にエスケープシーケンスを含む文字列を生成して、
  | | % それからそれをエンコードすると思われる。
  | | % UTF-8 にエンコードするという場合はどうなるだろう。
  | | % 多分受信側で先に UTF-8 をデコードするという仕組みにしている限りは何も起こらない。
  | | % では、ISO 2022 にする場合はどうなるだろう。
  | | % 先ず、制御文字の表現は決まっているので変な混乱は起こらない。
  | | % 一方で、0x20-0x7E が ISO 2022 を通した結果としてどの様に変換されるかは謎である。
  | | % もしかすると GR に割り当てられた上で 0xA0-0xFE というバイトで送られてくるかもしれない。
  | | % しかし、この場合は先に ISO 2022 から UTF-32 に戻してしまえば、
  | | % 結局元々の数値に戻るのでやはり問題は起こらない。
  | |
  | | つまり「送信側(アプリケーション)はエスケープシーケンスを生成してからそれをエンコードする。
  | | 受信側はUTF-32にデコードしてからエスケープシーケンスを解釈する」
  | | という取り決めにしている限りは途中の文字コードが ISO 2022 であろうと UTF-8 であろうと平気である。
  | |
  | | しかし送信側(アプリケーション)が通常文字列はエンコードしてから出力するが、
  | | エスケープシーケンスは直接書き込んでしまう、などという設計になっていると面倒だ。
  | | 受信側ではエスケープシーケンスと ISO 2022 のシーケンスを同時に処理する必要がある。
  | | その様にしておけば一応問題は起こらないのだろうと思われる。
  | | また UTF-8 だと 8bit C1 と UTF-8 を構成するバイトの区別ができないので死ぬ。
  | | ただ出力するエスケープシーケンスを 7bit C1 文字に徹していれば問題は起こらない。
  | |
  | | - gettext を使って国際化している場合などにはこれに該当すると思われる。
  | |   ただ、gettext で ISO 2022 を出力する際に毎回 GL を元の状態に戻すと思われるので、
  | |   先にデコードを実行してからでも問題は起こらない?
  | |   (そうでないと gettext を通さない英語のメッセージなどが文字化けしてしまう。)
  | |   UTF-8 の場合には 7bit エスケープシーケンスだけ出力する様に設計されていれば、
  | |   先にデコードして問題ない。8bit C1 を使っている場合にはそもそも論理的に
  | |   一意な切り出しが不可能なのでアプリケーションが壊れていることになる。
  | |   なのでそんなアプリケーションの事は気にしなくても良い。
  | |
  | | - gettext などは使わずに自前で文字列をエンコードしながら、
  | |   それでいてエンコード結果にエスケープシーケンスを挿入している場合は、
  | |   やはり問題が起こる。この場合は確かにエスケープシーケンスとデコードを同時にしなければならない。
  | |   しかし、そもそも stateful なエンコード形式を採用していながら、
  | |   そのエンコード結果を切り貼りする様なプログラムは壊れているとしか言いようがない。
  |
  | 以上の考察からまともな実装になっているアプリケーションの出力は、
  | 普通にデコードしてからその後で制御シーケンスの処理を行っても問題は起こらない筈である。
  |
  | もう一つの可能性は伝送路の途中に文字コード変換が挟まっている場合である。
  | この場合でもまともな設計のアプリケーションの出力する制御シーケンスならば、
  | 制御シーケンスは壊されずにちゃんと文字コード変換される筈である。
  | なのでこれも問題ないのではないかという気がする。
  |
  | さて、一方で気になる事もある。この ANSI (ECMA-48) が制定されたきっかけは、
  | 文字コードによってアルファベットなどの実際の数値が異なるので、
  | bit combinatinos (column/row) を用いて規格を記述する、という事である。
  | つまり、文字コードの変換をする前の生のバイト列に対して処理することを考えている。
  |
  | - うーん。プログラムを書く上では 'a' などと書くとそれがどの様にエンコードされるか (execution charset)
  |   が保証できないので危険で、だからこそ 0x61 などの様にして表現するわけだが、
  |   でもよく考えたら U'a' とか書いておけば済む話の様な気もする。
  |
  | これらの整合性については ISO/IEC 10646 に記述があるという事だった様に思うが
  | 一体どのようにしているのか実際に確かめてみる必要がある様に思う。
  |
  | http://kikakurui.com/x0/X0221-2007-01.html
  | [JIS X 0221/D.2.Note3] によると C1 の文字は U+0080 - U+009F を UTF-8 に変換した表現を持つとしている。
  | つまり、エスケープシーケンスを含んだ文字列を char32_t の列で作っておいて、
  | それをまるごとエンコードするという方式になっている。
  | [JIS X 0221/15] UTF-32, UTF-16 の時も同様のようである。

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそうしろと書かれている。
  それ以外の実装は駄目な実装なので気にしなくても良い様に思う。

  | しかし、ECMA-48/9 にある事を考えて、駄目なアプリケーションの為に
  | 途中で GL と GR が入れ替わったりする可能性を考慮に入れて、
  | CSI sequences だけは 0xA0-0xFE を受け入れても良い?
  | と思ったが例えばその後 UTF-8 に変換されたりすると、
  | 最早 iso 2022 でどの様な構成バイトを持っていたかの情報も失われてしまうので、
  | 下手に対応しないのが良い様に思う。
  |
  | うーん。改めて ECMA-48/9 を読んで見る。
  | 結局のところ iso 2022 の state に依らず同じ representation を
  | 制御機能に持たせたいが、その様にすると 7/8 bit 変換でぶれができるという事に見える。
  | そして実は iso 2022 の範囲内で扱っている限りに於いては 7/8 bit 変換のぶれは
  | 必ず GL/GR の入れ替わりしかないということが保証されているのだろう。
  | しかしそこに Unicode が入ってくると混乱が生じる。
  | Unicode から iso 2022 への変換は一意でない。
  | 同じ文字が複数の言語に含まれているかもしれないからだ。
  | だとすると GL/GR の文字化けは一旦 unicode にすると復元不可能という事になる。
  | というか文字化けとかそういうのに限らず、
  | "iso 2022 の state に依らず同じ representation になっている制御シーケンス" を
  | そのまま unicode に変換した時点で単射性が失われるので復元不可能である。

  ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、ECMA-48/9 の内容に対応する必要はない。

2016-09-24

* 取り敢えず 00/08-00/13 は実装しようと思ったが、ECMA-48 にある FF の説明が分からない。 [#D0007]

  screen では FF は単に無視される様だ。一方で ECMA-48/8.3.51 には FF は、
  列はそのままで、presentation component の中の次の form/page の
  page home position がある行に移動するという事になっている。

  然し、form だとか page とか page home position だとかは一体何なのか。
  仕方がないので ECMA-48 の初めの方の説明も見てみる事にする。
  presentation component だとか device (装置) について書かれているのは 6.1 である。

  | [ECMA-48/6.1.1, 6.1.3] presentation/data component とはそれぞれ行の集まりであり、
  | 行は文字を表示する位置の集まりである。
  | [ECMA-48/6.1.5] presentation が実際に表示される座標に関連する物であって、
  | data は内部的な座標に関連する物と考えれば良い。双方向 (bidi) の文字列表示に対応する為にある。
  | [ECMA-48/6.1.2, 6.2.4] presentation/data component はそれぞれカーソル (active position) を持つ。
  | active line/field/area/page はそれぞれカーソルが存在しているそれを指す。
  | [ECMA-48/6.1.5, 6.1.8] 両者のカーソルの位置は連動 (indirect movement) する。
  | [ECMA-48/6.1.6] 文字の挿入によるカーソルの移動は data component に作用する (implicit movement)。
  | [ECMA-48/6.1.7] 制御機能によるカーソルの移動は data copomponent もしくは
  | presentation component に作用する (explicit movement)。
  | 何れのカーソル移動の場合にも存在しない場所に移動しようとしたときの動作は処理系依存である。

  この説明の中で既に field/area/page などと言った定義の不明な語句が出てくる。
  もっと遡って調べる必要があるのか。最初の語句定義に色々載っていることに気付く。
  [4.2.7] Area: 範囲。連続する文字描画位置の集まり (必ずしも1つの行に含まれているとは限らない)
  [4.2.40] Field: ある tabstop から次の tabstop までの area (範囲)。
    但し、次の tabstop はその field には含まない。
  [4.2.56] Page: 連続する行の集合。
  [4.2.57] Page home position: presentation/data component の中でカーソルがそれ以上前へ動かせない位置。

  結局良くわからない。特に page が一体何なのかというのが分からない。
  というか出力のデバイスとして display または printer を想定するという事が書かれていたので、
  printer の場合には page というのはそのまま物理的な紙の事だと思って良いだろうか。
  だとすると、display を考える時には page という物を想定しなくても良いという事だろうか。

  改めて SPH/FF の説明を読んで見る。物理的な page だと思うとこの説明も納得が行く。
  page home position は紙を1枚送った後に何処にヘッドを置くのかという事に対応するのだろう。
  だとすれば display での自然な実装は、clear screen してから
  SPH の設定した位置を含む行に移動するという事だろうか。

  - ところで screen で試してみたが SPH にも対応はしていない様だ。
  - 次に xterm で試してみた所 FF は VT と同じ役割を持つ様に設計されている様だ。
  - mintty は xterm と同じ動作だ。
    沢山の機能を実装している RLogin はどうだろう→RLogin も xterm と同じく VT で実装している。
    SPH 等には対応しているのだろうか→対応していない様だ。
  - 更に RLogin の説明を読むと LF/VT/FF は全て同じ動作をする様だ。
    また LF で CR LF の動作になっている様に見えたのは仮想端末が LF を CR LF に翻訳しているからの様だ。
    基本的には全て VT の動作を行う。そして Mode 20 LNM でその動作を変更する事ができて、CR LF と同じ効果にできる。
  - これについて xterm でも確認を行ってみたが、やはり同様に LNM で VT/FF/LF の全てが影響を受ける様だ。
    また、何れも SPH 及び FF のそれっぽい実装には対応していない様だ。
    様々な端末における動作がよく分からなかったので包括的に調べる事にした。

  | 調査方法
  |
  | $ stty nl; printf '\e[20hhello\nworld\n\e[20lhello\nworld'
  | $ stty nl; printf '\e[20hhello\vworld\n\e[20lhello\vworld'
  | $ stty nl; printf '\e[20hhello\fworld\n\e[20lhello\fworld'
  |
  | - 仮想端末が勝手に \n を \n\r に変換しない様に設定する必要がある。
  | - Mode 20 LNM が設定されているかどうかで振る舞いが変わる。
  | - 更に現在位置が最終行かどうかで振る舞いが変わりうる。
  |   次の行を追加するかどうかで実装にぶれがある様だ。

  結果は gh-pages branch の escseq.html にまとめた。

* これから本格的に端末の機能を実装していこうと考えている。 [#D0006]
  しかし、多少プログラムが長くなってきたので再度構造を考えてからにする。

  window 自体はできるだけ plain な構造体にしたい。
  端末自体は window とは独立に "window を書き換える者" として実装したい。
  また window の描画先は "window の中身を写す者" として実装したい。
  つまり受動的なオブジェクトとして描画先を定義するのではなくて、
  能動的に window の中身を見て描画を行うのである。

  window を書き換える者の名前は何にしようか。案としては
  controller, painter, writer, layouter, application,...
  writer や application は一般的すぎる気がする。
  layouter は何か違う気がする。painter にすると、
  window を実際に描画する者の方は一体何になるのかという問題がある。
  controller も少々一般的というか余りしっくりと来ない。
  window を碁盤か何かと考えれば player と observer がいい。
  或いは window も board か何かに改名するか。
  (しかし、"player" はまた別の意味にも取れるかもしれない。)
  →取り敢えず各クラスの名前を変更する。

  出力に関しては現在は全体を出力する様になっているが、
  これは勿論効率が悪い。dirty section を管理する様にしなければならない。
  しかし一つの window に複数の observer がくっついている場合には、
  全ての observer で同じタイミングに同じ範囲を反映する様にするか、
  もしくは各 observer 側で dirty section を管理しなければならない。
  一つの window の履歴から各 observer の中で dirty section を再現するのは困難である。
  各セルについて version 番号を保持するという手もあるが効率的ではない。
  また、行の移動なども追跡したい。
  という訳で、やはり実際に window を変更するのと同時に dirty section を更新するしか無い。
  従って、実際の実装では (dirty section 情報を書き出すオブジェクト) を用意して、
  observer が自分の中に保持しているそれを、window の内部にあるリストに登録し、
  window は自分の状態が変更される度にそのリストにある dirty section オブジェクトの更新を行う、
  という仕組みにするのが良いのではないかと思う。

  何れにしても、出力部分を後で処理する事にする。
  それよりは先に実装するべきは player の方である。
  受け取ったバイトに応じて制御機能を呼び出すのである。
  また同時に UTF-8 のデコードも行いたい。
  一番初めに実装するべきは何か。UTF-8 のデコーダか。
  何でも良いから早く動くようにしたいという意味では、
  普通にバイトを受け取ってそれを書き出すという風にすれば良い。
  現在の put_char 関数を拡張する形で良いのではないだろうか。
  取り敢えず出力部分に関しては別のファイルに分離するか。

* is_ideogram_exclusive が使われていない -> fixed [#D0005]
* 49 が無駄に出力されている? -> fixed [#D0004]

2016-09-23

* 仮想端末の作り方については確か POSIX にサンプルコードが載っていたはず。 [#D0003]

  [[posix_openpt>http://pubs.opengroup.org/onlinepubs/9699919799//functions/posix_openpt.html#]] これ。

  ポーリングは O_NONBLOCK にするのが楽?
  [[ファイル入出力の基本 (IO モデル) を勉強する - フリーフォーム フリークアウト>http://d.hatena.ne.jp/cou929_la/20121103/1351950688]]

  あと exit とか _exit とか _Exit とか色々あるけれど何だったか。
  [[_Exit>http://pubs.opengroup.org/onlinepubs/9699919799/functions/_exit.html]]
  [[fork - Wikipedia>https://ja.wikipedia.org/wiki/Fork]] たぶん _exit でよい。

  一応何か起動した。
  bash: cannot set terminal process group (2692): Inappropriate ioctl for device
  と出るので子プロセスで setsid() しなければならない。

  さて、次に仮想端末の設定が変だ。どうも親プロセス側の仮想端末の設定がいけない様だ。
  (というか bash 側は bash 側でなんとかしているはずだ。)
  と、色々試行錯誤した後で以下の親切なページを見つけた。

  [[PTY を使ってシェルの入出力を好きなようにする - Hika Hibariya>http://note.hibariya.org/articles/20150628/pty.html]]

  簡単にできた。色々調べたりしながら分かった setsid や dup2 のことも全て書かれていた。
  初めから此処を見ていれば余り悩むこともなかった (然し理解が浅いままだったかもしれない)。
  あと、終了時に念のため子プロセスを kill しておくようだ。
  と思ったらこれらの事は詳細UNIXプログラミングという本に書かれている様だ。

2016-09-20

* バッファのデータ構造 [2016-09-19] [#D0002]

  行の管理

    行の管理はB木が良い様に思われたが、世の中にはスキップリストというデータ構造もある様だ。
    平衡を保つ仕組みは複雑になりがちだがそれから開放されるというのが売りの様である。然し実際の所どうなのだろう。
    Wikipedia によるとやはりリスト構造であるが故に遅いという様なことが書かれている。
    もっと調べると、M分木にすればB木だと logN/logM になるが、
    スキップリストだと M logN/ logM になるとある。考えてみれば確かにそうだ。
    連続添字の配列として使う場合は、赤黒木よりは良いけれど B 木には及ばないという所ではないか。
    しかしながらスキップリストには、アルゴリズムが簡単なお陰で並列処理・非同期処理などで分がある様だ。
    しかし、もし一旦画面の外に出た部分で内容の更新が起こらないのだとすれば、
    わざわざB木にしなくても単なる配列(or linked array)で良い。
    表示領域の高さは精々数百行なので挿入などは大したことない。

  文字の管理

    % 文字の管理はどうするのか悩ましい。
    % 一つの方法は列数と同じ要素数の配列を用意して、
    % その文字が表示される位置に文字を書き込むというものである。
    % しかしそれだと grapheme clusters に対応するのが苦しい。
    % 外字的な取り扱いにして新しい種類の clusters が来る度に登録を行うという手がある。
    % メモリリークを防ぐためには参照カウンタ方式にでもするか。
    % 遅そうではあるが、普通の文字を扱っている分には overhead がないというのは良い。
    % 一方で、proportional な font を許すような terminal を考えるとこの方法は苦しい。
    % (そもそもそんな物があるのか分からないし、あったとしても各文字の幅や
    % kerning などをどの様に取り決めておくのかという大きな問題がある。
    % 取り決めをしておかないと表示が乱れることになる。)
    %
    % 或いは、初めから可変長な文字の存在を受け入れて、
    % 要素が可変長な配列みたいな構造にしてしまうという手もある。
    % メモリ的にはこれが最もコンパクトである。UTF-8 を使うことにすれば
    % 通常のアルファベットを扱っている限りは各文字 1B しか消費しない。
    % 但し文字幅などの補助情報を持たせるとすると結局 2B になるか。
    % この時の問題はその様なデータ構造は前代未聞なので効率良い実装が可能なのかという事である。
    % 特に index を指定した時に対応する cluster を特定するのに必要な補助情報と計算時間である。
    % 補助情報が一切ないと先頭から順に文字を区切って行かなければならず不毛である。
    % 一応 B 木の各節で、下にぶらさがっている cluster の数を保持しておけば大分ましになる。
    % 問題は B 木の葉である。一つの方法は 1 cluster 1 byte の配列 (A) と、
    % 実際の文字の羅列を記録した配列 (B) の両方を保持して、
    % (A) に (B) 内での index を記録する方法である。
    % 然し、この方法だと単一の grapheme cluster の合計サイズに制限がかかってしまう。
    % また、その葉に含まれる全データサイズにも制限がかかる。
    % しかし、B木の容量を要素数ベースではなくデータ量ベースにするという手もある。
    % 更に一つの cluster が複数の葉に跨る事も許すことにすれば良い。
    % しかし効率の面から言ってこの方法は本当に得策なのか。
    % そもそも端末画面の横幅というのは上限がある。
    % 1行の文字数に制限のないエディタを作るのでないかぎりはB木にする必要もない。
    % また、端末での操作は基本的に挿入ではなくて上書きである。
    % なので各配列要素が各列に対応する様な設計の方が自然である。
    % やはりその様な側面から考えてもB木にするのは大げさである。
    %
    % やはり struct { char32_t ch; int32_t flags; } の配列のような構造にするのが無難だろうか。
    % しかし大抵の場合アルファベットの plain な配列だという事を考えるとこの表現はやはり無駄が大きいように感じられる。
    % この構造をベースに考えて、より効率化するという方向で考えられないだろうか。。
    % 例えば普段は char 配列で考える事にして、unicode 文字等の場合には何らかの特別な文字を使う。
    % そして unicode 文字本体の情報は別の所に格納する。
    % しかし何処に格納するのか? 格納位置を直接表現しようと思えば sizeof(void*) のデータが必要であり、
    % これだとそもそも char32_t と同じ大きさになってしまう。
    % だからと言って char の 128-255 の値を index に使おうと考えれば 128 文字しか unicode 文字を扱えない。
    % 或いは、128文字ごとに buffer を切り替えるというのも手なのかもしれない。うーん。
    % 然しそれだと初めから char32_t*128 の領域を確保しておくのと較べて得しているのかどうか怪しい。
    % 何より大量の文字が流れている場合、結局最終的に char32_t*画面の広さ 分だけの領域を確保する事にもなりそうである。
    % その場合には、初めから char32_t で全部領域を確保しておけば良かったという結論になりそうである。
    % 計算してみると、例えば sizeof(char32_t)*210*80 = 67.2 KB である。
    % 全部 char で済んだとしても 1/4 になるだけである。何かどうでも良い気がしてきた。
    % 実際に動いているプロセスを見ると普通に MB 食っている。
    % 16bit マシンならば 64KB もしくは 32KB に収めないといけないのかもしれないが、
    % 実のところその様なマシンで動かそうと思ったらプログラム自体をコンパクトにせねばならずそちらの方が問題だ。

    結局、char32_t ch の単純な配列で管理するのが良さそうだ。
    余計にメモリの確保解放を繰り返さない為には、初めから領域と同じ大きさの配列にしてしまう。

    Grapheme cluster は上限の大きさを決めておかないと攻撃が可能になってしまう。

  属性の管理

    さて次に考えるべきは属性をどの様に管理するのかという事である。
    実際の使用される状況を考えると、以下のことが言える。
    - 多くの場合は属性は設定されない。特に大量のデータを出力する場合。
    - 属性が設定されているとしても各文字ごとに設定されることは少なくて、
      連続する文字は完全に同じ属性を持っている可能性が高い。
    - colorful な実装にするにしても xterm 256color までが普通で、
      24bit color 等を出力する様なプログラムは稀である。
    勿論、これに反する様ないじわるなプログラムも作ることはできるが、
    上記の様な状況に対して効率の良いような実装にしてしまっても問題ないと思う。

    どのようにするのが良いか様々な実装について考えてみる。
    一番単純な方法は文字のデータと一緒に管理するという物である。
    しかし、実際に描画する時には一文字ずつ属性に応じて描画するというのは効率が悪い。
    普通は同じ属性の物をまとめて描画するという様にする筈である。
    実際に描画を行う場合には属性が連続しているかどうかを確認して出力を行うことになるだろう。

    もう一つの方法は Poderosa で使われている方法である。属性オブジェクトへのポインタを各セルに保持しておいて、
    描画する際の同じ属性の連続かどうかの判断はポインタが一致するかどうかで判定するという方法である。
    しかし、これが本当に効率的なのかどうかは怪しい。先ず、単に文字を描画すると言っても、
    複数の段階がある。まず初めに背景画像を描画し背景色があればそれを描画する。その後で文字を描く。
    各ステップで使用される属性が異なるので同じ属性が連続しているかどうかの判定も、
    属性オブジェクトをひとまとめにして行うのではなくて、
    関連のある属性のみに絞って連続しているかどうか判定した方が良さそうな物である。
    また、属性オブジェクトの確保・解放などの操作にもコストがかかる様な気がする。
    基本的な属性に関して言えば十分 32bit におさまるので
    32bit/64bit のポインタで属性オブジェクトを参照する方が余程メモリを食う。
    Poderosa の方法だと拡張性が高いのは良いが効率面で余り良くないだろう。

    あるいは Poderosa の様に属性オブジェクトを作るまでではないが、
    属性に変更があるという意味のフラグを char32_t の内部に置いて
    (unicode はどうせ 10FFFF までなのでフラグを幾つか設置する自由はある)、
    別の箇所に属性データを記録するという風にすることも可能だろう。
    しかし、その場合属性データはどの様に保持するべきだろう。
    属性に変更があったかどうかのフラグだけでは属性データに対する参照にならない。
    一つの方法は配列にして適用対象の文字と同じ位置に属性データを格納する事である。
    しかしこの方法だと初めから文字と一緒に属性データを記録するのとメモリ効率的に変わらない。
    逆にメモリの管理や参照が複雑になるだけで意味がない。
    もう一つの方法はハッシュテーブルや平衡木などを用いて sparse な map にするという物である。
    これならばメモリを節約できる。しかし、そこまでする程の事なのかという疑問が残る。
    特に高が属性を参照するのに一々毎回複雑なデータ構造を辿るというのは非効率的に思われる。

    結局、基本的な属性の範囲であれば文字のデータと一緒に固定長で管理をし、
    特別な種類の属性を含む場合にはそれを示すフラグと拡張属性データの index を埋め込む。
    拡張属性データは別の一つの配列に入れておいて管理すれば良い。
    同じ属性が連続して続く場合を考えれば拡張属性データは複数の文字から参照できる様にして、
    また参照カウントを用いて管理するのが良いだろう。

    基本的には各セル struct { char32_t ch; uint32_t flags; }; を保持する。
    基本的な属性に関しては flags に格納する事にして、
    特殊な属性を含む場合には或るフラグを立てておく事にする。
    そのフラグが立っている場合には、別に持っている拡張属性データ用配列にデータの格納を行う事にする。
    拡張属性データの配列要素は、参照カウントと基本属性と更に拡張属性データへのポインタを持つ。
    char32_t ch に収まらない様な unicode grapheme clusters についても同様に処理を行う。


  他に必要なデータはあるか

    他の実装も確認してみる。

    yaft.h を見ると、先ず気づくのは文字データは一つのオブジェクトとして生成し、
    セルはそこへのポインタを保持する。更にセルは uint8_t fg, bg と、
    enum char_attr attribute と、それから width まで保持する。
    加えて sixel support としてセル内部に bitmap データまで持つ
    (これはセルのサイズが固定だからできる事であろう)。
    yaft の目的上、メモリ使用量の上限が分からない動的なメモリ確保ではなくて、
    使用メモリ量の計算がしやすい固定的な割当になっているという事だろうか。
    また、glyph に関してはビットマップに結びついているので、
    予め用意された文字しか扱えない。当然、grapheme clusters に対応しているとは思われない。

    struct cell_t {
        const struct glyph_t *glyphp;
        struct color_pair_t color_pair;
        enum char_attr attribute;
        enum glyph_width_t width;
        bool has_bitmap;
        uint8_t bitmap[BYTES_PER_PIXEL * CELL_WIDTH * CELL_HEIGHT];
    };

    sixel もしくは端末の特定の領域に設置される挿入オブジェクトを管理できる様にしたい。
    当初は属性データに持たせる事を考えたが、属性データは複数の文字で共有されるという性質があり、
    しかし一方で挿入されるオブジェクトは或る位置セルに紐付けて管理した方が良い気がする。
    あるいは領域に属する全てのセルで共有しても良いが、何れにしても属性と同列の物ではない気がする。
    だとすれば flags とは別に更に拡張可能なオブジェクトを設定するべきか。
    もしくは grapheme clusters の別種として管理するべきか。それが良い気がする。
    例えば sixel オブジェクトと文字を両方保持しなければならないという事はなさそうに思われるし。

    tmux.h を見るとどうやら文字データは UTF-8 で保持している様だ。
    5 bytes で属性・フラグ・色・幅・UTF-8の長さを持つ様だ。
    不思議なのはこの実装も "幅" を保持している事である。
    幅なんていう物は右のセルに続いているかどうかだけ見れば良い気がするのだが。
    文字のデータには 9 bytes 使っている。そんなに使う文字は存在していただろうか。謎である。
    特定の grapheme clusters だけは扱える様にしているのかもしれない。

    #define UTF8_SIZE 9

    struct grid_cell {
            u_char  attr;
            u_char  flags;
            u_char  fg;
            u_char  bg;

            u_char  xstate; /* top 4 bits width, bottom 4 bits size */
            u_char  xdata[UTF8_SIZE];
    } __packed;

    screen については何処に定義があるのだろう?? image.h の struct mchar, mline?
    どうも screen がどういう処理方法になっているのか色々見ても見えてこないが、
    取り敢えずそれっぽいものはこれしかない。
    文字に関しては恐らく image と mbcs に分割して格納されている。
    ASCII の範囲内であれば image で、そうでなければ mbcs に続きが格納されるという事だろうか。
    他に色と属性とフォント(?)がある。./configure --help を見たがフォントが何か分からなかった。
    面倒なのでこれ以上は深追いしない。しかし前から思っていたがやはり screen のソースコードは汚い。

    struct mchar {
             unsigned char image;
             unsigned char attr;
    IFFONT(  unsigned char font; )
    IFCOLOR( unsigned char color; )
    IFCOLORX(unsigned char colorx; )
    IFDWCHAR(unsigned char mbcs; )
    };

    struct mline {
             unsigned char *image;
             unsigned char *attr;
    IFFONT(  unsigned char *font; )
    IFCOLOR( unsigned char *color; )
    IFCOLORX(unsigned char *colorx; )
    };

    mintty は term.h に一連の定義がある。
    mintty の構造は他のプログラムに較べてよく考えられた構造になっている。
    綺麗だ。他のプログラムが俄然ごみの様に思われてくる。詳しく見てみる事にする。
    - 気付く事は、色は初めから true color 前提で書かれている。
      256色前提の場合パレットを変更した時に既に表示した文字の色も変わってしまうので、
      理想的にはパレットの変更に追随させておけば背景黒と背景白の切り替えなどをしても見にくくならない、
      等の利点があると考えられるが実際にはそううまくは行かない。
      複雑な出力や様々な色を表示するプログラムの場合、パレット変更は普通は想定しない。
      パレットが変更されたときのことまで考えて設計するのは困難な為である。
      それを考えると true color 前提で書いた方が本当は良いのかもしれない。
    - もう一つ気になるのは grapheme clusters の取扱である。
      複数の文字が一つのセルに含まれる場合には、
      各文字毎に 文字&属性&cc_next(=リスト用) を保持する様になっていて、
      更に、同じセル内の次の文字 cc_next は相対位置で表現している。
      配列中で未だ使用されていない文字は termline::cc_free を先頭として、リストで管理している。
      よく考えられた設計である。気になるのは combining characters が沢山来て、
      行内の文字数が SHRT_MAX を超えた場合に何が起こるのかという事である。
      ちょっと見た所、何も対策がなされていない気がするがいいのか?
      後、相対位置にする意味があるのかというのも可也謎である。
      というか相対位置にしていると行内の文字を削除して
      切り詰める時に余分な操作が必要になってしまう気がする。
      もう一つは文字を格納する領域を行単位で管理している事である。
      これだと部分スクロールなどをする場合に文字の移動と一緒にリストを再構築しなければならない。
      一方で利点もある。行の生成・削除が簡単だという事である。
    - また sixel に関しては特殊な文字コード 0xFFFC で表現している。
      恐らく文字がこれになっている場合には其処には文字ではなくて画像が入るという事なのだろう。
      これの意味する所は端末の文字サイズ拡大縮小に際して
      埋め込み画像のサイズは一緒に大きくなったり小さくなったりするという事である。
      しかし下手に埋め込み画像をピクセル単位にしてレイアウトが変わったりするよりは、
      出力したときの領域をそのままに画像も一緒に大きくなったり小さくなったりするのが自然である。
      また U+FFFC は OBJECT REPLACEMENT CHARACTER で place holder の役割のある Unicode 文字の様だ。
      画像本体はどの様に管理しているのかと思ったら struct term の中に保持している様だ。
      恐らくこの中に画像の表示位置などの情報も含まれているのだろう。
    - 属性も様々な属性がある。
      bold dim underline italic reverse invisible blink
      doubleunderline overline protected wide/narrow/expand
    - temp_strage_t は temp_storage_t のつづり間違いではないだろうか。

    typedef struct {
      unsigned long long attr;
      uint truefg;
      uint truebg;
    } cattr;

    typedef struct {
      short cc_next;
      wchar chr;
      cattr attr;
    } termchar;


  結論

    エディタとデータ構造を共有する (エディタにも転用可能にする) のであれば、
    巨大なファイルに対して行の挿入などがスムーズにできる様に B 木にする。
    また、proportional なフォントに対応するために列と配列要素を対応させる構造は使えない。
    ファイルへの書き出しが楽になる様にするためには、
    ファイルに書き出すデータをそのまま保持するようなデータ構造の方が良いかもしれない。

    しかし terminal 専用に設計するのであればより簡単な実装になる。
    流れたデータは単に末尾に追加可能な配列に溜めれば良いし、
    行のデータも長さ決め打ちで良い。
    端末の領域と同じサイズの単一のメモリ領域でも allocate すれば良い。
    効率を考えれば terminal 専用に設計して、特殊な機能に関しては例外的な方法で処理するのが断然良い。

* 名称 [2016-09-18] [#D0001]

  [議論]

  名称を決めよう、と思うが良い名前は何だろう。
  変に凝った様な名前は嫌なので短いのが良い。でも他とは被りたくない。
  混同しやすいようなものや検索しにくいものも万一のため避けたい。

  暫定的に tty1 (単に tty の初めての実装ぐらいの意味) としたが、
  これは既に /dev/tty1 と被っていてよくない。それに version 番号をつけにくい。

  端末の名前といえば、*term *tty などが多い。
  この系統にするとしたら一文字入れるのが良い。
  然し未だ使われていないものが良い。
  - xterm は言うまでもない。
  - iTerm は Mac 用の物。
  - aterm はルータの製品名に使われている。
  - atty は isatty を思い出す。isatty は何の略だろう。"is a tty" ということか?
  - stty は仮想端末の設定を行うコマンドである。
  - RTTY とはアマチュア無線×TTYのこと??
  - VTTY というのも既にあるようだ。

  関連して pseudo-terminal を pty としたりする様だが、
  それだと pseudo-typewriter にならないか?
  それに、近くにあるコンソール tty に tele という語句が入って、
  遠くにあるリモートに繋がっている pty で tele が抜けていることになり妙だ。話がそれた。
  何れにしても ty だけを取るというのも手なのである。
  - mty とか vty とか…? 三文字だと流石に既存のコマンドなどと被るだろうか。

  screen 系列で行くと
  - 例えば tmux がある。これは terminal multiplexer の略である。
  - また、byobu というのもある (単なる設定集の様な物だが)。
    これは screen の言い換えだ。

  contra

    ふと昔書きかけたプログラムの事を思い出した。contra という名前だった。
    エスケープシーケンスを翻訳して TERM に応じた出力に変換する為の物である。
    もしくは Windows のコンソールに対して出力を行ったりもできる様にするという目的だった。
    これと合流するのが良い考えである様に思う。
    名称も contra に変更する。

    というのも今回のプログラムの構想としては、

    1 端末の内部状態と描画部分を分離する
    2 描画部分は "他の端末に対する制御シーケンス" だったり、
      あるいは "GUI ウィンドウに対する描画" だったり、
      容易に切り替えられる様にする。
    3 端末の内部状態に対する操作は、
      "プログラムから直接操作" したり、
      "制御シーケンスを解釈して操作" したり
      色々切り替えられる様にする。

    ということであったが、一方で contra は制御シーケンスの解析
    と制御シーケンスの解釈部分を分離して、
    制御シーケンスの適用先をまた別の端末にしたり、
    或いは Windows のコンソールやその他の GUI Window にしたりという事だった。

    これらは容易に統合してより機能を綺麗に整理する事ができる。

    - icontrol_function_processor

      制御シーケンスからデコードされた制御機能の呼び出しを処理する。

      実装として二通り考えられる。内部端末に対する操作を行うもの。
      それから他の端末に対する制御シーケンスを生成するもの。

      - tty_writer: icontrol_function_processor を実装

      - window_writer: icontrol_function_processor を実装

    - tty_reader

      制御シーケンスを解釈して icontrol_function_processor を操作する。

    - iwindow_target

      window の内容を表示・出力するための物。様々な実装が考えられる。

      - tty_target

        m_proc = icontrol_function_processor に対する操作として実装する。
        特に m_proc が tty_writer の場合には端末に対する出力になるし、
        或いは window_writer の場合には window の簡易複製になる。

      - x_target
      - gdi_target
      - console_target

        様々な GUI interface やコンソールに対する描画として実装しうる。

    以上を組み合わせれば様々なプログラムを容易に実装できる。

    - 例えば、tty_reader -> tty_writer を組み合わせれば、
      制御シーケンスの翻訳として動作する。

    - 或いは、tty_reader -> window_writer -> tty_target を組み合わせれば、
      screen の様なことができる筈である。

    - もしくは tty_reader -> window_writer -> x_target とすれば、
      新しい terminal emulator を実装できる。
      特に、様々の target を実装するだけで様々な環境に移植できる。

    さて、ここまで考えたのはプログラム→端末のデータの流れについてであるが、
    逆に端末→プログラムのデータの流れ (主にユーザの入力操作) についても
    同様に綺麗に扱うことができる。

    - キーシーケンスの解釈部: キーシーケンスを操作のイベントの列にする。
    - イベントの列を処理する部分:

      例えば、直接ここにプログラムを実装してしまっても良いだろう。
      或いは、また TERM に応じたキーシーケンスに翻訳しても良い。

  [結論]

  contra にする。更に、元々 contra という名前で書いていたコードと順次統合する。
