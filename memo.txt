# contra dev note


------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

2018-02-19

* データの表現方法

  行内の文字ではなくて行内の各文字位置(半角)に対して board_cell を保持する。
  board_cell は二つのメンバを持つ。

  - character_t character (32bit)
  - attribute_t attribute (32bit)

  character は character_flags と文字コードのビット和になる。
  character_flags として何も指定されていない時、値は Unicode である。
  character_flags として is_wide_extension が指定されている時、
  その領域は半角よりも大きな幅を持つ文字の余白である。

  is_wide_extension は一定の大きさの文字を格納する時に
  各セルに対応して board_cell がある。


2016-10-11

* 全角文字の取り扱い

  - ECMA-48/6.1.6/2 暗黙的移動 (文字挿入に伴って起こる) によって現在記憶位置は一つ次の文字位置に移動する
  - ECMA-48/6.3/3 行は予め決められた数の文字位置からなる
  - ECMA-48/6.3/5 文字位置の大きさは其処にある文字に依存しても良い

  これらの記述を総合するに、ECMA-48 では全角文字は複数の文字位置を専有するとして実装されるのではなく、
  文字位置自体の幅が大きくなって実装されるという想定の様である。しかし、この仕様は現実の実装と異なる。
  更に、行に含まれる全角文字の数に応じて各行の大きさが異なるという事になるし、
  また、CUU CUD CUB CUF などの制御機能でどの様にカーソルが移動するかを計算するのが困難になる。
  contra では ECMA-48 に従った実装は行わず、現実の端末と同様の方法で全角文字を取り扱う。

2016-10-04

* 方向付き文字列 (SRS/SDS string) の取り扱い

  0 文字列の定義によって記憶部上の文字の配列に影響は出ない様にする。

    # これは双方向に対応していないアプリケーションでアラビア語や
    # 双方向制御を含む Unicode 文字列を取り扱っても問題が生じない様にする為に必要である。
    # それに記憶部ではできるだけデータの受信順序を保ちたい。

  1 記憶部で文字列の開始終了の情報を記録・管理し、
    これらの情報から一意的に表示部での配列を再現できる様にする。

  2 行にまたがる文字列構造は管理しない。
    受信したデータの中に改行が含まれている場合や、折り返し処理によって行が分割される場合、
    一旦文字列を全て閉じて改行してから再び文字列を開いたかの様に動作する。

    # 理由は複数ある。
    #
    # + [明示的な改行との取り扱いの一貫性]
    #   明示的な改行が含まれている場合は改行前の文字列は前の行に、
    #   改行後の文字列は次の行に表示する。
    #   行折り返しによる暗黙的な改行も同様に取り扱うべきである。
    #   そうしないと暗黙的な改行が挿入された後に、
    #   再度その内容を別の装置に転送する時に、
    #   文章の順序が保たれなくなってしまうからである。
    #
    #   ※暗黙的な改行を区別して記録すれば良いという意見もあるかもしれない。
    #     しかし、様々な制御機能を経た後にそれが意味論的に
    #     まだ暗黙的改行として扱ってよいかなどを決める規則は難しい問題である。
    #     それに暗黙的な改行を区別する為のデータ表現も色々考えると難しい。
    #
    # + [行毎にSCPした時の取り扱い]
    #   行毎に SCP で character path を切り替える事ができる。
    #   例えば SRS 文字列が複数の異なる character path を持つ行に跨っていた場合に、
    #   どの様にその文字列の "範囲" を表現するのかや、
    #   それをどの様に整合的に表示するのかなどに曖昧な点が生じる。
    #
    #   例えば、文字列の各行に含まれる部分を切り出して一つの文字列としたのと
    #   同様に表示するという取り扱いにするのが自然だろう。しかし、
    #   その様に取り扱うのであれば、初めから各行毎に文字列を分割して管理したほうが良い。
    #
    # + [SCP による複数行表示との一貫性]
    #   例えば単に複数行のアラビア語を表示するとして、
    #   SCP を使用して出力する場合と、出力文字列全体を SRS で囲む場合を考える。
    #   前者では次の行は前の行の下に表示される。
    #   後者でも次の行は前の行の下に表示された方が動作として一貫している
    #   (それに読みやすさの観点から言ってもその方が良い)。
    #
    # + [行内での完結]
    #   表示する際に文字の並び替えは行内で完結していたほうが取り扱いやすい。
    #   ある所に表示する内容が別の行に含まれるというのは始末が悪い。
    #   それに座標の計算をする際に考慮に入れるべき範囲の長さに上限がなくなるので、
    #   そういう意味でも複数行に亘る文字列というのは都合が悪い。

2016-09-27

* ECMA-48/9 には対応しない。

  [2016-09-27 の考察の結果を抜粋する]

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそういう前提の内容がかかれている (15 および D.4.Note3)。
  それ以外の実装は駄目な実装なので気にしなくても良い。

  もともと ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである (ECMA-48/1)。
  意図的に 10/00 - 15/14 を使って制御シーケンスを記述するための物ではない。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、そもそもの前提が崩れるので、
  ECMA-48/9 の内容に対応する必要はない。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2019-04-11

2019-04-10

* どの段階で term.initialize_line(line) が適用されるべきか不明瞭である。
  一番最初に何らかの編集が行われる時?
  それとも一番最初にカーソルが移動した時?
  或いは一番最初に画面に現れた時?
  或いは始めてタブなどが実行されて情報が必要になった時かもしれない? うーん。

* TSM for DL IL
* ERM for EA, ECH, ED, EF, EL
* SEE for DCH DL ICH IL
* DECSTBM と IL DL 等の関係を調べる

* sequence: 制御列などは最大長さを設定しておくべきでは
* sequence: 中に規格外の文字列が入っても許容する設定があっても良いのでは

* emacs を起動してみると凄い勢いで
  DECSTBM (set scrolling region) を実行している。
  つまり DECSTBM に対応した方が良いのでは。という事。

* DECSCA ... これは描画属性に含めてしまって良い気がする。
  DECSC,DECRC で一緒に復元されるとの事なのでそういう実装なのだろう。

2019-04-08

* ansi: 思ったのだが marker と通常の文字を区別する意味はあるのだろうか。
  表示する時に出力されるかどうか?
  文字幅が0かどうかの違いしか無い様な気がする…。
  例えば bidi の制御文字に関して考えると、
  正しくレンダリングされる為にはやはり制御文字も一緒に表示する必要がある。
  という事などを考えるとやはり通常の文字として埋め込んでしまう方が良いのでは…。

* ansi: 結合文字について
  やはり screen と Poderosa で振る舞いが異なる。
  というか UTF-8 ではない文字列が送られてくる様になる。

* attribute だとか character の拡張機能はどの様に処理するべきか。

  * 拡張オブジェクトの寿命管理はどの様にするのが良いか

    | attribute や character のコピーコンストラクタ等に処理を追加してしまう事にするか。
    | そうすると書き込みや読み込みなどの際に毎回チェックが入る事になり重い気がする。
    | 勿論、殆どの場合には拡張はないので if でフラグを検査するだけではある。
    |
    | 或いは、cell の側にオブジェクトなどを保持する為のポインタを設置するべきか。
    | 特に文字に関してはそちらの方が良い様な気もする。
    | "文字" というスカラー値でオブジェクトを運搬できる様にする必要性など実はないのである。
    | 然し、そういったオブジェクトの寿命は誰が管理するのだろうか。
    | 特に複数のセルで使い回されている時にどうするのか。
    |
    | 様々の事を考えると実は character に持たせるのではなくて
    | セル側に持たせるほうが自然に思われてくる。
    | 然し、一方で巨大な attribute をコピーする理由は何だろう。
    | attribute はそう頻繁に変更する物でもないし、
    | コピーして持ち回るほうが普通なのではないか。
    | Poderosa の場合には GC があるので自由にコピーして良かった。
    | C++ で実装する時にはどうするのが良いか。
    | よく考えたら C# で GC に頼っているのであれば、
    | C++ でも同様に実装しても良いのではないか。
    | つまり、"時々" 全体をスキャンして使われていなない属性を破棄するという事。
    | しかし、時々というのはどのタイミングだろうか。
    | 更に sixel 等の巨大なオブジェクトの場合には時々ではなくて、
    | やはり消滅する時にちゃんと始末しておきたい所である。
    | うーん。何とか全体をスキャンするコストを抑えつつ、
    | 参照カウントの更新の様な煩わしさを避けつつ、
    | という様にする事はできないだろうか。
    |
    | 例えば、画面の見える領域に関しては全体をスキャンする事にして、
    | そしてそれ以外の領域に関しては参照カウントで対処する等。
    | うーん。それが良いような気がする。
    | 画面の見える領域に関しては root オブジェクトとして取り扱う。
    | 画面から出ていった領域に関しては行を登録する時と、
    |
    | 行を削除する時に参照カウントを更新する事にする。
    | 以前の取り扱いよりも更に複雑になった気がしないでもないが、
    | まあ、この様にする位が高速で良いのだろうという気がする。

    画面の見える領域については参照カウントはしない。
    GC をする時に全体をスキャンして使われているかどうかを判定する。
    画面から出ていった部分については参照カウントを実行する。
    つまり、画面外 buffer に行を移動する時に inc して、
    画面外 buffer から行を削除する時に dec する。
    基本的に画面外 buffer に含まれる行は二度と編集が起きないという事は仮定する。

    ページ等に関しては退避する時に参照カウントを inc して、
    また復帰する時に dec する事にすれば良い。
    GC は一定の回数 attribute を生成する毎に実行する。
    大きなオブジェクトに関してはその都度チェックを実施すれば良い。

  * attribute に拡張属性を使用するか

    | 今 attribute は 4 bytes である。
    | extended attributes は 16 bytes ある。
    | 実はそんなにけちる程の物でもないかもしれないが、
    | 将来的に拡張する事なども考えるとやはり拡張性を持たせる?
    | 16 bytes あっても普通は使わないのである。と思ったが、
    | 最近では full color 対応なども出てきた。
    | そう考えると full color の為の 8 bytes はやはりあった方が良いのだろうか。
    | xattr に関してはそんなに使う頻度が高いとは思われないが、
    | しかし contra が広まるなどして拡張属性が広まれば
    | やはり使われる様になるかもしれない。
    | 文字を書き込む度に 16 bytes のコピーを何度も実施するのは微妙な気もするが、
    | しかし、うーん。現状で既に文字を書き込む度に物凄く色々な処理をしている。
    | 文字幅のテーブルを引いて、それから踏み潰される全角文字がないか確認して、
    | その上で書き込みを実施するのである。16 bytes のコピーをけちる所ではない。
    | 或いは、ASCII のみしか存在していない状況で最適化した実装をする事ができるだろうか。
    | 何れにしても 16 bytes (4 fields) のコピー程度は何の事はないだろう。

    16 bytes は文字の書き込み時に行っている処理の複雑さを考えれば
    大した手間とはならない (それを言い出すと拡張フラグのチェックも大した手間ではないが)。
    データサイズ的にはそんなに大きな物ではない。
    例えば 200字x10000行x16bytes = 32MB である。うーん。結構ある…。
    char 4B width 4B attr 16B だと 48MB であり、
    char 4B width 4B attr 4B だと 24MB である。2倍位の差になる。

    c 或いは画面から流れた内容を何らかの方法で圧縮して
      保持する方法などあるだろうか…。ANSI seq に変換して記録する等。
      然し、それはそれで複雑な行内容だった場合に困難が生じるし、
      複雑なオブジェクトがある場合には何れにしても困る。

    d 画面から流れた内容はファイルに書き出してしまっても良いのかもしれない。
      と思ったが、その時には拡張属性等はどう管理したら良いだろうか…。
      ファイルの中に領域を作るのも変だし、拡張属性・拡張オブジェクトだけ
      メモリ上に保持するというのも片手落ちな気がする。
      更にファイルに記録するとすると、そのファイルのインデックス等も
      管理しなければならない。ファイル内のどの位置が何行目に対応しているかという。

      然し、ECMA 48 の書き方を考えると画面から出て行った内容に対して、
      この様にファイルに書き出す機能という物があっても良い様には思う。
      それを画像として出力するのか、テキストファイルとして出力するのか、
      或いは、ASCII seq を含んだファイルとして出力するのかは色々。
      HTML にして出力してしまうという手もあるのではないか。
      sixel 部分に関しては適当に画像に変換してセルごとに保存してしまう。
      うーん。オブジェクトは確かに画面の外に出た瞬間に
      画像として残すだけで良い気がしてきた。

      一方で、昨今の Web インターフェイスの様な物を考えると、
      実は端末上でも領域に id でもつけて対話的な事ができるようにしても良いのでは、
      そしてスクロールして色々な情報を見られる様にして良いのではないか、
      等と考えないでもないが、まあその様な機能を実装したとして広まらないし、
      やはりやっても余り意味が無いような気がするので考えても仕方がない。

      本気でなにか広めるのだとしたら新しい OS でも作って、
      標準のターミナルでそういう面白い機能をふんだんに使った
      アプリケーションを提供する等しなければならない。
      しかし、余り複雑だとそれに追随するソフトウェアが現れないし難しい所である。
      精々ボタンを設置して、そのボタンが押された時に受信されるシーケンスを設定する位である。
      或いは terminfo に代わる様なライブラリを提供するか。

* [暫定実装] ansi: c2w の実装は中途半端な物である。
  結合文字などの文字幅 0 の文字の事を考慮に入れていない。
* [暫定実装] ansi: utf8_decode の実装も中途半端である。
  これは別の encoding の場合も考慮に入れて
  インターフェイスを考えておく必要がある。
  使う側もそれに合わせて実装する必要がある。

2019-04-05

* bidi: 情報を収集していたら余計によく分からなくなった。

  Unicode には bidi 関連の機能を制御する文字がある。
  それだけでなく文字の種類によって自然な文字の方向というのが存在して、
  アラビア文字等の場合には特に制御をしなくても勝手に文字の方向が決まる。

  contra の内部実装ではデータ部での論理配置を軸にして、
  表示上の移動などにも対応する事になる。
  表示部での操作を実装する為には、対応するデータ部での配置に変換できなければならない。
  その変換を実行するために必要なデータ構造は何だろうか。
  また、データ部・表示部における様々な操作に対してそのデータ構造を更新する必要がある。

  アラビア文字を挿入する度に周囲のアラビア文字との結合を考えるのは面倒である。
  従って、データ部・表示部の変換を実行する度に、
  行内にどの様な種類の文字が存在してどの様な配置になるのかという事を計算するのか。
  或いは、文字配置に関連するデータをキャッシュしても良い。
  或いは、やはり文字を挿入する度にそう言ったデータを管理する様にするのか。

  そしてマーカはやはり文字列としてデータ部の中に埋め込む形にするのが良いだろうか。
  その場合にはデータ部における明示的移動でマーカをどの様に設置することにするのか。
  文字を新しく挿入するとその右にあるマーカは削除する事になる。
  現在の実装のアイディアはこれに基づいている気がする。

  - 属性化領域(DAQ)・選択領域(SSA, ESA)・保護領域(SPA, EPA)
    これらはデータ部・表示部の変換に影響しない。
    従って独立に管理するのが良いのではないだろうか。
    また ECMA-48 に従うと表示部に対する範囲指定だが、
    用途を考えるとデータ部に対する範囲指定と考える方が良いのではないか。

    ECMAによると SDS, SRS の内部でこれらを設定する事はできない。
    然し、実際の端末ではそういった入力を受け取る可能性を排除できない。
    これらはその位置における SDS, SRS を解除すると見做す事にする。
    然し、その様に解釈すると DAQ, SSA, ESA 等のマーカーも全て
    記録しなければならないのではないだろうか…。

  - 方向付き文字列(SDS)・反転文字列(SRS)
    これらはマーカとして埋め込む。対応はその場その場で構築する。
    変なマーカの配置の仕方をしていてもちゃんとそれっぽく解釈する。
    折返しが起こる場合には一旦方向付き文字列を閉じて、
    改行してから再び同じ入れ子状態に復元する。

  - タブ(HT)
    これは事前に設定されているタブストップの位置と、
    実際にタブによって移動した時に起こるタブの確立を区別するべき。
    そして実際にタブで動いた時に起こるタブはまた内部に記録される。
    実際に発生したタブについて実は TCC を考えると
    文字も記録しなければならないのではないだろうか。
    うーん。従って現在の形式はやはり何か限界があるという気がする。

  うーん。簡単なプロトタイプ実装でも作って考えてみる事にする。
  UAX #9 を確認してみる。思いの外複雑である。
  というか先に UAX#9 を実装してから考えるのが良さそう。
  UAX#9 の為に一から作り直しになるのは面倒である。

  UAX#9 の要点をまとめつつ読んでいく。X1 の規則が滅茶苦茶長い。
  うーん。然し…これに従って並び替えた後に
  表示部での消去を実装するとどう振る舞うべきなのだろうか…。
  この様な複雑な処理を経ると最終的にどの様に切断したら
  見た目を変化させずに消去する事ができるのかという事を判定できない…。
  或いは表示部で範囲を決定するだけで、実際の消去はデータ部で実行して良いのだろうか。

  % UAX#9 の UBA の overflow_isolate_count と
  % overflow_embedding_count の取扱はこれで良いのか。
  % 例えば max_depth = 124 の時 LRI に失敗してその後に RLE に成功する事がある。
  % この時 oic = 1, oec = 0 になる。PDF が来るとそのまま処理される。
  % PDI が来ると oic-- して oec はそのままである。
  % 或いは max_depth = 124 の時 LRE に失敗してその後に LRI に成功したとする。
  % この時 vic = 1, oic = 0, oec = 1 になる。
  % PDI が来ると、vic=0,oic=0,oec=0 になってしまう。
  % そして PDF が来ると駄目になる気がする。
  →と思ったが、よく文章を読んでみると oic || oec の時必ず失敗する事になっている。
    従って失敗した後それが pop されるまでは成功する事はあり得ない。

  取り敢えず UAX#9 の実装を試みる事にする。

2016-10-19

* 方向付き文字列の対応
  - HT によるマーカの挿入
  - 各種テストの実装
  - マーカ個数の最大数を設定

2016-10-10

* ページについて。

  ページ関連の機能については一体どの様に実装するのが良いのかと悩んでいたが、
  RLogin のエスケープシーケンスを眺めていた所 RLogin はページに対応している事に気づいた。
  (もしかして xterm なんかも実装しているのだろうかと思って試してみたが実装していない様だ。
  mintty, screen, Poderosa も実装していない。)

  # 特に気になっていたのは画面の上端から流れて出ていった内容をある一定の長さで区切ってページとするべきなのか、
  # 或いはそれどころか画面内である一定の行数毎に区切ってページとするべきなのかという事であった。
  # それよりは画面内はやはりずっと同じページだし、
  # 上端から流れて出ていった内容もやはり同じページにあると考えた方が自然な気もした。
  # しかしそれだと他のページの内容を確認しにくいし、
  # SPH で設定した行は画面内の行ではなくて流れていった内容に含まれる行なのかなど色々わからない。

  RLogin の実装を見てみた所、ページは恐らく見えている範囲が 1 ページになっていて、
  各ページは altscreen と同様に差し替えられるという仕組みになっている様だ。
  上端から流れていった内容は別にページの一部とは考えれていない。
  ページの視点からは上端から流れて出ていった内容は飽くまで失われた内容という事である。

  結局、既存の実装があるのだからこれに従うのが良さそうだし、
  何よりなんとなくこの実装がそれ自体設計として良さそうに思われる。
  が、保険のためもう少しこの実装の声質について考えてみる。

  | なるほど確かに考えてみれば display で見えている範囲というのが丁度カーソルによって移動できる範囲であり、
  | それがプリンタに於ける一枚の紙とみなすのは自然である。そして上端から流れていった内容は、
  | 単に端末の追加機能として記録している物に過ぎず、端末の制御下にあるものではないと考える。
  |
  | と思ったがロール紙 (?) の様なのに印刷している場合はどうなんだろう。その場合には上端から流れていった内容も
  | やはり移動の対象としても良いような気がする。何よりページの移動というのは実際の印刷機では
  | 一体どのような動作に対応するのだろうというのが気になる。特にページを戻るというのは何だろう。
  | 普通のプリンタでは一度出力した紙はトレーに落ちて機械的に自動的に戻したりする事はできない。
  | そういう事を考えると一連の長いロール紙にページという単位の区切りを用意して前にスクロールしたり、
  | 後ろにスクロールしたりする事でページを移動するという風にデザインする事も可能である。
  |
  | そして規格の意図していることとは独立に、アプリケーションから見た時の、
  | 端末機能としての利便性という観点からも考えたほうが良いかもしれない。
  | そういう観点だとページの機能というのは、複数ある画面を切り替えるものとして実装するととても便利そうである。
  | 一つの画面の中に勝手にページ区切りができたりという風な設計だと使いにくいし、
  | また、手動でページ区切りを挿入するのだとしても別に便利だとは思われない。
  | そんなのはアプリケーション内で独自に別の管理の仕方をした方が楽に決まっている。
  | そういう意味で実装して意味のある機能か、という観点から言っても RLogin の実装は合理的である。
  |
  | また上端から出ていった内容に関しては、データの管理の観点から言って
  | 其処にカーソルを戻す事ができる様な設計になっているのは面倒である。
  | というか現在の実装を大きく書き換えなければならなくなり面倒である。
  | もしそれに対応するのだとしたら上端から流れていった内容に関しても、
  | ディスプレイの続きとして同じ配列の中で管理しなければならなくなるし、
  | そうするとメモリ効率などの点から行っても余り嬉しくない。
  | そもそも上端から流れて出ていった内容を確認する頻度というのは、
  | 画面内に文字を出力する頻度と比べれば小さい物だし、
  | どこかに掃き溜めの様に集めておくだけで良いのである。
  |
  | 一つの懸念は FF である。FF は規格どおりに実装するのだとしたら
  | 次のページに移動して SPH に移動するという物である。
  | (page or form と書かれているから頁ではなくフォームでも良いのかもしれない。
  | しかし form とは何だろう。実質 page と同じに扱って良い気がする。)
  | この実装だと、誤って FF を出力した場合に混乱を来す事になる。
  | 次のページに進むことによって今まで表示されていた内容が見えなくなるからである。
  | しかし混乱を来すとは言っても再描画すれば済むことだしそんなに致命的でない気もする。
  | 誤ってではなく意図的に FF を出力する様なプログラムも、LF や VT がある事を考えれば、ないだろう。
  | そう考えれば FF は本当に次の頁に移ってしまうという実装で良い気がする。
  | 一応 FF で LF と同じ動作になる様にできるオプションも付けておくのが良いだろう。
  | # 所で、複数のページがある時に現在のページ番号を表示する様にしても良い。
  |
  | もう一つの懸念は幾らでもページを追加できる様にするのかという事である。
  | 例えば FF だとか PPR を延々と吐き出すプログラムを作った時に
  | 端末はどの様に応答するべきかという事である。
  | 上端から流れていった内容に関しては通常は最大の行数を指定する事ができて、
  | それより沢山の行を出力する場合には順次ローテーとして古い行から消えていく。
  | しかしページの場合には PPA を用いてページ番号を明示的に指定して移動する事ができるので、
  | 古い物から順に消していくという作戦も使えない。或いは、その様に実装して
  | 消えたページに戻った時には空の内容を表示するという風にしたとしても、
  | 実際にいざ移動した時に新しく確保したメモリは配列にどの様に格納するのかという問題が生じる。
  | 勿論スパースな配列を実装して其処に記録するというのでも良いのかもしれないが、
  | それもまた変な実装である。何より使う側からすると謎の挙動に見えて分かりづらいだろう。
  | だとすると予めページ数に上限を加えるというのが現実的な解になるだろう。
  | とここまで考えて RLogin の実装はどうなっているのかというのを確認してみる事にする。
  | もし上限があれば何処かで止まるか、あるいはエラーになるかするし、
  | 上限がないのだとしたらメモリがどんどん増えていくというのを観察できるはずだ。
  |
  | $ for f in {0..10000}; do printf $'\e[ Qhello'$f'\n'; done
  |
  | 結果 RLogin の最大ページ数は 100 という事が分かった。最大ページ番号まで行くと、
  | それより次に行こうとしても何も起こらなくなる (※カーソル位置も動かない)。
  | もしかして設定項目に最大ページ数があるのかもしれないと思って確認してみたが、
  | [スクロールバックできるヒストリー行数] は設定できてもページ数は設定できない様だ。
  | しかし、[通信ログ] の項目に PAGE が云々と書かれているのでやはりページを意識した設計になっている。
  |
  | 更に RLogin のページを見ていると DECRQDE DECCRA DECRQCRA でページについて言及がある。
  | つまり、VT系列の端末ではページに対応していたと考えられ、
  | だとすると RLogin のページに関する動作は VT互換な物であると期待できる。
  | 従って、やはり RLogin の真似をして実装するしか無いだろう。
  |
  | 他に NP PP という機能がある。ECMA に従うと n-th following/preceding page to be displlayed
  | と書かれている。表示されるだけというのはどういう事だろう。
  | また active presentation position の変化は定義されないと書かれている。
  | 一方で RLogin の実装では上端から流れた内容を一時的に表示する
  | (というかスクロールバーの位置を変更する) 様になっている。
  | 現在位置は変化せず、次に最新の内容に変化があった時にはまたもとの画面に戻る。
  | つまり、PPA PPR PPB で操作される "page" と、NP PP で操作される "page" は異なるという事になる。
  |
  | ECMA-48 にも色々書かれている事が分かった。
  | - ED が ECMA では ERASE IN PAGE になっている事から、
  |   やはり page は ED の対象の範囲と同一であるべきで、
  |   だとすれば現在の page というのは現在表示されている範囲の事だと思うべきである。
  |   (ただ、これだけだと現在のページ以外のページがどういう形態を持つのか、つまり、
  |   上端から流れたデータをも含むのか、それとも別のバッファとして記録するのかは不明である)。
  | - 更に QUAD JFY に関する補足が ECMA-48 の付録にあって其処では、
  |   a display device with a multiple-page buffer では云々と書かれている。
  |   つまり page を扱える為にはそれ専用の特別のバッファを持っていると想定できる。
  |   ただ単に上端から流れていく情報を溜めておく装置は multiple-page buffer とは言い難いし、
  |   上端から流れていく情報を一定の行数毎に区切って移動できる様にしただけの物に
  |   新しく multiple-page buffer と名前をつけてそれを display device の特徴の一つとして挙げるのも変である。
  |   そういう事を考えれば、やはり規格的にも page というのは RLogin が実装している様に、
  |   それ専用の buffer に割り当てられる領域とするのが自然であろう。
  | - もっと ECMA-48 を見てみるとちゃんと [ECMA-48/6.3/3] に page について書かれている。
  |   また、[ECMA-48/6/2] にも書かれている。所で気になるのは、行は predetermined number of character positions
  |   からなると書かれている一方で、ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている事である。
  |   これについてはまた別に項目を立てて考察を行う事にする。

  [まとめ]

  - アプリケーションから見た時の利便性の観点からも RLogin と同様の実装が支持される。
  - DECRQDE DECCRA DECRQCRA などの存在から VT 端末も RLogin と同じ動作だろうと期待できる。
  - ECMA-48 的にも ED や Annex C の記述から、page 専用の buffer を持つディスプレイ装置が想定される。
  - NP PP は ECMA-48 的には一時的に他のページを表示するもの (?) の様だが、RLogin は上端から流れた内容を表示する。

  - PPA PPR PPB NP PP に関しては全面的に RLogin と同様に実装する。
  - FF はオプションで LF と同じか次のページに行くかを選べる様にする。
  - 頁数の上限を設定できる様にする。


  関連する制御機能を整理しておく。

  SPH SPL FF PFS
  PPA PPR PPB NP PP
  他にも未だあったような気がする…→ SEF だ。

  | * [2016-10-05] SPH/SPL の効果について
  |
  |   FF 及び implicit movement それから
  |   active presentation position does not normally go
  |   beyond the page limit position というのを実装する。
  |
  |   しかし、そもそも頁の概念を端末上でどの様に実装するべきかが明確でない。
  |   その他の頁を制御する制御機能の説明を調べて、
  |   その上で適切な頁の概念の再現方法を考える事にしたい。
  |
  |   また SLH/SLL と同様に頁毎に home/limit
  |   の値を設定する事ができるかどうか考察する。

  これに関しては行の属性と同様に、
  各ページに SPH, SPL を保持する様にする。
  同時に "現在の既定の SPH, SPL" も保持する。

2016-10-08

* emacs だとかのアプリケーションを動作させるだけであれば、
  terminfo のエントリにある物だけ対応しておけば実は十分という事に気付く。
  一々起動してどの様なシーケンスを送ってくるかを調べる必要はないのだ。

  infocmp xterm を見てみると意外と沢山ある。
  しかしキーシーケンスも多いのでどれが制御機能かぱっと見て分からない。
  後で terminfo の entries についても纏める必要があるだろう。

  序で infocmp ansi を見ると大分すっきりしている。
  というかキーシーケンスが全然ない。考えてみれば当然だ。
  ANSI 規格は制御機能しか定義していなくてキーボードは定義していないからだ。
  また、気になるのは ANSI 規格で処理系定義とされている機能についてだ。
  例えば xenl は infocmp ansi では書かれていないが、
  別に xenl でもそうでなくても ANSI 規格準拠の筈だ。
  後、altcharset (acsc) に普通に非 7 bit 文字が記述されているが、
  これらを utf-8 の環境で使うと何が起こるのか気になる。
  (ncursesw はちゃんと encode してから送信するのだろうか?)

* DECDWL, DECDHL の動作に関して。

  DECDWL, DECDHL, DECSWL は VT510 のページに記述がある。
  これらは行に対する属性として動作する。
  しかしこれらの属性を持つ行に関してカーソルの移動はどの様に働くのだろう。

  xterm, RLogin, mintty が対応していたので動作を観察してみる。

  - VT510 の DECDWL の説明によると元から行に存在していた
    内容の右半分は失われると書かれている。

  - xterm は DECDWL を設定した行であっても表示が二倍の幅になっているだけで、
    一行に収める事のできる文字の数は変化しない様である。
    つまり、画面の右端に行ってもその場では折り返されず、
    行の右半分だけが表示されないという動作になる。
    そして画面の右端に行って隠れた文字列はちゃんと記録されていて、
    \e#5 で行の文字の幅を元に戻すと画面の右端に行って隠れた文字列が戻ってくる。

    また、カーソル移動に関しては \e[C もしくは \e[D で移動すると、
    二倍の距離移動する様になる。つまり、文字数で移動する。
    (因みにカーソルの下に全角文字がある場合に \e[D しても半角分しか移動しない。)

    DECDWL の行で 4 文字目 (つまり7列目) にカーソルがある場合、
    \e[A で上に移動すると他の行の 4 文字目 (4列目) にカーソルが移動する。
    見た目に合わせて 7 列目にカーソルを移動する等という動作はしない様である。
    (ECMA-48 は presentation component での見たままの上下左右の移動に拘っている様なので、
    ECMA-48 を標準化している様な人からすれば \e[A は見た目の通りに 7 列目にするべきと考えるだろう。)

    DECDWL した瞬間にカーソルの位置が変わるかどうかも興味深い。
    xterm の実装では DECDWL した瞬間にカーソル位置は表示上右に2倍の位置に移動する。
    文字データの観点から言うと、DECDWL する前と後で指している文字は変わらない。

    結局のところ xterm の DECDWL, DECDHL の対応はただ単に "表示する時に横幅を二倍にしているだけ" であって、
    実際の端末の処理としては全然幅を認識していないという事になる。

  - mintty は xterm の動作を模倣している。

  - RLogin の場合には画面の見た目で行折り返しが起こる。
    つまり、DECDWL の行では半分しか文字を出力できない。
    然しながら、一旦行内を埋めてから DECDWL してそれから DECSWL をすると、
    また内容が戻ってくる。つまり、SLL を一時的に半分の位置に設定しているだけで、
    実際の内部的な表現としてはやはり一文字一セルで記録している物と思われる。

    面白い振る舞いとしては一旦行内を半分以上埋めて DECDWL をしてカーソルが画面外に出た状態で
    何か文字を出力すると、1文字目は何処にも出力されず、2文字目は行折り返しが起こって
    次の行に表示されるという事である。
    思うに RLogin は現在のカーソル位置が範囲外にあるかどうかをカーソルが移動した時に
    判定して記録しているのだろう。なので、カーソルが移動した後に設定が変わってカーソル位置がはみ出ても
    それを認識せずに文字を置こうとして失敗して、その後でカーソルを移動した時にようやく
    現在位置が範囲外であったという事に気づいて行折り返しを行うというそういう動作になっているのだろうと思う。

    カーソル移動については xterm と全く同じである。\e[C \e[D は2列ずつ移動するし、
    また \e[A \e[B すると前後の行の同じ列ではなく同じ文字番号の場所に移動する。

    所で DECDWL/DECDHL と sixel を組み合わせるとどうなるかを見てみた所、
    sixel の絵も横に二倍に引き伸ばされて表示される様である。
    序に DCH や DL も試してみたがちゃんと画像の一部が削除される様だ。
    これらの動作についてはまた後で様々の実装の間で比較する必要がありそうだ。

  結局、これらの実装が本当に VT の実機と同様なのかは怪しい。
  何れの実装でも行の右半分のデータを保持している。
  一方で、わざわざ VT の説明に行の右半分のデータは discard すると書かれている。
  これは、VT の実装では単に表示を二倍にしているのではなくて、
  丁度表示位置に対応するセルにデータを記録しているという事の気がする。
  だとするとカーソル移動は見た目での列に従って起こるべきだし、
  また行の内容が保持されたり折り返しがなかなか起こらなかったりという事もないのではないか。

2016-10-05

* RIS

  xterm ,screen, mintty はちゃんと表示内容も消去する。
  RLogin は RIS をしても表示内容を消去しない。
  Poderosa はそもそも RIS に対応していない。

* 基本的な移動機能その他

  > CUU CUD CUB CUF (現在位置・上下左右)
  > HPA HPB HPR VPA VPB VPR (記憶位置・行列)
  > CHA CNL CPL (行列)
  CPR
  DCH ICH ECH DL IL EL ED

* RI は一度消えた行ではなくて新しい行を挿入している @ screen
  RI IND

* Poderosa IL bug
  →バグ特定については 2016-10-12 を参照。

* http://invisible-island.net/vttest/

2016-10-04

* 本当に行毎に SLL/SLH の値を保持するべきなのか。

  subsequent lines と書かれているが、
  CUU 等で戻ってから上書きする場合には適用されないのか。
  また ED で erased state にされた行に設定されていた home/limit は消去するべきなのか。

  他に "以降の行" に適用される様な状態はあっただろうか。
  それらの機能の自然な動作も考慮に入れて考える。
  例えば SCP が以降の行に対して適用される物である。
  SCP の説明では現在行の内容の更新方法については述べているが、
  以降の行についての更新方法については述べていない。
  - 既に出力された行に再度移動して其処に新しく何かを書き込んだ時に、
    突然表示方法が変化するというのも変である。
    或いは、既に出力された行に移動した瞬間に変化するというのも変である。
    だとすれば、SCP が適用されるのは本当に新しく作った行に対してのみであるべきである。
    或いは LF もしくは NEL によって移動した時にのみ SCP を更新するというのも考えられるかもしれないが、
    しかしそれでも LF を単なる移動に使うという場合も考えられるし、やはり表示方法が突然変化するというのは変である。
  - ED によって空にした行については SCP はどう働くべきだろうか。
    ED によって空にした行についてはそれが新しい行であるかのように動作して欲しい。
    以前其処にあった方向性が残っているというのはおかしいからである。
    例えば中身が全て erased になっている行に限っては SCP の方向性が新しく適用されるというのはどうだろうか。
    しかし、それも不自然な気がする。周りの行が新しい SCP に影響されていないのに、間にある行だけ影響を受けるというのも変である。
    という事は、行自体に "この行は新しい行である" かどうかを保持するデータをつけておくべきだろうか。
    そして新しい行であった時に限って、現在の SCP をその行に適用し、"新しい行ではない" という様に書き換える。
  - では書き換えるタイミングは何であろう。例えば、一番初めに文字を書き込んだときであるべきか。
    それともカーソルを移動させた瞬間であるべきか。
    カーソルを一気に動かした場合にはどうするべきか。
    カーソルを一気に動かした場合にはスキップされた間の行にまで値が適用されるのは変な気がする。
    という事はカーソルを一気に動かした場合にはあいだの行には SCP は適用しないとする。
    そして、カーソルを一気に動かした場合と一歩ずつ動かした場合で同じ動作になって欲しいという事を考えると、
    結局カーソルの移動だけでは新しい行に属性を適用するには至らないという風にした方が良い気がする。
    つまり、行に対して具体的に何らかの変更が適用される時に初めて行の属性を適用するという風にする。

  さて SCP がこの様な動作をしている時に SLL/SLH はどの様に動作するべきか。
  カーソルを移動して前の場所に戻った時に、現在の SLL/SLH を用いて動作する方が良いか、
  それとも行が生成された時の SLL/SLH を用いて動作する方が良いか。

  % 普通に考えると現在の SLL/SLH を用いて動作したい所だが、
  % 一方で SCP での "以降の行" というのは新しく生成した行に対してのみ適用する事に決めた。
  % この時 SLL/SLH での "以降の行" を別の意味に解釈するのも変である。
  % もう少し考えてみる。SLL/SLH は行を生成した時の値を用いるという動作の方が自然に思われる様な例があるかもしれない。
  %
  % % 例えば、SCP で character path が反転している様な場合はどうだろう。
  % % DCSM(PRESENTATION) の場合には見た目によって位置が決まる。
  % % →しかし、よく考えてみたら SCP は表示部での character path つまり文字位置の番号自体を反転させるのであって、
  % %   記憶部と表示部の列番号の対応関係に影響を与える物ではない。
  % %   そして SCP の異なる行を跨った場合には、例え DCSM(PRESENTATION) であっても、
  % %   見た目に左右が反転している事を考慮に入れて表示部での列番号を移動するのではなく、
  % %   飽くまで表示部での列番号は保持したままで実際の位置は左右反転するという事になる気がする。
  %
  % うーん。でもやはり SCP での "以降の行 (subsequent lines)" との整合性から考えて、
  % SLL/SLH で設定される境界についても各行で保持して、
  % 新しい行に対してのみ現在の設定を適用するという様にするべきな気がする。

  →改めて規格を見てみると SCP の "以降の行 (subsequent lines)" は SCP の説明にしか出てこない。
    一方で、SLL/SLH の "以降の行 (lines of subsequnet line)" は TAB の設定などで複数回出てくる。
    さて、もし SLL/SLH を SCP と同様に各行で定義するとすると、
    整合性から考えて tab stop 等も全て行毎に管理しなければならなくなる。
    それは面倒であるし効率が悪そうな気がする。
    だとすれば、やはり SLL/SLH については共通の設定を一つ何処かに持っておいて、
    行毎には記録しないように変更するべきか。

  [結論]

  - 行には新しい行かそうではないかを識別するための属性をつける。
  - 新しい行に初めて文字などの書き込みを実行する時に、属性を適用する。
    また LF や NEL を実行した際にも属性を適用する。
    後 CR の直前にも実行しなければならない。というか LF の代わりに CR で実行するべき?
  - ED 等の消去関数を用いた場合には空になった行は新しい行としてマークする。

  これらについてはタブ関連の機能について調べてからで良いだろう。
  タブ関連の機能を見て、行毎に tab stop を管理しなければならなそうであれば、
  SLL/SLH も含めて行毎に管理をする様にする。
  もしタブは全ての行について共有なのだとすれば SLL/SLH もその様にする。
  →どうもタブ関連の機能は TSM で動作を切り替えられる様である。
    しかし TSM に影響されずに動作する DAQ(7) 等の機能も存在する。
    つまり基本的に character tab stop は行毎に管理して、
    但し、TSM = MULTIPLE の場合には特定の制御機能は
    全ての既存の行に対して作用するという事らしい。
    全体で共通の tab stop を管理するという様な事ではない様だ。

2016-09-25

* 各機能のテストコードを書く必要がある。

* BEL/HT/VT の正しい実装

* cell で毎回セルのアドレスを計算して取得するのではなくて、
  window.cur に現在のセル、もしくは現在の行へのポインタを保持した方が
  効率が良いのではないか。

2016-09-24

* planned programs

  - terminal multiplexer
  - terminal with graphical user interface
  - screen の様に複雑なことをする物が最終目的の一つだが、
    一方で、cygterm の様に他のプログラムとの仲介を行う物もあった方が良い。
    何かの折にそのようなシンプルな物が欲しくなることがあるだろうからである。

* ポーリングを O_NONBLOCK でやって sleep するのはやはり良くない?

  とはいいつつ入力と出力の両方を監視しなければならないので結局
  timeout を設定して交互に確認することになるので結局同じかもしれない。
  いや、然し同時に複数のオブジェクトを待つという種類の同期の方法が
  提供されていても良いはずだ。

  これについては今の所は致命的な問題になっていないので対処しない。
  後で余裕が出てきた時に正しい方法を模索する事にすれば良い。

2016-09-23

* PLD/PLU/SGR 10-19 の出力を実装する

* SGR 60-69 の実装方法について決める

  同時に複数の属性を on にできるのかそうでないのか。
  或いは出力先のターミナルに応じて処理を変えるべきか否か。

2016-09-22

* ルビ?

  ANSI や Unicode にルビの機能があるようである。面倒である。

  - ANSI に PTX という物がある。これはルビのための制御機能に見える。
    「CSI 1 \ 漢字 CSI 3 \ かんじ CSI 5 \」などの様にして使うものと思われる。
    行内に無理やり押し込めるのではなくて、隣の行に表示することを意図している様だ。

  - 更に Unicode にもそれ専用の文字がある。
    U+FFF9 .. U+FFFB  Interlinear annotation characters
    「<U+FFF9>漢字<U+FFFA>かんじ<U+FFFB>」などの様にして使う。

    <a href="http://unicode.org/reports/tr20/tr20-1.html">UTR #20: The Use of Unicode with Markup Languages</a>
    <a href="http://www.slideshare.net/xkawabata/2014-1109-texruby">TeXユーザの集い2014　発表資料（W3C Ruby）</a>
    <a href="https://en.wikipedia.org/wiki/Ruby_character">Ruby character - Wikipedia</a>
    <a href="http://www.wdic.org/w/CUL/%E3%83%AB%E3%83%93">ルビ ‐ 通信用語の基礎知識</a>

    U+FFF9 - U+FFFB にはそれぞれ IAA IAS IAT という略称が与えられている様だ。

    しかし Unicode も一体何を目指しているのか謎だ。変な制御機能を追加してドキュメントの構造を定義するのであれば、
    SGR だとかに対応する様な機能をつけて加えても良いような気がしてくる。勿論、論理的な意味構造に対応する物しか
    追加したくないという主張なのだろうが、誰が使うのか分からない妙な制御機能を付け加えるならばより明確な機能である
    描画属性ぐらい対応しても良い気がする。毒も喰らわば皿までという事である。

  * PTX と SRS, SDS の interaction についての問題

    | PTX は ECMA-48 を読む限り "普通は隣の行に表示する" などと書かれているが、
    | SRS や SDS など双方向テキストが混ざっている場合にどうするのかというのが謎である。
    | 逆方向の文字列に文字を追加するとその度に既に出力した文字列の位置はずれる。
    | そこに PTX が含まれていると "隣の行" の内容をふりがなで塗りつぶす事になるのではないか?
    | 更に、隣の行の上での双方向の構造がどのようになるのかも謎である。
    |
    | 改めて PTX の説明を読んでみると、PTX is used to delimit strings of graphic characters that are communicated
    | one after another in **the data stream** but that are intended **to be presented** in parallel with one another,
    | usually in adjacent lines. と書かれている。6.3/4 によると data stream はデータ部の中にあるデータの事と思われ、
    | だとすればデータ部の中ではルビは単に付加情報として取り扱われ隣の行には影響を与えない。
    | 実際に表示部に表示されるときにだけ隣の行に上書きして表示するものと考えるという事になりそうだ。
    | しかし、そうすると隣のセルに既に内容がある場合にどちらを優先して表示するのかといった問題が生じる。
    | 例えば、
    | a 常にルビを優先するか、
    | b 或いは常に本来のセル内容を優先するか
    | c もしくは後に描画したものの方を優先して表示するとか
    | a' 次の行の内容を優先するか
    | b' 前の行の内容を優先するという可能性がある。
    | d 或いは重ねて表示してしまうか。
    |   考えて見るに Unicode を完全に処理するとしたら行からはみでて表示される文字も表示したいし、
    |   そう考えてみると重ねて表示してしまうというのが現実的な解になるのだろう。
    |   また実際に其処にあるのに表示されない文字というのも変なので、両方表示したい。

    [結論]

    - データ部ではルビは付加情報として埋め込み、隣の行には影響を与えない。
    - 表示の際に具体的にどうするかは実装に任せる。
      一般的な実装としては表示の際に隣の行に表示する。
      隣の行に既に内容がある場合は重ねて表示してしまうのが良い。

    ※はみ出る文字があると再描画領域の計算などが難しくなるが、
      HTML レンダリングエンジンではそれをやっているのだし、
      何れにしてもふりがなだとかよりも先に実装することになるだろう。

* ANSI の記述によるとエスケープシーケンスは全て "文字" ではなくて "数" で指定されている。
  つまり、変な文字コードを使っていたとしても、エスケープシーケンスに含まれる
  '[' や ';' や '0' は ASCII における値を使わなければならない。
  従って、ソースコード中ではこれらは数字で表現するべきである。


2016-09-20

* original contra のコードの取り込み

  更にもっと古い ConsoleEscapeSequenceHandler についても統合を行いたい。

* gh-pages

2016-09-18

* 端末を作って遊ぶ。

* 端末の要素

  制御シーケンス・文字コードの解釈

    文字コードの枠組み iso2022 は制御シーケンスと渾然一体になっているので、
    どの様に取り扱うかは微妙である。既存のライブラリを部分的に使うかそれとも全部自前で処理するか。
    取り敢えず UTF-8 だけに対応してみるというのであれば大分楽である。というか自明である。

    制御シーケンスの最大の長さというものは決めておかなくても良いだろうか。
    幾らでも巨大なシーケンスを許容すると、超巨大なシーケンスを送りつけてメモリ不足にさせる、
    という攻撃が可能になってしまう。例えば、巨大なシーケンスはファイルに書き出すなどとしても、
    ディスク容量に依存してしまう。そういう訳で制御シーケンスの長さに制限を与えるのが現実的である。
    しかし現代に於いては巨大なデータを送りつける用途もある。
    シーケンスの種類に応じて適応的に処理するべきな気がする。

  バッファの管理

    内部的なデータの表現方法が鍵になる。この定義によって性能が規定される。

    そもそも何が必要か。行、文字、文字幅、属性の管理が必要だ。
    更に unicode grapheme clusters を考えると、結局文字はどう頑張っても可変長になる。
    属性については種類を限定せずに幾らでも拡張可能な様に設計するのが無難だ。
    また、画像だとかのインライン要素も管理しなければならない。

    同時にメモリ効率や変な脆弱性が入らない様にしたい。

  bidi

    既存の各 terminal が bidi をどの様に処理しているのかは確認しておく必要がある。
    特に行折り返しの時にはどうしたら良いのだろう。
    http://unix.stackexchange.com/questions/100811/are-there-terminal-emulators-that-support-bi-directional-text

    うーん。ある場所に hoge (表示 egoh) と出力して、その後にカーソルを色々移動した後に
    hoge の末端に移動して fuga (表示 aguf) と出力したとする。この時にこの二つの文字列が結合して、
    agufegoh という表示になるとそれは変だ。という事は bidi に対応する場合には、
    どの部分が連続して出力されたものなのかという情報を保持する必要がある。

    例えば属性を用いてこれを表現するなどはどうだろう。或る属性がついている文字は、
    次の文字と結合して bidi になる。最後の文字には bidi 属性は設定しない。次の文字とくっつかない為に。
    但し、最後の文字を削除する場合には前の文字から bidi を削除しないと勝手に次の文字とくっついてしまうので注意する。

    →ECMA-48 を読んでいたらわざわざ bidi の為に presentation component
    と data component という物が用意されている様だ。[ECMA-4.8/6.1]

  描画部

    この部分はただ愚直に実装すれば良い。何も問題はない。
    但し、更に別の端末に対して出力を行う場合には terminfo 等を参照せねばなるまい。

  キーシーケンスその他

    逆にユーザ側からアプリケーションに向かって送信されるデータ。
    これについても愚直に実装すれば良いだけである様に思う。
    但し、別の端末から受け取ったデータは翻訳する必要がある。
    これはやはり terminfo 等を参照する事にする。



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2019-04-10

* ansi: DECSET, DECRST に対応したい [#D0042]
  SM, RM と同時に対応した。
  然し、結局認識していないモードが受信された時にメッセージを表示しておきたいので、、
  煩い認識できない〇〇のメッセージが表示されるのは変わらない。
  というか、覚えておいて二回目以降は表示されない様にするというのも手かもしれない。
  とも思ったが、そういうのは出力した後に処理するべきである。
  どの様なシーケンスがどのくらいの頻度で呼び出されているかが気になる事もあるかもしれない。

* ansi: ESC k や OSC(0) によるタイトル設定に対応した [#D0041]
  プロンプトからこれが出力されて画面に表示されるのがうるさいので。

* ansi: VEM for DL IL →DL IL の対応と同時に対応した [#D0040]

* ansi: SLH for ICH DL IL → これは対応した。mode_home_il というモードを作った [#D0039]

* [完了] 2019-04-05 ansi: 新しい端末の定義として ansi_term というのを作る事にした。 [#D0038]

  取り敢えず動く物から作る事にする。

* [完了] 2019-04-05 行のデータ構造の変更の可能性 [#D0037]

  | Unicode 対応等を考えると現在の形式は色々微妙である。
  | 先ず結合文字などが入ってくると特別にメモリ領域を作らなければならない。
  | (但し、これは特別なオブジェクトを保持する時には
  | やはり特別にメモリ領域を作らなければならないので同じ事かもしれない。
  | 然し、そういったオブジェクトは数が限られている一方で、
  | 結合文字などは余りにも簡単に出力する事ができてしまう。)
  | Grapheme cluster も考えて実装するとなると、
  | もう少し柔軟なデータ構造の方が望ましいのではないかと思われる。
  |
  | 結局どのような事を考えているかというと、
  | 行は幅などを考えずに文字の列で表現し、
  | その中に bidi を制御する文字なども含めるという事にする。
  | 座標からデータ内部の位置への変換をスムーズにする為に、
  | B木で各節に合計を保持する?
  | 或いは、行内の文字数がそんなにないと思えば直列に文字を保持しても良い気がする。
  |
  | Proportional なフォントなどを使う場合も考慮に入れて文字の幅は自由にする。
  | 全角2半角1でも良いし、或いはもっと細かい単位でも良いという事にする。
  | 元々の端末の考え方だと全て1だが、今や全角文字のためにその取り扱いは崩れている。
  | 従って、最早2だろうが何だろうが全部真面目に処理するしかないのである。

  行は単にデータ位置とは独立に文字の列として保持する。

    Unicode の bidi や SRS, SDS 等の文字列や、属性化領域・フィールド
    等の情報を保持する為には任意のゼロ幅の文字も保持できなければならない。

  Q. データ位置は行内の文字の番号なのか、仮想的な座標なのか。

    | というかそもそもECMA-48におけるデータ位置とは何だったのかが分からなくなってきた。
    | データ位置には埋め込まれたマーカーはカウントされるのだろうか。
    | 今までカウントされないと考えていたが本当だろうか。
    |
    | 文字が受信された時の事を考えると、受信した文字は次の"マーカー"を上書きするのではなくて、
    | 次の"文字位置"を上書きするのである。という事を考えるとデータ位置というのは
    | bidi の並び替えを実行する前の座標と考えるのが自然である。

    A. データ部における仮想的な座標であるべき。

    何故ならば (1) 文字を受信した時その "座標位置" にある文字を上書きするのであって、
    行内のN番目の文字を置き換えるという訳ではない。(2) データ位置は全角文字の途中にも
    移動する事ができる。

  Q. grapheme cluster で保持するか文字で保持するか

    | そうすると再度文字の表現方法から再考が必要になるのではあるまいか。
    | 今、行を Unicode 文字列で表現する事にしたので、
    | 実は grapheme cluster をそのまま複数の文字として行内に埋め込む事ができる。
    | 或いは今までどおりに特殊文字として毎回登録して使うという様にもできる。
    | どちらの方が良いのだろうか。
    |
    | UAX#9 等を考えると、並び替えの時に面倒なので grapheme cluster の単位で保持したい気もする。
    | 一方でメモリの確保・開放などの効率を考えると grapheme cluster は展開して埋め込みたい気もする。
    | そうすると並び替えなどの操作が色々面倒になってしまう。
    |
    | うーん。考えて見るに通常の使用方法における速度を保証する為には、
    | 内部に grapheme cluster だとか marker だとか R 文字だとか変な物が含まれていない、
    | というフラグを用意しておいて、そのフラグが立っている時は高速な処理にして、
    | そのフラグが立っていない時には低速な処理に切り替えるという手がある。
    |
    | 高速な処理にしている時には wide_extension を有効にしておいて、
    | 低速な処理にしている時には wide_extension を無視するという具合にする?
    | 実は wide_extension は結合文字や grapheme cluster の二番目以降の文字を格納するのに使えるのでは。

    wide_extension 文字を復活させる。
    grapheme cluster は wide_extension と同様の取り扱いにする。
    更に grapheme cluster, marker, R/AL 文字の有無で処理を切り替える。
    これらがない時にはデータ位置と文字インデックスは一致する。

* [消滅] 2016-10-31 bidi: ICH, DCH, ECH に際してどの様に設置されている文字列を更新するかが問題になる。 [#D0036]

  % つまり、文字列の更新とはマーカの位置をどの様に更新するのか、
  % 或いは削除するのかという問題に帰着する。
  % 
  % | 先ずは方向付き文字列しかない場合について考える (つまり TATE などの設置されていない場合)。
  % | ICH に関してマーカに隣接していない場合には単純にそれより後ろにあるマーカを移動すれば良い。
  % | また、DCH に関しても削除領域がマーカに隣接していない場合にはやはり後ろにあるマーカを移動すれば良い。
  % | しかしマーカに隣接している場合の取扱は微妙である。
  % |
  % | 先ず ICH に関しては比較的簡単に処理できそうな気がする。
  % | 挿入位置に丁度マーカが設定されている場合にはどの様に処理するべきか。
  % | 挿入位置のマーカは動かさなくて良い。
  % | では現在位置とその左側の位置に挿入を行おうとしている場合にはどうすれば良いか。
  % | (これは HEM で逆向きに設定されている場合のことを言っている)。
  % | どの様な場合にこの HEM を使うのかよくわからないが例えば SIMD と一緒に使うのだろうか。
  % | だとすると HEM が設定されている場合には現在位置に存在しているマーカも一緒に動かす必要がある。
  % | # しかしこの動作で丁度よい気がする。マーカが現在位置以前にあるものと現在位置より右にあるもの
  % | # の二つに分類されて、HEM に応じて片方のグループがまとめて動くという形になっている?
  % | # →ちょっとこの考え方は説得力に欠ける。
  % | 一方で、ICH において反対側で消去される部分のマーカをどうするのかという問題が残る。
  % |
  % | ECH, DCH, ICHシフトによって失われる領域のマーカの取り扱いに関しては、
  % | insert character 時の文字が置かれる場所の掃除を行う時の手法をそのまま使うのが自然に思われる。
  % | なので、insert character 時の処理がどの様になっているのかを改めて確認し、
  % | どれだけ再利用できるか、どれだけ書き直さなければならないかについて考える。
  % | 望ましいのは insert character で用いているコードを拡張して、
  % | 引数などのオプションに依って動作を切り替えて様々な消去の場合に対応できる様にする事である。
  % | (insert character の実装では任意の文字幅に対応できる様になっていた筈なので、
  % | 自然に拡張できれば嬉しいが…。)
  % |
  % | insert character 時の消去についてまとめる。
  % | 実装は board.cpp の board_line::update_markers_on_overwrite にある。
  % | 既に結構複雑な処理になっている様である。
  % | 先ず引数は curpos_t beg, end 文字の左端と右端を指定する。
  % | つまり、消去する領域の右端と左端と考えて良いだろう。
  % | そして beg <= p < end にあるマーカについてのループを考える。
  % | a bidi string の場合には
  % |   内部に存在するマーカは simd に従ってマーカを右端か左端に移動する。
  % |   その移動によって文字列が潰れる場合には始端・終端マーカを一緒に除去する。
  % |   更に、終端マーカの場合には直前に開始マーカまたはフィールド開始がある場合に除去する。
  % | b aligned string の場合には
  % |   基本的に削除を実行する。但し、simd に応じて左端または右端に存在するマーカは削除しない。
  % |   これは自然なデータの流れによって aligned string が開始して初めの文字が挿入される時に
  % |   直前に設置した aligned string マーカが削除されないという条件と同じであり、
  % |   それが自然な動作に丁度なっている。
  % |   更に、直後の aligned string marker が aligned string 終端の場合にはそれも一緒に削除する。
  % |
  % | 問題はこの動作は ECH や DCH ICH においても自然なのかどうかという事である。
  % | 実は余り自然ではないのではないかという予感がしている。
  % | 様々なケースを想定して考える必要があるだろう。
  % |
  % | 先ずは ECH について考える事にする。
  % | a bidi string 開始が ECH 消去領域の内部に存在する場合の動作は何か。
  % |   もし対応する終端がやはり ECH 内部にあるのだとしたら
  % |   その終端と一緒に削除するのが自然である。
  % |   また、もし対応する終端が ECH 外部にまで及んでいるのだとしたら、
  % |   その bidi string 開始は ECH 消去領域の終端に移動するべきである。
  % |   さて、その時 SIMD が逆になっている場合に ECH 消去領域の開始に移動するという事はありえるか?
  % |   →その動作は変な気がする。
  % |
  % |   ではそもそも何故文字挿入時にはその様な動作になっていたのだろうか。
  % |   例えば全角文字を挿入する時には [直前][現在] という様になっている升目を上書きする。
  % |   内部に存在している bidi string 開始マーカは左端に移動するのが自然と思われるというのも、
  % |   文字を挿入する前のカーソルの位置は確かに現在位置より前にあるのだからその時点で文字を挿入すれば、
  % |   その文字に押し出されて左端に移動するというのは自然だからである。一方で SIMD が設定されていない時には、
  % |   [現在][直後] というセルの並びになっているのだから、文字の挿入に依って現在位置から後方に向かって
  % |   マーカが押し出されるのだという風に解釈する事ができる。
  % |
  % |   さて、ECH を実行する際にも似たような解釈をする事は可能だろうか。
  % |   ECH で後方に向かって削除をする時には単純にマーカを終端に設置すれば良い。
  % |   では、現在位置から前方に向かって削除をする時にマーカを前方に移動するのは自然だろうか。
  % |   - 例えば、それが直後にそこに SIMD を用いて文字を書き込んでいくという事を想定しているとする。
  % |     うーん。もし現在位置が文字列の内部に存在していて現在位置の文脈を以て領域を拡大しようと
  % |     考えるのだとしたら ECH によって左側にマーカがずれるというのは自然である。
  % |     しかし ECH で消去をしようとしているのに bidi string の領域が増えるというのも変である。
  % |     また、ECH というのはやはり文字を挿入するという訳ではないのだから bidi string は長くならなくて良い気がする。
  % |     →やはり ECH で現在の階層の領域が拡大されるというのは無理がある様な気がする。
  % |   - そもそも update_markers_on_overwite では "文字を挿入した後" のマーカの位置を想定して設計された物である。
  % |     従って、削除した瞬間のマーカの配置を表す物ではない。つまり、"削除してから挿入する" という様な形にはなっていないのである。
  % |     つまり、マーカの移動は文字の挿入に固有のものであって、領域の確保によって起こる物ではない。
  % |     その様に考えるのだとしたら、別に ECH によってマーカを移動させたりしなくても良いような気もする。
  % |     しかしやはり ECH というからには其処に設置されている諸々のマーカが除去されてほしくもある。
  % |     →うーん。やはり ECH された領域の中ではマーカは存在してほしくない。
  % |   - しかし完全に階層構造を消去領域の中で解いて除去してしまうというのも変である。
  % |     というのも ICH や DCH を用いる場合には、現在のカーソルの位置に於ける階層構造の上で削除や挿入を行うのが自然であり、
  % |     それと整合性を取る為には ECH も同じように現在位置における階層で消去を行いたいからである。
  % |   - そうすると消去領域の内部に一部でも含んでいる階層については、消去領域の端まで移動を行い、
  % |     消去領域を完全に含む階層に関しては何も変更しないというふうにするのが現実的である。
  % |     しかし、その様な動作を実際に行った時にそれは自然な動作になるのかというのも考えておく必要がある。
  % |     例えば abc[defg]hijk という風になっていて現在位置が f にあるとする。
  % |     前方に向かって 1-3 文字消去する時には abc[   g]hijk という様になる。
  % |     更に前方に向かって 4 文字消去すると ab    [g]hijk という形になる。
  % |     また、初めに 3 文字消してそれから 4 文字目を消去すると ab [  g]hijk という形になる。
  % |     この様な不連続性は実際に行った時に気にならないだろうか。
  % |
  % |   | というかそもそも DCSM が表示部になっている時には一体どのように処理したら良いのか謎である。
  % |   | 一つ一番簡単な実装方法は一文字ずつ消去した時とまとめて消去した時の結果が同じになる様に設計して、
  % |   | それから消去対象の位置について一つずつ消去を実施していくという物である。
  % |   | 一文字ずつ消去しても動作が変わらない様にするというと、消去位置で完全に階層構造を解除するという物が考えられる。
  % |   | - その様な実装だと ICH をどの様に処理するのかが疑問として残る。ICH でも完全に階層構造を解除するのか、
  % |   |   或いは ICH に関してはその時の階層構造を尊重して挿入を行うのか。
  % |   |   特に DCSM で表示部になっている場合にはどの様に考えるのが良いのだろう。
  % |   |   特に ICH に伴うシフトをどの様に行うのかというのも問題である。
  % |   |   もし完全に階層構造を解除するのだとしたら、(1) 先ずは見た目に従って文字列を完全に分割する
  % |   |   (2) その後でシフトを実行するという様にできる。注意するべきは (1) でも字の並び替えが必要になるという事である。
  % |   |   ただ (1) さえ実装してしまえば後は簡単である。
  % |   |
  % |   |   また DCH について考えてみると…もし階層構造を完全に解除してからシフトなどを行うという事にしていると、
  % |   |   ある階層構造の中の或る文字を削除した時に、その文字があった箇所の前後で bidi string が分かたれてしまい、
  % |   |   見えない "切れ目" ができてしまう事になる。
  % |   |   その後の文字の書き込みなどで正しく bidi が処理されなくなるという問題が生じる。
  % |   |   そもそも DCH 等の非自明な操作を行ったときでも bidi が保たれる様に要求するべきかという話もあるが、
  % |   |   できるならば自然でありなおかつ予想可能な振る舞いをするのが良いように思う。
  % |   |
  % |   | - うーん。思うに DCSM で表示部だったとしても文字列の範囲をどの様に縮めるか、
  % |   |   もしくは拡大するか、文字列を削除するかといった様な論理はデータ部の時と同じである。
  % |   |   違うのはデータの表現方法との間に複雑な変換が必要になってしまうという事のみである。
  % |   |   従って、余りデータの変換方法などについては考えない様にして、
  % |   |   先に見た目での文字列の処理方法を与えるほうがよい。
  % |   |   編集が実際にデータ部にたいしてどの様になされるかの変換については後で考える事にすれば良い。
  % |   |
  % |   | さて DCSM に対して作用する事も考え合わせれば update_markers_on_overwrite は恐らく使えそうにない。
  % |   | この既存関数とは別に新しく考えるのが良いような気がする。
  % |
  % |   [結論]
  % |
  % |   - DCSM(PRESENTATION) に関しては先に見た目での文字列の消去・短縮を決定してから、
  % |     それを実現する様にデータ部に対して加工を行うという様に考える。
  % |     恐らく複雑な文字のシフトを伴う変換が起こるがそれについては後で考える。
  % |   - update_markers_on_overwrite については忘れる。
  % |
  % | うーん。やはり ECH においては其処にある bidi string は全て除去するのが自然な気がする。
  % | 一方で DCH は現在の階層において削除を実行する。
  % | ICH は現在の階層において挿入を実行する。端から出ていった物に関しては ECH と同様に消去を行う。
  % | それを元にして再度ルールを決め直すのが良い気がする。
  % |
  % | 次に問題になるのは aligned string のマーカの移動に関してである。
  % | ECH に於いては消去範囲の中に aligned string マーカが存在する場合に削除を行う。
  % | 隣接している場合には削除は行わなくて良い。
  % | 問題は DCH や ICH を行う際に移動範囲に ECH が含まれていたとしてそれを一緒に移動するかどうかである。
  % | 一緒に移動しないと文字だけがずれるので変な事になる。
  % | 一方で一緒に移動すると全て解除するというのも変な気がする。
  % | 或いは、aligned string の内部にある文字列は移動しないという風にする可能性もあるかもしれないと思ったが、
  % | やはりそれは ICH してから何かを上書きするという様な使い方などを考えるに、文字列を動かさないのは駄目である。
  % | 結局、一緒に移動せざるを得ないという風に考えるのが良いだろう。
  % | では、中に設置してある tab stop についてはどうするか。一緒に動かすかそのままかという選択肢がある。
  % | MULTI の場合には DCH でずれる様になっていると全体で共通のタブという状態が崩れてしまう。
  % | その事を考えればずれないという実装にするのが自然である様に思う。
  % | つまり、後になってまた HT 等で移動を行った時は DCH をする前の位置にまた上書きをするという形になる。
  % 
  % [結論]
  % 
  % - ECH は階層構造も全て消去する。内部の aligned string marker は削除する。
  % - ICH, DCH は現在の階層構造において実行する。DCH において内部の aligned string marker は削除する。
  %   ICH においてシフトで押し出される内容はその階層で削除する。つまり、DCH で削除する。
  %   (実は ICH と DCH は全く同じ実装で行けるのではないかという気がする。)
  % - 何れにしても隣接する aligned string marker はそのままである。
  % - SIMD の影響は受けない。代わりに HEM の影響を受けても良い。
  % - DCSM(PRESENTATION) の場合には表示部における消去・挿入・削除をデータ部にどの様に反映させるかについて考える必要がある。
  %   単純に表示部の範囲をデータ部の範囲に写像して消去を行うと駄目である。階層構造がばらばらになってしまう。
  %   上の階層にある文字列から順に適用していって分割統治で行くような感じに実装したい。これは後で考える。
  % 
  % ----------
  % 
  % 次に考えなくてはならないのは DCSM(PRESENTATION) の時にどの様に表示部での編集をデータ部での編集に変換するかである。
  % それを考える為には先ずどの様に問題を分割して、そして個々の場合についてどの様に場合分けをするかが重要になる。
  % 
  % 取り敢えずは aligned string については考えない事にする…というか、aligned string に関しては
  % データ部と表示部での差異については考えないという実装だったはずだ。
  % つまり、aligned string に関しては特別の変換は必要ないという事になる。
  % また方向付き文字列の内部に aligned string が含まれているという事も設計上無いはずだから、
  % 結局 aligned string の削除についてはデータ部と表示部での差はないという事になる。
  % 
  % 問題は方向付き文字列が存在する時の処理についてである。先ず初めに ECH について考える。
  % ECH の領域と方向付き文字列がどの様な関係になるのかというのには幾つかのパターンが考えられる。
  % 1 先ずは ECH の領域が方向付き文字列に完全に含まれている場合である。
  %   今 ECH の領域が eb <= x < ee として方向付き文字列が sb <= x < se であるとする。
  %   sb <= eb && ee <= se の時 ECH 領域が方向付き文字列に含まれていると判断する。
  %   この場合には方向付き文字列内部の座標で ECH を実行する様にすれば良い。
  % 2 次の場合は ECH の領域が方向付き文字列を完全に含んでいる場合である。
  %   これは eb <= sb && se <= ee という条件で表される。
  %   この場合には単純に方向付き文字列諸共削除してしまえば良いだけの話である。
  %   1 かつ 2 の場合には 2 の取り扱いで良いだろう。
  % 3 次のパターンは eb < sb && ee < se という様な場合である。
  %   この場合には消去領域は二つに分割される。
  %   先ずは eb <= x < sb に当たる部分に関しては現在の階層で消去を行う。
  %   そして sb <= x < ee に当たる部分に関しては更にその方向付き文字列の内部で消去を行う。
  % 4 逆に sb < eb && se < ee という場合もあるが、これは 3 と同様に処理すれば良い。
  % 結局以上のことを文字列の入れ子階層に従って実行すれば良いという事である。
  % ここで注意しなければならないのは 3, 4 において ECH は階層構造を消去するという事である。
  % 
  % ----------
  % 
  % | この時方向付き文字列の中身をシフトしなければならない。
  % | どのタイミングでシフトを行うか・どの様にしてシフトを行うかについてはまた考える必要がある。
  % | というか 1 の場合にも分かたれた２つの部分それぞれについてシフトを実行しなければならない気がする。
  % | 更にどんどん文字列が入れ子になっている場合には単純なシフトでは済まないだろう。
  % | 一体どの様に処理すれば良いだろうか…。一つの方法は一旦表示部に内容を転写して、
  % | 消去を行った後で再びデータ部に転写する方法である。この方法は簡単で安全であるが、余りスマートでない様にも思う。
  % | もしもっと簡単に位置関係・シフトなどを表す表式があればそれを採用したい。それについて考える。
  % |
  % | 一回数式にしてみようとも考えたが複雑になりそうである。
  % | 数式を見ても簡単な形に単純化することができるとは思われない。
  % | 一旦簡単な場合で考えてそれから入れ子がある場合を考えていくという様にしたい。
  % | 入れ子のない一番単純な場合で反転領域の内部を消去する場合は、
  % | 右の端に残ったデータと左の端に残ったデータを交換しなくてはならない。
  % | つまりシフトもしくは swap の様な物が必要になる。
  % |
  % | とここで思ったのだが入れ子が複雑になっている場合はシフトもしくは swap の組み合わせで対処できるようには思われない。
  % | というのも、原理上入れ子を組み合わせる事によって任意の置換を表現する事ができるはずで、
  % | 表示部での単純なシフトでさえデータ部では複雑な置換になりうるからである。
  % | 置換は循環の組み合わせで書くことが出来るが独立な swap で組み合わせて書くことはできない。
  % | つまり、何れにしても原理上は swap やシフトを複数回実行しなければならない訳である。
  % | なので、シフトを複数回ではなくて一回で実行するという事に拘る事はできないし、しなくても良い。
  % | 結局、シフトの組み合わせで実装するという事を受け入れて良い気がする。
  % |
  % | 入れ子の構造がある場合の問題は、交換する領域 (右端のデータと左端のデータ) の境界が
  % | 更に内側の文字列の内部にあるという場合である。しかし、これに関しては
  % | 内側にある文字列から順番に交換・消去を実行していけば良い。
  % | 先に内側から交換すれば、外側の文字列で交換を実行する時には
  % | 丁度内側の文字列の境界が交換領域の境界に一致する様になっている。
  % 
  % [まとめ]
  % 
  % DCSM(PRESENTATION) の時は ECH は見た目が変わらないようにデータ部で文字の並び替えを実行しなければならない。
  % 特に反転文字列内部で消去部分の右側にある部分と左側にある部分の内容を交換する必要がある。
  % 表示部・データ部の変換および文字の並び替えに関しては、内容交換を階層ごとに実行する事によって行う。
  % 入れ子階層の一番深いものから順に消去・分割・内容交換を実行していけば良い。
  % 
  % ----------
  % 
  % 次に考慮しなければならないのは文字列を切断した時にどのようにマーカを更新するのかという事である。
  % 交換に際してマーカも一緒に交換しなければならない。そのまま愚直にその様にするのが良さそうである。
  % "交換を全て実行した後の位置" というのを計算するのは面倒そうである。
  % (或いはオフセットを計算できるだろうか?)
  % 
  % - うーん。というか文字列を分割する時の表現はどの様にするのが良いか。
  %   マーカにするべきかそれとも文字列の配列にするべきか。
  %   マーカで交換をそのまま実施するのは困難を極める。というのも、
  %   マーカが必ず開始と終端のペアになっているとは限らないからだ。
  %   という訳でマーカで移動を行うとしても正規化などの操作が必要になるだろう。
  %   更に正規化したとしても一つの文字列が "開始" と "終端" という複数の (離れた) 要素からなるため、
  %   移動・交換などの処理が面倒である。但し、"文字列" の配列であったとしても
  %   入れ子になっている子孫も一緒に移動しなければならない事を考えると大した違いはないかもしれない。
  %   何れにしても正規化という手順を踏む必要性がある事を考えれば、
  %   マーカでの処理は諦めて普通に "文字列" で並び替えを実行して、
  %   その後でそれをマーカに逆変換する方が自然である。
  % 
  % ----------
  % 
  % 2018-02-19 暫く時間を置いたので現状でどこまで実装したのかが何だか良くわからない状態になっている。
  % 
  % ToDo: 後シフトの際に中途半端に全角文字の半分だけシフトするという事がない様にする。
  %   消去される領域が中途半端に被っている場合にはその全角文字全体を削除する必要がある。
  %   また、そもそもマーカが全角文字の中途半端な位置に挿入されない様に設計しておく事も必要である。
  %   (ただ、それでも何かの拍子にマーカが全角文字の途中に置かれる事も考えられなくはないので、
  %   その様な中途半端な事が起こっても大丈夫な様に設計したい。)
  % 
  % ToDo: ICH, DCH についても場合分けを考える必要がある。
  % 
  % 2019-04-04 ECH について時間を費やし過ぎである。
  % うーん。紙に書くなどして簡単に実装することはできないのか。
  % そもそもどの様に方向付き文字列を表現していたかを確認する必要がある。
  % 
  % board_line に std::vector<line_marker> m_markers; というメンバがある。
  % line_marker は curpos_t position と nested_string_type stype というメンバを持つ。
  % nested_string_type には方向付き文字列、反転文字列、
  % 横位置合わせ文字列 (string_aligned) の三種類がある。
  % というか string_aligned とは何だったか…。
  % 確認すると TATE TALE TAC TCC 等である。
  % これらは次の string_aligned が現れると其処で範囲が終わると見なされる。
  % 
  % * update_markers_on_overwrite の実装を見ると、
  %   1. aligned string は次の aligned marker が現れる迄の範囲を表す。
  %   2. aligned string の終わりは方向付き・逆転文字列の終わりを表す。
  %     これは workaround というよりも実際にそういう表現を正当な物として許す。
  % 
  %   というより update_markers_on_overwrite の実装が変な気がする。
  %   これに対応するテストという物は存在するのだろうか…。
  %   うーん。明らかにテストは実装されていない。
  %   勝手に実装し直す事にする。
  % 
  % うーん。そもそも現在の表現方法自体がおかしい気がするが…。
  % まあ、これで実装を続けるとするとどうなるだろうか…。
  % とも思ったが、やはり微妙である。
  % ICH だとか DCH だとか色々実装しなければならない物は沢山ある。
  % その時にも毎回この様に複雑な事を考える必要があるのだろうか。
  % もっとすっきりした表現で簡単に実装する事はできないのだろうか。
  % 
  % 例えば ECH を実装する際には、文字列の開始位置・終了位置を
  % 削除範囲の両端に寄せれば良いのでは。
  % その上で空の文字列を削除する様にする。
  % TATE 等で設置した aligned 文字列は単に削除する事にする。
  % と思ったが、途中で方向付き文字列の内部で消去が起こった時は微妙。
  % 方向付き文字列の内部のままという事にしておくと、
  % 後から其処に何かを記入した時に意図しない表示になってしまう。
  % 従って、現在の実装では方向付き文字列を分断して、
  % 其処には文字列が現れない様にするという様に実装している。
  % うーん。結局昔の考察の通りに ECH は階層構造も全て削除するという仕様にする。
  % 
  % DCSM(PRESENTATION)の時の動作については。
  % というか DCSM(PRESENTATION) はどの様に実装しているのだったか。
  % 恐らくカーソル位置はデータ部での位置になっている。
  % それを表示部での位置に変換して更に其処から右にN文字進んだ場所までを削除領域とする。
  % それをデータ部での消去に変換する必要がある。
  % 
  % 最終的な結果は完全に階層構造を取り除いた状態というのは DCSM(DATA) の時と同じ。
  % うーん。競技プログラミング勢だとあっという間に実装してしまうのだろうか…。
  % 取り敢えず、データ構造は考えない事にして、構造とアルゴリズムについて考える事にする。
  % 
  % (1) 表示部における範囲を決定する。
  % (2) トップレベルの反転文字列から再帰的に処理を行う。
  % 
  % うーん。どうも滅茶苦茶構造が汚い。全く駄目だ。実装し直したい。
  % そもそも marker で文字列を表現しようとしたのは何故だったか。
  % 1. 実際の文字の配列と別個に管理したかった。
  % 2. 受信するのは開始マーカと終了マーカである。
  % という事だった。従って、marker で管理するのが自然であるとの考えであった。
  % 然し、marker による表現は実際の構造を反映しているとは言い難いので、
  % 具体的な操作を実装しようとすると対応するマーカを探し出すという事を
  % 毎回実行しなければならない。従って、色々と面倒な事になってしまう。
  % 
  % 実は文字列に関しては真面目に木構造で保持した方が良いのではないだろうか。
  % うーん。

  これはデータ形式を変更して実装し直した。

* ansi: SPD の実装 [#D0035]

  見た目を変えずに charpath が反転する為には
  データ部での反転を実行しなければならない。
  然し、strings などがあると複雑になってしまう。
  どの様に処理するのが正しいのか。

  因みに strings は終端していない場合は強制的に終端しても良い物だろうか。
  例えば反転文字列を書き込んでいる途中で SPD による反転が実施されたとする。
  この時反転文字列の続きを記入できる様にするべきだろうか。
  考えてみるにそうではない気がする。やはり反転が起こったらその時点で固定化する。
  つまり、strings は終端を明示的に挿入する様にするという事なのである。

  さて、どの様に実装したら良いだろうか。
  update_strings は実行する必要がある気がする。

  a 例えば以下の様に実装する。
    先ず update_strings で得られた結果を反転する。
    然し単純に逆転させれば良い訳ではない。
    開始点について昇順に元々並んでいるが、
    これは終端点について昇順であるとは限らない。
    そして、それに基づいてマーカーを挿入しながら
    文字を順番に登録していく。
    中に含まれていた文字列のマーカーは全て無視する。

    と思ったが色々問題がある。
    零幅文字と文字列開始・終端の順序が保たれない。
    それに update_strings を end について
    ソートし直さなければならないのは面倒。

  b 例えば、始めに文字列終端を設置していく。
    完全に設置して対応が取れている状態になって、
    その時に始めて反転を実施し始める。
    反転する時には予め update_strings で得られた
    情報を元に開始マーカーと終了マーカーを入れ替える。

    或いは update_strings のルーチンを改造して、
    その時にもう開始マーカーと終了マーカを入れ替えるべきだろうか。

  取り敢えず b で実装できた気がする。

* ansi: カーソル移動について。 [#D0034]
  これは色々調整が必要かと思っていたが
  実は表面的に書き換えたら簡単に動く様になってしまった。

* ansi: SGR 等。 [#D0033]

  取り敢えず鬼門だった ICH, DCH, ECH の類を実装できたので、
  SGR 等の機能について移植していく事にする。

  うーん。これらの属性は拡張フラグを使って実装されている。
  面倒なので attribute_t に沢山関数を生やして実装する事にする。
  後で拡張したくなっても大丈夫な様にする為に。

* ansi: ICH, DCH も同様に実装するべき? [#D0032]

  どの様に実装するべきだろうか。
  ICH に関しては現在の位置に文字を挿入する。

  SIMD の影響は受けない様である。HEM の影響を受ける。
  DCSM の影響も受ける。

* ansi: ECH 取り敢えず実装した。まあこんな物だろうか…。 [#D0031]

2019-04-08

* ansi: ECH (DCSM(PRESENTATION)) [#D0030]

  さて、問題の ECH である。これの実装をどの様に考えるか。
  思うに Unicode Bidi を考え始めると訳が分からなくなるし、
  もっと言うと Unicode Bidi を考慮に入れて端末にシーケンスを
  送ってくる様なアプリケーションが存在するとは思われない。
  強いて言えばユーザが画面を見た目で操作する為にその様な物を送るぐらいか。

  さて、今となっては NUL が segment separator の役割をしているので、
  DCSM(DATA) の時には単に ECH は NUL を書き込むだけで良い。
  NUL を書き込んだ場所より後の反転の効果は解除されるが、
  まあ、データ部は marker も含めた文字列の集合なのだと思えば、
  その様な振る舞いは自然なのである。

  DCSM(PRESENTATION) の時にはどの様に取り扱うのが良いのだろうか…。
  表示部に於ける各点に対応するマス目を消していけば良いのだろうか。
  然し、そうすると変な事になる気がする。更に境界上に乗っている
  marker をどの様に取り扱うのかが謎である。
  というか PRESENTATION というからには、やはり見た目を保持したい気もする。
  Unicode bidi を対応しないという決断をした今、実はその様な実装は可能の気がする。

  文字列 m_strings_cache の情報は使う前提である。
  結局、前半部分までの文字列と、後半部分までの文字列を生成して、
  それを接続するという事にすれば良いのではないだろうか…。

  前半部分までの文字列は内容を変更しない様に構築しようとするとどうなるか?

  * ゼロ幅の文字の取り扱い

    | 取り敢えずゼロ幅の文字をどの様に取り扱うのか決めておく必要がある?
    | ゼロ幅の文字も一緒に反転して表示する前提にした方が良いだろうか。
    |
    | 例えばデータ部で ...[A|B|C|D]... となっていて
    | 表示部で ...[D|C|B|A]... となっている時に、B 以降を削除するとする。
    | 得られる結果は表示部で ...[D|C|] という事で良いのだろうか。
    | というか ECH はできるだけゼロ幅を残す様に実装すると考えれば、
    | 実はあんまり考えなくてもゼロ幅文字をいつも残す様にしておけば良い気がする。

    →ゼロ幅の文字はできるだけ拾う様にする。

  うーん。取り敢えず…。前半部分の範囲を取得するコードを書く事にする。

  | 早速何がどうなっているのか分からなくなった…。
  | 結局何をしたいのだったか。
  | 持っているデータは何かというとデータ部で見た時の入れ子の構造である。
  |
  | 外から中に見て行った時に、反転を起こす。
  | 更に範囲で見ているので範囲が分断されたり色々する。
  | 分断された範囲をそれぞれどの様に取り扱うのか。
  |
  | 例えば [] で切り取り範囲を () で反転範囲を示すと、
  | 以下の様な場合には [>>>(<<<)>>>] 三分割される。
  |
  | 或いは [>>>(<<<]<<<) という様な場合には、
  | () に要求するのは後半の3文字である。
  | うーん。実は要求はデータ位置で行っておけば良いのではないか?
  | 何だかよく分からなくなってきた。データ位置というか、
  | その反転範囲に取ってのデータ位置というべきである?

  a うーん。ちゃんと木を作ってから処理すればできる気がするが、
    今のデータ構造の儘で単純に深さ優先で並列に処理する事は可能なのだろうか。
    そのノードの中に入る時に座標を変換して、そして出る時にまた変換を戻す。
    そんな風にして処理していけるのだろうか…。
    行ける筈だが何だか面倒な感じしかしない。
    先ず、ノードに入る・出るというのを検出しなければならない。

  b うーん。特にノードを出たというのを判定するのが難しいのではないか。
    と思ったが、それは parent を記録しておいて、それが減ったら抜けたと思えば良いのか?

    前回処理した i と現在の parent を比べる。現在のノードが前回処理したノードの
    子供ならば i - 1 == range.parent になる。現在のノードが前回の兄弟ならば、
    strings[i - 1].parent == range.parent になる。前回のノードが抜けたのであれば、
    strings[i - 1].parent > range.parent になる。
    そんな感じに先ずは抜けたとか入ったとかを検出できる様にしたい。

  取り敢えず b によって入ったり抜けたりするのは試験的に実装した。

  | この段階でどの様に実装したら良いのだろうか。
  | 少しずつ考える事にする。今見ているのは常にデータ部での範囲である。
  | 基本的には文字を削除するのと等価なのでデータ部での順序は保たれる。
  | 問題は切り取る範囲をどの様に動的に管理するのかという事である。
  | 実は簡単な気がしてきた…。
  | 
  | と思ったがそうでもない。途中で範囲が二つに別れたりする…。
  | 
  |   表示部   ----[--**]**--
  |   データ部 ----[**--]**--
  | 
  | うーん。push する度に結局何処か別の場所に範囲を記録しなければならないのだろうか。
  | 更に入れ子が増えていくとどんどん分裂していく事になる。これに対処するのは難しい。
  | 結局スタックか何かを用意して処理していくしかないのだという気がする。
  | そして、現在の範囲は現在のノードの中でのみ有効と考える。
  | →残っている断片をスタックに記録して処理する事にした。実装できた。
  |   動作テストもしてみた。ちゃんと動いている。

  スタックに分断した断片を記録する事にして、範囲取得は実装してテストした。

  * ネスト状態の復元について

    うーん。然し、本当にこんな実装で良いのだろうか…?
    というか文字列の始まりと終わりについて記録しなくて良かったのだろうか?
    またネスト状態の追跡をしたいという要望もあるのである。
    もしネスト状態の追跡をしたとして、範囲で拾った物の前にネスト状態の復元を置いたとする。
    しかし、範囲で拾った物に既にネスト状態の更新が含まれていたらどうするのか?
    うーん。含まれていたり含まれていなかったりの気がする。
    という事を考えてみると実はネスト状態の復元に必要な点もリストに含めておく必要がある?

    本当だろうか。境界上の marker は全て拾う様になっているので、
    境界に至る直前のネスト状態を復元すれば良いという事になるのではないか。
    然し…境界上の marker を全て拾うというのはそれはそれで厄介である。
    重複して前後して拾ったりはしないのか? と思ったがデータ部の上でちゃんと
    順番に列挙する様になっているので境界が重複しているという事はない筈である。

  うーん。と思ったけれどやはり微妙な気がしてきた。
  必ずしも先頭ではないのである。少し動かしてみる。
  必要なのは丁度先頭に来た部分に対して状態を復元する事である。

  因みに削除直前の部分に関しては特に処理は必要ない。
  というのも NUL を置いた時点で其処で文字列が強制的に終了するからである。

  * 因みに NUL にした所に文字を書き込んで行くと、
    文字列が延長されて混ざり合ってしまう。
    この様な振る舞いをよしとするかどうかは微妙である。

    a まあ、再び同じ内容を書き込んだら復元できるという様に考えたらこれでも良い気がする。

      x と思ったが、表示部でそうなる様に文字を書き込むというのは困難がある。
        実際に書き込みが行われるのはデータ部であって、
        データ部に於けるデータの並び方に関しては既に並び替えられてしまっているので、
        再び復元する事は不可能である。

    b 或いは、何らかの文章を途中に書き込むのが目的と思えば、
      勝手に混ざり合ってしまうのは都合が悪いという考え方もある。

    その様に考えると実は、ちゃんと終端して置いた方が良い気がする。
    →終端する様に実装した。

  * テストが不十分な気がする。
    もっとちゃんとテストするにはどうしたら良いか。
    テストコードを書いた。幾らか試した。動いている気がする。

  * find_innermost_string についてもテストして置きたい。
    →テストを書いた。ちゃんと動いている。完璧な気がする。OK

* ansi: to_data_position [#D0029]

  これの実装はどうしたら良いのか…。

  [>>>>[<<<<x<<<<]>>>>]

  持っているのは presentation_position なので、
  反転範囲が終わるまで見ないと分からない気がする…。
  うーん。一旦、完全な string のリストを作ってしまう事にするか…。
  そして外側から順に中に入っていくという作戦。
  これが元々の contra の実装である。

  もっと簡単にする事は果たして可能なのだろうか。
  うーん。一旦、対応する終端までジャンプすれば可能なのだろうか。
  とも思ったが、其処から更に後退していく等の処理を考えると、
  やはり一旦完全な string のリストを作ってしまう方が楽の気がする。
  これは既存の実装を参考にするのである。

  実装した。動いている。

* ansi: to_presentation_position [#D0028]

  nested_state を追跡する事で計算できるだろうか。
  要するに目的のデータ点 x を含む nest について
  深さを以下の様に書いた時 (x を含まない nest は書かない)、

  [>>>>[<<<<x<<<<]>>>>]

  x より前にある >>> と x より後にある <<<< の数を集計すれば良い。
  また、都合上 x と同じ位置にあるマーカーは x の直前にあると見做す。
  先ずは x が現れるまでループを回す事を考える。
  その間に nest を開いたり閉じたりする事になる。
  x に出会った時にどの状態になっているかを調べる。

  nest を記録する時に何を記録するべきだろうか。
  始まりの位置? それから方向?
  stack の中にある逆方向の文字列の数も調べておくべき。
  途中で中断できる様にしたいので。

  contra::ansi における文字列の入れ子の解釈

  1. SDS(1) SDS(2) SRS(1) によって文字列を開始する
  2. SDS(0) によって対応する SDS に当たるまで全部閉じる。
    SRS(0) によって対応する SRS に当たるまで全部閉じる。
    対応する物がない場合には無視する。
    例えば SDS(1) aa SRS(1) bb SDS(0) cc SRS(0) は [aa[bb]]cc と解釈される。
  3. NUL に当たった時は全部閉じる。
    (但し、NUL は HT 等によってフィールドを移動した時に設置される。)

  取り敢えず実装した。幾つかテストケースを試してみて動いているからよしとする。

* ansi (line_t::proportional_glb): [#D0027]
  もっとまともなデータの保持の仕方はないだろうか…。

  a 例えば std::multiset で良いのではないか
    % …と一瞬思ったが、ICH や DCH をする度に位置を全て書き換えなければならず非効率的である。
    % と思ったが、実は ICH/DCH の頻度は低いし全て位置を書き換える方法の方が効率的なのでは。。

    x 然し、その場合には monospace の時とデータ構造を切り替える必要がある。
      o 何れにしても工夫をするのであればデータ構造を切り替える必要があるのは確実である。

  b 或いは最後に触った位置を記録しておけば良いのかもしれない。
    どうせ前から後ろに向かって書き込んでいく場合が殆どなのだから、
    実は最後に触った位置を記録しておけば問題は起こらない。

  →取り敢えず b の様にして最後の位置を記録する様にした。
    SIMD で逆方向に進んでいる時は毎回全て計算する事になるが、
    まあ気にしない事にする。

* ansi: wcwidth に相当する物を自分で実装する [#D0026]
  これは ble.sh にテーブルがあった筈なのでこれを流用する。
  →これは enc.c2w に実装した。contra::encoding::c2w である。
  取り敢えず現在の端末の c2w_width_emacs でテストを続ける事にする。

  monospace 側も non-monospace 側も正しく動作している様に見える。

2019-04-05

* [棄却] bidi: 文字列の構造はマーカではなくてちゃんとした構造に変更する [#D0025]
  そもそも文字列はそんなに頻繁には使われないので複雑な構造でも大丈夫の筈。
  但し、文字の記入などのあらゆる操作に対して文字列がある場合には色々と考察が必要になる。

  取り敢えず試験実装として現在の実装と並列にする事にする。
  試験実装の構造には prefix として xxx をつける事にする。
  リスト構造にしようか、或いは vector にしようか。
  そんなに要素が増えないと思えばリスト構造である。
  メモリを節約しようと思うとリスト構造になるだろうか。
  然し、最悪の使用方法の場合を考えると vector の方が効率も良い。
  実装は断然 vector の方が楽である。

  うーん。属性化領域だとか色々考え出すと余りにも複雑である。

2016-10-19

* [2016-10-14] "文字列" データ構造再考 [#D0024]

  | -- 方向付き文字列の表現について --
  |
  | タブなどの仕様について調べた結果、"文字列" の記録方法に変更を加えた方が良いような気がする。
  | タブの仕組みの内に TATE, TALE, TAC, TCC という物があって、これは
  | ある HT と次の HT または CR, NEL の間を一つの単位として
  | 表示する時の配置を指定する物である。
  |
  | SRS, SDS の文字列の内部で HT や VT を行った時の動作が未定義になっているのはそういう事だろう。
  | また、他にも文字列のある場所にカーソルを移動して其処に文字を挿入すると、
  | 文字列の内部に文字が挿入される形になるという仕様についても合理的な実現方法を考えなければならない。
  | 思うに、SRS, SDS は "data stream の中に文字列の開始を意味するマークを挿入する" という意味なのだから、
  | その通りにデータ部の中身を一つの stream と思って其処にマークを挿入するという風に処理するという手があるのではないか。
  | しかし、それをそのままやるとデータ形式を全く変えなければならないし、また、データの位置と表示位置との対応が崩れるので、
  | 様々の処理の効率も悪くなる。そもそも文字列だとか特殊な配置を持つタブだとかを使う機会は殆どないのだから、
  | その様な機能のために overhead を追加したくない。そう考えれば、文字列のマークなどのデータは別に管理したい。
  | 結局、現在は文字列のデータとして開始点と終了点のペアを管理しているが、
  | それを直接更新する事によって状態の変化を追跡するのではなくて、
  | 単にマーカの位置と種類を保持する様なデータ構造を追加するというので良いような気がする。
  | もし座標の対応関係などを取得したくなったら、それらのマーカの情報を用いて計算を行うか、
  | 或いはその都度開始点と終了点のペアのリストの構造を構築してそれを元にして計算を行う様にすれば良い。
  |
  | -- タブ揃えなどの配置の実現方法 --
  |
  | もう一つ考えて置かなければならないのは変なタブ配置が設定されている時の表示の方法である。
  | a 一つの手はデータ部では文字の重なりなどは全く気にしないという事である。
  |   データ部の内容を元にして描画する時に全て処理するという風に考える。
  |   しかし、問題は普通の端末ではそもそもそういう変な揃えタブに対応していないという事である。
  |   受信側の端末では表示がそれっぽくならなくても仕方がないという風に捉えるのであれば、
  |   そのままデータ部の内容を転送するようにすれば良い。
  | b しかし、受信側の端末が様々の機能に対応していなくても、
  |   それっぽい表示にするようにしたいというのであれば、色々と考えなければならない。
  | 思うに、データ構造としてはデータ部の中にマーカとして保持するだけで十分である。
  | これらの問題はデータ部の中に保持している時の問題ではなくて、描画する時の問題である。
  | つまりレンダラの都合でそれらの機能に対応したり対応しなかったりという風にして良いのではないか。
  | そして他の端末に内容を転送する場合には
  | a 変な揃えタブの機能は無視して出力するか
  | b 変な揃えタブの機能を STAB, SDS や SRS を埋め込んで出力するか
  | c contra 側で配置を行った後の結果を転送するか
  | という風にして良い気がする。
  |
  | 但し、描画する時に正しくカーソル位置を動かせる様にする為には
  | やはり描画した時にどの位置にどの文字が表示されるのかという情報を計算できる必要がある。
  | うーん…。本当に必要だろうか。特に問題になるのは上下移動を行おうとした時だろうが、
  | 見た目にカーソル位置がずれても別に問題ないのではないだろうか。
  | むしろ複雑なカーソル位置判定を行うとアプリケーションの側で
  | それに応じた動きをするのが難しくなるのではないかという懸念がある。
  | まあ、これはどちらでも良い気がする。
  |
  | いや、しかしレンダリング先が複数ある場合には困る。
  | 或る表示処理系ではある配置をされて、別の表示処理系では別の配置をされて、
  | という風になっていると表示部での移動というのをどの様に取り扱うべきかというのは難しくなる。
  | また、フォントだとか字間だとかそういうのの取り扱いも入ってくるとより難しくなるだろう。
  | その様に考えれば、実際の所表示部での移動というのは内部的なデータ構造から計算できる範囲に留めておいて、
  | 表示する時の様々な配置に関しては追随しないという様な実装が無難である様に思う。
  |
  | 上記の様に "文字列" などの構造は (規格にある通りに) 所詮は始まりと終わりを扱うマーカであり、
  | そのマーカは制御機能に依って明示的に挿入される物で、自動的に範囲を考慮して辻褄が合う様に
  | 生成されたりするものではないのだという立場にたてば実装が大分すっきりする。
  | そもそも、端末の場合文字を受け取る度に端末の状態が更新されるわけで、その様な場合に
  | 途中の中途半端な "文字列" の状態が何であるのかというのを色々定義しようとするのは無理がある。
  | それならば単にデータ部に埋め込まれたマーカであると考えた方が楽であるし、自然な定義になる。

  [現在の結論]

  1 先ず方向付き文字列などのデータはマーカの配列 (1) として表現する
  2 場合に応じて一時的なデータとして文字列の開始点と終端点のペアを保持する配列を
    (1) から生成して使っても良い。
  3 TATE などによるタブ揃えの処理とデータ部を完全に分離する。
    つまり contra::board 上では表示部における細かい配置については関知しない。
    ただ、属性値として保持するだけに留める。
    "表示部に置けるカーソル移動" の制御機能は方向付き文字列による文字位置の入れ替えのみに対応する。
  4 端末を出力先とするレンダリングにおいては、
    タブ揃えなどの配置について関知せずにそのまま出力する物と、
    内部的に配置をしてからそれを出力する物の二種類を考える事ができる。
    特に後者については実装方法について考える必要がある。


  | -- 配置をしてから端末に出力する場合の実装方法 --
  |
  | この実装をする時に注意しなければならないのは、できるだけ出力するデータを少なくしたいという事である。
  | 例えば配置をし直す度に全データを出力するなどという実装にしていると環境によっては遅くて仕方がない。
  | 従って、できるだけ出力先の端末の持っている機能を用いて簡潔な出力になる様にしたい。
  |
  | ところで、実際の仕様では TATE だとか SDS だとかを使う機会は殆どないと思われるので、
  | そういう物が使われない限りは普通に動作して、そういうのが使われる場合に限っては
  | 遅くても仕方がないという考え方でも良い様に思う。
  |
  | さて、次の問題はいざ使われたという時に一体どの様なデータ構造に依って現在の表示状態を表現するのかという事である。
  | 一番簡単な方法は、何のデータ構造も使わず、行を更新する必要が生じる度に完全に一から表示内容を構築するという方法である。
  | そして差分のある部分だけを出力する様にする。もう少しちゃんと考えるのであれば、ウィンドウシステムの様にしてしまうという手もある。
  | つまり、表示する領域毎にオブジェクトを定義し、
  | 各オブジェクトの重なりなどを計算して一番上にあるオブジェクトの内容が表示されているという様に処理する。
  | そして或るオブジェクトの内容に更新があったとすればそのオブジェクトの表示されている領域について再表示を行い、
  | またそのオブジェクトの位置やサイズが変わったとすればそのオブジェクトが新しく占拠する領域、または、
  | そのオブジェクトが退去した領域について再度どのオブジェクトが一番上に来ているのかという事を計算し直す。
  | ここで難しいのは実際のデータ部におけるデータの更新はオブジェクトに対する操作という形になっている訳ではないという事である。
  | ちょっとした操作によってオブジェクトが完全に組み変わったりする。
  | そもそも "或るオブジェクトの位置が変わる" とか "大きさが変わる" とかそういう風な更新ではなかったりする。
  | 面倒なので取り敢えずは非自明な行に関しては行の内容を毎回完全に生成するという形にする事にする。
  | 後で必要性が生じればもっと効率のよい方法を模索する事にすれば良い。

  [現在の結論] (端末を出力先とするレイアウトエンジンについて)

  1 非自明な設定のない行に関しては単純に出力を行う。
  2 非自明な行に関しては毎回行内容を全て構築して出力するという形態をとって良い。
  3 余裕があれば、先ず方向付き文字列の部分についてだけは対応を行う。
  4 更に余裕があればウィンドウシステム的にオブジェクトの入れ子構造を構築・管理して、
    効率の良い更新ができないか模索を行っても良い。

  という訳で現在のデータ構造を変更する事になる。
  現在のデータ構造を変更した時の影響範囲はどれくらいになるだろうか。
  調べた所、外部から使っている箇所は現在はテストコードだけという事がわかった。
  皆 to_data_position/to_presentation_position 経由で情報を使っている。
  この二つの関数さえ修正すれば自由に変更できる状態にある。

  | 取り敢えずデータ構造は確定した。
  | 次に実装するべきは to_data_position/to_presentation_position である。
  | これを実装する時にどの様な戦略が考えられるかについて一度考察したほうが良い。
  | また、その前に文字列の始まりと終わりの対応が取れない場合などに
  | 一体どの様に処理するかなどについても確定しておく必要がある気がする。
  |
  | a 一つの方法は始点と終点の対応を取って配列に格納してからそれを使うという方法である。
  |   これにすれば既存の to_data_position/to_presentation_position を流用できる。
  |
  |   しかし to_data_position/to_presentation_position を呼び出す度に配列を構築するコストがかかる。
  |   これについてはどうにかならないだろうか。
  |   例えば一つの方法は始点と終点のペアの配列をキャッシュする様にしておいて、
  |   前回から変更がなければ前回のデータを使うという風にすれば良い。
  |
  |   x しかし問題は marker の配列に変更がなかったとしても、
  |     行の内容の文字列の側に変更があると文字列の終端位置などに影響が出るという事である。
  |     つまり、前回から変更があったかどうかというのの判断は行内容も含めて実行しなければならない。
  |     これだと駄目である。なので、何とかこれを回避する方法はないだろうか。
  |
  |     例えば、特に行内容で影響を与えているのは "行終端" = "行の内容が存在している一番右端の位置" だけの気がする。
  |     だとすれば、行終端を表す特別な値 -1 などを使ってキャッシュすれば良い気がする。
  |     しかし、本当にデータ部における行内容が影響を与えるのは行終端だけなのだろうか。
  |     例えば行内容で一番初めに文字がある位置というのは影響を与えない。
  |     何故なら文字列の始まりはかならず明示的に指定されるからである。
  |     問題なのは文字列の終端がまだ受信されていない "過渡的な文字列" なのである。
  |     また、当然行内容の文字が入れ替わっても何の影響もないだろう。
  |
  |     但し、文字挿入の際に或る marker を跨ぐような文字が設置されると困る。
  |     でも、その際にはそれによって marker の除去もしくは修正が行われなければならないから、
  |     結局それに依って marker 列に変更が生じるので変更検出については問題ない。
  |     しかし、この文字挿入時の marker 修正については留意しておく必要があるだろう。
  |     marker の位置をずらすのだとしたら後方にずらして、もしその他の marker と衝突するようであれば
  |     それらも広報にずらす様にする必要がある。その際に長さ 0 の文字列が発生すればそれは削除する。
  |     しかし aligned tabulation に関してはずらすというのは変なので削除する。
  |     削除する時には、対になる end marker が既に来ているのだとしたらちゃんとそれも削除しなければならない。
  |     そうしないとその他の文字列を一気に閉じる事になり望まない結果になる様な気がする。
  |
  |     結局そんな理由で行終端だけが文字列範囲の決定に影響を与えると思って良さそうである。
  |
  |   所で、どの様にしてその様な対応関係の配列を生成するのかというのは一つの問題である。
  |   効率的な方法があるかどうかについてはまた後で考える必要がある。
  |   うーん。結局 stack の様な構造を作って処理するしかないのだろうか。
  |   それだと結構コストがあるような気がするが。しかしだからといって
  |   再帰にするとスタックオーバーフローの危険性があるし、うーん。
  |
  | b 或いは、対応関係を配列に入れなくても処理する方法はあるだろうか。
  |   例えば始点が来た時に終点をその場で計算するという方法が考えられる。
  |   この方法を使えば新しくメモリを確保するなどの手間が省けて良い。
  |   しかしこの方法だと始点ごとに入れ子になっている部分について
  |   同じ計算を実行する事になり非効率的な気がする。
  |   結局処理の見通しの良さなどを考えてもこの方法は取りづらい。
  |
  | まあ a で実装するのが現実的な気がするので、それで行く。
  |
  | + SIMD で文字が逆方向に進んでいる時には一体どうするのか?
  |   - SDS 開始と終了を反転させた順序で認識しなければならないのだろうか。
  |     しかし思うにデータ部内の内容自体がデータストリームであって、
  |     SIMD で文字を逆方向に進めるというのはデータ部内の "データストリームに対する編集" の一つだと考えるならば、
  |     文字を挿入する時に逆方向に進んでいたとしても、
  |     最終的に解釈する時にはその時にデータ部に記録されている内容から SIMD に関係なく文字列などの構造を決定するべきである。
  |     従って SIMD がどうだとかそういうのによって marker の解釈を買える必要はない。
  |   - もう一つ考えて置かなければならないのは過渡的な状態についてである。
  |     データ部に逆方向にデータを格納できるとすると、例えば SDS 終端を先に記録して、
  |     その後で SRS 始端を書き込むという事が可能になる。その過渡的状態で何か問題になる事はないだろうか。
  |     先ずそもそも終端のマーカだけでは SDS の場合には、その文字列の方向を決定できない。
  |     なので SDS の場合には終端マーカだけで有効な文字列として解釈するというのは不可能である。
  |     従って、SDS 終端マーカしか存在しない場合にはそれは単に無視するという風に処理するのが無難に思われる。
  |     だとすれば SRS の終端マーカの場合にも同様に処理するしかないだろう。
  |     それに終端マーカだけ存在していた時に、例えばそれを行頭までの文字列と解釈しようとすると
  |     文字列入れ子状態キャッシュ配列の処理もより複雑になる。
  |     といっても "行頭" を表す特別な値 "-2" に対して処理を書くだけのような気もするが。
  |     何れにしても余り凝ったことをしても自然な振る舞いになる様に思われないので、
  |     終端マーカだけしか無い文字列に関しては単に無視するというので良いだろう。
  |
  | + 一つの行に設定できるマーカの個数に上限を設定する必要がある。
  |   もしくは複数のマーカを縮約する方法について取り決めれば論理的に上限の数があるかもしれない。
  |   例えば同じ位置で始まって同じ位置で終わる文字列というのはくっつける事ができるのではないかという事である。
  |   そして入れ子になっていなければならない (閉路がない) という事と、空の文字列はないという事を考えれば、
  |   文字列は最大でも (行の文字数) * 2 - 1 個しか作成できない。
  |   但し、過渡的な状態として開始マーカを大量に仕込むことが出来る。
  |   開始マーカの時点ではそれぞれのマーカの終端が同じになるかどうかについて何も分からないので、
  |   結局終端マーカが来るまでは縮約については保留しなければならない。
  |   だとすると結局縮約をするとしてもマーカの個数に上限を設定しなければならないという事だから、
  |   そもそも縮約などの面倒な事も考えなくて良さそうな気がしてくる。
  |   ただ、マーカの個数の上限は (行の文字数) * 4 以上でないと不都合が生じるケースが
  |   存在するという事は分かった。なのでマーカの個数の上限は十分大きくとっておくことにする。

  [結論] 記録したマーカの処理方法について

  - 文字挿入時の marker の修正。全角文字の挿入に依って marker 位置の上に文字を上書きするとき、
    a その marker が aligned tabulation による物である場合にはそれを削除する。
      もし対応する終端マーカ (通常の tabstop への HT) がある場合にはそれも削除する。
      但し、それよりも前に aligned tabulation marker がある場合には削除しない (フィールド連結になる)。
    b その marker が SRS/SDS 文字列である時には marker の位置を新しく挿入した文字の終端に移動する。
      この時、文字列長が 0 になった場合には (つまり文字列終端が挿入文字の終端にあったときは)、
      その文字列 (同じ位置にあるマーカのペア) は削除する。

  - 終端マーカだけの存在は許す。文字列としては解釈しない。
    これは SIMD(1) による data stream 構築の過渡的状態として考えられる。

  - 一つの行に設定できるマーカの個数に上限を設ける。
    それは、論理的に配置できる文字列の個数が 2 * (行の文字数) であることから、
    4 * (行の文字数) より十分大きな物にする必要がある。
    この制限は tty_player の側でかける事にする。

  という訳で取り敢えず実装するものについて整理する。
  > 1 マーカ配列 → 文字列配列 への変換。
  > 2 to_data_position/to_presentation_position の調整。
  > 3 SDS/SRS によるマーカの挿入。
  > 4 文字挿入時のマーカ修正。
  # 5 HT によるマーカの挿入 (これはタブ実装の後で)
  # 6 一頻り実装が終わった後で様々な動作テストを行うべきである。

  5,6 に関しては別に項目を立てる。

  | [過渡的状態の文字列(非終端文字列)の取り扱い]
  |
  | to_data_position/to_presentation_position で行の終端を意味する
  | nested_string::npos を処理する必要がある。
  | しかし、そのためには行の終端を取得しなければならない。
  | line 構造体自体は行の内容について関知しないから行の終端を取得するためには
  |
  | a line 構造体自体に行の終端を格納するフィールドを用意して、
  |   行内容の変更に応じて line 構造体の行終端位置も更新する様にする。
  |
  |   # この方法を採用すると行内容の編集と一緒に毎回行終端位置を更新しなければならない。
  |   # そのまま愚直な実装で実装するとコストが高いし、
  |   # 或いは更新の方法に応じて賢い方法を考えるとすると複雑になる。
  |   # やはり使いたい時にその場で計算する方が理に適っている様な気がする。
  |
  | b もしくは、to_data_position に引数として予め計算した行終端を渡す様にする。
  |
  |   # この方法を採用すると行終端を毎回必ず計算しなければならず非効率的である。
  |   # 関数オブジェクトでも渡す様にすれば必要になった時にだけ計算する様にできるが、
  |   # 何か設計を誤っている様な気がする。
  |
  | c 或いは board の側に data_position を移して実行する様にした方が良いか。
  |   現状では presentationDirection を引数に受け取っているが、
  |   その様な情報によって計算結果が左右されるという事はやはり
  |   to_data_position/to_presentation_position は論理的にも board の管轄下にあると考えるのが自然である。
  |
  |   と思って確認してみたが、presentationDirection が記録されているのは board ではなくて tty_state の方だった。
  |   だとすると to_data_position/to_presentation_position は tty_player に実装するべきなのだろうか。
  |   しかしそれは変だ。行毎に文字列を管理しているのだから board や line のレベルで to_data_presentation
  |   に対応していないとおかしい。tty_player に実装するとなると、これらの board や line に記憶されているデータは、
  |   tty_player で board を操作している時にしか有効でない外付けの様なデータになる。
  |   だとすれば、これらの文字列のデータは board ではなくて player の方に移すべきなのだろうか。
  |   そもそも board にどれだけの機能をつけて、また、どれだけの機能を player の方に任せるのかというのを考えないと行けない。
  |   確かに双方向サポートなどというのは ANSI ターミナルを実装するときにしか使いそうにない機能である。
  |   その様に考えれば tty_player の側に実装する物の様にも思われる。
  |   しかし、一方で tty_player で管理するべきなのは "画像の出力内容をどのようにするかという設定" だけで、
  |   "実際のどの様な画像が表示されているか" に関しては board に完全に情報を持たせるべきの様にも思われる。
  |   また、各行についての設定・データを tty_player の側で管理するというのはやはり違う気がする。
  |   その様な情報はやはり飽くまで画面に付随している属性に思われる。
  |
  | どうも腑に落ちない。いろいろ考えている内に眠くなってきたので晩ごはんを食べに行く。
  |
  | 歩いていて思ったのだが、そもそも presentationDirection が tty_state の上にあるのがおかしいのだ。
  | これは board 上でどの様にデータが表現されているかという board の情報であって、
  | tty_player の振る舞いを規定するような情報ではない。それが tty_player の上にあるのがいけないのだ。
  | そもそもの方向付き文字列なども board 自体の presentationDirection を与えないと一意に定まらない。
  | さて、presentationDirection を board 上に移動するとなれば話はずっとすっきりする。
  | という訳で presentationDirection の移動を実施する。→移動した。意外と簡単に移動できた。
  |
  | 後は to_data_position/to_presentation_position の実装を board_line から board に移動するだけの筈である。
  | →これも無事にできた。

  | [文字列挿入時のマーカの上書き]
  |
  |
  | 文字列挿入時のマーカの修正方法について改めて考える必要がある気がする。
  | 実装している途中でよくわからなくなったので。
  | できるだけ様々な場合で整合的に動作する様にしたい。
  | つまり微妙な違いで振る舞いがぜんぜん違うというのは良くない気がする。
  |
  | 1 先ず初めにマーカの或る位置に文字を書き込んだ時の動作について。
  |   特に HT を行った時に設定される aligned string について。
  |   実際に実装する前には上書きする場合には消去し、
  |   隣接する場合には消去しないという風に考えていた。
  |   しかし、それだと全角で文字を出力していって丁度マーカを踏み潰す形になった場合には
  |   前のフィールドと次のフィールドが連結されるという様な形になるが、
  |   一方で、半角で出力していった場合や丁度全角文字がフィールドに収まる場合には、
  |   途中で書き込む先のフィールドが変わるという動作になる。
  |   出力位置の微妙な違いでこれらの大きな動作の違いがあるのは何か変だ。
  |
  |   そもそも、次のフィールドに移動する時に HT をするという前提で考えると、
  |   フィールドの末端ギリギリまで文字を出力するわけには行かない。
  |   そうすると、その文字を出力した直後に既に次のフィールドの位置に移動していて、
  |   その場所で次のフィールドに移動しようと思って HT を出力すると更に次のフィールドに移動してしまうからである。
  |   だとすればぎりぎりまで出力した場合には、上書きする時と同様にマーカを削除してしまって良い気がする。
  |   その次の瞬間にカーソルがそこを跨ぐから削除するという風に考えても良い。
  |
  |   改めて書くと、境界 a から境界 b に亘る文字を配置した時、a < m <= b なる位置 m にあるマーカは削除する。
  |   ではこの動作にした時に不明瞭は点は他にないだろうか。
  |   aligned string のマーカには三種類ある。純粋な終了点を表すマーカと、開始点を表すマーカ、
  |   それから開始点を表すマーカはそれより前に開始点を表すマーカがあった場合に終了点をも兼ねる。
  |   - 先ず状況の簡単そうな終了点のマーカを削除する事について考える。
  |     終了点のマーカが其処にあるという事は普通の状況では、
  |     現在出力している場所は前の開始点マーカで指定される文字列の途中という風に思われる。
  |     その時に其処に終了点が現れたらどうするか。
  |     もし、その行に対する出力が初めてであった場合には其処には何も終了点マーカなどはなかった筈で、
  |     過渡的な状態においては終了点が存在しないフィールドという物が許される。
  |     その様に考えればその様な終了点マーカは単純に削除してしまって良いと考える。
  |   - 次に純粋な開始点の場合にはどの様に処理すればよいだろうか。
  |     純粋な開始点を削除するというのは一体どういう事だろうか。
  |     先ずそれより前の部分は algned string ではないという事。
  |     なので、それより前の aligned string の整合性などについては考えなくて良い。
  |     一方で、対応する終了点について気になる。それは削除した方が良いのではないか。
  |     しかし、よく考えてみれば対応する終了点が孤立して残されたとしても何か問題が起こるという訳でもない。
  |     処理の上では単純に無視される。それならば局所的な変更になる様にしておいた方が後々様々な所での動作が自然になるのではあるまいか。
  |     しかし、これは data stream という観点から考えるとどうだろう。終了点マーカというのは HT によって次のフィールドに移った時や、
  |     NEL によってその行を終了したとき等に自動的に設置される。明示的に其処に埋め込むという物ではない。
  |     そう考えると開始点が消滅しているのに終了点だけ其処に残留するというのも変な話である。
  |     例えば、カーソル移動で適当に移動して文字を挿入したりタブを設置したりしようとすると変な事になる。
  |     従って、やはり終了点も対で削除した方が良い様に思われる。
  |   - では開始点と終了点の両方を兼ねているマーカの場合にはどの様に処理すればよいか。
  |     基本的には純粋な終了点と純粋な開始点の両方の処理をすれば良い気がする。
  |     純粋な開始点の様に前方に終了点マーカが存在すればそれと一緒に削除を行う。
  |     後は単純に削除を実施する。
  |
  |   結局動作についてまとめると、それが開始点マーカであるならば、
  |   次のマーカを探してそのマーカが終了点であればその終了点マーカを削除する。
  |   そしてそのマーカを (終了点マーカ・開始点マーカかに限らず) 削除する。
  |   また、マーカの範囲に関しては SIMD でない時には a < m <= b であり、
  |   SIMD である場合には a <= m < b にする。
  |
  |   ※実装前の考えではその点が終了点マーカである場合には、
  |   終了点をずらして今までのフィールドの長さを縮める様にしていた。
  |   しかし、この動作はやはりおかしい気がする。
  |   それだと例えばその行に既に内容が出力されているという事を知らずに、
  |   通常通りに出力を行った時に意図しないフィールド分割になってしまうという事になる。
  |   何も知らずに上書きしていっても副作用が出ない様に設計するのが良いのだ。
  |
  | 2 SDS/SRS で挿入される文字列についてはもう少し慎重になりたい。
  |   不用意に上書きをすると左右が突然反転したりして何か良くわからない事になる。
  |   上書きされる文字の部分は消えてしまうとしても、
  |   残った部分の方向性については保持する様にしたい。
  |
  |   もし、挿入文字がマーカ直前に隣接するという場合には何もしない。
  |   というのもマーカ直前に文字を挿入したとしても
  |   SDS/SRS 文字列の内容はそこに変わらず残るからである。
  |   直前に文字を書いただけで内容が破壊されるというのは変である。
  |   しかしそうするとその次に文字が書き込まれるのは文字列の内部という事になる。
  |   しかし、文字列先頭の位置はデータ部ではマーカの直後になるが、
  |   表示部で見るとその文字列の方向性に従った位置に表示されている。
  |   その様に考えると次の文字が挿入されるのはやはり方向性を考慮して計算された位置であるべきで、
  |   つまり、SDS/SRS 文字列の内部に文字が追加されるという事になる。
  |
  |   ※この動作は先の algned string の時と違う。
  |   aligned string の時には最終的な状態が空の行に出力した時と同じになる様に考えたが、
  |   今回の SDS/SRS 文字列の内部に侵入可能という様な実装では、
  |   既に其処に文字列が存在している状態で行を出力すると変な出力になってしまう。
  |   うーん。これについては後でもう少し考えたほうが良いような気もする。
  |   例えば現在の出力位置にどの様にして移動してきたのかという事や、
  |   マーカがいつ設置されたものなのかという情報を考慮に入れて文字挿入の動作を変化させるなど。
  |   しかし、それはそれで変な気もする。
  |
  |   また、挿入文字がマーカを上書きするという場合にはマーカを後ろにずらす。
  |   SIMD の場合には前にずらす様にするのが良いだろう。
  |   一つの懸念はマーカをずらす時にマーカの順序が変化してしまわないかという事である。
  |   終了マーカは開始マーカの直後になければならずその順序が変わってしまってはならない。
  |   m_markers 配列の中では勿論登録されている順序は変化しないが、
  |   しかし、位置を補正する事によって m_markers の内容がソートされているという条件が破れるのが心配だ。
  |   しかし、SDS/SRS マーカを全て同列に扱っている限りは開始マーカが後ろにずらされる事によって
  |   終了マーカの位置を追い越したとしても終了マーカも同様に後ろにずらされる筈であるから、
  |   問題は起こらない筈である。
  |   所で、ずらす事によって長さ 0 の文字列ができる事があるこれについては残しておいても良いような気もするが、
  |   やはり削除してしまったほうが自然な動作と思われる。従って、これについてチェックして削除を行う。
  |   これは終了マーカを移動した時にチェックを行えば良いであろう。
  |
  |   ? しかし SIMD の時に前方にマーカをずらすとするとちょっと微妙である。
  |     終了マーカが移動した時に文字列が潰れるかどうかの判定はどの様に行えば良いだろう。
  |     と思ったが、終了マーカも前方に移動するのでその時にやはり文字列が潰れているか
  |     どうか見極めて削除を行えば良い気がしてきた。
  |     実のところ開始マーカで判定をしても終了マーカで判定をしても良いけれども、
  |     両方移動した後に判定を実行しなければならない。
  |     そんな訳で順方向にループを回すのであれば終了マーカ移動時に文字列が潰れたかチェックし、
  |     逆方向にループを回すのであれば開始マーカ移動時に文字列が潰れたかチェックを行うという事になるのだろう。
  |     今回は順方向にループを回す実装しか考えてないので SIMD に拘らず終端マーカで空文字列判定を行えば良い。
  |
  |     うーん SIMD の時に前方にずらしたとしてその時に何か別の物を跨いだりして変な事にはならないだろうか。
  |     今のところの実装としては最終的な状態では挿入文字の内部にマーカが残る様な事はない。
  |     従って、SIMD の時に前方にずらしたとして追い越すとしたら元々文字内部または文字の境界にあったマーカだけである。
  |     うーん。SIMD で前方にずれるマーカというのは文字内部のマーカである。それが追い越すとしたら
  |     文字内部のマーカしか無い。文字内部のマーカの内 SDS/SRS マーカは同様に移動するので追い越す事はない。
  |     aligned string マーカに関しては削除されるので、これも追い越すという事はない。
  |     従って、SIMD で前方にずらしたとしても SDS/SRS/alignd string markes の何れも追い越さない筈である。
  |
  |   ? もう一つの問題は終了マーカで削除判定を行うとすると開始マーカと削除マーカの二つを削除する事になり、
  |     マーカに対するループの番号を補正しなければならない。
  |     と思ったが、よく考えてみればこれは aligned string の時も同様である。
  |     削除が発生した場合には次に検索するマーカは前回と同じ i であるべきなので、i-- するか、
  |     i++ しないようにするかの対策が必要である。
  |     同様に文字列が潰れた事の判定に依ってマーカの対を削除するのだとしたら単に i -= 2 などとすれば良い。
  |
  |   ? さて、しかし SDS/SRS 文字列が終端する条件は一つではない。
  |     SDS/SRS による明示的な終端だけではなく、次に aligned string マーカが存在するというパターンも有る。
  |     aligned string マーカの際に直前にある文字列が潰れていないか判定するのは面倒である。
  |     その様に考えると実は開始マーカの移動の際に一緒に終了点マーカの移動先も計算して、
  |     その上で文字列が潰れるかどうかを判定するという手のほうが良いのかもしれない?
  |     しかしそれだと入れ子になっている文字列が潰れた時に削除できない。
  |     終端マーカで削除判定を行う事の利点は、空文字列の終端マーカに到達した時には、
  |     必ず内部に入れ子になった文字列 (すべからく空文字列である) のマーカは既に全部除去されているという事である。
  |     つまり、直前の要素を見れば必ず開始点マーカに対応する物が存在するはずという事である。
  |
  |     もし直前の要素がない場合や、aligned string マーカである場合には
  |     そもそも開始点が存在しないという事になるので、
  |     そのマーカは単に削除すれば良いだろう。
  |
  |     結局、終了点マーカもしくは aligned string マーカが現れた時には空文字列判定を行うという事になる。
  |     SDS/SRS 終了点マーカの場合には移動後に空文字列判定を実施する。
  |     aligned string マーカの場合には先に空文字列判定を行って、その後で aligned string マーカの処理を行う。
  |
  |     →実装している時に気づいたが。
  |     現在の実装では aligned string マーカが現れたらその直前にある SDS/SRS を削除するという方針にしていた。
  |     しかし、この方法だと既にあってシフトの対象となった SDS/SRS だけではなくて、
  |     新しく追加した SDS/SRS マーカまでも削除してしまう事になる。
  |     つまり、alined string マーカの直前で SDS/SRS を設置してもそれが削除されてしまうという事態になる。
  |     本当に処理しなければならないのは何かというと、暗黙上書きによってシフトされた SDS/SRS に関して、
  |     直後に aligned string が存在していた時に空文字列として削除を行うという物である。
  |     元々の懸念は入れ子文字列の場合に正しく削除できないのではないかということだったが、
  |     仕方がないので可能性のあるマーカは全て確認して aligned string が一つでもあったら
  |     空文字列になると判定して削除するという具合にする。

  | [SDS/SRS によるマーカ挿入]
  |
  | 通常時は現在の文字位置の左側に挿入し、SIMD 時は現在の文字位置の右側に挿入する。
  | (そもそもその様にしないと次に全角文字が来た時に潰されてしまう。)
  | 左側に挿入する時は append で右側に挿入する時は prepend にするべきだろう。


* [2016-10-05] TAB 関連の機能 [#D0023]

  | Mode TSM
  | VT VTS
  | TAC TALE TATE TBC TCC TSR
  | STAB (ISO 8613-6) HTJ HT HTS CHT CBT CTC CVT
  |
  | 影響のあるもの: DAQ(7) DCH ICH DL IL RIS
  |
  | RLogin は HTS, DECHTS, VTS, DECVTS を認識するが、
  | 何も設定しない状態で HT を呼び出すと何が起こるのだろうか。
  | 確認する必要がある。
  | 因みに VT に関しては次の行に単に進むだけの様に見える。
  | VTS を設定してる状態で VT を実行するとどうなるだろうか?
  |
  | 1 HTS の設定に関する確認。
  |   $ printf $'\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |   xterm, screen, RLogin, mintty, Poderosa の何れも TSM(MULTIPLE) で、
  |   予め 8 の倍数の位置にタブが設定された状態で始まる。
  |   HTS を呼び出すと予め設定されているタブに加えて新しいタブを設定する。
  |
  |   TSM 対応に関して
  |
  |     $ printf $'\ec\e[5W\e[18h\e[15G\eH\e[20G\eH\ra\tb\tc\td\te\tf\na\tb\tc\td\te\tf\n'
  |
  |     RLogin のマニュアルを見ると TSM を ISM という名前で対応している。
  |     しかし "マルチ" と "シングル" の名前が間違っている。逆である。
  |     動作自体は逆にはなっておらず正しい。
  |     CTC(5) の仕様が異なるのは気になるが、何れにしても TSM(SINGLE) にすると、
  |     TSM の変更前に全体に共通のタブを色々設定していたとしても、
  |     各行で 8 の倍数にタブが設定された状態になる様だ。
  |     つまり、TSM の変更前のタブは引き継がれない。
  |
  |     xterm のマニュアルには何も書かれていない。実際に試しても対応していない。
  |     mintty, screen, Poderosa も試してみたが対応していない。
  |
  |   CTC in RLogin
  |
  |     RLogin の CTC(5) と CTC(6) の記述が ECMA-48 の記述と異なる。何故か?
  |     ECMA-48 側が変化したのかもしれないと思って確かめたが
  |     2nd edition から 5th edition まで記述は同じである。
  |     vt510 及び xterm にはそもそも CTC が存在しない。
  |     all-escapes.txt の内容は ECMA-48 の内容と全く同じだ。
  |
  | 2 TAC, TALE, TATE の取り扱い方法?
  |
  |   ECMA-48 に含まれるこれらの機能によって設置されたタブは特別な意味を持つ。
  |   タブ位置の前後にある文字列の配置に影響を与えるとある。
  |   しかし、実際のどの様に実装する物なのかよく分からない。
  |   まず例えばデータ部での配置に影響を与える物なのかどうか、
  |   表示部での上下左右の移動に影響を与えるのかといったことである。
  |
  |   恐らくデータ部での配置には影響を与えないつもりなのだろう。
  |   これらは飽くまで実際に表示する時にどう表示するかというのを指定するためにある。
  |   表示部での取り扱いをどの様にするべきかという事を考える前に、
  |   そもそもこれらのタブが具体的にどの様に処理されるかについて考えなければならない。
  |
  |   % 恐らく前後の文字列というのはフィールドと考えて良いだろう。
  |   % "文字列" と言えば方向付きの文字列という物が ECMA-48 の中で定義されているが、
  |   % それだと、それらが丁度タブの前後で分かたれているとは限らないのでよく分からない。
  |
  |   改めて規格の文面を見ると前後の文字列という訳ではなくて、
  |   何らかの text string があってそれが TAC などによるタブで揃えられる時には、
  |   その文字列の先端もしくは後端の位置によって左右位置の調整が行われるものと見える。
  |   また text string というのは恐らく双方向対応で出て来る strings とは別の物であろう。
  |   よくわからない点が色々ある。先ず、"tabstop by TAC で揃えられる text string" という物を
  |   どの様に指定するのかという事である。"これこれここの範囲はタブによって揃える text string ですよ"
  |   という様な感じに明示的にそれを指定する制御機能はないように思う。
  |   しかしだからといって、タブに従って揃えられますという様な表示規則も元々あるという訳ではなさそうだ。
  |   もし何かあるとすればフィールドだが、これについて何か説明が見つかるかもしれないので
  |   また改めて規格の内容をフィールドに関連して観察してみる。ECMA-48/6.7 を見る。
  |   うーん。分からない。とここで STAB の説明を改めて読むとそこに、
  |   以降の文字列を引数に依って指定されるタブ位置とその性質に従って align されると書かれている。
  |   実は TAC, TALE, TATE, TCC はこの制御機能ありきの機能なのではないだろうか。
  |   しかし、この制御機能は ISO 8613-6 に詳細を投げている。そちらも参照する必要があるだろう。
  |   ISO 8613-6 というか T.416 を見ると TAC, TALE, TATE, TCC は存在しない。やはり関係ないのか。
  |   T.416 STAB に関して見てみると、[T.416/9.1.13] のデータ構造 Line layout table を参照している。
  |   このデータ構造を見ると丁度 TAC, TALE, TATE, TCC などに対応する状態を持っている。
  |   というか、このデータ構造をそのまま採用すれば良い気がしてきた…。
  |
  |   更に、HT の説明に、もし次のタブ位置が TATE, TALE, TAC, TCC による物だとしたら、
  |   次に HT または改行が来るまでは文字列の内容はそのタブに関連付けられた文字列とすると書かれている。
  |   しかもそれは表示部で定義される物ではなくてデータ部の data stream 内で記録されるという。
  |
  | 3 RLogin で垂直タブの設定などをいろいろ試してみたがどうもうまく動かない。
  |   いつでも VT や DECSVT などは一行下に移動するという意味になる様に見える。
  |   xterm でやって見ると DECSVT は効果を持たない (対応していない?)。
  |
  |   縦タブを全てクリアしてから縦タブを設置する様にしてみたり色々したがうまくいかなかった。
  |   でもマニュアルにはちゃんと縦タブについて系統的に対応している様に見える。
  |
  |   - 一つの可能性は初期状態として全ての行に縦タブが設定されていて、
  |     更に縦タブをクリアする機能が効いていないという物である。
  |     縦タブをクリアする機能は CTC と TBC, DECAVT しかない。何れも試したが駄目だった。
  |
  |     $ printf '\e[H\e4\e[6W\e[4g\e[91m\e[10HX\eJ\e[20HY\e3\e[Hhello\vworld\e[1Ytest\e[m\n'
  |
  |     \e4 \e[6W \e[4g のどれを使っても縦タブが解除されていないという事になる。
  |
  |   - もう一つの可能性は何処かにモードがあって縦タブによる移動と
  |     単に一行下に移動するのを切り替えられる様になっているという物である。
  |     しかし説明を見ても VT もしくは縦タブに関連したその様なモードはない様に見える。
  |
  |   - 更に可能性として縦タブの設置に失敗しているという可能性がある。
  |     縦タブが存在しない場合は一つしたの行に移動するという実装になっているのかもしれない。
  |     しかし VTS も DECVTS も駄目だった。
  |
  |   - 或いは VT は常にひとつ下の行に移動するだけで、
  |     実際に縦タブするには CVT を使わないと行けない可能性もある。
  |     しかし CVT で試してみてもやはり状況は変わらない。
  |
  |   - 縦タブは1つずつ解除しなければならないのかもしれないと思って以下も試したが駄目だった。
  |
  |     $ printf '\e[H'; for a in {0..20}; do printf '\e[1g\e[3W'$a'\e[B'; done; printf '\eJ\e3\e[Hhello\vworld\e[Ytest\n'
  |
  |   うーん。RLogin は本当に縦タブに対応しているのだろうか。


  [実装方針]

  1 早々に実装方針を決定したい。
    基本的には ISO 8613-6 (というか T.416) にある様なデータ構造で保持したい。
    タブ構造は各行で保持する。但し、全体で共通のタブ構造を管理している場合には、
    共通のタブ構造と一致する限りに於いて実際にタブ配列を複製するのを避ける。
  2 TSM(MULTIPLE) のとき同じページの全ての行に適用する。
    新規行の文字タブ設定は頁毎に保持する。
  3 タブの位置は常に表示部で定義される。
    と思ったがタブと方向付き文字列の実装に関連して考察した結果、
    方向付き文字列の内部でタブは設定しないという風に考え、

2016-10-12

* Poderosa bug [#D0022]

  | Poderosa で RI を試そうとして以下を入力していたら無限ループになって死ぬ。
  |
  | $ printf 'hello\e[H\eMworld\n'
  |
  | ble.sh をロードした状態で上ボタンで履歴を表示してそれからこれを実行するとなる。
  | 具体的にどの様なエスケープシーケンスを受け取って死ぬのかは調べないと分からない。
  | 面倒だ。どの様にすれば確認できるだろう? contra で escape sequence を全て出力する?
  | 新しく escape sequence を全て出力するクラスを作った: sequence_dump
  | 関係のありそうなものだけを抽出する。DECSET(25), SGR, OSC, SI は関係ないだろう。
  |
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   CR LF
  |   unrecognized control sequence: CSI 1 L
  |   l o a d i n g   h i s t o r y . . .
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 1 1 C
  |   CR LF
  |   unrecognized control sequence: CSI 1 M
  |   unrecognized control sequence: CSI 1 A
  |   unrecognized control sequence: CSI 2 9 C
  |   p r i n t f
  |
  |   '
  |   h e l l o \ e [ H \ e M w o r l d \ n
  |   '
  |   unrecognized control sequence: CSI K
  |   CR LF h e l l o
  |   unrecognized control sequence: CSI H
  |   RI w o r l d CR LF
  |   unrecognized escape sequence: ESC 7
  |   [ b l e :   E O F ]
  |   unrecognized escape sequence: ESC 8
  |   unrecognized control sequence: CSI 2 0 7 C
  |       CR
  |   unrecognized control sequence: CSI K
  |   unrecognized control sequence: CSI 2 K
  |   [
  |   m u r a s e @ p a d p a r a d s c h a
  |     0   s r c ] $
  |   [ b l e :   e x i t ]
  |   CR LF e x i t CR LF
  |
  |   くっつけて見る。
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\e[13D\n\e[1M\e[1A\e[5Cprintf\e[K\nhello\e[H\eMworld\n\e7EOF\e8'
  |
  |   ちょっとここまでで Poderosa に食わせてみる。何も起こらない…。もう一回実行してみる。再現した。
  |   何だろう。ただ単に printf 'hello\e[H\eMworld\n' を繰り返すだけでは起こらない様だ。
  |   もう一度やってみる事にする。起こらない。どうやら境界が下の方にできて、その境界の直後で実行するとなる様だ?
  |
  |   printf '\e[2Khello\n\e[1Lloading...\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK
  |   printf '\e[H\n\e[1L\e[1A\n\e[1M\e[1A\n\e[H\eM\n' OK 再現性あり
  |   printf '\e[H\n\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[A\n\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\e[A\n\e[H\eM' OK
  |   printf '\e[2H\e[L\e[M\n\e[H\eM' OK

  まとめ: 以下の手順で Poderosa が死ぬ。
  (1) Poderosa で新しいウィンドウを開く
  (2) printf '\e[2H\e[L\e[M\n\e[H\eM' と入力して実行する

* escape sequence の処理の段階で NUL や DEL は無視しなければならないのではないか。 [#D0021]
  恐らくシーケンスの途中に NUL や DEL が含まれていても単に無視して取り扱うべき。

2016-10-11

* bidi サポート追記 [#D0020]

  規格を読んでも active data position と active presentation position の関係が分からないと考えていたが、
  ECMA-48/6.3/4 に書かれている。この段落はとても重要な段落である。

  > The graphic image output is constructed in the presentation component from the data stream stored in the
  > data component, and according to the line orientation and line progression of the presentation component.
  > The presentation of characters along a line in the presentation component is dependent on the character
  > path, the character progression and the direction associated with the string.
  >
  > 訳: 記憶部に記録されたデータストリームから、表示部の行送りの方向と行の向きに従って、
  > 表示部に画像出力が構築される。行内の文字の表示は文字進路・文字進行・文字列の方向に依る。

  acative data/presentation position の関係について全てがこの段落に含まれている。
  他の部分の記述や ECMA-TR/53 の記述を組み合わせて解釈したのと整合しているので、
  実装について変更を行う必要はないという事が分かった。つまり現在の実装を変更する必要はない。
  そのことが分かっただけでも大きな成果である。

* 全角文字の取り扱い in ECMA-48 [#D0019]

  ECMA-48/6.3/3 に行は predetermined number of character positions からなると書かれている一方で、
  ECMA-48/6.3/5 に character position のサイズは文字によって異なって良いと書かれている。
  つまり、全角文字などは複数の character position を専有するという扱いではなくて、character position 自体の
  大きさが大きくなるという解釈なのだろうか。だとすると一行に収める事のできる文字の数は全角・半角に関係なく、
  ただ表示する時に全角文字で構成された行はサイズが大きいという風な扱いということなのだろうか。
  これは実際の端末の実装とは一致しないし、何より変だ。しかし、異なっても良いし固定でも良いと書かれている
  (may be fixed or may be depend)。文字に依って専有する character position が複数でも良いという風に何処かに書かれていれば
  それが実際の実装と一致した物と考える事ができる。でも 6.1.6/2 には implicit movement によって
  the active data position is moved to the following character position と書かれている。the とついているので、
  やはりこれは一つ次の character position に移動するという事である。

  ECMA-48 的には
  - 行に全角文字が含まれていても行に入れる事のできる "文字数" は同じで、
  - 例えば SLH SLL で設定される文字番号は幅ではなく "文字数" でカウントされ、
  - CUF や CUB では半角幅毎ではなくて文字毎に移動するべきなのか…。

  これは実際の端末の実装と乖離しているし、それに実装として不自然である。
  また全角幅の文字は普通に使われる機能なので、今ここで ECMA-48 に厳密な実装にすると色々な問題が実用上生じる。
  どう考えても、実際の端末の実装の方が自然で現実的な実装であるので、ここでは ECMA-48 を無視する。
  これについて Note を残しておく事にする。

2016-10-05

* SPH/SPL [#D0018]

  page_home_position -> page_home, page_limit
  取り敢えず値を設定できる様にする。

* sequence_decoder, sequence: support ESC sequence [#D0017]
* escape sequences の解釈 [#D0016]

2016-10-04

* SCP SPD に対応する。 [#D0015]
* CR ... SCP SPD の向きが逆の場合に対応する。 [#D0014]

* data position と presentation position の変換方法について。 [#D0013]

  SCP による character path の方向は基本的な計算部分に影響を与えない。
  何故ならば character path は presentation position の番号と、
  実際に表示される位置の対応関係を規定する物であって、
  data position と presentation position の間の関係には影響ないからだ。
  但し、directed string の ltor と rtol は、
  character path によって意味が入れ替わるので注意する。

  従って、計算の上で気にしなければならないのは directed_string だけである。
  directed_string によって向きが反転している範囲の中にあれば反転するという事をしなければならない。


  presentation position -> data position の実装は比較的簡単である。
  1 先ず presentation position を x とする。
  2 directed_string のリストから x を含む
    一番大きい directed_string を拾って str とする。
    もし x を含む directed_string がもうなければ処理は終了する。
    ここで x は記憶部で最終的に必ず str の範囲に含まれる事に注意する。
  3 もし str の向きが外側の向きと一致していなければ x の位置を反転させる:
    x = str.end - 1 - (x - str.begin);
  4 以降は str 及び、その中に含まれる directed_string のみを考えれば良い。
    従って、str に含まれる directed_string のリストについて 2 に戻って繰り返す。

  data position -> presentation position については少々厄介である。
  presentation position -> data position の逆の処理をすれば良いかと考えたが、
  外側と較べて反転しているかどうかを知るためには外側から順に辿って
  一旦何処で反転が起こるのかを記録しなければならない。
  もっと賢い方法はないだろうか。
  反転は線形の関数である事を思えば、shift の量だけを記録すれば行ける気がする。
  反転が起こる度に、

    x = -x + (str.end + str.begin - 1)

  という事になる。i 回目での shift 量を

    shift[i] = str[i].end - 1 + str[i].begin

  とすれば、最終的な結果は、

    x[i] = -x[i-1] + shift[i],
    (-1)^i x[i] = (-1)^{i-1} x[i-1] + (-1)^i shift[i],
    (-1)^n x[n] = (-1)^0 x[0] + ∑[i = 1 .. n] (-1)^i shift[i],
    x[n] = (-1)^n x[0] + ∑[i = 1 .. n] (-1)^{n-i} shift[i]

  で求められるという事になる。但し、i の小さな shift の方が、
  より小さな範囲の directed_string に対応している。
  今、番号付けを変更して k = n - i とすれば、
  一番大きな単位の directed_string が k = 0 に対応する様になる。

    x[n] = (-1)^n x[0] + ∑[k = 0 .. n - 1] (-1)^k shift[n-k].

  これで行く。自身がないので様々な例に対してテストを実行して確認する。

    x[n] = (-1)^n (x[0] + ∑[i = 1 .. n] (-1)^i shift[i])

* tty_player (SGR): ANSI font [#D0012]

* bidi サポート [2016-10-02] [#D0011]

  具体的にどの様に実装するべきかについて。
  これは ECMA TR/53 の Appendix にある動作例が参考になる。

  思っていたのと似たような動作を考えている様だが、実際にはもっと複雑である。
  具体的には nested strings という仕組みが問題である。
  行の中に配置を反転して表示するべき領域を埋め込むという構造は想定していた。
  しかしその様な文字列を幾らでも入れ子にする事ができる様なのである。

  問題点が二つある。

  1 先ずその様な入れ子構造を表現するのに適したデータ構造は一体なんであろうか。

    勿論、愚直にそのまま実装すれば実装できない事はないが、
    パフォーマンスなどへの影響が気になる。
    特にこの様な、実際に使う人が本当に存在するのかどうか不明な謎機能のために、
    フラットな配列の構造を諦めて何らかのリストの様な構造にするのは受け入れがたい。
    つまり、基本的には配列の構造にデータを記録しておいて、
    この様な埋め込み文字列の様な物を表現したい場合に特別な取り扱いをするというのが良い。
    その時にできるだけシンプルに最小限のデータサイズで記録する方法があれば良い。
    特に、入れ子構造を表現する為の固定長のデータ表現が存在しうるかという事である。

    例えば各セルにネストレベルを記録したらどうだろうか。
    そうしておけば同じ位置でネストレベルが複数段階変化する場合に対応できる。
    (ab[[cde]fgh]ijk の様な感じの入れ子構造が存在しうる。)
    しかしそれだと各ネストレベルでどの方向性を持っていたかという情報を保持できない。
    或いは完全に別のデータ構造として構造を保持するという手の方が現実的なのかもしれない。

  2 もう一つは後から編集が起こって別の文字を上書きした時に、
    どの様に更新範囲を検出するのかという事である。
    更に関連して編集の順序を記録しないでもちゃんと一意的に座標の対応を取る事ができるのかというのも気になる。
    また SHP や SLL を変更した時に既に出力した内容について
    どのような表示を行うべきかについても考える必要がある。

  うーん。その前にもっと詳しく動作について考えておく必要がある。

  文字列をどの様に記録するかについては 2016-10-04 に議論を残した。
  具体的に文字列の挿入を行う時にどの様に動作するべきかについては後で考える事にして、
  取り敢えずはデータ構造を確定する事にする。

  →データ構造は Memo 2016-10-04 にある通りに、
    方向付き文字列のリストとして表現する事にした。
    後で問題が起こればその時にまた変更すれば良い。


* SLL/SLH と DCSM の関係 [#D0010]

  | DCSM(PRESENTATION) の時 DCSM(DATA) の時で動作が異なる。
  | ここで問題になるのが実際に効くのは、
  | SLL/SLH を設定した時の DCSM なのか、
  | それとも実際に CR などを実行する瞬間の DCSM なのかという事である。
  |
  | もう一つ気になるのは、SLL/SLH を設定した時の DCSM が効くという場合に、
  | それを data component における座標に対応させる事は可能なのかという事である。
  | (つまり単に data component における座標を記憶しておくだけで良いのか、
  | 或いは、SLL/SLH を設定した瞬間の DCSM の状態も
  | 一緒に記録して置かなければならないのかという事である。)
  |
  | これを決定する為には、CR の動作を詳しく調べて、
  | それに整合する様に決めなければならない。
  | 例えば DCSM(PRESENTATION) で CR/LF を実行した時に、
  | LF によってカーソルが丁度下に移動する様にしたい。
  | もしくは DCSM(DATA) の時に CR/LF して、
  | LF によってカーソルが data component 内部で丁度下に移動する様にしたい。
  |
  | CR について調べた。CR 自体の動作が DCSM, SIMD によって、
  | SLL の値を使ったり SLH の値を使ったりという風になっている様だ。
  | そして SLL/SLH が設定された時の DCSM がどうたらという様な記述は全くない。
  |
  | a つまり、SLL/SLH の側では特に DCSM の値によって記録方法を変えたり
  |   という事はしなくて良い様に思う。
  |   それに、その方が自然である。つまり、DCSM や SIMD によらない
  |   一定の範囲が存在して、CR の方がモードによって変化するという事である。
  |   範囲自体が DCSM や SIMD を切り替える度に変化するというのは変である。
  |   一方で DCSM(PRESENTATION) DCSM(DATA) の切り替えによって、
  |   見た目の範囲が変わってしまう。
  |
  | b (他の例) DCSM(PRESENTATION) か DCSM(DATA) かに拘らず表示部での表示位置で
  |   記録するという様な実装も考えられたが、DCSM(DATA) の状態で
  |   SLL/SLH した行で表示部・記憶部で複雑な座標の対応になっている場合、
  |   記憶部での値で指定した列を表示部での座標に変換して記録する事になる。
  |   どの様に動作するかを予期するのが難しく、しかも使い所が分からない。
  |   うーん、訳が分からない。
  |
  | やはり自然なのは a である。
  | ECMA-48 の説明には SLL/SLH の項目で矢鱈説明がされていて、
  | SLL/SLH した瞬間に複雑な処理をしなければならない様に錯覚するが、
  | これらの説明は単に CR や他の制御機能にどう影響を与えるかを説明しているだけと思われる。
  | というか、CR や他の制御機能の説明の所に書かれている動作をそのまま再度説明しているだけで、
  | ECMA-48 SLL/SLH の部分に書かれている説明は冗長である。
  | 丁寧という事なのかもしれないが規格書らしくないし、却って混乱を招いている。
  | ここは単に "CR/IL/DL/NEL で参照される、行内の使用範囲の先頭列を設定する" とか書いておけば良いのだ。

  [結論]

  - SLL/SLH によって記録される情報は単に一つの列番号であり、
    DCSM の状態に応じて変化する様な物ではない。
  - 機能 CR/IL/DL/NEL を実行する際に、
    それぞれの機能が DCSM の値に応じて SLH または SLL の値を参照する。

* 双方向テキストに対応する際の動作について [2016-10-02] [#D0009]

  | ★例えば nested strings の中で行末に達して、折り返し処理をしなければならない場合にはどうすれば良いのか。
  |
  |   例えば [one [two [three] four] five] の各箇所で改行が起こった場合にどの様になるべきだろうか。
  |   但し一番外側の括弧で括られた部分は左から右で、その内側の括弧で右から左になり、更に内側で左から右になっているとする。
  |   折り返しがない場合には、[one [ruof [three] owt] five] という具合に表示される。
  |
  |   1 もう少し単純化する。[one [two] five] の場合はどうだろう。[one [owt] five] と表示される。
  |     これで tw の直後で改行が起こったとする。こうか?
  |
  |       [one [wt
  |       o] five]
  |
  |     或いは、
  |
  |       [one [ow
  |       t] five]
  |
  |     元の言語の文章に於いて改行を考えるとすれば前者の様な気がする。
  |     しかし改行の後に一番左に配置されるというのは元の言語の文章ではないことだし、
  |     また、これはその言語の文章というよりも外側の言語に埋め込まれた物だと思うと、
  |     埋め込まれた部分の内部で内側の言語の改行ルールによる改行が行われるというのも変である。
  |     つまり、改行というのは一番外側のレベルで行われる物なので、
  |     一番外側の言語の規則で行われるべきものなのではないかという気がするのである。
  |     だとすると後者のほうが正しいという事になる。
  |
  |   2 具体的な例で考えてみないと感覚がよくわからない。
  |
  |     日本語は古くは右から左であったが、しかし、
  |     これは、基本的に縦書きで高さが狭い場合には右から左になるという事であって、
  |     本当に右から左なのかというと微妙だし、更にそこで改行を入れることがあるのかというともっと微妙である。
  |     それに普段使っている訳ではないので実際にこれで例を作ってみた所で感覚はよく分からない。
  |
  |     どちらの方が自然だろうか。これは縦書きの日本語の文章に含まれた英文でも同様の事が言えるだろう。
  |     英単語を右に 90 度傾けて印刷する場合には問題は起こらない。英語も日本語も上から下に流れるからだ。
  |     しかし、もし仮に英単語を左に 90 度傾けて印刷する事になった場合にはどうだろう。
  |     英語は下から上に読まなければならない。そしてその途中に改行が入った場合に、
  |     英単語をどの様に並べるべきだろうか。考えて見るにどちらでもありの様な気がする。
  |
  |     取り敢えず、埋め込まれている部分が短い場合には外側の言語のルールで改行し、
  |     内側の言語については一旦行内に全て配置してから見た目で改行を実行するのが自然そうだ。
  |     つまり、1 の例で言えば後者である。
  |     しかし、ある程度の長さの文章(複数行に跨る)が埋め込まれている場合には、
  |     1 の例で言えば前者の様にした方が自然な気がする。
  |     でもやはり総じて後者の方が良いような気がする。
  |
  |   3 ここで TR/53 の例で参考になる物はないか改めて調べてみる事にする。
  |
  |     うーん。途中で改行したりという事はしていない様だ。
  |
  |     % というかそもそもの SRS の動作がよくわからない。
  |     % →と思ったら勘違いだった。data component を見ていた。
  |
  |
  | ★一番初めに各 SRS や SDS の動作について確認しておくべきだ。
  |
  |   SRS 元々確立されている方向性とは逆方向の文字列の開始・終了を定義する。
  |
  |     [ECMA-48] における記述は以下の通りである。
  |
  |     但し、character progression (data component 内の文字の記録順序) は影響を受けない。
  |     つまり、data component の中で見ている限りには SRS はあってもなくても変わらない。
  |     ただ、presentation component における位置との対応を考える為には、
  |     SRS が何処で始まって何処で終わっているのかといった情報を記録する必要があるだろう。
  |
  |     また、"文字列" 中で CVT HT SCP SPD VT によって引き起こされる効果については定義されない。
  |     また are に関係する機能 DAQ, EPA, ESA, SPA, SSA は文字列の中では用いてはならない。
  |
  |   SCP
  |     これは表示の際の方向を指定する。
  |
  |     途中で改行したりした時に一体どういう扱いにするつもりなのかと考えて改めて ECMA-48 を参照してみると、
  |     この制御機能は "現在の行" 及び "それ以降の行 (subsequent lines)" に対して適用される物のようである。
  |
  |     では、既に確立した行に対してはどうなのだろう。例えばカーソルを移動してそこに何か書き込んだ時はどうなるか、
  |     これは TR/53 の動作を見るに、後で SCP してからその行に戻って其処に文字を書き込んだとしてもその行の
  |     characater path は変わらないという様に見える。それでは一旦カーソルを上に戻して、その場所で SCP したら
  |     一体どうなるのだろうか。もし subsequent lines というのが行番号が現在いる行よりも大きい全ての行、
  |     という意味であるのだとすれば既に表示している内容に影響を与えるという事になる。
  |     一方で、もし subsequent lines というのが新しく作成される行なのだとしたら、
  |     既に出力されている行については影響を受けないという事になる。
  |
  |     うーん。説明を読むと、現在の位置に既に書かれている内容をどの様に処理するかについては書かれているが、
  |     subsequent lines の内容をどの様に処理するかについては何も書かれていないので、
  |     新しく生成される行に対してのみこの character path が適用されると考える方が自然だろう。
  |
  |     然し、一方で subsequent lines in presentation component という表現もされれているので、
  |     見た目で現在行よりも下に表示されている全ての行に対して適用するという意味なのかもしれないが、
  |     もしそうだったとすると規格の文章にはミスがあるという事になる。
  |     既に表示されている内容についてどの様に処理するかは active line については記述があるが、
  |     subsequent lines については記述がない。しかし、"subsequent lines にも同様に適用する"
  |     だとかいう感じに簡単に一文付け加えるだけで済むはずなので、この記述がないという事は、
  |     そもそも subsequent lines は空の新しい行であるか、
  |     或いは規格を記述・確認した人たちがうっかりしていて思い至らなくて書き忘れたかのどちらかである。
  |     しかし、規格を記述するにあたって実現不可能な変な記述がないように参照実装ぐらいは行って、
  |     規格に問題がないかというのを確認するのが普通だと思われるし、
  |     特に記述がないという事は subsequent lines というのは新しく生成される行という事で問題ないだろう。
  |     →この解釈については escseq.html に記述する事にした。
  |
  |   TR/53 の二つ目の例を見る限り、文字列の中で新しく文字の挿入を行った場合は、
  |     入れ子のレベルはその部分におけるレベルに埋め込まれる形で文字が挿入される様だ。
  |     つまり、その場所に移動した時点でそこにある入れ子レベルに従う事になる。
  |
  |   結局、一通り ECMA-48, ECMA-TR/53 の内容を gh-pages/escseq.html にまとめた。
  |   結局不明な事は不明なままであるが、何が不明で何が分かっているかが多少すっきりした様に思う。
  |
  |   * 自動的な折り返しに際してどの様に振る舞うかについては記述はない。
  |   * 文字列の中で制御機能を用いて移動を行った場合にどの様に振る舞うかについても記述はない。
  |   * 文字列中での active data position は定義されていない。
  |     しかし TR/53 Annex A で何かしらの方法が与えられている様にも見える。
  |   % * "文字列" の中に後から文字を挿入して追加することができる。
  |   %   これはとても厄介である。
  |
  | ★文字列の入れ子構造は記録部に記録されるのか? そして後で挿入を実行できるのか?
  |
  |   % "文字列" の中に後で内容を追加する事はできるのかできないのか。
  |
  |   TR/53 の Example 2 を見ると、一度出力して確定した "文字列" の入れ子構造の内部に
  |   後から文字を挿入する事によって、入れ子構造を変化させる事ができるという様にも見えた。
  |   しかし、落ち着いて考えてみると実はそうではないのかもしれない。というのも、
  |
  |   1 先ず、規格を参照して見るに strings だとか nested strings の概念があるのは、
  |     data stream だけであって、data component や presentation component に関しては、
  |     string がどうのこうのという記述はない様に思われる。
  |     従って後になって入れ子構造がどうのこうのというのは変なのではないか。
  |
  |   2 また、別に入れ子構造を保持していなかったとしても、
  |     data component と presentation component でそれぞれ独立に文字の挿入を行って、
  |     同時に data position と presentation position の対応関係をセル毎に記録したとする。
  |     その様な動作をしている限りにおいては Example に出ているのと同様の効果が得られるであろう。
  |
  |     しかし何れにしても対応関係をセルごとに記録するとしても、
  |     文字が新しく来る度にその対応関係を大幅に更新しなければならない。
  |     少なくとも文字列が閉じるまでは入れ子構造を保持しておく必要がある。
  |     但し、文字列が閉じた後は内部の並び替えは起こらない物と思って、
  |     入れ構造を記録したデータについては削除しても良い。
  |
  |     然しながら、data/presentation positions の対応表を保持するぐらいであれば、
  |     実のところ元になった入れ子構造を記録しておいても良い気がする。
  |
  |
  |   さて、これを区別するためには TR/53 の Example 2 で挿入する文字列について、
  |   "方向を明示せずに挿入する"、もしくは "SRS 文字列を挿入する" という例があれば良い。
  |   文字列の入れ構造に挿入されるのだとしたら、"方向を明示せずに挿入" した結果、
  |   挿入点の方向に影響されて文字列が表示されることになる。
  |   一方で、単に指定した位置に data/presentation component 上で文字列を挿入するというだけであれば、
  |   "方向を明示せずに挿入" した結果として普通の文字列の向きで文字が表示されることになる。
  |   しかし、残念ながら "方向を明示せずに挿入する" 例も "SRS 文字列を挿入する" 例も載っていない。
  |   説明文には "Character insertion is always performed according to the presentation directions
  |   and the nesting level which are established by the data stream." としか書かれていない。
  |   data stream によって確立した nesting level が何処で記録されるかによって解釈が異なる。
  |   もし data/presentation component の各行・文字の位置で記録されるのだとしたら、
  |   入れ子構造を後から変更できるという事になるし、もし nesting level というのは
  |   実際にデータを受け取って書き込む時に保持するものなのだとしたら、
  |   後から文字列を挿入するのは単に data/presentation component 上の配列を見て挿入するだけという事になる。
  |
  |   と思ったが改めて SRS の説明を見ると "SRS is used to establish in the data component
  |   the beginning and the end of a string of characters as well as the direction of the string."
  |   と書かれている。つまり、SRS は data component 内部に入れ子構造を構築するという事になる。
  |
  |   それに data/presentation component の間の座標の対応を一つずつ覚えておく方法だと、
  |   結局どのように表示されているのかということが人にとって良く分からない物になる気がする。
  |
  |   [結論]
  |
  |   文字列の入れ子構造は記録部に記録する。
  |   そして文字の挿入は入れ子構造の内部で行われる。
  |
  |   但し、方向が異なる場合には新しく入れ子文字列を作って挿入するのが良いだろう。
  |   挿入点の方向について意識しなくても安全に挿入ができる様にするためである。
  |   というのはアラビア語など言語自体が方向性を持っている場合、
  |   明示的に SRS/SDS を指定しなくても反転文字列が設定されうる。
  |   その時に或る任意の場所に新しく文字列を書き込もうとした時に、
  |   挿入位置の方向に従って勝手に文字列が反転されてしまっては困るからである。
  |
  |
  | ★途中で折り返しや改行があった場合の処理方法としてどの様な物が考えられるか。
  |   先ず初めに、明示的な改行があった場合にはそのまま其処で改行してしまって良い。
  |   改行前の文字列の内容は前の行に表示し、改行後の文字列の内容は次の行に表示する。
  |   折り返しによって反転部分に改行が挿入された時の動作は微妙である。
  |
  |   a data [he][llo] presentation [eh/oll] (/ が折り返し改行挿入位置)
  |     (行毎に文字列の構造を管理し、表示内容は行分割してから方向を適用したものにする。)
  |
  |     行に入る部分までを一つの文字列の単位として切り、改行を挿入する。
  |     続きの部分はまた新しい文字列として開始する。
  |     この方法が一番単純であり実装に曖昧さが残らない。
  |     これだと外側の文字列に埋め込まれた部分文字列だという風に思うと不自然な結果になる。
  |
  |   b data [hello] presentation [ol/leh]
  |     (複数の行に跨って構造を管理し、表示内容は方向を適用してから行分割したものにする。)
  |
  |     外側の文字列に埋め込まれた形で行を構築して、その後で行を分断したという感じになる。
  |     しかし right-to-left の人にとって見れば読みにくい文章になるかもしれない。
  |     この方法だと改行に跨った領域に "文字列" が存在するという事を管理しなければならない。
  |     特に、後になって行を挿入したり行を削除したりした時に一体どの様に管理するのか謎である。
  |
  |     例えば文字列を構成するセルを一つずつ全て記録してリストにして保持するとする。
  |     - その時、最終的な結果を別の端末に転送する場合にはどうしたら良いのか。
  |       正しく転送する為には文字列を構成するセルの順序に従って端末内を
  |       色々に飛び回る様なシーケンスを生成する必要が出る。
  |     - ※例え文字列の内部で制御機能を呼び出す事が禁止されていたとしても、
  |       後になって行を追加削除したり文字を追加削除したり出来る様になっている以上は、
  |       "文字列" が連続になっている事は保証できないのではないかという気がする。
  |       或いは、挿入される行や文字は全て "文字列" の内部に追加されるという風に考えるのだろうか。
  |     - 然し、何れにしてもその様な実装は極めて不自然である。
  |       その様な動作を期待してそれに整合する様なプログラムを書くのは難しい。
  |       結局、多少動作が人間にとって不自然に思われても、
  |       曖昧さを含まない単純な規則で動作する様に実装しないと、
  |       アプリケーションプログラムを書くのが難しくなる。
  |       人間的に自然かどうかだとかそういった事に対して柔軟に対処するためには、
  |       そういったものは装置の側で対応するのではなくてアプリケーションプログラムの側で対応するべきである。
  |
  |     従って、この方法にするとしても開始点と終了点だけを保持して、
  |     それ以降に内部に行が挿入されたり削除されたりという事は気にしない様にするという手もある。
  |     つまり、開始点と終了点だけを素直に記録して、
  |     間に文字や行が挿入される場合には開始点と終了点も同じだけずらすという様な具合にしたらどうだろう。
  |     - しかし、色々と問題がある。例えば開始点と終了店の間で SCP をした時に行内容の位置がずらされるが、
  |       その時に、元々の文字列の内容があった領域は分断される事になる。
  |       間に新しく入った空白も反転の対象だと解釈すると表示が滅茶苦茶になり、
  |       SCP がどうのといった機能が効かなくなってしまうのでそれはない。
  |
  |   c data [hello] presentation [eh/oll]
  |     (複数の行に跨って構造を管理し、表示内容は行分割してから方向を適用した物にする。)

  色々に考えた結果、一定の結論を得た。
  この結論は 2016-10-04 の memo にまとめる。

  以上の事から "文字列" を管理するデータを行毎に管理する事にする。
  特に文字列を使用する事はそんなに多くない事から、実装の見通しが立ちやすい様なデータ構造を採用する。
  (開始点, 終了点, 方向) の三組を配列に格納し、未だ閉じていない文字列に関しては終了点に -1 でも代入しておく。
  implicit movement をしている限りは終了点の更新は行わない。


2016-09-27

* ECMA-48/9 の記述についてどうするか。 [#D0008]

  Control sequences や Control strings の中にある文字 (0xA0-0xFE) は、
  0x20-0x7E と同じに解釈しろと書かれている。しかし、これに愚直に従うと、
  Control strings で日本語などの文字列を送ることができなくなる。

  | というか、何故この様な仕様になっているかというと、
  | ECMA-35 (ISO 2022) に従って 7bit から 8bit に変換した時に、
  | GL に何を呼び出しているかに応じて変換後に 0x20-0x7E が 0xA0-0xFE に
  | map されてしまうという問題があるからなのだと思われる。
  | つまり escape sequences の内、CSI sequences や control strings は処理せずに、
  | ISO 2022 の sequences だけを実行してしまうことに問題がある。
  |
  | 例えばUTF-8 前提でやっている場合にはこの問題は起こらない。
  | あるいは ISO 2022 の sequences と CSI sequences
  | を同時に処理する場合にも問題は起こらない。
  | 然し、何処かに変な filter が入っていたりすると問題になる。
  |
  | 普通は端末とプログラムの間に文字コード変換が入ったりする事はない。
  | 問題になるとすればエスケープシーケンスを出力するプログラムの内部の問題である。
  |
  | | % 通常はエスケープシーケンスを出力する部分と、
  | | % 文字コードを変換する部分は分離されて設計されている。
  | | % 特にエスケープシーケンスを含む文字列を生成して、
  | | % それからそれをエンコードすると思われる。
  | | % UTF-8 にエンコードするという場合はどうなるだろう。
  | | % 多分受信側で先に UTF-8 をデコードするという仕組みにしている限りは何も起こらない。
  | | % では、ISO 2022 にする場合はどうなるだろう。
  | | % 先ず、制御文字の表現は決まっているので変な混乱は起こらない。
  | | % 一方で、0x20-0x7E が ISO 2022 を通した結果としてどの様に変換されるかは謎である。
  | | % もしかすると GR に割り当てられた上で 0xA0-0xFE というバイトで送られてくるかもしれない。
  | | % しかし、この場合は先に ISO 2022 から UTF-32 に戻してしまえば、
  | | % 結局元々の数値に戻るのでやはり問題は起こらない。
  | |
  | | つまり「送信側(アプリケーション)はエスケープシーケンスを生成してからそれをエンコードする。
  | | 受信側はUTF-32にデコードしてからエスケープシーケンスを解釈する」
  | | という取り決めにしている限りは途中の文字コードが ISO 2022 であろうと UTF-8 であろうと平気である。
  | |
  | | しかし送信側(アプリケーション)が通常文字列はエンコードしてから出力するが、
  | | エスケープシーケンスは直接書き込んでしまう、などという設計になっていると面倒だ。
  | | 受信側ではエスケープシーケンスと ISO 2022 のシーケンスを同時に処理する必要がある。
  | | その様にしておけば一応問題は起こらないのだろうと思われる。
  | | また UTF-8 だと 8bit C1 と UTF-8 を構成するバイトの区別ができないので死ぬ。
  | | ただ出力するエスケープシーケンスを 7bit C1 文字に徹していれば問題は起こらない。
  | |
  | | - gettext を使って国際化している場合などにはこれに該当すると思われる。
  | |   ただ、gettext で ISO 2022 を出力する際に毎回 GL を元の状態に戻すと思われるので、
  | |   先にデコードを実行してからでも問題は起こらない?
  | |   (そうでないと gettext を通さない英語のメッセージなどが文字化けしてしまう。)
  | |   UTF-8 の場合には 7bit エスケープシーケンスだけ出力する様に設計されていれば、
  | |   先にデコードして問題ない。8bit C1 を使っている場合にはそもそも論理的に
  | |   一意な切り出しが不可能なのでアプリケーションが壊れていることになる。
  | |   なのでそんなアプリケーションの事は気にしなくても良い。
  | |
  | | - gettext などは使わずに自前で文字列をエンコードしながら、
  | |   それでいてエンコード結果にエスケープシーケンスを挿入している場合は、
  | |   やはり問題が起こる。この場合は確かにエスケープシーケンスとデコードを同時にしなければならない。
  | |   しかし、そもそも stateful なエンコード形式を採用していながら、
  | |   そのエンコード結果を切り貼りする様なプログラムは壊れているとしか言いようがない。
  |
  | 以上の考察からまともな実装になっているアプリケーションの出力は、
  | 普通にデコードしてからその後で制御シーケンスの処理を行っても問題は起こらない筈である。
  |
  | もう一つの可能性は伝送路の途中に文字コード変換が挟まっている場合である。
  | この場合でもまともな設計のアプリケーションの出力する制御シーケンスならば、
  | 制御シーケンスは壊されずにちゃんと文字コード変換される筈である。
  | なのでこれも問題ないのではないかという気がする。
  |
  | さて、一方で気になる事もある。この ANSI (ECMA-48) が制定されたきっかけは、
  | 文字コードによってアルファベットなどの実際の数値が異なるので、
  | bit combinatinos (column/row) を用いて規格を記述する、という事である。
  | つまり、文字コードの変換をする前の生のバイト列に対して処理することを考えている。
  |
  | - うーん。プログラムを書く上では 'a' などと書くとそれがどの様にエンコードされるか (execution charset)
  |   が保証できないので危険で、だからこそ 0x61 などの様にして表現するわけだが、
  |   でもよく考えたら U'a' とか書いておけば済む話の様な気もする。
  |
  | これらの整合性については ISO/IEC 10646 に記述があるという事だった様に思うが
  | 一体どのようにしているのか実際に確かめてみる必要がある様に思う。
  |
  | http://kikakurui.com/x0/X0221-2007-01.html
  | [JIS X 0221/D.2.Note3] によると C1 の文字は U+0080 - U+009F を UTF-8 に変換した表現を持つとしている。
  | つまり、エスケープシーケンスを含んだ文字列を char32_t の列で作っておいて、
  | それをまるごとエンコードするという方式になっている。
  | [JIS X 0221/15] UTF-32, UTF-16 の時も同様のようである。

  結論としては出力時はエスケープシーケンスを含んだ char32_t 列をエンコードし、
  入力時はデコードして char32_t にしてからエスケープシーケンスを解釈する、
  もしくはそうしたのと等価な入出力をするのがまともな実装である。
  ISO 10646 にもそうしろと書かれている。
  それ以外の実装は駄目な実装なので気にしなくても良い様に思う。

  | しかし、ECMA-48/9 にある事を考えて、駄目なアプリケーションの為に
  | 途中で GL と GR が入れ替わったりする可能性を考慮に入れて、
  | CSI sequences だけは 0xA0-0xFE を受け入れても良い?
  | と思ったが例えばその後 UTF-8 に変換されたりすると、
  | 最早 iso 2022 でどの様な構成バイトを持っていたかの情報も失われてしまうので、
  | 下手に対応しないのが良い様に思う。
  |
  | うーん。改めて ECMA-48/9 を読んで見る。
  | 結局のところ iso 2022 の state に依らず同じ representation を
  | 制御機能に持たせたいが、その様にすると 7/8 bit 変換でぶれができるという事に見える。
  | そして実は iso 2022 の範囲内で扱っている限りに於いては 7/8 bit 変換のぶれは
  | 必ず GL/GR の入れ替わりしかないということが保証されているのだろう。
  | しかしそこに Unicode が入ってくると混乱が生じる。
  | Unicode から iso 2022 への変換は一意でない。
  | 同じ文字が複数の言語に含まれているかもしれないからだ。
  | だとすると GL/GR の文字化けは一旦 unicode にすると復元不可能という事になる。
  | というか文字化けとかそういうのに限らず、
  | "iso 2022 の state に依らず同じ representation になっている制御シーケンス" を
  | そのまま unicode に変換した時点で単射性が失われるので復元不可能である。

  ECMA-48/9 の記述は ISO 2022 の中に制御シーケンスを state
  とは独立に埋め込んでも問題がない様にするためのものである。
  しかし Unicode もサポートする場合、ISO 2022 の中に state
  とは独立に埋め込んだ制御シーケンスは Unicode への変換の際に破壊されるので、
  そもそも使ってはならない。従って、ECMA-48/9 の内容に対応する必要はない。

2016-09-24

* 取り敢えず 00/08-00/13 は実装しようと思ったが、ECMA-48 にある FF の説明が分からない。 [#D0007]

  screen では FF は単に無視される様だ。一方で ECMA-48/8.3.51 には FF は、
  列はそのままで、presentation component の中の次の form/page の
  page home position がある行に移動するという事になっている。

  然し、form だとか page とか page home position だとかは一体何なのか。
  仕方がないので ECMA-48 の初めの方の説明も見てみる事にする。
  presentation component だとか device (装置) について書かれているのは 6.1 である。

  | [ECMA-48/6.1.1, 6.1.3] presentation/data component とはそれぞれ行の集まりであり、
  | 行は文字を表示する位置の集まりである。
  | [ECMA-48/6.1.5] presentation が実際に表示される座標に関連する物であって、
  | data は内部的な座標に関連する物と考えれば良い。双方向 (bidi) の文字列表示に対応する為にある。
  | [ECMA-48/6.1.2, 6.2.4] presentation/data component はそれぞれカーソル (active position) を持つ。
  | active line/field/area/page はそれぞれカーソルが存在しているそれを指す。
  | [ECMA-48/6.1.5, 6.1.8] 両者のカーソルの位置は連動 (indirect movement) する。
  | [ECMA-48/6.1.6] 文字の挿入によるカーソルの移動は data component に作用する (implicit movement)。
  | [ECMA-48/6.1.7] 制御機能によるカーソルの移動は data copomponent もしくは
  | presentation component に作用する (explicit movement)。
  | 何れのカーソル移動の場合にも存在しない場所に移動しようとしたときの動作は処理系依存である。

  この説明の中で既に field/area/page などと言った定義の不明な語句が出てくる。
  もっと遡って調べる必要があるのか。最初の語句定義に色々載っていることに気付く。
  [4.2.7] Area: 範囲。連続する文字描画位置の集まり (必ずしも1つの行に含まれているとは限らない)
  [4.2.40] Field: ある tabstop から次の tabstop までの area (範囲)。
    但し、次の tabstop はその field には含まない。
  [4.2.56] Page: 連続する行の集合。
  [4.2.57] Page home position: presentation/data component の中でカーソルがそれ以上前へ動かせない位置。

  結局良くわからない。特に page が一体何なのかというのが分からない。
  というか出力のデバイスとして display または printer を想定するという事が書かれていたので、
  printer の場合には page というのはそのまま物理的な紙の事だと思って良いだろうか。
  だとすると、display を考える時には page という物を想定しなくても良いという事だろうか。

  改めて SPH/FF の説明を読んで見る。物理的な page だと思うとこの説明も納得が行く。
  page home position は紙を1枚送った後に何処にヘッドを置くのかという事に対応するのだろう。
  だとすれば display での自然な実装は、clear screen してから
  SPH の設定した位置を含む行に移動するという事だろうか。

  - ところで screen で試してみたが SPH にも対応はしていない様だ。
  - 次に xterm で試してみた所 FF は VT と同じ役割を持つ様に設計されている様だ。
  - mintty は xterm と同じ動作だ。
    沢山の機能を実装している RLogin はどうだろう→RLogin も xterm と同じく VT で実装している。
    SPH 等には対応しているのだろうか→対応していない様だ。
  - 更に RLogin の説明を読むと LF/VT/FF は全て同じ動作をする様だ。
    また LF で CR LF の動作になっている様に見えたのは仮想端末が LF を CR LF に翻訳しているからの様だ。
    基本的には全て VT の動作を行う。そして Mode 20 LNM でその動作を変更する事ができて、CR LF と同じ効果にできる。
  - これについて xterm でも確認を行ってみたが、やはり同様に LNM で VT/FF/LF の全てが影響を受ける様だ。
    また、何れも SPH 及び FF のそれっぽい実装には対応していない様だ。
    様々な端末における動作がよく分からなかったので包括的に調べる事にした。

  | 調査方法
  |
  | $ stty nl; printf '\e[20hhello\nworld\n\e[20lhello\nworld'
  | $ stty nl; printf '\e[20hhello\vworld\n\e[20lhello\vworld'
  | $ stty nl; printf '\e[20hhello\fworld\n\e[20lhello\fworld'
  |
  | - 仮想端末が勝手に \n を \n\r に変換しない様に設定する必要がある。
  | - Mode 20 LNM が設定されているかどうかで振る舞いが変わる。
  | - 更に現在位置が最終行かどうかで振る舞いが変わりうる。
  |   次の行を追加するかどうかで実装にぶれがある様だ。

  結果は gh-pages branch の escseq.html にまとめた。

* これから本格的に端末の機能を実装していこうと考えている。 [#D0006]
  しかし、多少プログラムが長くなってきたので再度構造を考えてからにする。

  window 自体はできるだけ plain な構造体にしたい。
  端末自体は window とは独立に "window を書き換える者" として実装したい。
  また window の描画先は "window の中身を写す者" として実装したい。
  つまり受動的なオブジェクトとして描画先を定義するのではなくて、
  能動的に window の中身を見て描画を行うのである。

  window を書き換える者の名前は何にしようか。案としては
  controller, painter, writer, layouter, application,...
  writer や application は一般的すぎる気がする。
  layouter は何か違う気がする。painter にすると、
  window を実際に描画する者の方は一体何になるのかという問題がある。
  controller も少々一般的というか余りしっくりと来ない。
  window を碁盤か何かと考えれば player と observer がいい。
  或いは window も board か何かに改名するか。
  (しかし、"player" はまた別の意味にも取れるかもしれない。)
  →取り敢えず各クラスの名前を変更する。

  出力に関しては現在は全体を出力する様になっているが、
  これは勿論効率が悪い。dirty section を管理する様にしなければならない。
  しかし一つの window に複数の observer がくっついている場合には、
  全ての observer で同じタイミングに同じ範囲を反映する様にするか、
  もしくは各 observer 側で dirty section を管理しなければならない。
  一つの window の履歴から各 observer の中で dirty section を再現するのは困難である。
  各セルについて version 番号を保持するという手もあるが効率的ではない。
  また、行の移動なども追跡したい。
  という訳で、やはり実際に window を変更するのと同時に dirty section を更新するしか無い。
  従って、実際の実装では (dirty section 情報を書き出すオブジェクト) を用意して、
  observer が自分の中に保持しているそれを、window の内部にあるリストに登録し、
  window は自分の状態が変更される度にそのリストにある dirty section オブジェクトの更新を行う、
  という仕組みにするのが良いのではないかと思う。

  何れにしても、出力部分を後で処理する事にする。
  それよりは先に実装するべきは player の方である。
  受け取ったバイトに応じて制御機能を呼び出すのである。
  また同時に UTF-8 のデコードも行いたい。
  一番初めに実装するべきは何か。UTF-8 のデコーダか。
  何でも良いから早く動くようにしたいという意味では、
  普通にバイトを受け取ってそれを書き出すという風にすれば良い。
  現在の put_char 関数を拡張する形で良いのではないだろうか。
  取り敢えず出力部分に関しては別のファイルに分離するか。

* is_ideogram_exclusive が使われていない -> fixed [#D0005]
* 49 が無駄に出力されている? -> fixed [#D0004]

2016-09-23

* 仮想端末の作り方については確か POSIX にサンプルコードが載っていたはず。 [#D0003]

  [[posix_openpt>http://pubs.opengroup.org/onlinepubs/9699919799//functions/posix_openpt.html#]] これ。

  ポーリングは O_NONBLOCK にするのが楽?
  [[ファイル入出力の基本 (IO モデル) を勉強する - フリーフォーム フリークアウト>http://d.hatena.ne.jp/cou929_la/20121103/1351950688]]

  あと exit とか _exit とか _Exit とか色々あるけれど何だったか。
  [[_Exit>http://pubs.opengroup.org/onlinepubs/9699919799/functions/_exit.html]]
  [[fork - Wikipedia>https://ja.wikipedia.org/wiki/Fork]] たぶん _exit でよい。

  一応何か起動した。
  bash: cannot set terminal process group (2692): Inappropriate ioctl for device
  と出るので子プロセスで setsid() しなければならない。

  さて、次に仮想端末の設定が変だ。どうも親プロセス側の仮想端末の設定がいけない様だ。
  (というか bash 側は bash 側でなんとかしているはずだ。)
  と、色々試行錯誤した後で以下の親切なページを見つけた。

  [[PTY を使ってシェルの入出力を好きなようにする - Hika Hibariya>http://note.hibariya.org/articles/20150628/pty.html]]

  簡単にできた。色々調べたりしながら分かった setsid や dup2 のことも全て書かれていた。
  初めから此処を見ていれば余り悩むこともなかった (然し理解が浅いままだったかもしれない)。
  あと、終了時に念のため子プロセスを kill しておくようだ。
  と思ったらこれらの事は詳細UNIXプログラミングという本に書かれている様だ。

2016-09-20

* バッファのデータ構造 [2016-09-19] [#D0002]

  行の管理

    行の管理はB木が良い様に思われたが、世の中にはスキップリストというデータ構造もある様だ。
    平衡を保つ仕組みは複雑になりがちだがそれから開放されるというのが売りの様である。然し実際の所どうなのだろう。
    Wikipedia によるとやはりリスト構造であるが故に遅いという様なことが書かれている。
    もっと調べると、M分木にすればB木だと logN/logM になるが、
    スキップリストだと M logN/ logM になるとある。考えてみれば確かにそうだ。
    連続添字の配列として使う場合は、赤黒木よりは良いけれど B 木には及ばないという所ではないか。
    しかしながらスキップリストには、アルゴリズムが簡単なお陰で並列処理・非同期処理などで分がある様だ。
    しかし、もし一旦画面の外に出た部分で内容の更新が起こらないのだとすれば、
    わざわざB木にしなくても単なる配列(or linked array)で良い。
    表示領域の高さは精々数百行なので挿入などは大したことない。

  文字の管理

    % 文字の管理はどうするのか悩ましい。
    % 一つの方法は列数と同じ要素数の配列を用意して、
    % その文字が表示される位置に文字を書き込むというものである。
    % しかしそれだと grapheme clusters に対応するのが苦しい。
    % 外字的な取り扱いにして新しい種類の clusters が来る度に登録を行うという手がある。
    % メモリリークを防ぐためには参照カウンタ方式にでもするか。
    % 遅そうではあるが、普通の文字を扱っている分には overhead がないというのは良い。
    % 一方で、proportional な font を許すような terminal を考えるとこの方法は苦しい。
    % (そもそもそんな物があるのか分からないし、あったとしても各文字の幅や
    % kerning などをどの様に取り決めておくのかという大きな問題がある。
    % 取り決めをしておかないと表示が乱れることになる。)
    %
    % 或いは、初めから可変長な文字の存在を受け入れて、
    % 要素が可変長な配列みたいな構造にしてしまうという手もある。
    % メモリ的にはこれが最もコンパクトである。UTF-8 を使うことにすれば
    % 通常のアルファベットを扱っている限りは各文字 1B しか消費しない。
    % 但し文字幅などの補助情報を持たせるとすると結局 2B になるか。
    % この時の問題はその様なデータ構造は前代未聞なので効率良い実装が可能なのかという事である。
    % 特に index を指定した時に対応する cluster を特定するのに必要な補助情報と計算時間である。
    % 補助情報が一切ないと先頭から順に文字を区切って行かなければならず不毛である。
    % 一応 B 木の各節で、下にぶらさがっている cluster の数を保持しておけば大分ましになる。
    % 問題は B 木の葉である。一つの方法は 1 cluster 1 byte の配列 (A) と、
    % 実際の文字の羅列を記録した配列 (B) の両方を保持して、
    % (A) に (B) 内での index を記録する方法である。
    % 然し、この方法だと単一の grapheme cluster の合計サイズに制限がかかってしまう。
    % また、その葉に含まれる全データサイズにも制限がかかる。
    % しかし、B木の容量を要素数ベースではなくデータ量ベースにするという手もある。
    % 更に一つの cluster が複数の葉に跨る事も許すことにすれば良い。
    % しかし効率の面から言ってこの方法は本当に得策なのか。
    % そもそも端末画面の横幅というのは上限がある。
    % 1行の文字数に制限のないエディタを作るのでないかぎりはB木にする必要もない。
    % また、端末での操作は基本的に挿入ではなくて上書きである。
    % なので各配列要素が各列に対応する様な設計の方が自然である。
    % やはりその様な側面から考えてもB木にするのは大げさである。
    %
    % やはり struct { char32_t ch; int32_t flags; } の配列のような構造にするのが無難だろうか。
    % しかし大抵の場合アルファベットの plain な配列だという事を考えるとこの表現はやはり無駄が大きいように感じられる。
    % この構造をベースに考えて、より効率化するという方向で考えられないだろうか。。
    % 例えば普段は char 配列で考える事にして、unicode 文字等の場合には何らかの特別な文字を使う。
    % そして unicode 文字本体の情報は別の所に格納する。
    % しかし何処に格納するのか? 格納位置を直接表現しようと思えば sizeof(void*) のデータが必要であり、
    % これだとそもそも char32_t と同じ大きさになってしまう。
    % だからと言って char の 128-255 の値を index に使おうと考えれば 128 文字しか unicode 文字を扱えない。
    % 或いは、128文字ごとに buffer を切り替えるというのも手なのかもしれない。うーん。
    % 然しそれだと初めから char32_t*128 の領域を確保しておくのと較べて得しているのかどうか怪しい。
    % 何より大量の文字が流れている場合、結局最終的に char32_t*画面の広さ 分だけの領域を確保する事にもなりそうである。
    % その場合には、初めから char32_t で全部領域を確保しておけば良かったという結論になりそうである。
    % 計算してみると、例えば sizeof(char32_t)*210*80 = 67.2 KB である。
    % 全部 char で済んだとしても 1/4 になるだけである。何かどうでも良い気がしてきた。
    % 実際に動いているプロセスを見ると普通に MB 食っている。
    % 16bit マシンならば 64KB もしくは 32KB に収めないといけないのかもしれないが、
    % 実のところその様なマシンで動かそうと思ったらプログラム自体をコンパクトにせねばならずそちらの方が問題だ。

    結局、char32_t ch の単純な配列で管理するのが良さそうだ。
    余計にメモリの確保解放を繰り返さない為には、初めから領域と同じ大きさの配列にしてしまう。

    Grapheme cluster は上限の大きさを決めておかないと攻撃が可能になってしまう。

  属性の管理

    さて次に考えるべきは属性をどの様に管理するのかという事である。
    実際の使用される状況を考えると、以下のことが言える。
    - 多くの場合は属性は設定されない。特に大量のデータを出力する場合。
    - 属性が設定されているとしても各文字ごとに設定されることは少なくて、
      連続する文字は完全に同じ属性を持っている可能性が高い。
    - colorful な実装にするにしても xterm 256color までが普通で、
      24bit color 等を出力する様なプログラムは稀である。
    勿論、これに反する様ないじわるなプログラムも作ることはできるが、
    上記の様な状況に対して効率の良いような実装にしてしまっても問題ないと思う。

    どのようにするのが良いか様々な実装について考えてみる。
    一番単純な方法は文字のデータと一緒に管理するという物である。
    しかし、実際に描画する時には一文字ずつ属性に応じて描画するというのは効率が悪い。
    普通は同じ属性の物をまとめて描画するという様にする筈である。
    実際に描画を行う場合には属性が連続しているかどうかを確認して出力を行うことになるだろう。

    もう一つの方法は Poderosa で使われている方法である。属性オブジェクトへのポインタを各セルに保持しておいて、
    描画する際の同じ属性の連続かどうかの判断はポインタが一致するかどうかで判定するという方法である。
    しかし、これが本当に効率的なのかどうかは怪しい。先ず、単に文字を描画すると言っても、
    複数の段階がある。まず初めに背景画像を描画し背景色があればそれを描画する。その後で文字を描く。
    各ステップで使用される属性が異なるので同じ属性が連続しているかどうかの判定も、
    属性オブジェクトをひとまとめにして行うのではなくて、
    関連のある属性のみに絞って連続しているかどうか判定した方が良さそうな物である。
    また、属性オブジェクトの確保・解放などの操作にもコストがかかる様な気がする。
    基本的な属性に関して言えば十分 32bit におさまるので
    32bit/64bit のポインタで属性オブジェクトを参照する方が余程メモリを食う。
    Poderosa の方法だと拡張性が高いのは良いが効率面で余り良くないだろう。

    あるいは Poderosa の様に属性オブジェクトを作るまでではないが、
    属性に変更があるという意味のフラグを char32_t の内部に置いて
    (unicode はどうせ 10FFFF までなのでフラグを幾つか設置する自由はある)、
    別の箇所に属性データを記録するという風にすることも可能だろう。
    しかし、その場合属性データはどの様に保持するべきだろう。
    属性に変更があったかどうかのフラグだけでは属性データに対する参照にならない。
    一つの方法は配列にして適用対象の文字と同じ位置に属性データを格納する事である。
    しかしこの方法だと初めから文字と一緒に属性データを記録するのとメモリ効率的に変わらない。
    逆にメモリの管理や参照が複雑になるだけで意味がない。
    もう一つの方法はハッシュテーブルや平衡木などを用いて sparse な map にするという物である。
    これならばメモリを節約できる。しかし、そこまでする程の事なのかという疑問が残る。
    特に高が属性を参照するのに一々毎回複雑なデータ構造を辿るというのは非効率的に思われる。

    結局、基本的な属性の範囲であれば文字のデータと一緒に固定長で管理をし、
    特別な種類の属性を含む場合にはそれを示すフラグと拡張属性データの index を埋め込む。
    拡張属性データは別の一つの配列に入れておいて管理すれば良い。
    同じ属性が連続して続く場合を考えれば拡張属性データは複数の文字から参照できる様にして、
    また参照カウントを用いて管理するのが良いだろう。

    基本的には各セル struct { char32_t ch; uint32_t flags; }; を保持する。
    基本的な属性に関しては flags に格納する事にして、
    特殊な属性を含む場合には或るフラグを立てておく事にする。
    そのフラグが立っている場合には、別に持っている拡張属性データ用配列にデータの格納を行う事にする。
    拡張属性データの配列要素は、参照カウントと基本属性と更に拡張属性データへのポインタを持つ。
    char32_t ch に収まらない様な unicode grapheme clusters についても同様に処理を行う。


  他に必要なデータはあるか

    他の実装も確認してみる。

    yaft.h を見ると、先ず気づくのは文字データは一つのオブジェクトとして生成し、
    セルはそこへのポインタを保持する。更にセルは uint8_t fg, bg と、
    enum char_attr attribute と、それから width まで保持する。
    加えて sixel support としてセル内部に bitmap データまで持つ
    (これはセルのサイズが固定だからできる事であろう)。
    yaft の目的上、メモリ使用量の上限が分からない動的なメモリ確保ではなくて、
    使用メモリ量の計算がしやすい固定的な割当になっているという事だろうか。
    また、glyph に関してはビットマップに結びついているので、
    予め用意された文字しか扱えない。当然、grapheme clusters に対応しているとは思われない。

    struct cell_t {
        const struct glyph_t *glyphp;
        struct color_pair_t color_pair;
        enum char_attr attribute;
        enum glyph_width_t width;
        bool has_bitmap;
        uint8_t bitmap[BYTES_PER_PIXEL * CELL_WIDTH * CELL_HEIGHT];
    };

    sixel もしくは端末の特定の領域に設置される挿入オブジェクトを管理できる様にしたい。
    当初は属性データに持たせる事を考えたが、属性データは複数の文字で共有されるという性質があり、
    しかし一方で挿入されるオブジェクトは或る位置セルに紐付けて管理した方が良い気がする。
    あるいは領域に属する全てのセルで共有しても良いが、何れにしても属性と同列の物ではない気がする。
    だとすれば flags とは別に更に拡張可能なオブジェクトを設定するべきか。
    もしくは grapheme clusters の別種として管理するべきか。それが良い気がする。
    例えば sixel オブジェクトと文字を両方保持しなければならないという事はなさそうに思われるし。

    tmux.h を見るとどうやら文字データは UTF-8 で保持している様だ。
    5 bytes で属性・フラグ・色・幅・UTF-8の長さを持つ様だ。
    不思議なのはこの実装も "幅" を保持している事である。
    幅なんていう物は右のセルに続いているかどうかだけ見れば良い気がするのだが。
    文字のデータには 9 bytes 使っている。そんなに使う文字は存在していただろうか。謎である。
    特定の grapheme clusters だけは扱える様にしているのかもしれない。

    #define UTF8_SIZE 9

    struct grid_cell {
            u_char  attr;
            u_char  flags;
            u_char  fg;
            u_char  bg;

            u_char  xstate; /* top 4 bits width, bottom 4 bits size */
            u_char  xdata[UTF8_SIZE];
    } __packed;

    screen については何処に定義があるのだろう?? image.h の struct mchar, mline?
    どうも screen がどういう処理方法になっているのか色々見ても見えてこないが、
    取り敢えずそれっぽいものはこれしかない。
    文字に関しては恐らく image と mbcs に分割して格納されている。
    ASCII の範囲内であれば image で、そうでなければ mbcs に続きが格納されるという事だろうか。
    他に色と属性とフォント(?)がある。./configure --help を見たがフォントが何か分からなかった。
    面倒なのでこれ以上は深追いしない。しかし前から思っていたがやはり screen のソースコードは汚い。

    struct mchar {
             unsigned char image;
             unsigned char attr;
    IFFONT(  unsigned char font; )
    IFCOLOR( unsigned char color; )
    IFCOLORX(unsigned char colorx; )
    IFDWCHAR(unsigned char mbcs; )
    };

    struct mline {
             unsigned char *image;
             unsigned char *attr;
    IFFONT(  unsigned char *font; )
    IFCOLOR( unsigned char *color; )
    IFCOLORX(unsigned char *colorx; )
    };

    mintty は term.h に一連の定義がある。
    mintty の構造は他のプログラムに較べてよく考えられた構造になっている。
    綺麗だ。他のプログラムが俄然ごみの様に思われてくる。詳しく見てみる事にする。
    - 気付く事は、色は初めから true color 前提で書かれている。
      256色前提の場合パレットを変更した時に既に表示した文字の色も変わってしまうので、
      理想的にはパレットの変更に追随させておけば背景黒と背景白の切り替えなどをしても見にくくならない、
      等の利点があると考えられるが実際にはそううまくは行かない。
      複雑な出力や様々な色を表示するプログラムの場合、パレット変更は普通は想定しない。
      パレットが変更されたときのことまで考えて設計するのは困難な為である。
      それを考えると true color 前提で書いた方が本当は良いのかもしれない。
    - もう一つ気になるのは grapheme clusters の取扱である。
      複数の文字が一つのセルに含まれる場合には、
      各文字毎に 文字&属性&cc_next(=リスト用) を保持する様になっていて、
      更に、同じセル内の次の文字 cc_next は相対位置で表現している。
      配列中で未だ使用されていない文字は termline::cc_free を先頭として、リストで管理している。
      よく考えられた設計である。気になるのは combining characters が沢山来て、
      行内の文字数が SHRT_MAX を超えた場合に何が起こるのかという事である。
      ちょっと見た所、何も対策がなされていない気がするがいいのか?
      後、相対位置にする意味があるのかというのも可也謎である。
      というか相対位置にしていると行内の文字を削除して
      切り詰める時に余分な操作が必要になってしまう気がする。
      もう一つは文字を格納する領域を行単位で管理している事である。
      これだと部分スクロールなどをする場合に文字の移動と一緒にリストを再構築しなければならない。
      一方で利点もある。行の生成・削除が簡単だという事である。
    - また sixel に関しては特殊な文字コード 0xFFFC で表現している。
      恐らく文字がこれになっている場合には其処には文字ではなくて画像が入るという事なのだろう。
      これの意味する所は端末の文字サイズ拡大縮小に際して
      埋め込み画像のサイズは一緒に大きくなったり小さくなったりするという事である。
      しかし下手に埋め込み画像をピクセル単位にしてレイアウトが変わったりするよりは、
      出力したときの領域をそのままに画像も一緒に大きくなったり小さくなったりするのが自然である。
      また U+FFFC は OBJECT REPLACEMENT CHARACTER で place holder の役割のある Unicode 文字の様だ。
      画像本体はどの様に管理しているのかと思ったら struct term の中に保持している様だ。
      恐らくこの中に画像の表示位置などの情報も含まれているのだろう。
    - 属性も様々な属性がある。
      bold dim underline italic reverse invisible blink
      doubleunderline overline protected wide/narrow/expand
    - temp_strage_t は temp_storage_t のつづり間違いではないだろうか。

    typedef struct {
      unsigned long long attr;
      uint truefg;
      uint truebg;
    } cattr;

    typedef struct {
      short cc_next;
      wchar chr;
      cattr attr;
    } termchar;


  結論

    エディタとデータ構造を共有する (エディタにも転用可能にする) のであれば、
    巨大なファイルに対して行の挿入などがスムーズにできる様に B 木にする。
    また、proportional なフォントに対応するために列と配列要素を対応させる構造は使えない。
    ファイルへの書き出しが楽になる様にするためには、
    ファイルに書き出すデータをそのまま保持するようなデータ構造の方が良いかもしれない。

    しかし terminal 専用に設計するのであればより簡単な実装になる。
    流れたデータは単に末尾に追加可能な配列に溜めれば良いし、
    行のデータも長さ決め打ちで良い。
    端末の領域と同じサイズの単一のメモリ領域でも allocate すれば良い。
    効率を考えれば terminal 専用に設計して、特殊な機能に関しては例外的な方法で処理するのが断然良い。

* 名称 [2016-09-18] [#D0001]

  [議論]

  名称を決めよう、と思うが良い名前は何だろう。
  変に凝った様な名前は嫌なので短いのが良い。でも他とは被りたくない。
  混同しやすいようなものや検索しにくいものも万一のため避けたい。

  暫定的に tty1 (単に tty の初めての実装ぐらいの意味) としたが、
  これは既に /dev/tty1 と被っていてよくない。それに version 番号をつけにくい。

  端末の名前といえば、*term *tty などが多い。
  この系統にするとしたら一文字入れるのが良い。
  然し未だ使われていないものが良い。
  - xterm は言うまでもない。
  - iTerm は Mac 用の物。
  - aterm はルータの製品名に使われている。
  - atty は isatty を思い出す。isatty は何の略だろう。"is a tty" ということか?
  - stty は仮想端末の設定を行うコマンドである。
  - RTTY とはアマチュア無線×TTYのこと??
  - VTTY というのも既にあるようだ。

  関連して pseudo-terminal を pty としたりする様だが、
  それだと pseudo-typewriter にならないか?
  それに、近くにあるコンソール tty に tele という語句が入って、
  遠くにあるリモートに繋がっている pty で tele が抜けていることになり妙だ。話がそれた。
  何れにしても ty だけを取るというのも手なのである。
  - mty とか vty とか…? 三文字だと流石に既存のコマンドなどと被るだろうか。

  screen 系列で行くと
  - 例えば tmux がある。これは terminal multiplexer の略である。
  - また、byobu というのもある (単なる設定集の様な物だが)。
    これは screen の言い換えだ。

  contra

    ふと昔書きかけたプログラムの事を思い出した。contra という名前だった。
    エスケープシーケンスを翻訳して TERM に応じた出力に変換する為の物である。
    もしくは Windows のコンソールに対して出力を行ったりもできる様にするという目的だった。
    これと合流するのが良い考えである様に思う。
    名称も contra に変更する。

    というのも今回のプログラムの構想としては、

    1 端末の内部状態と描画部分を分離する
    2 描画部分は "他の端末に対する制御シーケンス" だったり、
      あるいは "GUI ウィンドウに対する描画" だったり、
      容易に切り替えられる様にする。
    3 端末の内部状態に対する操作は、
      "プログラムから直接操作" したり、
      "制御シーケンスを解釈して操作" したり
      色々切り替えられる様にする。

    ということであったが、一方で contra は制御シーケンスの解析
    と制御シーケンスの解釈部分を分離して、
    制御シーケンスの適用先をまた別の端末にしたり、
    或いは Windows のコンソールやその他の GUI Window にしたりという事だった。

    これらは容易に統合してより機能を綺麗に整理する事ができる。

    - icontrol_function_processor

      制御シーケンスからデコードされた制御機能の呼び出しを処理する。

      実装として二通り考えられる。内部端末に対する操作を行うもの。
      それから他の端末に対する制御シーケンスを生成するもの。

      - tty_writer: icontrol_function_processor を実装

      - window_writer: icontrol_function_processor を実装

    - tty_reader

      制御シーケンスを解釈して icontrol_function_processor を操作する。

    - iwindow_target

      window の内容を表示・出力するための物。様々な実装が考えられる。

      - tty_target

        m_proc = icontrol_function_processor に対する操作として実装する。
        特に m_proc が tty_writer の場合には端末に対する出力になるし、
        或いは window_writer の場合には window の簡易複製になる。

      - x_target
      - gdi_target
      - console_target

        様々な GUI interface やコンソールに対する描画として実装しうる。

    以上を組み合わせれば様々なプログラムを容易に実装できる。

    - 例えば、tty_reader -> tty_writer を組み合わせれば、
      制御シーケンスの翻訳として動作する。

    - 或いは、tty_reader -> window_writer -> tty_target を組み合わせれば、
      screen の様なことができる筈である。

    - もしくは tty_reader -> window_writer -> x_target とすれば、
      新しい terminal emulator を実装できる。
      特に、様々の target を実装するだけで様々な環境に移植できる。

    さて、ここまで考えたのはプログラム→端末のデータの流れについてであるが、
    逆に端末→プログラムのデータの流れ (主にユーザの入力操作) についても
    同様に綺麗に扱うことができる。

    - キーシーケンスの解釈部: キーシーケンスを操作のイベントの列にする。
    - イベントの列を処理する部分:

      例えば、直接ここにプログラムを実装してしまっても良いだろう。
      或いは、また TERM に応じたキーシーケンスに翻訳しても良い。

  [結論]

  contra にする。更に、元々 contra という名前で書いていたコードと順次統合する。
